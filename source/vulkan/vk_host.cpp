// DON'T MODIFY, this is autogenerated
#include "boxedwine.h"
#ifdef BOXEDWINE_VULKAN
#include <SDL.h>
#include <SDL_vulkan.h>
#define VK_NO_PROTOTYPES
#include "vk/vulkan.h"
#include "vk/vulkan_core.h"
#define BOXED_VK_EXTERN
#include "vk_host.h"
#include "vk_host_marshal.h"

void initVulkan();
BoxedVulkanInfo* getInfoFromHandle(KMemory* memory, U32 address);
void freeVulkanPtr(KMemory* memory, U32 p);
void registerVkMemoryAllocation(VkDeviceMemory memory, VkDeviceSize size);
void unregisterVkMemoryAllocation(VkDeviceMemory memory);
U32 mapVkMemory(VkDeviceMemory memory, void* pData, VkDeviceSize len);
void unmapVkMemory(VkDeviceMemory memory);

#define ARG1 cpu->peek32(1)
#define ARG2 cpu->peek32(2)
#define ARG3 cpu->peek32(3)
#define ARG4 cpu->peek32(4)
#define ARG5 cpu->peek32(5)
#define ARG6 cpu->peek32(6)
#define ARG7 cpu->peek32(7)
#define ARG8 cpu->peek32(8)
#define ARG9 cpu->peek32(9)
#define ARG10 cpu->peek32(10)
#define ARG11 cpu->peek32(11)
#define ARG12 cpu->peek32(12)
#define ARG13 cpu->peek32(13)
#define ARG14 cpu->peek32(14)
#define ARG15 cpu->peek32(15)
#define ARG16 cpu->peek32(16)
#define ARG17 cpu->peek32(17)
#define ARG18 cpu->peek32(18)
#define ARG19 cpu->peek32(19)
#define ARG20 cpu->peek32(20)
#define ARG21 cpu->peek32(21)
#define ARG22 cpu->peek32(22)
#define ARG23 cpu->peek32(23)
#define ARG24 cpu->peek32(24)
#define ARG25 cpu->peek32(25)
#define ARG26 cpu->peek32(26)
#if defined(__linux__) && defined(__i386__)
static_assert(sizeof(VkBaseOutStructure) == 8, "false");
static_assert(sizeof(VkOffset2D) == 8, "false");
static_assert(sizeof(VkOffset3D) == 12, "false");
static_assert(sizeof(VkExtent2D) == 8, "false");
static_assert(sizeof(VkExtent3D) == 12, "false");
static_assert(sizeof(VkViewport) == 24, "false");
static_assert(sizeof(VkRect2D) == 16, "false");
static_assert(sizeof(VkClearRect) == 24, "false");
static_assert(sizeof(VkComponentMapping) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceProperties) == 800, "false");
static_assert(sizeof(VkExtensionProperties) == 260, "false");
static_assert(sizeof(VkLayerProperties) == 520, "false");
static_assert(sizeof(VkApplicationInfo) == 28, "false");
static_assert(sizeof(VkDeviceQueueCreateInfo) == 24, "false");
static_assert(sizeof(VkDeviceCreateInfo) == 40, "false");
static_assert(sizeof(VkInstanceCreateInfo) == 32, "false");
static_assert(sizeof(VkQueueFamilyProperties) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryProperties) == 456, "false");
static_assert(sizeof(VkMemoryAllocateInfo) == 20, "false");
static_assert(sizeof(VkMemoryRequirements) == 20, "false");
static_assert(sizeof(VkSparseImageFormatProperties) == 20, "false");
static_assert(sizeof(VkSparseImageMemoryRequirements) == 48, "false");
static_assert(sizeof(VkMemoryType) == 8, "false");
static_assert(sizeof(VkMemoryHeap) == 12, "false");
static_assert(sizeof(VkMappedMemoryRange) == 32, "false");
static_assert(sizeof(VkFormatProperties) == 12, "false");
static_assert(sizeof(VkImageFormatProperties) == 32, "false");
static_assert(sizeof(VkDescriptorBufferInfo) == 24, "false");
static_assert(sizeof(VkDescriptorImageInfo) == 20, "false");
static_assert(sizeof(VkWriteDescriptorSet) == 44, "false");
static_assert(sizeof(VkCopyDescriptorSet) == 44, "false");
static_assert(sizeof(VkBufferUsageFlags2CreateInfo) == 16, "false");
static_assert(sizeof(VkBufferCreateInfo) == 36, "false");
static_assert(sizeof(VkBufferViewCreateInfo) == 40, "false");
static_assert(sizeof(VkImageSubresource) == 12, "false");
static_assert(sizeof(VkImageSubresourceLayers) == 16, "false");
static_assert(sizeof(VkImageSubresourceRange) == 20, "false");
static_assert(sizeof(VkMemoryBarrier) == 16, "false");
static_assert(sizeof(VkBufferMemoryBarrier) == 48, "false");
static_assert(sizeof(VkImageMemoryBarrier) == 60, "false");
static_assert(sizeof(VkImageCreateInfo) == 68, "false");
static_assert(sizeof(VkSubresourceLayout) == 40, "false");
static_assert(sizeof(VkImageViewCreateInfo) == 64, "false");
static_assert(sizeof(VkBufferCopy) == 24, "false");
static_assert(sizeof(VkSparseMemoryBind) == 36, "false");
static_assert(sizeof(VkSparseImageMemoryBind) == 56, "false");
static_assert(sizeof(VkSparseBufferMemoryBindInfo) == 16, "false");
static_assert(sizeof(VkSparseImageOpaqueMemoryBindInfo) == 16, "false");
static_assert(sizeof(VkSparseImageMemoryBindInfo) == 16, "false");
static_assert(sizeof(VkBindSparseInfo) == 48, "false");
static_assert(sizeof(VkImageCopy) == 68, "false");
static_assert(sizeof(VkImageBlit) == 80, "false");
static_assert(sizeof(VkBufferImageCopy) == 56, "false");
static_assert(sizeof(VkImageResolve) == 68, "false");
static_assert(sizeof(VkShaderModuleCreateInfo) == 20, "false");
static_assert(sizeof(VkDescriptorSetLayoutBinding) == 20, "false");
static_assert(sizeof(VkDescriptorSetLayoutCreateInfo) == 20, "false");
static_assert(sizeof(VkDescriptorPoolSize) == 8, "false");
static_assert(sizeof(VkDescriptorPoolCreateInfo) == 24, "false");
static_assert(sizeof(VkDescriptorSetAllocateInfo) == 24, "false");
static_assert(sizeof(VkSpecializationMapEntry) == 12, "false");
static_assert(sizeof(VkSpecializationInfo) == 16, "false");
static_assert(sizeof(VkPipelineShaderStageCreateInfo) == 32, "false");
static_assert(sizeof(VkComputePipelineCreateInfo) == 64, "false");
static_assert(sizeof(VkComputePipelineIndirectBufferInfoNV) == 32, "false");
static_assert(sizeof(VkPipelineCreateFlags2CreateInfo) == 16, "false");
static_assert(sizeof(VkVertexInputBindingDescription) == 12, "false");
static_assert(sizeof(VkVertexInputAttributeDescription) == 16, "false");
static_assert(sizeof(VkPipelineVertexInputStateCreateInfo) == 28, "false");
static_assert(sizeof(VkPipelineInputAssemblyStateCreateInfo) == 20, "false");
static_assert(sizeof(VkPipelineTessellationStateCreateInfo) == 16, "false");
static_assert(sizeof(VkPipelineViewportStateCreateInfo) == 28, "false");
static_assert(sizeof(VkPipelineRasterizationStateCreateInfo) == 52, "false");
static_assert(sizeof(VkPipelineMultisampleStateCreateInfo) == 36, "false");
static_assert(sizeof(VkPipelineColorBlendAttachmentState) == 32, "false");
static_assert(sizeof(VkPipelineColorBlendStateCreateInfo) == 44, "false");
static_assert(sizeof(VkPipelineDynamicStateCreateInfo) == 20, "false");
static_assert(sizeof(VkStencilOpState) == 28, "false");
static_assert(sizeof(VkPipelineDepthStencilStateCreateInfo) == 96, "false");
static_assert(sizeof(VkGraphicsPipelineCreateInfo) == 88, "false");
static_assert(sizeof(VkPipelineCacheCreateInfo) == 20, "false");
static_assert(sizeof(VkPushConstantRange) == 12, "false");
static_assert(sizeof(VkPipelineBinaryCreateInfoKHR) == 24, "false");
static_assert(sizeof(VkPipelineBinaryHandlesInfoKHR) == 16, "false");
static_assert(sizeof(VkPipelineBinaryDataKHR) == 8, "false");
static_assert(sizeof(VkPipelineBinaryKeysAndDataKHR) == 12, "false");
static_assert(sizeof(VkPipelineBinaryKeyKHR) == 44, "false");
static_assert(sizeof(VkPipelineBinaryInfoKHR) == 16, "false");
static_assert(sizeof(VkReleaseCapturedPipelineDataInfoKHR) == 16, "false");
static_assert(sizeof(VkPipelineBinaryDataInfoKHR) == 16, "false");
static_assert(sizeof(VkPipelineCreateInfoKHR) == 8, "false");
static_assert(sizeof(VkPipelineLayoutCreateInfo) == 28, "false");
static_assert(sizeof(VkSamplerCreateInfo) == 72, "false");
static_assert(sizeof(VkCommandPoolCreateInfo) == 16, "false");
static_assert(sizeof(VkCommandBufferAllocateInfo) == 24, "false");
static_assert(sizeof(VkCommandBufferInheritanceInfo) == 40, "false");
static_assert(sizeof(VkCommandBufferBeginInfo) == 16, "false");
static_assert(sizeof(VkRenderPassBeginInfo) == 48, "false");
static_assert(sizeof(VkClearColorValue) == 16, "false");
static_assert(sizeof(VkClearDepthStencilValue) == 8, "false");
static_assert(sizeof(VkClearAttachment) == 24, "false");
static_assert(sizeof(VkAttachmentDescription) == 36, "false");
static_assert(sizeof(VkAttachmentReference) == 8, "false");
static_assert(sizeof(VkSubpassDescription) == 40, "false");
static_assert(sizeof(VkSubpassDependency) == 28, "false");
static_assert(sizeof(VkRenderPassCreateInfo) == 36, "false");
static_assert(sizeof(VkEventCreateInfo) == 12, "false");
static_assert(sizeof(VkFenceCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFeatures) == 220, "false");
static_assert(sizeof(VkPhysicalDeviceSparseProperties) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceLimits) == 488, "false");
static_assert(sizeof(VkSemaphoreCreateInfo) == 12, "false");
static_assert(sizeof(VkQueryPoolCreateInfo) == 24, "false");
static_assert(sizeof(VkFramebufferCreateInfo) == 40, "false");
static_assert(sizeof(VkMultiDrawInfoEXT) == 8, "false");
static_assert(sizeof(VkMultiDrawIndexedInfoEXT) == 12, "false");
static_assert(sizeof(VkSubmitInfo) == 36, "false");
static_assert(sizeof(VkDisplaySurfaceStereoCreateInfoNV) == 12, "false");
static_assert(sizeof(VkDisplayPresentInfoKHR) == 44, "false");
static_assert(sizeof(VkSurfaceCapabilitiesKHR) == 52, "false");
static_assert(sizeof(VkSurfaceFormatKHR) == 8, "false");
static_assert(sizeof(VkSwapchainCreateInfoKHR) == 84, "false");
static_assert(sizeof(VkPresentInfoKHR) == 32, "false");
static_assert(sizeof(VkDebugReportCallbackCreateInfoEXT) == 20, "false");
static_assert(sizeof(VkValidationFlagsEXT) == 16, "false");
static_assert(sizeof(VkValidationFeaturesEXT) == 24, "false");
static_assert(sizeof(VkLayerSettingsCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkLayerSettingEXT) == 20, "false");
static_assert(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD) == 12, "false");
static_assert(sizeof(VkDebugMarkerObjectNameInfoEXT) == 24, "false");
static_assert(sizeof(VkDebugMarkerObjectTagInfoEXT) == 36, "false");
static_assert(sizeof(VkDebugMarkerMarkerInfoEXT) == 28, "false");
static_assert(sizeof(VkDedicatedAllocationImageCreateInfoNV) == 12, "false");
static_assert(sizeof(VkDedicatedAllocationBufferCreateInfoNV) == 12, "false");
static_assert(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV) == 24, "false");
static_assert(sizeof(VkExternalMemoryImageCreateInfoNV) == 12, "false");
static_assert(sizeof(VkExportMemoryAllocateInfoNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV) == 20, "false");
static_assert(sizeof(VkDevicePrivateDataCreateInfo) == 12, "false");
static_assert(sizeof(VkPrivateDataSlotCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePrivateDataFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) == 44, "false");
static_assert(sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT) == 12, "false");
static_assert(sizeof(VkGraphicsShaderGroupCreateInfoNV) == 24, "false");
static_assert(sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV) == 24, "false");
static_assert(sizeof(VkIndirectCommandsStreamNV) == 16, "false");
static_assert(sizeof(VkIndirectCommandsLayoutTokenNV) == 64, "false");
static_assert(sizeof(VkIndirectCommandsLayoutCreateInfoNV) == 32, "false");
static_assert(sizeof(VkGeneratedCommandsInfoNV) == 96, "false");
static_assert(sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV) == 32, "false");
static_assert(sizeof(VkPipelineIndirectDeviceAddressInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceFeatures2) == 228, "false");
static_assert(sizeof(VkPhysicalDeviceProperties2) == 808, "false");
static_assert(sizeof(VkFormatProperties2) == 20, "false");
static_assert(sizeof(VkImageFormatProperties2) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceImageFormatInfo2) == 28, "false");
static_assert(sizeof(VkQueueFamilyProperties2) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryProperties2) == 464, "false");
static_assert(sizeof(VkSparseImageFormatProperties2) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceSparseImageFormatInfo2) == 28, "false");
static_assert(sizeof(VkPhysicalDevicePushDescriptorProperties) == 12, "false");
static_assert(sizeof(VkConformanceVersion) == 4, "false");
static_assert(sizeof(VkPhysicalDeviceDriverProperties) == 528, "false");
static_assert(sizeof(VkPresentRegionsKHR) == 16, "false");
static_assert(sizeof(VkPresentRegionKHR) == 8, "false");
static_assert(sizeof(VkRectLayerKHR) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceVariablePointersFeatures) == 16, "false");
static_assert(sizeof(VkExternalMemoryProperties) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExternalImageFormatInfo) == 12, "false");
static_assert(sizeof(VkExternalImageFormatProperties) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceExternalBufferInfo) == 20, "false");
static_assert(sizeof(VkExternalBufferProperties) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceIDProperties) == 56, "false");
static_assert(sizeof(VkExternalMemoryImageCreateInfo) == 12, "false");
static_assert(sizeof(VkExternalMemoryBufferCreateInfo) == 12, "false");
static_assert(sizeof(VkExportMemoryAllocateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExternalSemaphoreInfo) == 12, "false");
static_assert(sizeof(VkExternalSemaphoreProperties) == 20, "false");
static_assert(sizeof(VkExportSemaphoreCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExternalFenceInfo) == 12, "false");
static_assert(sizeof(VkExternalFenceProperties) == 20, "false");
static_assert(sizeof(VkExportFenceCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMultiviewFeatures) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceMultiviewProperties) == 16, "false");
static_assert(sizeof(VkRenderPassMultiviewCreateInfo) == 32, "false");
static_assert(sizeof(VkSurfaceCapabilities2EXT) == 64, "false");
static_assert(sizeof(VkDisplayPowerInfoEXT) == 12, "false");
static_assert(sizeof(VkDeviceEventInfoEXT) == 12, "false");
static_assert(sizeof(VkDisplayEventInfoEXT) == 12, "false");
static_assert(sizeof(VkSwapchainCounterCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceGroupProperties) == 144, "false");
static_assert(sizeof(VkMemoryAllocateFlagsInfo) == 16, "false");
static_assert(sizeof(VkBindBufferMemoryInfo) == 32, "false");
static_assert(sizeof(VkBindBufferMemoryDeviceGroupInfo) == 16, "false");
static_assert(sizeof(VkBindImageMemoryInfo) == 32, "false");
static_assert(sizeof(VkBindImageMemoryDeviceGroupInfo) == 24, "false");
static_assert(sizeof(VkDeviceGroupRenderPassBeginInfo) == 20, "false");
static_assert(sizeof(VkDeviceGroupCommandBufferBeginInfo) == 12, "false");
static_assert(sizeof(VkDeviceGroupSubmitInfo) == 32, "false");
static_assert(sizeof(VkDeviceGroupBindSparseInfo) == 16, "false");
static_assert(sizeof(VkDeviceGroupPresentCapabilitiesKHR) == 140, "false");
static_assert(sizeof(VkImageSwapchainCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkBindImageMemorySwapchainInfoKHR) == 20, "false");
static_assert(sizeof(VkAcquireNextImageInfoKHR) == 44, "false");
static_assert(sizeof(VkDeviceGroupPresentInfoKHR) == 20, "false");
static_assert(sizeof(VkDeviceGroupDeviceCreateInfo) == 16, "false");
static_assert(sizeof(VkDeviceGroupSwapchainCreateInfoKHR) == 12, "false");
static_assert(sizeof(VkDescriptorUpdateTemplateEntry) == 24, "false");
static_assert(sizeof(VkDescriptorUpdateTemplateCreateInfo) == 48, "false");
static_assert(sizeof(VkXYColorEXT) == 8, "false");
static_assert(sizeof(VkPhysicalDevicePresentIdFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPresentIdKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePresentWaitFeaturesKHR) == 12, "false");
static_assert(sizeof(VkHdrMetadataEXT) == 56, "false");
static_assert(sizeof(VkHdrVividDynamicMetadataHUAWEI) == 16, "false");
static_assert(sizeof(VkViewportWScalingNV) == 8, "false");
static_assert(sizeof(VkPipelineViewportWScalingStateCreateInfoNV) == 20, "false");
static_assert(sizeof(VkViewportSwizzleNV) == 16, "false");
static_assert(sizeof(VkPipelineViewportSwizzleStateCreateInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT) == 12, "false");
static_assert(sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) == 12, "false");
static_assert(sizeof(VkInputAttachmentAspectReference) == 12, "false");
static_assert(sizeof(VkRenderPassInputAttachmentAspectCreateInfo) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceSurfaceInfo2KHR) == 16, "false");
static_assert(sizeof(VkSurfaceCapabilities2KHR) == 60, "false");
static_assert(sizeof(VkSurfaceFormat2KHR) == 16, "false");
static_assert(sizeof(VkDisplayProperties2KHR) == 48, "false");
static_assert(sizeof(VkDisplayPlaneProperties2KHR) == 20, "false");
static_assert(sizeof(VkDisplayModeProperties2KHR) == 28, "false");
static_assert(sizeof(VkDisplayModeStereoPropertiesNV) == 12, "false");
static_assert(sizeof(VkDisplayPlaneInfo2KHR) == 20, "false");
static_assert(sizeof(VkDisplayPlaneCapabilities2KHR) == 76, "false");
static_assert(sizeof(VkPhysicalDevice16BitStorageFeatures) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceSubgroupProperties) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) == 12, "false");
static_assert(sizeof(VkBufferMemoryRequirementsInfo2) == 16, "false");
static_assert(sizeof(VkDeviceBufferMemoryRequirements) == 12, "false");
static_assert(sizeof(VkImageMemoryRequirementsInfo2) == 16, "false");
static_assert(sizeof(VkImageSparseMemoryRequirementsInfo2) == 16, "false");
static_assert(sizeof(VkDeviceImageMemoryRequirements) == 16, "false");
static_assert(sizeof(VkMemoryRequirements2) == 28, "false");
static_assert(sizeof(VkSparseImageMemoryRequirements2) == 56, "false");
static_assert(sizeof(VkPhysicalDevicePointClippingProperties) == 12, "false");
static_assert(sizeof(VkMemoryDedicatedRequirements) == 16, "false");
static_assert(sizeof(VkMemoryDedicatedAllocateInfo) == 24, "false");
static_assert(sizeof(VkImageViewUsageCreateInfo) == 12, "false");
static_assert(sizeof(VkImageViewSlicedCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPipelineTessellationDomainOriginStateCreateInfo) == 12, "false");
static_assert(sizeof(VkSamplerYcbcrConversionInfo) == 16, "false");
static_assert(sizeof(VkSamplerYcbcrConversionCreateInfo) == 52, "false");
static_assert(sizeof(VkBindImagePlaneMemoryInfo) == 12, "false");
static_assert(sizeof(VkImagePlaneMemoryRequirementsInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures) == 12, "false");
static_assert(sizeof(VkSamplerYcbcrConversionImageFormatProperties) == 12, "false");
static_assert(sizeof(VkTextureLODGatherFormatPropertiesAMD) == 12, "false");
static_assert(sizeof(VkConditionalRenderingBeginInfoEXT) == 28, "false");
static_assert(sizeof(VkProtectedSubmitInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceProtectedMemoryFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceProtectedMemoryProperties) == 12, "false");
static_assert(sizeof(VkDeviceQueueInfo2) == 20, "false");
static_assert(sizeof(VkPipelineCoverageToColorStateCreateInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties) == 16, "false");
static_assert(sizeof(VkSampleLocationEXT) == 8, "false");
static_assert(sizeof(VkSampleLocationsInfoEXT) == 28, "false");
static_assert(sizeof(VkAttachmentSampleLocationsEXT) == 32, "false");
static_assert(sizeof(VkSubpassSampleLocationsEXT) == 32, "false");
static_assert(sizeof(VkRenderPassSampleLocationsBeginInfoEXT) == 24, "false");
static_assert(sizeof(VkPipelineSampleLocationsStateCreateInfoEXT) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT) == 36, "false");
static_assert(sizeof(VkMultisamplePropertiesEXT) == 16, "false");
static_assert(sizeof(VkSamplerReductionModeCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) == 32, "false");
static_assert(sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceInlineUniformBlockFeatures) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceInlineUniformBlockProperties) == 28, "false");
static_assert(sizeof(VkWriteDescriptorSetInlineUniformBlock) == 16, "false");
static_assert(sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo) == 12, "false");
static_assert(sizeof(VkPipelineCoverageModulationStateCreateInfoNV) == 28, "false");
static_assert(sizeof(VkImageFormatListCreateInfo) == 16, "false");
static_assert(sizeof(VkValidationCacheCreateInfoEXT) == 20, "false");
static_assert(sizeof(VkShaderModuleValidationCacheCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance3Properties) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance4Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance4Properties) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance5Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance5Properties) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance6Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMaintenance6Properties) == 20, "false");
static_assert(sizeof(VkRenderingAreaInfo) == 28, "false");
static_assert(sizeof(VkDescriptorSetLayoutSupport) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderDrawParametersFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderFloat16Int8Features) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceFloatControlsProperties) == 76, "false");
static_assert(sizeof(VkPhysicalDeviceHostQueryResetFeatures) == 12, "false");
static_assert(sizeof(VkDeviceQueueGlobalPriorityCreateInfo) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceGlobalPriorityQueryFeatures) == 12, "false");
static_assert(sizeof(VkQueueFamilyGlobalPriorityProperties) == 76, "false");
static_assert(sizeof(VkDebugUtilsObjectNameInfoEXT) == 24, "false");
static_assert(sizeof(VkDebugUtilsObjectTagInfoEXT) == 36, "false");
static_assert(sizeof(VkDebugUtilsLabelEXT) == 28, "false");
static_assert(sizeof(VkDebugUtilsMessengerCreateInfoEXT) == 28, "false");
static_assert(sizeof(VkDebugUtilsMessengerCallbackDataEXT) == 48, "false");
static_assert(sizeof(VkImportMemoryHostPointerInfoEXT) == 16, "false");
static_assert(sizeof(VkMemoryHostPointerPropertiesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT) == 44, "false");
static_assert(sizeof(VkCalibratedTimestampInfoKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderCorePropertiesAMD) == 64, "false");
static_assert(sizeof(VkPhysicalDeviceShaderCoreProperties2AMD) == 16, "false");
static_assert(sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorIndexingFeatures) == 88, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorIndexingProperties) == 100, "false");
static_assert(sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo) == 16, "false");
static_assert(sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo) == 16, "false");
static_assert(sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport) == 12, "false");
static_assert(sizeof(VkAttachmentDescription2) == 44, "false");
static_assert(sizeof(VkAttachmentReference2) == 20, "false");
static_assert(sizeof(VkSubpassDescription2) == 52, "false");
static_assert(sizeof(VkSubpassDependency2) == 40, "false");
static_assert(sizeof(VkRenderPassCreateInfo2) == 44, "false");
static_assert(sizeof(VkSubpassBeginInfo) == 12, "false");
static_assert(sizeof(VkSubpassEndInfo) == 8, "false");
static_assert(sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceTimelineSemaphoreProperties) == 16, "false");
static_assert(sizeof(VkSemaphoreTypeCreateInfo) == 20, "false");
static_assert(sizeof(VkTimelineSemaphoreSubmitInfo) == 24, "false");
static_assert(sizeof(VkSemaphoreWaitInfo) == 24, "false");
static_assert(sizeof(VkSemaphoreSignalInfo) == 24, "false");
static_assert(sizeof(VkVertexInputBindingDivisorDescription) == 8, "false");
static_assert(sizeof(VkPipelineVertexInputDivisorStateCreateInfo) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceVertexAttributeDivisorProperties) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT) == 24, "false");
static_assert(sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDevice8BitStorageFeatures) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceShaderAtomicInt64Features) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) == 56, "false");
static_assert(sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT) == 56, "false");
static_assert(sizeof(VkPhysicalDeviceVertexAttributeDivisorFeatures) == 16, "false");
static_assert(sizeof(VkQueueFamilyCheckpointPropertiesNV) == 12, "false");
static_assert(sizeof(VkCheckpointDataNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceDepthStencilResolveProperties) == 24, "false");
static_assert(sizeof(VkSubpassDescriptionDepthStencilResolve) == 20, "false");
static_assert(sizeof(VkImageViewASTCDecodeModeEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT) == 52, "false");
static_assert(sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) == 12, "false");
static_assert(sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV) == 12, "false");
static_assert(sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV) == 24, "false");
static_assert(sizeof(VkShadingRatePaletteNV) == 8, "false");
static_assert(sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI) == 12, "false");
static_assert(sizeof(VkCoarseSampleLocationNV) == 12, "false");
static_assert(sizeof(VkCoarseSampleOrderCustomNV) == 16, "false");
static_assert(sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceMeshShaderFeaturesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceMeshShaderPropertiesNV) == 76, "false");
static_assert(sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT) == 152, "false");
static_assert(sizeof(VkRayTracingShaderGroupCreateInfoNV) == 28, "false");
static_assert(sizeof(VkRayTracingShaderGroupCreateInfoKHR) == 32, "false");
static_assert(sizeof(VkRayTracingPipelineCreateInfoNV) == 52, "false");
static_assert(sizeof(VkRayTracingPipelineCreateInfoKHR) == 64, "false");
static_assert(sizeof(VkGeometryTrianglesNV) == 80, "false");
static_assert(sizeof(VkGeometryAABBNV) == 32, "false");
static_assert(sizeof(VkGeometryDataNV) == 112, "false");
static_assert(sizeof(VkGeometryNV) == 128, "false");
static_assert(sizeof(VkAccelerationStructureInfoNV) == 28, "false");
static_assert(sizeof(VkAccelerationStructureCreateInfoNV) == 44, "false");
static_assert(sizeof(VkBindAccelerationStructureMemoryInfoNV) == 40, "false");
static_assert(sizeof(VkWriteDescriptorSetAccelerationStructureKHR) == 16, "false");
static_assert(sizeof(VkWriteDescriptorSetAccelerationStructureNV) == 16, "false");
static_assert(sizeof(VkAccelerationStructureMemoryRequirementsInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceRayQueryFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR) == 52, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingPropertiesNV) == 52, "false");
static_assert(sizeof(VkStridedDeviceAddressRegionKHR) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR) == 16, "false");
static_assert(sizeof(VkImageStencilUsageCreateInfo) == 12, "false");
static_assert(sizeof(VkDeviceMemoryOverallocationCreateInfoAMD) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) == 16, "false");
static_assert(sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT) == 264, "false");
static_assert(sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT) == 12, "false");
static_assert(sizeof(VkMemoryPriorityAllocateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) == 20, "false");
static_assert(sizeof(VkBufferDeviceAddressInfo) == 16, "false");
static_assert(sizeof(VkBufferOpaqueCaptureAddressCreateInfo) == 16, "false");
static_assert(sizeof(VkBufferDeviceAddressCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT) == 12, "false");
static_assert(sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceImagelessFramebufferFeatures) == 12, "false");
static_assert(sizeof(VkFramebufferAttachmentsCreateInfo) == 16, "false");
static_assert(sizeof(VkFramebufferAttachmentImageInfo) == 36, "false");
static_assert(sizeof(VkRenderPassAttachmentBeginInfo) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV) == 12, "false");
static_assert(sizeof(VkCooperativeMatrixPropertiesNV) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) == 12, "false");
static_assert(sizeof(VkImageViewHandleInfoNVX) == 28, "false");
static_assert(sizeof(VkImageViewAddressPropertiesNVX) == 24, "false");
static_assert(sizeof(VkPipelineCreationFeedback) == 12, "false");
static_assert(sizeof(VkPipelineCreationFeedbackCreateInfo) == 20, "false");
static_assert(sizeof(VkPhysicalDevicePresentBarrierFeaturesNV) == 12, "false");
static_assert(sizeof(VkSurfaceCapabilitiesPresentBarrierNV) == 12, "false");
static_assert(sizeof(VkSwapchainPresentBarrierCreateInfoNV) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR) == 12, "false");
static_assert(sizeof(VkPerformanceCounterKHR) == 36, "false");
static_assert(sizeof(VkPerformanceCounterDescriptionKHR) == 780, "false");
static_assert(sizeof(VkQueryPoolPerformanceCreateInfoKHR) == 20, "false");
static_assert(sizeof(VkAcquireProfilingLockInfoKHR) == 20, "false");
static_assert(sizeof(VkPerformanceQuerySubmitInfoKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV) == 12, "false");
static_assert(sizeof(VkPipelineCoverageReductionStateCreateInfoNV) == 16, "false");
static_assert(sizeof(VkFramebufferMixedSamplesCombinationNV) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) == 12, "false");
static_assert(sizeof(VkPerformanceValueINTEL) == 12, "false");
static_assert(sizeof(VkInitializePerformanceApiInfoINTEL) == 12, "false");
static_assert(sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL) == 12, "false");
static_assert(sizeof(VkPerformanceMarkerInfoINTEL) == 16, "false");
static_assert(sizeof(VkPerformanceStreamMarkerInfoINTEL) == 12, "false");
static_assert(sizeof(VkPerformanceOverrideInfoINTEL) == 24, "false");
static_assert(sizeof(VkPerformanceConfigurationAcquireInfoINTEL) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderClockFeaturesKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceIndexTypeUint8Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) == 12, "false");
static_assert(sizeof(VkAttachmentReferenceStencilLayout) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) == 16, "false");
static_assert(sizeof(VkAttachmentDescriptionStencilLayout) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPipelineInfoKHR) == 16, "false");
static_assert(sizeof(VkPipelineExecutablePropertiesKHR) == 528, "false");
static_assert(sizeof(VkPipelineExecutableInfoKHR) == 20, "false");
static_assert(sizeof(VkPipelineExecutableStatisticKHR) == 532, "false");
static_assert(sizeof(VkPipelineExecutableInternalRepresentationKHR) == 532, "false");
static_assert(sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceSubgroupSizeControlProperties) == 24, "false");
static_assert(sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) == 12, "false");
static_assert(sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI) == 44, "false");
static_assert(sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo) == 16, "false");
static_assert(sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceLineRasterizationFeatures) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceLineRasterizationProperties) == 12, "false");
static_assert(sizeof(VkPipelineRasterizationLineStateCreateInfo) == 24, "false");
static_assert(sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan11Features) == 56, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan11Properties) == 100, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan12Features) == 196, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan12Properties) == 724, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan13Features) == 68, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan13Properties) == 200, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan14Features) == 92, "false");
static_assert(sizeof(VkPhysicalDeviceVulkan14Properties) == 120, "false");
static_assert(sizeof(VkPipelineCompilerControlCreateInfoAMD) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceToolProperties) == 1036, "false");
static_assert(sizeof(VkSamplerCustomBorderColorCreateInfoEXT) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT) == 16, "false");
static_assert(sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT) == 16, "false");
static_assert(sizeof(VkAccelerationStructureGeometryTrianglesDataKHR) == 52, "false");
static_assert(sizeof(VkAccelerationStructureGeometryAabbsDataKHR) == 24, "false");
static_assert(sizeof(VkAccelerationStructureGeometryInstancesDataKHR) == 20, "false");
static_assert(sizeof(VkAccelerationStructureGeometryKHR) == 68, "false");
static_assert(sizeof(VkAccelerationStructureBuildGeometryInfoKHR) == 56, "false");
static_assert(sizeof(VkAccelerationStructureBuildRangeInfoKHR) == 16, "false");
static_assert(sizeof(VkAccelerationStructureCreateInfoKHR) == 48, "false");
static_assert(sizeof(VkAccelerationStructureDeviceAddressInfoKHR) == 16, "false");
static_assert(sizeof(VkAccelerationStructureVersionInfoKHR) == 12, "false");
static_assert(sizeof(VkCopyAccelerationStructureInfoKHR) == 28, "false");
static_assert(sizeof(VkCopyAccelerationStructureToMemoryInfoKHR) == 28, "false");
static_assert(sizeof(VkCopyMemoryToAccelerationStructureInfoKHR) == 28, "false");
static_assert(sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkPipelineLibraryCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT) == 132, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT) == 12, "false");
static_assert(sizeof(VkColorBlendEquationEXT) == 24, "false");
static_assert(sizeof(VkColorBlendAdvancedEXT) == 20, "false");
static_assert(sizeof(VkRenderPassTransformBeginInfoQCOM) == 12, "false");
static_assert(sizeof(VkCopyCommandTransformInfoQCOM) == 12, "false");
static_assert(sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV) == 12, "false");
static_assert(sizeof(VkDeviceDiagnosticsConfigCreateInfoNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRobustness2FeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceRobustness2PropertiesEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceImageRobustnessFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) == 24, "false");
static_assert(sizeof(VkPhysicalDevice4444FormatsFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI) == 12, "false");
static_assert(sizeof(VkBufferCopy2) == 32, "false");
static_assert(sizeof(VkImageCopy2) == 76, "false");
static_assert(sizeof(VkImageBlit2) == 88, "false");
static_assert(sizeof(VkBufferImageCopy2) == 64, "false");
static_assert(sizeof(VkImageResolve2) == 76, "false");
static_assert(sizeof(VkCopyBufferInfo2) == 32, "false");
static_assert(sizeof(VkCopyImageInfo2) == 40, "false");
static_assert(sizeof(VkBlitImageInfo2) == 44, "false");
static_assert(sizeof(VkCopyBufferToImageInfo2) == 36, "false");
static_assert(sizeof(VkCopyImageToBufferInfo2) == 36, "false");
static_assert(sizeof(VkResolveImageInfo2) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) == 16, "false");
static_assert(sizeof(VkFragmentShadingRateAttachmentInfoKHR) == 20, "false");
static_assert(sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR) == 88, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShadingRateKHR) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) == 12, "false");
static_assert(sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV) == 24, "false");
static_assert(sizeof(VkAccelerationStructureBuildSizesInfoKHR) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) == 12, "false");
static_assert(sizeof(VkMutableDescriptorTypeListEXT) == 8, "false");
static_assert(sizeof(VkMutableDescriptorTypeCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT) == 56, "false");
static_assert(sizeof(VkGeneratedCommandsPipelineInfoEXT) == 16, "false");
static_assert(sizeof(VkGeneratedCommandsShaderInfoEXT) == 16, "false");
static_assert(sizeof(VkGeneratedCommandsMemoryRequirementsInfoEXT) == 32, "false");
static_assert(sizeof(VkIndirectExecutionSetPipelineInfoEXT) == 20, "false");
static_assert(sizeof(VkIndirectExecutionSetShaderLayoutInfoEXT) == 16, "false");
static_assert(sizeof(VkIndirectExecutionSetShaderInfoEXT) == 32, "false");
static_assert(sizeof(VkIndirectExecutionSetCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkGeneratedCommandsInfoEXT) == 76, "false");
static_assert(sizeof(VkWriteIndirectExecutionSetPipelineEXT) == 20, "false");
static_assert(sizeof(VkWriteIndirectExecutionSetShaderEXT) == 20, "false");
static_assert(sizeof(VkIndirectCommandsLayoutCreateInfoEXT) == 36, "false");
static_assert(sizeof(VkIndirectCommandsLayoutTokenEXT) == 20, "false");
static_assert(sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDepthClampControlFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPipelineViewportDepthClampControlCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR) == 12, "false");
static_assert(sizeof(VkVertexInputBindingDescription2EXT) == 24, "false");
static_assert(sizeof(VkVertexInputAttributeDescription2EXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPipelineColorWriteCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkMemoryBarrier2) == 40, "false");
static_assert(sizeof(VkImageMemoryBarrier2) == 84, "false");
static_assert(sizeof(VkBufferMemoryBarrier2) == 72, "false");
static_assert(sizeof(VkDependencyInfo) == 36, "false");
static_assert(sizeof(VkSemaphoreSubmitInfo) == 36, "false");
static_assert(sizeof(VkCommandBufferSubmitInfo) == 16, "false");
static_assert(sizeof(VkSubmitInfo2) == 36, "false");
static_assert(sizeof(VkQueueFamilyCheckpointProperties2NV) == 16, "false");
static_assert(sizeof(VkCheckpointData2NV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceSynchronization2Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceHostImageCopyFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceHostImageCopyProperties) == 44, "false");
static_assert(sizeof(VkMemoryToImageCopy) == 60, "false");
static_assert(sizeof(VkImageToMemoryCopy) == 60, "false");
static_assert(sizeof(VkCopyMemoryToImageInfo) == 32, "false");
static_assert(sizeof(VkCopyImageToMemoryInfo) == 32, "false");
static_assert(sizeof(VkCopyImageToImageInfo) == 44, "false");
static_assert(sizeof(VkHostImageLayoutTransitionInfo) == 44, "false");
static_assert(sizeof(VkSubresourceHostMemcpySize) == 16, "false");
static_assert(sizeof(VkHostImageCopyDevicePerformanceQuery) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) == 12, "false");
static_assert(sizeof(VkSubpassResolvePerformanceQueryEXT) == 12, "false");
static_assert(sizeof(VkMultisampledRenderToSingleSampledInfoEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDevicePipelineProtectedAccessFeatures) == 12, "false");
static_assert(sizeof(VkQueueFamilyVideoPropertiesKHR) == 12, "false");
static_assert(sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR) == 12, "false");
static_assert(sizeof(VkVideoProfileListInfoKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceVideoFormatInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoFormatPropertiesKHR) == 44, "false");
static_assert(sizeof(VkVideoEncodeQuantizationMapCapabilitiesKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH264QuantizationMapCapabilitiesKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH265QuantizationMapCapabilitiesKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeAV1QuantizationMapCapabilitiesKHR) == 16, "false");
static_assert(sizeof(VkVideoFormatQuantizationMapPropertiesKHR) == 16, "false");
static_assert(sizeof(VkVideoFormatH265QuantizationMapPropertiesKHR) == 12, "false");
static_assert(sizeof(VkVideoFormatAV1QuantizationMapPropertiesKHR) == 12, "false");
static_assert(sizeof(VkVideoProfileInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoCapabilitiesKHR) == 320, "false");
static_assert(sizeof(VkVideoSessionMemoryRequirementsKHR) == 32, "false");
static_assert(sizeof(VkBindVideoSessionMemoryInfoKHR) == 36, "false");
static_assert(sizeof(VkVideoPictureResourceInfoKHR) == 36, "false");
static_assert(sizeof(VkVideoReferenceSlotInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoDecodeCapabilitiesKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeUsageInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeInfoKHR) == 84, "false");
static_assert(sizeof(VkPhysicalDeviceVideoMaintenance1FeaturesKHR) == 12, "false");
static_assert(sizeof(VkVideoInlineQueryInfoKHR) == 24, "false");
static_assert(sizeof(StdVideoDecodeH264PictureInfo) == 20, "false");
static_assert(sizeof(StdVideoDecodeH264ReferenceInfo) == 16, "false");
static_assert(sizeof(VkVideoDecodeH264ProfileInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoDecodeH264CapabilitiesKHR) == 20, "false");
static_assert(sizeof(StdVideoH264SequenceParameterSet) == 76, "false");
static_assert(sizeof(StdVideoH264PictureParameterSet) == 20, "false");
static_assert(sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoDecodeH264SessionParametersCreateInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoDecodeH264PictureInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoDecodeH264DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(StdVideoH265VideoParameterSet) == 36, "false");
static_assert(sizeof(StdVideoH265SequenceParameterSet) == 84, "false");
static_assert(sizeof(StdVideoH265PictureParameterSet) == 136, "false");
static_assert(sizeof(StdVideoDecodeH265PictureInfo) == 40, "false");
static_assert(sizeof(StdVideoDecodeH265ReferenceInfo) == 8, "false");
static_assert(sizeof(VkVideoDecodeH265ProfileInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeH265CapabilitiesKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR) == 32, "false");
static_assert(sizeof(VkVideoDecodeH265SessionParametersCreateInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoDecodeH265PictureInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoDecodeH265DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(StdVideoAV1SequenceHeader) == 32, "false");
static_assert(sizeof(StdVideoDecodeAV1PictureInfo) == 104, "false");
static_assert(sizeof(StdVideoDecodeAV1ReferenceInfo) == 16, "false");
static_assert(sizeof(VkVideoDecodeAV1ProfileInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoDecodeAV1CapabilitiesKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeAV1SessionParametersCreateInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoDecodeAV1PictureInfoKHR) == 56, "false");
static_assert(sizeof(VkVideoDecodeAV1DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoSessionCreateInfoKHR) == 48, "false");
static_assert(sizeof(VkVideoSessionParametersCreateInfoKHR) == 28, "false");
static_assert(sizeof(VkVideoSessionParametersUpdateInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeSessionParametersGetInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeSessionParametersFeedbackInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoBeginCodingInfoKHR) == 36, "false");
static_assert(sizeof(VkVideoEndCodingInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoCodingControlInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeUsageInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoEncodeInfoKHR) == 88, "false");
static_assert(sizeof(VkVideoEncodeQuantizationMapInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR) == 12, "false");
static_assert(sizeof(VkQueryPoolVideoEncodeFeedbackCreateInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeQualityLevelInfoKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeQualityLevelPropertiesKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeRateControlInfoKHR) == 32, "false");
static_assert(sizeof(VkVideoEncodeRateControlLayerInfoKHR) == 32, "false");
static_assert(sizeof(VkVideoEncodeCapabilitiesKHR) == 44, "false");
static_assert(sizeof(VkVideoEncodeH264CapabilitiesKHR) == 60, "false");
static_assert(sizeof(VkVideoEncodeH264QualityLevelPropertiesKHR) == 52, "false");
static_assert(sizeof(StdVideoEncodeH264SliceHeader) == 28, "false");
static_assert(sizeof(StdVideoEncodeH264PictureInfo) == 28, "false");
static_assert(sizeof(StdVideoEncodeH264ReferenceInfo) == 24, "false");
static_assert(sizeof(VkVideoEncodeH264SessionCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH264SessionParametersAddInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH264SessionParametersCreateInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoEncodeH264SessionParametersGetInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH264SessionParametersFeedbackInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH264DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH264PictureInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH264ProfileInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH264NaluSliceInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH264RateControlInfoKHR) == 28, "false");
static_assert(sizeof(VkVideoEncodeH264QpKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH264FrameSizeKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH264GopRemainingFrameInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH264RateControlLayerInfoKHR) == 56, "false");
static_assert(sizeof(VkVideoEncodeH265CapabilitiesKHR) == 76, "false");
static_assert(sizeof(VkVideoEncodeH265QualityLevelPropertiesKHR) == 48, "false");
static_assert(sizeof(StdVideoEncodeH265PictureInfo) == 36, "false");
static_assert(sizeof(StdVideoEncodeH265SliceSegmentHeader) == 28, "false");
static_assert(sizeof(StdVideoEncodeH265ReferenceInfo) == 16, "false");
static_assert(sizeof(VkVideoEncodeH265SessionCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH265SessionParametersAddInfoKHR) == 32, "false");
static_assert(sizeof(VkVideoEncodeH265SessionParametersCreateInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH265SessionParametersGetInfoKHR) == 32, "false");
static_assert(sizeof(VkVideoEncodeH265SessionParametersFeedbackInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoEncodeH265PictureInfoKHR) == 20, "false");
static_assert(sizeof(VkVideoEncodeH265NaluSliceSegmentInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeH265RateControlInfoKHR) == 28, "false");
static_assert(sizeof(VkVideoEncodeH265QpKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH265FrameSizeKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH265GopRemainingFrameInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeH265RateControlLayerInfoKHR) == 56, "false");
static_assert(sizeof(VkVideoEncodeH265ProfileInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeH265DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1CapabilitiesKHR) == 120, "false");
static_assert(sizeof(VkVideoEncodeAV1QualityLevelPropertiesKHR) == 76, "false");
static_assert(sizeof(StdVideoEncodeAV1ExtensionHeader) == 2, "false");
static_assert(sizeof(StdVideoEncodeAV1DecoderModelInfo) == 8, "false");
static_assert(sizeof(StdVideoEncodeAV1OperatingPointInfo) == 20, "false");
static_assert(sizeof(StdVideoEncodeAV1PictureInfo) == 116, "false");
static_assert(sizeof(StdVideoEncodeAV1ReferenceInfo) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceVideoEncodeAV1FeaturesKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1SessionCreateInfoKHR) == 16, "false");
static_assert(sizeof(VkVideoEncodeAV1SessionParametersCreateInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeAV1DpbSlotInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1PictureInfoKHR) == 60, "false");
static_assert(sizeof(VkVideoEncodeAV1ProfileInfoKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1RateControlInfoKHR) == 28, "false");
static_assert(sizeof(VkVideoEncodeAV1QIndexKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1FrameSizeKHR) == 12, "false");
static_assert(sizeof(VkVideoEncodeAV1GopRemainingFrameInfoKHR) == 24, "false");
static_assert(sizeof(VkVideoEncodeAV1RateControlLayerInfoKHR) == 56, "false");
static_assert(sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV) == 12, "false");
static_assert(sizeof(VkCommandBufferInheritanceViewportScissorInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT) == 16, "false");
static_assert(sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkCuModuleCreateInfoNVX) == 16, "false");
static_assert(sizeof(VkCuModuleTexturingModeCreateInfoNVX) == 12, "false");
static_assert(sizeof(VkCuFunctionCreateInfoNVX) == 20, "false");
static_assert(sizeof(VkCuLaunchInfoNVX) == 60, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT) == 164, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) == 12, "false");
static_assert(sizeof(VkDescriptorAddressInfoEXT) == 28, "false");
static_assert(sizeof(VkDescriptorBufferBindingInfoEXT) == 20, "false");
static_assert(sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT) == 16, "false");
static_assert(sizeof(VkDescriptorGetInfoEXT) == 20, "false");
static_assert(sizeof(VkBufferCaptureDescriptorDataInfoEXT) == 16, "false");
static_assert(sizeof(VkImageCaptureDescriptorDataInfoEXT) == 16, "false");
static_assert(sizeof(VkImageViewCaptureDescriptorDataInfoEXT) == 16, "false");
static_assert(sizeof(VkSamplerCaptureDescriptorDataInfoEXT) == 16, "false");
static_assert(sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT) == 24, "false");
static_assert(sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties) == 128, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingValidationFeaturesNV) == 12, "false");
static_assert(sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV) == 16, "false");
static_assert(sizeof(VkAccelerationStructureMotionInfoNV) == 16, "false");
static_assert(sizeof(VkCudaModuleCreateInfoNV) == 16, "false");
static_assert(sizeof(VkCudaFunctionCreateInfoNV) == 20, "false");
static_assert(sizeof(VkCudaLaunchInfoNV) == 60, "false");
static_assert(sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT) == 12, "false");
static_assert(sizeof(VkFormatProperties3) == 32, "false");
static_assert(sizeof(VkPipelineRenderingCreateInfo) == 28, "false");
static_assert(sizeof(VkRenderingInfo) == 52, "false");
static_assert(sizeof(VkRenderingAttachmentInfo) == 60, "false");
static_assert(sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceDynamicRenderingFeatures) == 12, "false");
static_assert(sizeof(VkCommandBufferInheritanceRenderingInfo) == 36, "false");
static_assert(sizeof(VkAttachmentSampleCountInfoAMD) == 20, "false");
static_assert(sizeof(VkMultiviewPerViewAttributesInfoNVX) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT) == 12, "false");
static_assert(sizeof(VkImageViewMinLodCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePipelineBinaryFeaturesKHR) == 12, "false");
static_assert(sizeof(VkDevicePipelineBinaryInternalCacheControlKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePipelineBinaryPropertiesKHR) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) == 16, "false");
static_assert(sizeof(VkGraphicsPipelineLibraryCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) == 12, "false");
static_assert(sizeof(VkDescriptorSetBindingReferenceVALVE) == 20, "false");
static_assert(sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceNestedCommandBufferFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceNestedCommandBufferPropertiesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT) == 24, "false");
static_assert(sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkShaderModuleIdentifierEXT) == 44, "false");
static_assert(sizeof(VkImageCompressionControlEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT) == 12, "false");
static_assert(sizeof(VkImageCompressionPropertiesEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) == 12, "false");
static_assert(sizeof(VkImageSubresource2) == 20, "false");
static_assert(sizeof(VkSubresourceLayout2) == 48, "false");
static_assert(sizeof(VkRenderPassCreationControlEXT) == 12, "false");
static_assert(sizeof(VkRenderPassCreationFeedbackInfoEXT) == 4, "false");
static_assert(sizeof(VkRenderPassCreationFeedbackCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkRenderPassSubpassFeedbackInfoEXT) == 264, "false");
static_assert(sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) == 12, "false");
static_assert(sizeof(VkMicromapBuildInfoEXT) == 72, "false");
static_assert(sizeof(VkMicromapCreateInfoEXT) == 48, "false");
static_assert(sizeof(VkMicromapVersionInfoEXT) == 12, "false");
static_assert(sizeof(VkCopyMicromapInfoEXT) == 28, "false");
static_assert(sizeof(VkCopyMicromapToMemoryInfoEXT) == 28, "false");
static_assert(sizeof(VkCopyMemoryToMicromapInfoEXT) == 28, "false");
static_assert(sizeof(VkMicromapBuildSizesInfoEXT) == 28, "false");
static_assert(sizeof(VkMicromapUsageEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT) == 16, "false");
static_assert(sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT) == 52, "false");
static_assert(sizeof(VkPipelinePropertiesIdentifierEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) == 12, "false");
static_assert(sizeof(VkExternalMemoryAcquireUnmodifiedEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePipelineRobustnessFeatures) == 12, "false");
static_assert(sizeof(VkPipelineRobustnessCreateInfo) == 24, "false");
static_assert(sizeof(VkPhysicalDevicePipelineRobustnessProperties) == 24, "false");
static_assert(sizeof(VkImageViewSampleWeightCreateInfoQCOM) == 28, "false");
static_assert(sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM) == 36, "false");
static_assert(sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkTilePropertiesQCOM) == 36, "false");
static_assert(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT) == 12, "false");
static_assert(sizeof(VkDeviceAddressBindingCallbackDataEXT) == 32, "false");
static_assert(sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV) == 52, "false");
static_assert(sizeof(VkOpticalFlowImageFormatInfoNV) == 12, "false");
static_assert(sizeof(VkOpticalFlowImageFormatPropertiesNV) == 12, "false");
static_assert(sizeof(VkOpticalFlowSessionCreateInfoNV) == 44, "false");
static_assert(sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV) == 20, "false");
static_assert(sizeof(VkOpticalFlowExecuteInfoNV) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceFaultFeaturesEXT) == 16, "false");
static_assert(sizeof(VkDeviceFaultAddressInfoEXT) == 20, "false");
static_assert(sizeof(VkDeviceFaultVendorInfoEXT) == 272, "false");
static_assert(sizeof(VkDeviceFaultCountsEXT) == 24, "false");
static_assert(sizeof(VkDeviceFaultInfoEXT) == 276, "false");
static_assert(sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT) == 12, "false");
static_assert(sizeof(VkDepthBiasInfoEXT) == 20, "false");
static_assert(sizeof(VkDepthBiasRepresentationInfoEXT) == 16, "false");
static_assert(sizeof(VkDecompressMemoryRegionNV) == 40, "false");
static_assert(sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM) == 12, "false");
static_assert(sizeof(VkFrameBoundaryEXT) == 52, "false");
static_assert(sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT) == 12, "false");
static_assert(sizeof(VkSurfacePresentModeEXT) == 12, "false");
static_assert(sizeof(VkSurfacePresentScalingCapabilitiesEXT) == 36, "false");
static_assert(sizeof(VkSurfacePresentModeCompatibilityEXT) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT) == 12, "false");
static_assert(sizeof(VkSwapchainPresentFenceInfoEXT) == 16, "false");
static_assert(sizeof(VkSwapchainPresentModesCreateInfoEXT) == 16, "false");
static_assert(sizeof(VkSwapchainPresentModeInfoEXT) == 16, "false");
static_assert(sizeof(VkSwapchainPresentScalingCreateInfoEXT) == 20, "false");
static_assert(sizeof(VkReleaseSwapchainImagesInfoEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR) == 12, "false");
static_assert(sizeof(VkDeviceImageSubresourceInfo) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShaderCorePropertiesARM) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM) == 16, "false");
static_assert(sizeof(VkQueryLowLatencySupportNV) == 12, "false");
static_assert(sizeof(VkMemoryMapInfo) == 36, "false");
static_assert(sizeof(VkMemoryUnmapInfo) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT) == 28, "false");
static_assert(sizeof(VkShaderCreateInfoEXT) == 56, "false");
static_assert(sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR) == 16, "false");
static_assert(sizeof(VkCooperativeMatrixPropertiesKHR) == 44, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceAntiLagFeaturesAMD) == 12, "false");
static_assert(sizeof(VkAntiLagDataAMD) == 20, "false");
static_assert(sizeof(VkAntiLagPresentationInfoAMD) == 20, "false");
static_assert(sizeof(VkBindMemoryStatus) == 12, "false");
static_assert(sizeof(VkBindDescriptorSetsInfo) == 40, "false");
static_assert(sizeof(VkPushConstantsInfo) == 32, "false");
static_assert(sizeof(VkPushDescriptorSetInfo) == 32, "false");
static_assert(sizeof(VkPushDescriptorSetWithTemplateInfo) == 32, "false");
static_assert(sizeof(VkSetDescriptorBufferOffsetsInfoEXT) == 36, "false");
static_assert(sizeof(VkBindDescriptorBufferEmbeddedSamplersInfoEXT) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM) == 12, "false");
static_assert(sizeof(VkSamplerCubicWeightsCreateInfoQCOM) == 12, "false");
static_assert(sizeof(VkBlitImageCubicWeightsInfoQCOM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM) == 16, "false");
static_assert(sizeof(VkSamplerBlockMatchWindowCreateInfoQCOM) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePerStageDescriptorSetFeaturesNV) == 16, "false");
static_assert(sizeof(VkLatencySleepModeInfoNV) == 20, "false");
static_assert(sizeof(VkLatencySleepInfoNV) == 24, "false");
static_assert(sizeof(VkSetLatencyMarkerInfoNV) == 20, "false");
static_assert(sizeof(VkGetLatencyMarkerInfoNV) == 16, "false");
static_assert(sizeof(VkLatencyTimingsFrameReportNV) == 120, "false");
static_assert(sizeof(VkOutOfBandQueueTypeInfoNV) == 12, "false");
static_assert(sizeof(VkLatencySubmissionPresentIdNV) == 16, "false");
static_assert(sizeof(VkSwapchainLatencyCreateInfoNV) == 12, "false");
static_assert(sizeof(VkLatencySurfaceCapabilitiesNV) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceCudaKernelLaunchFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCudaKernelLaunchPropertiesNV) == 16, "false");
static_assert(sizeof(VkDeviceQueueShaderCoreControlCreateInfoARM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceSchedulingControlsFeaturesARM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceSchedulingControlsPropertiesARM) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRenderPassStripedFeaturesARM) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRenderPassStripedPropertiesARM) == 20, "false");
static_assert(sizeof(VkRenderPassStripeInfoARM) == 24, "false");
static_assert(sizeof(VkRenderPassStripeBeginInfoARM) == 16, "false");
static_assert(sizeof(VkRenderPassStripeSubmitInfoARM) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderSubgroupRotateFeatures) == 16, "false");
static_assert(sizeof(VkPhysicalDeviceShaderExpectAssumeFeatures) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderFloatControls2Features) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceDynamicRenderingLocalReadFeatures) == 12, "false");
static_assert(sizeof(VkRenderingAttachmentLocationInfo) == 16, "false");
static_assert(sizeof(VkRenderingInputAttachmentIndexInfo) == 24, "false");
static_assert(sizeof(VkPhysicalDeviceShaderQuadControlFeaturesKHR) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceMapMemoryPlacedFeaturesEXT) == 20, "false");
static_assert(sizeof(VkPhysicalDeviceMapMemoryPlacedPropertiesEXT) == 16, "false");
static_assert(sizeof(VkMemoryMapPlacedInfoEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceRawAccessChainsFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceCommandBufferInheritanceFeaturesNV) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceImageAlignmentControlFeaturesMESA) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceImageAlignmentControlPropertiesMESA) == 12, "false");
static_assert(sizeof(VkImageAlignmentControlCreateInfoMESA) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT) == 12, "false");
static_assert(sizeof(VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT) == 12, "false");
static_assert(sizeof(VkDepthClampRangeEXT) == 8, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrix2FeaturesNV) == 36, "false");
static_assert(sizeof(VkPhysicalDeviceCooperativeMatrix2PropertiesNV) == 20, "false");
static_assert(sizeof(VkCooperativeMatrixFlexibleDimensionsPropertiesNV) == 48, "false");
static_assert(sizeof(VkPhysicalDeviceHdrVividFeaturesHUAWEI) == 12, "false");
static_assert(sizeof(VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT) == 12, "false");
static_assert(sizeof(StdVideoEncodeH264WeightTableFlags) == 16, "false");
static_assert(sizeof(StdVideoEncodeH264WeightTable) == 404, "false");
static_assert(sizeof(StdVideoH265SubLayerHrdParameters) == 516, "false");
static_assert(sizeof(StdVideoH265DecPicBufMgr) == 44, "false");
static_assert(sizeof(StdVideoH265HrdParameters) == 48, "false");
static_assert(sizeof(StdVideoH265ProfileTierLevel) == 12, "false");
static_assert(sizeof(StdVideoH265ScalingLists) == 1000, "false");
static_assert(sizeof(StdVideoH265ShortTermRefPicSet) == 88, "false");
static_assert(sizeof(StdVideoH265LongTermRefPicsSps) == 132, "false");
static_assert(sizeof(StdVideoH265PredictorPaletteEntries) == 768, "false");
static_assert(sizeof(StdVideoH265SequenceParameterSetVui) == 52, "false");
static_assert(sizeof(StdVideoEncodeH265WeightTableFlags) == 8, "false");
static_assert(sizeof(StdVideoEncodeH265WeightTable) == 190, "false");
static_assert(sizeof(StdVideoEncodeH265ReferenceListsInfo) == 68, "false");
static_assert(sizeof(StdVideoEncodeH265LongTermRefPics) == 148, "false");
static_assert(sizeof(StdVideoH264ScalingLists) == 484, "false");
static_assert(sizeof(StdVideoH264HrdParameters) == 308, "false");
static_assert(sizeof(StdVideoH264SequenceParameterSetVui) == 36, "false");
static_assert(sizeof(StdVideoEncodeH264RefListModEntry) == 8, "false");
static_assert(sizeof(StdVideoEncodeH264RefPicMarkingEntry) == 12, "false");
static_assert(sizeof(StdVideoEncodeH264ReferenceListsInfo) == 92, "false");
static_assert(sizeof(StdVideoAV1Quantization) == 16, "false");
static_assert(sizeof(StdVideoAV1TileInfo) == 32, "false");
static_assert(sizeof(StdVideoAV1LoopFilter) == 24, "false");
static_assert(sizeof(StdVideoAV1Segmentation) == 136, "false");
static_assert(sizeof(StdVideoAV1CDEF) == 34, "false");
static_assert(sizeof(StdVideoAV1LoopRestoration) == 20, "false");
static_assert(sizeof(StdVideoAV1GlobalMotion) == 200, "false");
static_assert(sizeof(StdVideoAV1TimingInfo) == 16, "false");
static_assert(sizeof(StdVideoAV1ColorConfig) == 24, "false");
static_assert(sizeof(StdVideoAV1FilmGrain) == 164, "false");
static_assert(sizeof(VkDisplayModePropertiesKHR) == 20, "false");
static_assert(sizeof(VkDisplayPropertiesKHR) == 40, "false");
static_assert(sizeof(VkDisplayPlaneCapabilitiesKHR) == 68, "false");
static_assert(sizeof(VkDisplayPlanePropertiesKHR) == 12, "false");
static_assert(sizeof(VkDisplayModeParametersKHR) == 12, "false");
#endif

void vk_DestroyInstance(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyInstance:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyInstance(instance, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDevices(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceCount = &tmp_pPhysicalDeviceCount;
    VkPhysicalDevice* pPhysicalDevices = NULL;
    if (ARG3) {
        pPhysicalDevices = new VkPhysicalDevice[*pPhysicalDeviceCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, pPhysicalDevices[i], pBoxedInfo));
        }
        delete[] pPhysicalDevices;
    }
}
void vk_GetPhysicalDeviceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties pProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties::write(pBoxedInfo, cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceMemoryProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties pMemoryProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties::write(pBoxedInfo, cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceFeatures(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures pFeatures(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures::write(pBoxedInfo, cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties pFormatProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties::write(pBoxedInfo, cpu->memory, ARG3, &pFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkImageTiling tiling = (VkImageTiling)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageCreateFlags flags = (VkImageCreateFlags)ARG6;
    MarshalVkImageFormatProperties pImageFormatProperties(pBoxedInfo, cpu->memory, ARG7);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties::write(pBoxedInfo, cpu->memory, ARG7, &pImageFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_CreateDevice(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDevice pDevice = (VkDevice)getVulkanPtr(cpu->memory, ARG4);
    EAX = (U32)pBoxedInfo->pvkCreateDevice(physicalDevice, pCreateInfo, pAllocator, &pDevice);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, pDevice, pBoxedInfo));
}
void vk_DestroyDevice(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDevice(device, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceVersion(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pApiVersion = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pApiVersion = &tmp_pApiVersion;
    EAX = (U32)pvkEnumerateInstanceVersion(pApiVersion);
    cpu->memory->writed(ARG1, (U32)tmp_pApiVersion);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceLayerProperties(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = NULL;
    if (ARG2) {
        pProperties = new VkLayerProperties[*pPropertyCount];
    }
    EAX = (U32)pvkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
    cpu->memory->writed(ARG1, (U32)tmp_pPropertyCount);
    if (ARG2) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkLayerProperties::write(nullptr, cpu->memory, ARG2 + i * 520, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceLayerProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkLayerProperties[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkLayerProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 520, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceExtensionProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    char* pLayerName = nullptr;
    if (ARG2) {
        U32 len = cpu->memory->strlen(ARG2);
        pLayerName = new char[len];
        cpu->memory->memcpy(pLayerName, ARG2, (U32)len * sizeof(char));
    }
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkExtensionProperties* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkExtensionProperties[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
    delete[] pLayerName;
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkExtensionProperties::write(pBoxedInfo, cpu->memory, ARG4 + i * 260, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_GetDeviceQueue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t queueIndex = (uint32_t)ARG3;
    VkQueue pQueue = (VkQueue)getVulkanPtr(cpu->memory, ARG4);
    pBoxedInfo->pvkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &pQueue);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkQueueSubmit(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
// return type: VkResult(4 bytes)
void vk_QueueWaitIdle(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = (U32)pBoxedInfo->pvkQueueWaitIdle(queue);
}
// return type: VkResult(4 bytes)
void vk_DeviceWaitIdle(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = (U32)pBoxedInfo->pvkDeviceWaitIdle(device);
}
// return type: VkResult(4 bytes)
void vk_AllocateMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryAllocateInfo local_pAllocateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMemoryAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkAllocateMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeviceMemory tmp_pMemory = (VkDeviceMemory) cpu->memory->readq(ARG4);
    VkDeviceMemory* pMemory = &tmp_pMemory;
    EAX = (U32)pBoxedInfo->pvkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
    if (EAX == 0 && pMemory) {
        registerVkMemoryAllocation(*pMemory, pAllocateInfo->allocationSize);
    }
    cpu->memory->writeq(ARG4, (U64)tmp_pMemory);
}
void vk_FreeMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkFreeMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkFreeMemory(device, memory, pAllocator);
    unregisterVkMemoryAllocation(memory);
}
// return type: VkResult(4 bytes)
void vk_MapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkMemoryMapFlags flags = (VkMemoryMapFlags)ARG5;
    void *pData = NULL;
    EAX = (U32)pBoxedInfo->pvkMapMemory(device, memory, offset, size, flags, &pData);
    if (EAX == 0) {
        cpu->memory->writed(ARG6, mapVkMemory(memory, pData, size));
    }
}
void vk_UnmapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    pBoxedInfo->pvkUnmapMemory(device, memory);
    unmapVkMemory(memory);
}
// return type: VkResult(4 bytes)
void vk_FlushMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
// return type: VkResult(4 bytes)
void vk_InvalidateMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
void vk_GetDeviceMemoryCommitment(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    VkDeviceSize tmp_pCommittedMemoryInBytes = (VkDeviceSize) cpu->memory->readq(ARG3);
    VkDeviceSize* pCommittedMemoryInBytes = &tmp_pCommittedMemoryInBytes;
    pBoxedInfo->pvkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    cpu->memory->writeq(ARG3, (U64)tmp_pCommittedMemoryInBytes);
}
void vk_GetBufferMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    MarshalVkMemoryRequirements pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements(device, buffer, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG3);
    VkDeviceSize memoryOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkBindBufferMemory(device, buffer, memory, memoryOffset);
}
void vk_GetImageMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    MarshalVkMemoryRequirements pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements(device, image, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG3);
    VkDeviceSize memoryOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkBindImageMemory(device, image, memory, memoryOffset);
}
void vk_GetImageSparseMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements::write(pBoxedInfo, cpu->memory, ARG4 + i * 48, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetPhysicalDeviceSparseImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageTiling tiling = (VkImageTiling)ARG6;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG7);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties* pProperties = NULL;
    if (ARG8) {
        pProperties = new VkSparseImageFormatProperties[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    cpu->memory->writed(ARG7, (U32)tmp_pPropertyCount);
    if (ARG8) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties::write(pBoxedInfo, cpu->memory, ARG8 + i * 20, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_QueueBindSparse(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindSparseInfo* pBindInfo = NULL;
    if (ARG3) {
        pBindInfo = new VkBindSparseInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindSparseInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 48, &pBindInfo[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
    if (pBindInfo) {
        delete[] pBindInfo;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFenceCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkFenceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFence tmp_pFence = (VkFence) cpu->memory->readq(ARG4);
    VkFence* pFence = &tmp_pFence;
    EAX = (U32)pBoxedInfo->pvkCreateFence(device, pCreateInfo, pAllocator, pFence);
    cpu->memory->writeq(ARG4, (U64)tmp_pFence);
}
void vk_DestroyFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFence(device, fence, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = nullptr;
    if (ARG3) {
        pFences = new VkFence[fenceCount];
        cpu->memory->memcpy(pFences, ARG3, (U32)fenceCount * sizeof(VkFence));
    }
    EAX = (U32)pBoxedInfo->pvkResetFences(device, fenceCount, pFences);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_GetFenceStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkGetFenceStatus(device, fence);
}
// return type: VkResult(4 bytes)
void vk_WaitForFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = nullptr;
    if (ARG3) {
        pFences = new VkFence[fenceCount];
        cpu->memory->memcpy(pFences, ARG3, (U32)fenceCount * sizeof(VkFence));
    }
    VkBool32 waitAll = (VkBool32)ARG4;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG5);
    EAX = (U32)pBoxedInfo->pvkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_CreateSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSemaphoreCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSemaphore tmp_pSemaphore = (VkSemaphore) cpu->memory->readq(ARG4);
    VkSemaphore* pSemaphore = &tmp_pSemaphore;
    EAX = (U32)pBoxedInfo->pvkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
    cpu->memory->writeq(ARG4, (U64)tmp_pSemaphore);
}
void vk_DestroySemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySemaphore(device, semaphore, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkEventCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkEventCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkEvent tmp_pEvent = (VkEvent) cpu->memory->readq(ARG4);
    VkEvent* pEvent = &tmp_pEvent;
    EAX = (U32)pBoxedInfo->pvkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
    cpu->memory->writeq(ARG4, (U64)tmp_pEvent);
}
void vk_DestroyEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyEvent(device, event, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetEventStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkGetEventStatus(device, event);
}
// return type: VkResult(4 bytes)
void vk_SetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkSetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_ResetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkResetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_CreateQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkQueryPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkQueryPool tmp_pQueryPool = (VkQueryPool) cpu->memory->readq(ARG4);
    VkQueryPool* pQueryPool = &tmp_pQueryPool;
    EAX = (U32)pBoxedInfo->pvkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pQueryPool);
}
void vk_DestroyQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyQueryPool(device, queryPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetQueryPoolResults(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    VkDeviceSize stride = (VkDeviceSize)cpu->memory->readq(ARG7);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG8;
    EAX = (U32)pBoxedInfo->pvkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_ResetQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
void vk_ResetQueryPoolEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
}
// return type: VkResult(4 bytes)
void vk_CreateBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBuffer tmp_pBuffer = (VkBuffer) cpu->memory->readq(ARG4);
    VkBuffer* pBuffer = &tmp_pBuffer;
    EAX = (U32)pBoxedInfo->pvkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pBuffer);
}
void vk_DestroyBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBuffer(device, buffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferViewCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBufferView tmp_pView = (VkBufferView) cpu->memory->readq(ARG4);
    VkBufferView* pView = &tmp_pView;
    EAX = (U32)pBoxedInfo->pvkCreateBufferView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBufferView bufferView = (VkBufferView)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBufferView(device, bufferView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    std::shared_ptr<MarshalVkImageCreateInfo> local_pCreateInfo = std::make_shared<MarshalVkImageCreateInfo>(pBoxedInfo, cpu->memory, ARG2);
    VkImageCreateInfo* pCreateInfo = &local_pCreateInfo->s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImage tmp_pImage = (VkImage) cpu->memory->readq(ARG4);
    VkImage* pImage = &tmp_pImage;
    EAX = (U32)pBoxedInfo->pvkCreateImage(device, pCreateInfo, pAllocator, pImage);
    if (!EAX && tmp_pImage) {
        pBoxedInfo->imageCreateInfo[(U64)tmp_pImage] = local_pCreateInfo;
    }
    cpu->memory->writeq(ARG4, (U64)tmp_pImage);
}
void vk_DestroyImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImage(device, image, pAllocator);
    pBoxedInfo->imageCreateInfo.erase((U64)image);
}
void vk_GetImageSubresourceLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    MarshalVkImageSubresource local_pSubresource(pBoxedInfo, cpu->memory, ARG3);
    VkImageSubresource* pSubresource = &local_pSubresource.s;
    MarshalVkSubresourceLayout pLayout(pBoxedInfo, cpu->memory, ARG4);
    pBoxedInfo->pvkGetImageSubresourceLayout(device, image, pSubresource, &pLayout.s);
    MarshalVkSubresourceLayout::write(pBoxedInfo, cpu->memory, ARG4, &pLayout.s);
}
// return type: VkResult(4 bytes)
void vk_CreateImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImageView tmp_pView = (VkImageView) cpu->memory->readq(ARG4);
    VkImageView* pView = &tmp_pView;
    EAX = (U32)pBoxedInfo->pvkCreateImageView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImageView(device, imageView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkShaderModuleCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkShaderModuleCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkShaderModule tmp_pShaderModule = (VkShaderModule) cpu->memory->readq(ARG4);
    VkShaderModule* pShaderModule = &tmp_pShaderModule;
    EAX = (U32)pBoxedInfo->pvkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
    cpu->memory->writeq(ARG4, (U64)tmp_pShaderModule);
}
void vk_DestroyShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderModule shaderModule = (VkShaderModule)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyShaderModule(device, shaderModule, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineCacheCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineCacheCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineCache tmp_pPipelineCache = (VkPipelineCache) cpu->memory->readq(ARG4);
    VkPipelineCache* pPipelineCache = &tmp_pPipelineCache;
    EAX = (U32)pBoxedInfo->pvkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineCache);
}
void vk_DestroyPipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineCache(device, pipelineCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineCacheData(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)*pDataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
    cpu->memory->writed(ARG3, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergePipelineCaches(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache dstCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t srcCacheCount = (uint32_t)ARG3;
    VkPipelineCache* pSrcCaches = nullptr;
    if (ARG4) {
        pSrcCaches = new VkPipelineCache[srcCacheCount];
        cpu->memory->memcpy(pSrcCaches, ARG4, (U32)srcCacheCount * sizeof(VkPipelineCache));
    }
    EAX = (U32)pBoxedInfo->pvkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineBinariesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineBinaryCreateInfoKHR local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineBinaryCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineBinariesKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    MarshalVkPipelineBinaryHandlesInfoKHR pBinaries(pBoxedInfo, cpu->memory, ARG4);
    EAX = (U32)pBoxedInfo->pvkCreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, &pBinaries.s);
    MarshalVkPipelineBinaryHandlesInfoKHR::write(pBoxedInfo, cpu->memory, ARG4, &pBinaries.s);
}
void vk_DestroyPipelineBinaryKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBinaryKHR pipelineBinary = (VkPipelineBinaryKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipelineBinaryKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineKeyKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineCreateInfoKHR local_pPipelineCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineCreateInfoKHR* pPipelineCreateInfo = &local_pPipelineCreateInfo.s;
    MarshalVkPipelineBinaryKeyKHR pPipelineKey(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPipelineKeyKHR(device, pPipelineCreateInfo, &pPipelineKey.s);
    MarshalVkPipelineBinaryKeyKHR::write(pBoxedInfo, cpu->memory, ARG3, &pPipelineKey.s);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineBinaryDataKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineBinaryDataInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineBinaryDataInfoKHR* pInfo = &local_pInfo.s;
    MarshalVkPipelineBinaryKeyKHR pPipelineBinaryKey(pBoxedInfo, cpu->memory, ARG3);
    size_t tmp_pPipelineBinaryDataSize = (size_t) cpu->memory->readd(ARG4);
    size_t* pPipelineBinaryDataSize = &tmp_pPipelineBinaryDataSize;
    void* pPipelineBinaryData = nullptr;
    if (ARG5) {
        pPipelineBinaryData = new char[*pPipelineBinaryDataSize];
        cpu->memory->memcpy(pPipelineBinaryData, ARG5, (U32)*pPipelineBinaryDataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetPipelineBinaryDataKHR(device, pInfo, &pPipelineBinaryKey.s, pPipelineBinaryDataSize, pPipelineBinaryData);
    MarshalVkPipelineBinaryKeyKHR::write(pBoxedInfo, cpu->memory, ARG3, &pPipelineBinaryKey.s);
    cpu->memory->writed(ARG4, (U32)tmp_pPipelineBinaryDataSize);
    if (pPipelineBinaryData) {
        cpu->memory->memcpy(ARG5, pPipelineBinaryData, (U32)*pPipelineBinaryDataSize * sizeof(char));
    }
    delete[] pPipelineBinaryData;
}
// return type: VkResult(4 bytes)
void vk_ReleaseCapturedPipelineDataKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkReleaseCapturedPipelineDataInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkReleaseCapturedPipelineDataInfoKHR* pInfo = &local_pInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkReleaseCapturedPipelineDataKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    EAX = (U32)pBoxedInfo->pvkReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateGraphicsPipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkGraphicsPipelineCreateInfo* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkGraphicsPipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkGraphicsPipelineCreateInfo::read(pBoxedInfo, cpu->memory, ARG4 + i * 88, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateGraphicsPipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = (U32)pBoxedInfo->pvkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_CreateComputePipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkComputePipelineCreateInfo* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkComputePipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkComputePipelineCreateInfo::read(pBoxedInfo, cpu->memory, ARG4 + i * 64, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateComputePipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = (U32)pBoxedInfo->pvkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderpass = (VkRenderPass)cpu->memory->readq(ARG2);
    VkExtent2D* pMaxWorkgroupSize = NULL;
    if (ARG3) {
        pMaxWorkgroupSize = new VkExtent2D[1];
    }
    EAX = (U32)pBoxedInfo->pvkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
    if (ARG3) {
        for (U32 i=0;i<1;i++) {
            MarshalVkExtent2D::write(pBoxedInfo, cpu->memory, ARG3 + i * 8, &pMaxWorkgroupSize[i]);
        }
        delete[] pMaxWorkgroupSize;
    }
}
void vk_DestroyPipeline(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipeline:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipeline(device, pipeline, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineLayoutCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineLayout tmp_pPipelineLayout = (VkPipelineLayout) cpu->memory->readq(ARG4);
    VkPipelineLayout* pPipelineLayout = &tmp_pPipelineLayout;
    EAX = (U32)pBoxedInfo->pvkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineLayout);
}
void vk_DestroyPipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout pipelineLayout = (VkPipelineLayout)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateSampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSamplerCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSampler tmp_pSampler = (VkSampler) cpu->memory->readq(ARG4);
    VkSampler* pSampler = &tmp_pSampler;
    EAX = (U32)pBoxedInfo->pvkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
    cpu->memory->writeq(ARG4, (U64)tmp_pSampler);
}
void vk_DestroySampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampler sampler = (VkSampler)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySampler(device, sampler, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorSetLayout tmp_pSetLayout = (VkDescriptorSetLayout) cpu->memory->readq(ARG4);
    VkDescriptorSetLayout* pSetLayout = &tmp_pSetLayout;
    EAX = (U32)pBoxedInfo->pvkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pSetLayout);
}
void vk_DestroyDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSetLayout descriptorSetLayout = (VkDescriptorSetLayout)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorPoolCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorPool tmp_pDescriptorPool = (VkDescriptorPool) cpu->memory->readq(ARG4);
    VkDescriptorPool* pDescriptorPool = &tmp_pDescriptorPool;
    EAX = (U32)pBoxedInfo->pvkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorPool);
}
void vk_DestroyDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorPool(device, descriptorPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    VkDescriptorPoolResetFlags flags = (VkDescriptorPoolResetFlags)ARG3;
    EAX = (U32)pBoxedInfo->pvkResetDescriptorPool(device, descriptorPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetAllocateInfo local_pAllocateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorSetAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG3) {
        pDescriptorSets = new VkDescriptorSet[pAllocateInfo->descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG3, (U32)pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    }
    EAX = (U32)pBoxedInfo->pvkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
    if (pDescriptorSets) {
        cpu->memory->memcpy(ARG3, pDescriptorSets, (U32)pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    }
    delete[] pDescriptorSets;
}
// return type: VkResult(4 bytes)
void vk_FreeDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    uint32_t descriptorSetCount = (uint32_t)ARG3;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG4) {
        pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG4, (U32)descriptorSetCount * sizeof(VkDescriptorSet));
    }
    EAX = (U32)pBoxedInfo->pvkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    delete[] pDescriptorSets;
}
void vk_UpdateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t descriptorWriteCount = (uint32_t)ARG2;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG3) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(pBoxedInfo, cpu->memory, ARG3 + i * 44, &pDescriptorWrites[i]);
        }
    }
    uint32_t descriptorCopyCount = (uint32_t)ARG4;
    VkCopyDescriptorSet* pDescriptorCopies = NULL;
    if (ARG5) {
        pDescriptorCopies = new VkCopyDescriptorSet[descriptorCopyCount];
        for (U32 i=0;i<descriptorCopyCount;i++) {
            MarshalVkCopyDescriptorSet::read(pBoxedInfo, cpu->memory, ARG5 + i * 44, &pDescriptorCopies[i]);
        }
    }
    pBoxedInfo->pvkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
    if (pDescriptorCopies) {
        delete[] pDescriptorCopies;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFramebufferCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkFramebufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFramebuffer tmp_pFramebuffer = (VkFramebuffer) cpu->memory->readq(ARG4);
    VkFramebuffer* pFramebuffer = &tmp_pFramebuffer;
    EAX = (U32)pBoxedInfo->pvkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pFramebuffer);
}
void vk_DestroyFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFramebuffer framebuffer = (VkFramebuffer)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFramebuffer(device, framebuffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = (U32)pBoxedInfo->pvkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_DestroyRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyRenderPass(device, renderPass, pAllocator);
}
void vk_GetRenderAreaGranularity(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)cpu->memory->readq(ARG2);
    MarshalVkExtent2D pGranularity(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetRenderAreaGranularity(device, renderPass, &pGranularity.s);
    MarshalVkExtent2D::write(pBoxedInfo, cpu->memory, ARG3, &pGranularity.s);
}
void vk_GetRenderingAreaGranularity(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingAreaInfo local_pRenderingAreaInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingAreaInfo* pRenderingAreaInfo = &local_pRenderingAreaInfo.s;
    MarshalVkExtent2D pGranularity(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetRenderingAreaGranularity(device, pRenderingAreaInfo, &pGranularity.s);
    MarshalVkExtent2D::write(pBoxedInfo, cpu->memory, ARG3, &pGranularity.s);
}
void vk_GetRenderingAreaGranularityKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingAreaInfo local_pRenderingAreaInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingAreaInfo* pRenderingAreaInfo = &local_pRenderingAreaInfo.s;
    MarshalVkExtent2D pGranularity(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, &pGranularity.s);
    MarshalVkExtent2D::write(pBoxedInfo, cpu->memory, ARG3, &pGranularity.s);
}
// return type: VkResult(4 bytes)
void vk_CreateCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandPoolCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCommandPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCommandPool tmp_pCommandPool = (VkCommandPool) cpu->memory->readq(ARG4);
    VkCommandPool* pCommandPool = &tmp_pCommandPool;
    EAX = (U32)pBoxedInfo->pvkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pCommandPool);
}
void vk_DestroyCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCommandPool(device, commandPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolResetFlags flags = (VkCommandPoolResetFlags)ARG3;
    EAX = (U32)pBoxedInfo->pvkResetCommandPool(device, commandPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferAllocateInfo local_pAllocateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCommandBufferAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkCommandBuffer* pCommandBuffers = NULL;
    if (ARG3) {
        pCommandBuffers = new VkCommandBuffer[pAllocateInfo->commandBufferCount];
    }
    EAX = (U32)pBoxedInfo->pvkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
    if (ARG3) {
        for (U32 i=0;i<pAllocateInfo->commandBufferCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, pCommandBuffers[i], pBoxedInfo));
        }
        delete[] pCommandBuffers;
    }
}
void vk_FreeCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    uint32_t commandBufferCount = (uint32_t)ARG3;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG4 + i*4));
    }
    pBoxedInfo->pvkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
// return type: VkResult(4 bytes)
void vk_BeginCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferBeginInfo local_pBeginInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCommandBufferBeginInfo* pBeginInfo = &local_pBeginInfo.s;
    EAX = (U32)pBoxedInfo->pvkBeginCommandBuffer(commandBuffer, pBeginInfo);
}
// return type: VkResult(4 bytes)
void vk_EndCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = (U32)pBoxedInfo->pvkEndCommandBuffer(commandBuffer);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandBufferResetFlags flags = (VkCommandBufferResetFlags)ARG2;
    EAX = (U32)pBoxedInfo->pvkResetCommandBuffer(commandBuffer, flags);
}
void vk_CmdBindPipeline(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
}
void vk_CmdSetAttachmentFeedbackLoopEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageAspectFlags aspectMask = (VkImageAspectFlags)ARG2;
    pBoxedInfo->pvkCmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask);
}
void vk_CmdSetViewport(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewport* pViewports = NULL;
    if (ARG4) {
        pViewports = new VkViewport[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkViewport::read(pBoxedInfo, cpu->memory, ARG4 + i * 24, &pViewports[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    if (pViewports) {
        delete[] pViewports;
    }
}
void vk_CmdSetScissor(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstScissor = (uint32_t)ARG2;
    uint32_t scissorCount = (uint32_t)ARG3;
    VkRect2D* pScissors = NULL;
    if (ARG4) {
        pScissors = new VkRect2D[scissorCount];
        for (U32 i=0;i<scissorCount;i++) {
            MarshalVkRect2D::read(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pScissors[i]);
        }
    }
    pBoxedInfo->pvkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    if (pScissors) {
        delete[] pScissors;
    }
}
void vk_CmdSetLineWidth(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalFloat lineWidthFloat;
    lineWidthFloat.i = ARG2;
    float lineWidth = lineWidthFloat.f;
    pBoxedInfo->pvkCmdSetLineWidth(commandBuffer, lineWidth);
}
void vk_CmdSetDepthBias(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.i = ARG2;
    float depthBiasConstantFactor = depthBiasConstantFactorFloat.f;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.i = ARG3;
    float depthBiasClamp = depthBiasClampFloat.f;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.i = ARG4;
    float depthBiasSlopeFactor = depthBiasSlopeFactorFloat.f;
    pBoxedInfo->pvkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
void vk_CmdSetBlendConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float* blendConstants = nullptr;
    if (ARG2) {
        blendConstants = new float[4];
        cpu->memory->memcpy(blendConstants, ARG2, (U32)4 * sizeof(float));
    }
    pBoxedInfo->pvkCmdSetBlendConstants(commandBuffer, blendConstants);
    delete[] blendConstants;
}
void vk_CmdSetDepthBounds(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalFloat minDepthBoundsFloat;
    minDepthBoundsFloat.i = ARG2;
    float minDepthBounds = minDepthBoundsFloat.f;
    MarshalFloat maxDepthBoundsFloat;
    maxDepthBoundsFloat.i = ARG3;
    float maxDepthBounds = maxDepthBoundsFloat.f;
    pBoxedInfo->pvkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
}
void vk_CmdSetStencilCompareMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t compareMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
}
void vk_CmdSetStencilWriteMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t writeMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
}
void vk_CmdSetStencilReference(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t reference = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilReference(commandBuffer, faceMask, reference);
}
void vk_CmdBindDescriptorSets(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t firstSet = (uint32_t)ARG4;
    uint32_t descriptorSetCount = (uint32_t)ARG5;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG6) {
        pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG6, (U32)descriptorSetCount * sizeof(VkDescriptorSet));
    }
    uint32_t dynamicOffsetCount = (uint32_t)ARG7;
    uint32_t* pDynamicOffsets = nullptr;
    if (ARG8) {
        pDynamicOffsets = new uint32_t[dynamicOffsetCount];
        cpu->memory->memcpy(pDynamicOffsets, ARG8, (U32)dynamicOffsetCount * sizeof(uint32_t));
    }
    pBoxedInfo->pvkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    delete[] pDescriptorSets;
    delete[] pDynamicOffsets;
}
void vk_CmdBindIndexBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkIndexType indexType = (VkIndexType)ARG4;
    pBoxedInfo->pvkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
}
void vk_CmdBindVertexBuffers(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    delete[] pBuffers;
    delete[] pOffsets;
}
void vk_CmdDraw(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstVertex = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
void vk_CmdDrawIndexed(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t indexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstIndex = (uint32_t)ARG4;
    int32_t vertexOffset = (int32_t)ARG5;
    uint32_t firstInstance = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
void vk_CmdDrawMultiEXT(CPU* cpu) {
    uint32_t stride = (uint32_t)ARG6;
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawInfoEXT* pVertexInfo = NULL;
    if (ARG3) {
        pVertexInfo = new VkMultiDrawInfoEXT[drawCount];
        for (U32 i=0;i<drawCount;i++) {
            MarshalVkMultiDrawInfoEXT::read(pBoxedInfo, cpu->memory, ARG3 + i * stride, &pVertexInfo[i]);
        }
        stride = 4;
    }
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
    if (pVertexInfo) {
        delete[] pVertexInfo;
    }
}
void vk_CmdDrawMultiIndexedEXT(CPU* cpu) {
    uint32_t stride = (uint32_t)ARG6;
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawIndexedInfoEXT* pIndexInfo = NULL;
    if (ARG3) {
        pIndexInfo = new VkMultiDrawIndexedInfoEXT[drawCount];
        for (U32 i=0;i<drawCount;i++) {
            MarshalVkMultiDrawIndexedInfoEXT::read(pBoxedInfo, cpu->memory, ARG3 + i * stride, &pIndexInfo[i]);
        }
        stride = 4;
    }
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    int32_t* pVertexOffset = nullptr;
    if (ARG7) {
        pVertexOffset = new int32_t[drawCount];
        cpu->memory->memcpy(pVertexOffset, ARG7, (U32)drawCount * sizeof(int32_t));
    }
    pBoxedInfo->pvkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
    if (pIndexInfo) {
        delete[] pIndexInfo;
    }
    delete[] pVertexOffset;
}
void vk_CmdDrawIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawIndexedIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDispatch(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t groupCountX = (uint32_t)ARG2;
    uint32_t groupCountY = (uint32_t)ARG3;
    uint32_t groupCountZ = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdDispatchIndirect(commandBuffer, buffer, offset);
}
void vk_CmdSubpassShadingHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdSubpassShadingHUAWEI(commandBuffer);
}
void vk_CmdDrawClusterHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t groupCountX = (uint32_t)ARG2;
    uint32_t groupCountY = (uint32_t)ARG3;
    uint32_t groupCountZ = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDrawClusterIndirectHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset);
}
void vk_CmdUpdatePipelineIndirectBufferNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline);
}
void vk_CmdCopyBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    uint32_t regionCount = (uint32_t)ARG4;
    VkBufferCopy* pRegions = NULL;
    if (ARG5) {
        pRegions = new VkBufferCopy[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkBufferCopy::read(pBoxedInfo, cpu->memory, ARG5 + i * 24, &pRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdCopyImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageCopy* pRegions = NULL;
    if (ARG7) {
        pRegions = new VkImageCopy[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkImageCopy::read(pBoxedInfo, cpu->memory, ARG7 + i * 68, &pRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdBlitImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageBlit* pRegions = NULL;
    if (ARG7) {
        pRegions = new VkImageBlit[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkImageBlit::read(pBoxedInfo, cpu->memory, ARG7 + i * 80, &pRegions[i]);
        }
    }
    VkFilter filter = (VkFilter)ARG8;
    pBoxedInfo->pvkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdCopyBufferToImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG3);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG4;
    uint32_t regionCount = (uint32_t)ARG5;
    VkBufferImageCopy* pRegions = NULL;
    if (ARG6) {
        pRegions = new VkBufferImageCopy[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkBufferImageCopy::read(pBoxedInfo, cpu->memory, ARG6 + i * 56, &pRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdCopyImageToBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    uint32_t regionCount = (uint32_t)ARG5;
    VkBufferImageCopy* pRegions = NULL;
    if (ARG6) {
        pRegions = new VkBufferImageCopy[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkBufferImageCopy::read(pBoxedInfo, cpu->memory, ARG6 + i * 56, &pRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdCopyMemoryIndirectNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceAddress copyBufferAddress = (VkDeviceAddress)cpu->memory->readq(ARG2);
    uint32_t copyCount = (uint32_t)ARG3;
    uint32_t stride = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
}
void vk_CmdCopyMemoryToImageIndirectNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceAddress copyBufferAddress = (VkDeviceAddress)cpu->memory->readq(ARG2);
    uint32_t copyCount = (uint32_t)ARG3;
    uint32_t stride = (uint32_t)ARG4;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG5);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG6;
    VkImageSubresourceLayers* pImageSubresources = NULL;
    if (ARG7) {
        pImageSubresources = new VkImageSubresourceLayers[copyCount];
        for (U32 i=0;i<copyCount;i++) {
            MarshalVkImageSubresourceLayers::read(pBoxedInfo, cpu->memory, ARG7 + i * 16, &pImageSubresources[i]);
        }
    }
    pBoxedInfo->pvkCmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
    if (pImageSubresources) {
        delete[] pImageSubresources;
    }
}
void vk_CmdUpdateBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize dataSize = (VkDeviceSize)cpu->memory->readq(ARG4);
    void* pData = nullptr;
    if (ARG5) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG5, (U32)dataSize * sizeof(char));
    }
    pBoxedInfo->pvkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    delete[] pData;
}
void vk_CmdFillBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t data = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
}
void vk_CmdClearColorImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    MarshalVkClearColorValue local_pColor(pBoxedInfo, cpu->memory, ARG4);
    VkClearColorValue* pColor = &local_pColor.s;
    uint32_t rangeCount = (uint32_t)ARG5;
    VkImageSubresourceRange* pRanges = NULL;
    if (ARG6) {
        pRanges = new VkImageSubresourceRange[rangeCount];
        for (U32 i=0;i<rangeCount;i++) {
            MarshalVkImageSubresourceRange::read(pBoxedInfo, cpu->memory, ARG6 + i * 20, &pRanges[i]);
        }
    }
    pBoxedInfo->pvkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    if (pRanges) {
        delete[] pRanges;
    }
}
void vk_CmdClearDepthStencilImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    MarshalVkClearDepthStencilValue local_pDepthStencil(pBoxedInfo, cpu->memory, ARG4);
    VkClearDepthStencilValue* pDepthStencil = &local_pDepthStencil.s;
    uint32_t rangeCount = (uint32_t)ARG5;
    VkImageSubresourceRange* pRanges = NULL;
    if (ARG6) {
        pRanges = new VkImageSubresourceRange[rangeCount];
        for (U32 i=0;i<rangeCount;i++) {
            MarshalVkImageSubresourceRange::read(pBoxedInfo, cpu->memory, ARG6 + i * 20, &pRanges[i]);
        }
    }
    pBoxedInfo->pvkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    if (pRanges) {
        delete[] pRanges;
    }
}
void vk_CmdClearAttachments(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkClearAttachment* pAttachments = NULL;
    if (ARG3) {
        pAttachments = new VkClearAttachment[attachmentCount];
        for (U32 i=0;i<attachmentCount;i++) {
            MarshalVkClearAttachment::read(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pAttachments[i]);
        }
    }
    uint32_t rectCount = (uint32_t)ARG4;
    VkClearRect* pRects = NULL;
    if (ARG5) {
        pRects = new VkClearRect[rectCount];
        for (U32 i=0;i<rectCount;i++) {
            MarshalVkClearRect::read(pBoxedInfo, cpu->memory, ARG5 + i * 24, &pRects[i]);
        }
    }
    pBoxedInfo->pvkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    if (pAttachments) {
        delete[] pAttachments;
    }
    if (pRects) {
        delete[] pRects;
    }
}
void vk_CmdResolveImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageResolve* pRegions = NULL;
    if (ARG7) {
        pRegions = new VkImageResolve[regionCount];
        for (U32 i=0;i<regionCount;i++) {
            MarshalVkImageResolve::read(pBoxedInfo, cpu->memory, ARG7 + i * 68, &pRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    if (pRegions) {
        delete[] pRegions;
    }
}
void vk_CmdSetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG3;
    pBoxedInfo->pvkCmdSetEvent(commandBuffer, event, stageMask);
}
void vk_CmdResetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG3;
    pBoxedInfo->pvkCmdResetEvent(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = nullptr;
    if (ARG3) {
        pEvents = new VkEvent[eventCount];
        cpu->memory->memcpy(pEvents, ARG3, (U32)eventCount * sizeof(VkEvent));
    }
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG4;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG5;
    uint32_t memoryBarrierCount = (uint32_t)ARG6;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG7) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG7 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG8;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG9) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG9 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG10;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG11) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG11 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    delete[] pEvents;
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdPipelineBarrier(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG2;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG3;
    VkDependencyFlags dependencyFlags = (VkDependencyFlags)ARG4;
    uint32_t memoryBarrierCount = (uint32_t)ARG5;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG6) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG6 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG7;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG8) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG8 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG9;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG10) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(pBoxedInfo, cpu->memory, ARG10 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdBeginQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG4;
    pBoxedInfo->pvkCmdBeginQuery(commandBuffer, queryPool, query, flags);
}
void vk_CmdEndQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdEndQuery(commandBuffer, queryPool, query);
}
void vk_CmdBeginConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkConditionalRenderingBeginInfoEXT local_pConditionalRenderingBegin(pBoxedInfo, cpu->memory, ARG2);
    VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin = &local_pConditionalRenderingBegin.s;
    pBoxedInfo->pvkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
}
void vk_CmdEndConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndConditionalRenderingEXT(commandBuffer);
}
void vk_CmdResetQueryPool(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
}
void vk_CmdWriteTimestamp(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
}
void vk_CmdCopyQueryPoolResults(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG5);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG6);
    VkDeviceSize stride = (VkDeviceSize)cpu->memory->readq(ARG7);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG8;
    pBoxedInfo->pvkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
void vk_CmdPushConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG2);
    VkShaderStageFlags stageFlags = (VkShaderStageFlags)ARG3;
    uint32_t offset = (uint32_t)ARG4;
    uint32_t size = (uint32_t)ARG5;
    void* pValues = nullptr;
    if (ARG6) {
        pValues = new char[size];
        cpu->memory->memcpy(pValues, ARG6, (U32)size * sizeof(char));
    }
    pBoxedInfo->pvkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    delete[] pValues;
}
void vk_CmdBeginRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    VkSubpassContents contents = (VkSubpassContents)ARG3;
    pBoxedInfo->pvkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
}
void vk_CmdNextSubpass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSubpassContents contents = (VkSubpassContents)ARG2;
    pBoxedInfo->pvkCmdNextSubpass(commandBuffer, contents);
}
void vk_CmdEndRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndRenderPass(commandBuffer);
}
void vk_CmdExecuteCommands(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t commandBufferCount = (uint32_t)ARG2;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG3 + i*4));
    }
    pBoxedInfo->pvkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
// return type: VkResult(4 bytes)
void vk_CreateSharedSwapchainsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t swapchainCount = (uint32_t)ARG2;
    VkSwapchainCreateInfoKHR* pCreateInfos = NULL;
    if (ARG3) {
        pCreateInfos = new VkSwapchainCreateInfoKHR[swapchainCount];
        for (U32 i=0;i<swapchainCount;i++) {
            MarshalVkSwapchainCreateInfoKHR::read(pBoxedInfo, cpu->memory, ARG3 + i * 84, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG4) { klog("vkCreateSharedSwapchainsKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSwapchainKHR* pSwapchains = nullptr;
    if (ARG5) {
        pSwapchains = new VkSwapchainKHR[swapchainCount];
        cpu->memory->memcpy(pSwapchains, ARG5, (U32)swapchainCount * sizeof(VkSwapchainKHR));
    }
    EAX = (U32)pBoxedInfo->pvkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pSwapchains) {
        cpu->memory->memcpy(ARG5, pSwapchains, (U32)swapchainCount * sizeof(VkSwapchainKHR));
    }
    delete[] pSwapchains;
}
void vk_DestroySurfaceKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySurfaceKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySurfaceKHR(instance, surface, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceSupportKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG3);
    VkBool32 tmp_pSupported = (VkBool32) cpu->memory->readd(ARG4);
    VkBool32* pSupported = &tmp_pSupported;
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
    cpu->memory->writed(ARG4, (U32)tmp_pSupported);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilitiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    MarshalVkSurfaceCapabilitiesKHR pSurfaceCapabilities(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilitiesKHR::write(pBoxedInfo, cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormatsKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormatKHR* pSurfaceFormats = NULL;
    if (ARG4) {
        pSurfaceFormats = new VkSurfaceFormatKHR[*pSurfaceFormatCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG3, (U32)tmp_pSurfaceFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormatKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 8, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfacePresentModesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pPresentModeCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPresentModeCount = &tmp_pPresentModeCount;
    static_assert (sizeof(VkPresentModeKHR) == 4, "unhandled enum size");
    VkPresentModeKHR* pPresentModes = nullptr;
    if (ARG4) {
        pPresentModes = new VkPresentModeKHR[*pPresentModeCount];
        cpu->memory->memcpy(pPresentModes, ARG4, (U32)*pPresentModeCount * sizeof(VkPresentModeKHR));
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
    cpu->memory->writed(ARG3, (U32)tmp_pPresentModeCount);
    if (pPresentModes) {
        cpu->memory->memcpy(ARG4, pPresentModes, (U32)*pPresentModeCount * sizeof(VkPresentModeKHR));
    }
    delete[] pPresentModes;
}
// return type: VkResult(4 bytes)
void vk_CreateSwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSwapchainCreateInfoKHR local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSwapchainCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSwapchainKHR tmp_pSwapchain = (VkSwapchainKHR) cpu->memory->readq(ARG4);
    VkSwapchainKHR* pSwapchain = &tmp_pSwapchain;
    EAX = (U32)pBoxedInfo->pvkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
    cpu->memory->writeq(ARG4, (U64)tmp_pSwapchain);
}
void vk_DestroySwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySwapchainKHR(device, swapchain, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetSwapchainImagesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pSwapchainImageCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSwapchainImageCount = &tmp_pSwapchainImageCount;
    VkImage* pSwapchainImages = nullptr;
    if (ARG4) {
        pSwapchainImages = new VkImage[*pSwapchainImageCount];
        cpu->memory->memcpy(pSwapchainImages, ARG4, (U32)*pSwapchainImageCount * sizeof(VkImage));
    }
    EAX = (U32)pBoxedInfo->pvkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    cpu->memory->writed(ARG3, (U32)tmp_pSwapchainImageCount);
    if (pSwapchainImages) {
        cpu->memory->memcpy(ARG4, pSwapchainImages, (U32)*pSwapchainImageCount * sizeof(VkImage));
    }
    delete[] pSwapchainImages;
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImageKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG4);
    VkFence fence = (VkFence)cpu->memory->readq(ARG5);
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG6);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = (U32)pBoxedInfo->pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
    cpu->memory->writed(ARG6, (U32)tmp_pImageIndex);
}
// return type: VkResult(4 bytes)
void vk_QueuePresentKHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPresentInfoKHR local_pPresentInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPresentInfoKHR* pPresentInfo = &local_pPresentInfo.s;
    EAX = (U32)pBoxedInfo->pvkQueuePresentKHR(queue, pPresentInfo);
}
// return type: VkResult(4 bytes)
void vk_CreateDebugReportCallbackEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugReportCallbackCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugReportCallbackCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDebugReportCallbackEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDebugReportCallbackEXT tmp_pCallback = (VkDebugReportCallbackEXT) cpu->memory->readq(ARG4);
    VkDebugReportCallbackEXT* pCallback = &tmp_pCallback;
    pBoxedInfo->debugReportCallbacks[(U64)tmp_pCallback] = local_pCreateInfo.s.pUserData;
    EAX = (U32)pBoxedInfo->pvkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
    cpu->memory->writeq(ARG4, (U64)tmp_pCallback);
}
void vk_DestroyDebugReportCallbackEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDebugReportCallbackEXT callback = (VkDebugReportCallbackEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDebugReportCallbackEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    delete pBoxedInfo->debugReportCallbacks[(U64)callback];
    pBoxedInfo->debugReportCallbacks.erase((U64)callback);
    pBoxedInfo->pvkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
}
void vk_DebugReportMessageEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDebugReportFlagsEXT flags = (VkDebugReportFlagsEXT)ARG2;
    VkDebugReportObjectTypeEXT objectType = (VkDebugReportObjectTypeEXT)ARG3;
    uint64_t object = (uint64_t)cpu->memory->readq(ARG4);
    size_t location = (size_t)ARG5;
    int32_t messageCode = (int32_t)ARG6;
    char* pLayerPrefix = nullptr;
    if (ARG7) {
        U32 len = cpu->memory->strlen(ARG7);
        pLayerPrefix = new char[len];
        cpu->memory->memcpy(pLayerPrefix, ARG7, (U32)len * sizeof(char));
    }
    char* pMessage = nullptr;
    if (ARG8) {
        U32 len = cpu->memory->strlen(ARG8);
        pMessage = new char[len];
        cpu->memory->memcpy(pMessage, ARG8, (U32)len * sizeof(char));
    }
    pBoxedInfo->pvkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
    delete[] pLayerPrefix;
    delete[] pMessage;
}
// return type: VkResult(4 bytes)
void vk_DebugMarkerSetObjectNameEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugMarkerObjectNameInfoEXT local_pNameInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugMarkerObjectNameInfoEXT* pNameInfo = &local_pNameInfo.s;
    EAX = (U32)pBoxedInfo->pvkDebugMarkerSetObjectNameEXT(device, pNameInfo);
}
// return type: VkResult(4 bytes)
void vk_DebugMarkerSetObjectTagEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugMarkerObjectTagInfoEXT local_pTagInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugMarkerObjectTagInfoEXT* pTagInfo = &local_pTagInfo.s;
    EAX = (U32)pBoxedInfo->pvkDebugMarkerSetObjectTagEXT(device, pTagInfo);
}
void vk_CmdDebugMarkerBeginEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugMarkerMarkerInfoEXT local_pMarkerInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugMarkerMarkerInfoEXT* pMarkerInfo = &local_pMarkerInfo.s;
    pBoxedInfo->pvkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
}
void vk_CmdDebugMarkerEndEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdDebugMarkerEndEXT(commandBuffer);
}
void vk_CmdDebugMarkerInsertEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugMarkerMarkerInfoEXT local_pMarkerInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugMarkerMarkerInfoEXT* pMarkerInfo = &local_pMarkerInfo.s;
    pBoxedInfo->pvkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
}
void vk_CmdExecuteGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 isPreprocessed = (VkBool32)ARG2;
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(pBoxedInfo, cpu->memory, ARG3);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
void vk_CmdPreprocessGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
}
void vk_CmdBindPipelineShaderGroupNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG3);
    uint32_t groupIndex = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
void vk_GetGeneratedCommandsMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsMemoryRequirementsInfoNV local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_CreateIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkIndirectCommandsLayoutCreateInfoNV local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkIndirectCommandsLayoutNV tmp_pIndirectCommandsLayout = (VkIndirectCommandsLayoutNV) cpu->memory->readq(ARG4);
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout = &tmp_pIndirectCommandsLayout;
    EAX = (U32)pBoxedInfo->pvkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pIndirectCommandsLayout);
}
void vk_DestroyIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectCommandsLayoutNV indirectCommandsLayout = (VkIndirectCommandsLayoutNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
}
void vk_CmdExecuteGeneratedCommandsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 isPreprocessed = (VkBool32)ARG2;
    MarshalVkGeneratedCommandsInfoEXT local_pGeneratedCommandsInfo(pBoxedInfo, cpu->memory, ARG3);
    VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
void vk_CmdPreprocessGeneratedCommandsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsInfoEXT local_pGeneratedCommandsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    VkCommandBuffer stateCommandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG3);
    pBoxedInfo->pvkCmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
}
void vk_GetGeneratedCommandsMemoryRequirementsEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_CreateIndirectCommandsLayoutEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkIndirectCommandsLayoutCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateIndirectCommandsLayoutEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkIndirectCommandsLayoutEXT tmp_pIndirectCommandsLayout = (VkIndirectCommandsLayoutEXT) cpu->memory->readq(ARG4);
    VkIndirectCommandsLayoutEXT* pIndirectCommandsLayout = &tmp_pIndirectCommandsLayout;
    EAX = (U32)pBoxedInfo->pvkCreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pIndirectCommandsLayout);
}
void vk_DestroyIndirectCommandsLayoutEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectCommandsLayoutEXT indirectCommandsLayout = (VkIndirectCommandsLayoutEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyIndirectCommandsLayoutEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateIndirectExecutionSetEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkIndirectExecutionSetCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkIndirectExecutionSetCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateIndirectExecutionSetEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkIndirectExecutionSetEXT tmp_pIndirectExecutionSet = (VkIndirectExecutionSetEXT) cpu->memory->readq(ARG4);
    VkIndirectExecutionSetEXT* pIndirectExecutionSet = &tmp_pIndirectExecutionSet;
    EAX = (U32)pBoxedInfo->pvkCreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet);
    cpu->memory->writeq(ARG4, (U64)tmp_pIndirectExecutionSet);
}
void vk_DestroyIndirectExecutionSetEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectExecutionSetEXT indirectExecutionSet = (VkIndirectExecutionSetEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyIndirectExecutionSetEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator);
}
void vk_UpdateIndirectExecutionSetPipelineEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectExecutionSetEXT indirectExecutionSet = (VkIndirectExecutionSetEXT)cpu->memory->readq(ARG2);
    uint32_t executionSetWriteCount = (uint32_t)ARG3;
    VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites = NULL;
    if (ARG4) {
        pExecutionSetWrites = new VkWriteIndirectExecutionSetPipelineEXT[executionSetWriteCount];
        for (U32 i=0;i<executionSetWriteCount;i++) {
            MarshalVkWriteIndirectExecutionSetPipelineEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 20, &pExecutionSetWrites[i]);
        }
    }
    pBoxedInfo->pvkUpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
    if (pExecutionSetWrites) {
        delete[] pExecutionSetWrites;
    }
}
void vk_UpdateIndirectExecutionSetShaderEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectExecutionSetEXT indirectExecutionSet = (VkIndirectExecutionSetEXT)cpu->memory->readq(ARG2);
    uint32_t executionSetWriteCount = (uint32_t)ARG3;
    VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites = NULL;
    if (ARG4) {
        pExecutionSetWrites = new VkWriteIndirectExecutionSetShaderEXT[executionSetWriteCount];
        for (U32 i=0;i<executionSetWriteCount;i++) {
            MarshalVkWriteIndirectExecutionSetShaderEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 20, &pExecutionSetWrites[i]);
        }
    }
    pBoxedInfo->pvkUpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
    if (pExecutionSetWrites) {
        delete[] pExecutionSetWrites;
    }
}
void vk_GetPhysicalDeviceFeatures2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(pBoxedInfo, cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceFeatures2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2KHR(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(pBoxedInfo, cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(pBoxedInfo, cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2KHR(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(pBoxedInfo, cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(pBoxedInfo, cpu->memory, ARG3, &pFormatProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(pBoxedInfo, cpu->memory, ARG3, &pFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(pBoxedInfo, cpu->memory, ARG3, &pImageFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(pBoxedInfo, cpu->memory, ARG3, &pImageFormatProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceQueueFamilyProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceMemoryProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(pBoxedInfo, cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceMemoryProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(pBoxedInfo, cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(pBoxedInfo, cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(pBoxedInfo, cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(pBoxedInfo, cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_CmdPushDescriptorSet(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    uint32_t descriptorWriteCount = (uint32_t)ARG5;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG6) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(pBoxedInfo, cpu->memory, ARG6 + i * 44, &pDescriptorWrites[i]);
        }
    }
    pBoxedInfo->pvkCmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
}
void vk_CmdPushDescriptorSetKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    uint32_t descriptorWriteCount = (uint32_t)ARG5;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG6) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(pBoxedInfo, cpu->memory, ARG6 + i * 44, &pDescriptorWrites[i]);
        }
    }
    pBoxedInfo->pvkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
}
void vk_TrimCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG3;
    pBoxedInfo->pvkTrimCommandPool(device, commandPool, flags);
}
void vk_TrimCommandPoolKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG3;
    pBoxedInfo->pvkTrimCommandPoolKHR(device, commandPool, flags);
}
void vk_GetPhysicalDeviceExternalBufferProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalBufferPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphoreProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphorePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalFenceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalFenceProperties.s);
}
void vk_GetPhysicalDeviceExternalFencePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(pBoxedInfo, cpu->memory, ARG3, &pExternalFenceProperties.s);
}
// return type: VkResult(4 bytes)
void vk_ReleaseDisplayEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDisplayKHR display = (VkDisplayKHR)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkReleaseDisplayEXT(physicalDevice, display);
}
// return type: VkResult(4 bytes)
void vk_DisplayPowerControlEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDisplayKHR display = (VkDisplayKHR)cpu->memory->readq(ARG2);
    MarshalVkDisplayPowerInfoEXT local_pDisplayPowerInfo(pBoxedInfo, cpu->memory, ARG3);
    VkDisplayPowerInfoEXT* pDisplayPowerInfo = &local_pDisplayPowerInfo.s;
    EAX = (U32)pBoxedInfo->pvkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
}
// return type: VkResult(4 bytes)
void vk_RegisterDeviceEventEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceEventInfoEXT local_pDeviceEventInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceEventInfoEXT* pDeviceEventInfo = &local_pDeviceEventInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkRegisterDeviceEventEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFence tmp_pFence = (VkFence) cpu->memory->readq(ARG4);
    VkFence* pFence = &tmp_pFence;
    EAX = (U32)pBoxedInfo->pvkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
    cpu->memory->writeq(ARG4, (U64)tmp_pFence);
}
// return type: VkResult(4 bytes)
void vk_RegisterDisplayEventEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDisplayKHR display = (VkDisplayKHR)cpu->memory->readq(ARG2);
    MarshalVkDisplayEventInfoEXT local_pDisplayEventInfo(pBoxedInfo, cpu->memory, ARG3);
    VkDisplayEventInfoEXT* pDisplayEventInfo = &local_pDisplayEventInfo.s;
    static bool shown; if (!shown && ARG4) { klog("vkRegisterDisplayEventEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFence tmp_pFence = (VkFence) cpu->memory->readq(ARG5);
    VkFence* pFence = &tmp_pFence;
    EAX = (U32)pBoxedInfo->pvkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
    cpu->memory->writeq(ARG5, (U64)tmp_pFence);
}
// return type: VkResult(4 bytes)
void vk_GetSwapchainCounterEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    VkSurfaceCounterFlagBitsEXT counter = (VkSurfaceCounterFlagBitsEXT)ARG3;
    uint64_t tmp_pCounterValue = (uint64_t) cpu->memory->readq(ARG4);
    uint64_t* pCounterValue = &tmp_pCounterValue;
    EAX = (U32)pBoxedInfo->pvkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
    cpu->memory->writeq(ARG4, (U64)tmp_pCounterValue);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilities2EXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    MarshalVkSurfaceCapabilities2EXT pSurfaceCapabilities(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilities2EXT::write(pBoxedInfo, cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroups(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroupsKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
void vk_GetDeviceGroupPeerMemoryFeatures(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
void vk_GetDeviceGroupPeerMemoryFeaturesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindBufferMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindImageMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdSetDeviceMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMask(commandBuffer, deviceMask);
}
void vk_CmdSetDeviceMaskKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupPresentCapabilitiesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities(pBoxedInfo, cpu->memory, ARG2);
    EAX = (U32)pBoxedInfo->pvkGetDeviceGroupPresentCapabilitiesKHR(device, &pDeviceGroupPresentCapabilities.s);
    MarshalVkDeviceGroupPresentCapabilitiesKHR::write(pBoxedInfo, cpu->memory, ARG2, &pDeviceGroupPresentCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupSurfacePresentModesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    VkDeviceGroupPresentModeFlagsKHR tmp_pModes = (VkDeviceGroupPresentModeFlagsKHR) cpu->memory->readd(ARG3);
    VkDeviceGroupPresentModeFlagsKHR* pModes = &tmp_pModes;
    EAX = (U32)pBoxedInfo->pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
    cpu->memory->writed(ARG3, (U32)tmp_pModes);
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImage2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireNextImageInfoKHR local_pAcquireInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAcquireNextImageInfoKHR* pAcquireInfo = &local_pAcquireInfo.s;
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = (U32)pBoxedInfo->pvkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
    cpu->memory->writed(ARG3, (U32)tmp_pImageIndex);
}
void vk_CmdDispatchBase(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchBaseKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDevicePresentRectanglesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pRectCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pRectCount = &tmp_pRectCount;
    VkRect2D* pRects = NULL;
    if (ARG4) {
        pRects = new VkRect2D[*pRectCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
    cpu->memory->writed(ARG3, (U32)tmp_pRectCount);
    if (ARG4) {
        for (U32 i=0;i<*pRectCount;i++) {
            MarshalVkRect2D::write(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pRects[i]);
        }
        delete[] pRects;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = (U32)pBoxedInfo->pvkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = (U32)pBoxedInfo->pvkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
void vk_DestroyDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
void vk_DestroyDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
}
void vk_UpdateDescriptorSetWithTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)cpu->memory->readq(ARG2);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG3);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_UpdateDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)cpu->memory->readq(ARG2);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG3);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplateKHR not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_CmdPushDescriptorSetWithTemplate(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    void* pData;
    kpanic("vkCmdPushDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
void vk_CmdPushDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    void* pData;
    kpanic("vkCmdPushDescriptorSetWithTemplateKHR not implemented");
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
void vk_SetHdrMetadataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t swapchainCount = (uint32_t)ARG2;
    VkSwapchainKHR* pSwapchains = nullptr;
    if (ARG3) {
        pSwapchains = new VkSwapchainKHR[swapchainCount];
        cpu->memory->memcpy(pSwapchains, ARG3, (U32)swapchainCount * sizeof(VkSwapchainKHR));
    }
    VkHdrMetadataEXT* pMetadata = NULL;
    if (ARG4) {
        pMetadata = new VkHdrMetadataEXT[swapchainCount];
        for (U32 i=0;i<swapchainCount;i++) {
            MarshalVkHdrMetadataEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pMetadata[i]);
        }
    }
    pBoxedInfo->pvkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
    delete[] pSwapchains;
    if (pMetadata) {
        delete[] pMetadata;
    }
}
void vk_CmdSetViewportWScalingNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewportWScalingNV* pViewportWScalings = NULL;
    if (ARG4) {
        pViewportWScalings = new VkViewportWScalingNV[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkViewportWScalingNV::read(pBoxedInfo, cpu->memory, ARG4 + i * 8, &pViewportWScalings[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    if (pViewportWScalings) {
        delete[] pViewportWScalings;
    }
}
void vk_CmdSetDiscardRectangleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstDiscardRectangle = (uint32_t)ARG2;
    uint32_t discardRectangleCount = (uint32_t)ARG3;
    VkRect2D* pDiscardRectangles = NULL;
    if (ARG4) {
        pDiscardRectangles = new VkRect2D[discardRectangleCount];
        for (U32 i=0;i<discardRectangleCount;i++) {
            MarshalVkRect2D::read(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pDiscardRectangles[i]);
        }
    }
    pBoxedInfo->pvkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    if (pDiscardRectangles) {
        delete[] pDiscardRectangles;
    }
}
void vk_CmdSetDiscardRectangleEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 discardRectangleEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable);
}
void vk_CmdSetDiscardRectangleModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDiscardRectangleModeEXT discardRectangleMode = (VkDiscardRectangleModeEXT)ARG2;
    pBoxedInfo->pvkCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode);
}
void vk_CmdSetSampleLocationsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSampleLocationsInfoEXT local_pSampleLocationsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSampleLocationsInfoEXT* pSampleLocationsInfo = &local_pSampleLocationsInfo.s;
    pBoxedInfo->pvkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
}
void vk_GetPhysicalDeviceMultisamplePropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG2;
    MarshalVkMultisamplePropertiesEXT pMultisampleProperties(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, &pMultisampleProperties.s);
    MarshalVkMultisamplePropertiesEXT::write(pBoxedInfo, cpu->memory, ARG3, &pMultisampleProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilities2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    MarshalVkSurfaceCapabilities2KHR pSurfaceCapabilities(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilities2KHR::write(pBoxedInfo, cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormats2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormat2KHR* pSurfaceFormats = NULL;
    if (ARG4) {
        pSurfaceFormats = new VkSurfaceFormat2KHR[*pSurfaceFormatCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG3, (U32)tmp_pSurfaceFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormat2KHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceDisplayProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkDisplayProperties2KHR* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkDisplayProperties2KHR[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkDisplayProperties2KHR::write(pBoxedInfo, cpu->memory, ARG3 + i * 48, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceDisplayPlaneProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkDisplayPlaneProperties2KHR* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkDisplayPlaneProperties2KHR[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkDisplayPlaneProperties2KHR::write(pBoxedInfo, cpu->memory, ARG3 + i * 20, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetDisplayModeProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDisplayKHR display = (VkDisplayKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkDisplayModeProperties2KHR* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkDisplayModeProperties2KHR[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkDisplayModeProperties2KHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetDisplayPlaneCapabilities2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDisplayPlaneInfo2KHR local_pDisplayPlaneInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo = &local_pDisplayPlaneInfo.s;
    MarshalVkDisplayPlaneCapabilities2KHR pCapabilities(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, &pCapabilities.s);
    MarshalVkDisplayPlaneCapabilities2KHR::write(pBoxedInfo, cpu->memory, ARG3, &pCapabilities.s);
}
void vk_GetBufferMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetBufferMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageSparseMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetImageSparseMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetDeviceBufferMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceBufferMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceBufferMemoryRequirements* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceBufferMemoryRequirements(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetDeviceBufferMemoryRequirementsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceBufferMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceBufferMemoryRequirements* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceBufferMemoryRequirementsKHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetDeviceImageMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageMemoryRequirements* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceImageMemoryRequirements(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetDeviceImageMemoryRequirementsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageMemoryRequirements* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceImageMemoryRequirementsKHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetDeviceImageSparseMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageMemoryRequirements* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetDeviceImageSparseMemoryRequirementsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageMemoryRequirements local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageMemoryRequirements* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = (U32)pBoxedInfo->pvkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = (U32)pBoxedInfo->pvkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
void vk_DestroySamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
void vk_DestroySamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
}
void vk_GetDeviceQueue2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceQueueInfo2 local_pQueueInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceQueueInfo2* pQueueInfo = &local_pQueueInfo.s;
    VkQueue pQueue = (VkQueue)getVulkanPtr(cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceQueue2(device, pQueueInfo, &pQueue);
    cpu->memory->writed(ARG3, createVulkanPtr(cpu->memory, pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_CreateValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkValidationCacheCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkValidationCacheCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkValidationCacheEXT tmp_pValidationCache = (VkValidationCacheEXT) cpu->memory->readq(ARG4);
    VkValidationCacheEXT* pValidationCache = &tmp_pValidationCache;
    EAX = (U32)pBoxedInfo->pvkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pValidationCache);
}
void vk_DestroyValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyValidationCacheEXT(device, validationCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetValidationCacheDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)*pDataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
    cpu->memory->writed(ARG3, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergeValidationCachesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT dstCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    uint32_t srcCacheCount = (uint32_t)ARG3;
    VkValidationCacheEXT* pSrcCaches = nullptr;
    if (ARG4) {
        pSrcCaches = new VkValidationCacheEXT[srcCacheCount];
        cpu->memory->memcpy(pSrcCaches, ARG4, (U32)srcCacheCount * sizeof(VkValidationCacheEXT));
    }
    EAX = (U32)pBoxedInfo->pvkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
void vk_GetDescriptorSetLayoutSupport(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupport(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(pBoxedInfo, cpu->memory, ARG3, &pSupport.s);
}
void vk_GetDescriptorSetLayoutSupportKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(pBoxedInfo, cpu->memory, ARG3, &pSupport.s);
}
// return type: VkResult(4 bytes)
void vk_GetShaderInfoAMD(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    VkShaderStageFlagBits shaderStage = (VkShaderStageFlagBits)ARG3;
    VkShaderInfoTypeAMD infoType = (VkShaderInfoTypeAMD)ARG4;
    size_t tmp_pInfoSize = (size_t) cpu->memory->readd(ARG5);
    size_t* pInfoSize = &tmp_pInfoSize;
    void* pInfo = nullptr;
    if (ARG6) {
        pInfo = new char[*pInfoSize];
        cpu->memory->memcpy(pInfo, ARG6, (U32)*pInfoSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    cpu->memory->writed(ARG5, (U32)tmp_pInfoSize);
    if (pInfo) {
        cpu->memory->memcpy(ARG6, pInfo, (U32)*pInfoSize * sizeof(char));
    }
    delete[] pInfo;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCalibrateableTimeDomainsKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pTimeDomainCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pTimeDomainCount = &tmp_pTimeDomainCount;
    static_assert (sizeof(VkTimeDomainKHR) == 4, "unhandled enum size");
    VkTimeDomainKHR* pTimeDomains = nullptr;
    if (ARG3) {
        pTimeDomains = new VkTimeDomainKHR[*pTimeDomainCount];
        cpu->memory->memcpy(pTimeDomains, ARG3, (U32)*pTimeDomainCount * sizeof(VkTimeDomainKHR));
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains);
    cpu->memory->writed(ARG2, (U32)tmp_pTimeDomainCount);
    if (pTimeDomains) {
        cpu->memory->memcpy(ARG3, pTimeDomains, (U32)*pTimeDomainCount * sizeof(VkTimeDomainKHR));
    }
    delete[] pTimeDomains;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCalibrateableTimeDomainsEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pTimeDomainCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pTimeDomainCount = &tmp_pTimeDomainCount;
    static_assert (sizeof(VkTimeDomainKHR) == 4, "unhandled enum size");
    VkTimeDomainKHR* pTimeDomains = nullptr;
    if (ARG3) {
        pTimeDomains = new VkTimeDomainKHR[*pTimeDomainCount];
        cpu->memory->memcpy(pTimeDomains, ARG3, (U32)*pTimeDomainCount * sizeof(VkTimeDomainKHR));
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
    cpu->memory->writed(ARG2, (U32)tmp_pTimeDomainCount);
    if (pTimeDomains) {
        cpu->memory->memcpy(ARG3, pTimeDomains, (U32)*pTimeDomainCount * sizeof(VkTimeDomainKHR));
    }
    delete[] pTimeDomains;
}
// return type: VkResult(4 bytes)
void vk_GetCalibratedTimestampsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t timestampCount = (uint32_t)ARG2;
    VkCalibratedTimestampInfoKHR* pTimestampInfos = NULL;
    if (ARG3) {
        pTimestampInfos = new VkCalibratedTimestampInfoKHR[timestampCount];
        for (U32 i=0;i<timestampCount;i++) {
            MarshalVkCalibratedTimestampInfoKHR::read(pBoxedInfo, cpu->memory, ARG3 + i * 12, &pTimestampInfos[i]);
        }
    }
    uint64_t* pTimestamps = nullptr;
    if (ARG4) {
        pTimestamps = new uint64_t[timestampCount];
        cpu->memory->memcpy(pTimestamps, ARG4, (U32)timestampCount * sizeof(uint64_t));
    }
    uint64_t tmp_pMaxDeviation = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pMaxDeviation = &tmp_pMaxDeviation;
    EAX = (U32)pBoxedInfo->pvkGetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (pTimestampInfos) {
        delete[] pTimestampInfos;
    }
    if (pTimestamps) {
        cpu->memory->memcpy(ARG4, pTimestamps, (U32)timestampCount * sizeof(uint64_t));
    }
    delete[] pTimestamps;
    cpu->memory->writeq(ARG5, (U64)tmp_pMaxDeviation);
}
// return type: VkResult(4 bytes)
void vk_GetCalibratedTimestampsEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t timestampCount = (uint32_t)ARG2;
    VkCalibratedTimestampInfoKHR* pTimestampInfos = NULL;
    if (ARG3) {
        pTimestampInfos = new VkCalibratedTimestampInfoKHR[timestampCount];
        for (U32 i=0;i<timestampCount;i++) {
            MarshalVkCalibratedTimestampInfoKHR::read(pBoxedInfo, cpu->memory, ARG3 + i * 12, &pTimestampInfos[i]);
        }
    }
    uint64_t* pTimestamps = nullptr;
    if (ARG4) {
        pTimestamps = new uint64_t[timestampCount];
        cpu->memory->memcpy(pTimestamps, ARG4, (U32)timestampCount * sizeof(uint64_t));
    }
    uint64_t tmp_pMaxDeviation = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pMaxDeviation = &tmp_pMaxDeviation;
    EAX = (U32)pBoxedInfo->pvkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (pTimestampInfos) {
        delete[] pTimestampInfos;
    }
    if (pTimestamps) {
        cpu->memory->memcpy(ARG4, pTimestamps, (U32)timestampCount * sizeof(uint64_t));
    }
    delete[] pTimestamps;
    cpu->memory->writeq(ARG5, (U64)tmp_pMaxDeviation);
}
// return type: VkResult(4 bytes)
void vk_SetDebugUtilsObjectNameEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsObjectNameInfoEXT local_pNameInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsObjectNameInfoEXT* pNameInfo = &local_pNameInfo.s;
    EAX = (U32)pBoxedInfo->pvkSetDebugUtilsObjectNameEXT(device, pNameInfo);
}
// return type: VkResult(4 bytes)
void vk_SetDebugUtilsObjectTagEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsObjectTagInfoEXT local_pTagInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsObjectTagInfoEXT* pTagInfo = &local_pTagInfo.s;
    EAX = (U32)pBoxedInfo->pvkSetDebugUtilsObjectTagEXT(device, pTagInfo);
}
void vk_QueueBeginDebugUtilsLabelEXT(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsLabelEXT local_pLabelInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsLabelEXT* pLabelInfo = &local_pLabelInfo.s;
    pBoxedInfo->pvkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
}
void vk_QueueEndDebugUtilsLabelEXT(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkQueueEndDebugUtilsLabelEXT(queue);
}
void vk_QueueInsertDebugUtilsLabelEXT(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsLabelEXT local_pLabelInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsLabelEXT* pLabelInfo = &local_pLabelInfo.s;
    pBoxedInfo->pvkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
}
void vk_CmdBeginDebugUtilsLabelEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsLabelEXT local_pLabelInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsLabelEXT* pLabelInfo = &local_pLabelInfo.s;
    pBoxedInfo->pvkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
void vk_CmdEndDebugUtilsLabelEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndDebugUtilsLabelEXT(commandBuffer);
}
void vk_CmdInsertDebugUtilsLabelEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsLabelEXT local_pLabelInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsLabelEXT* pLabelInfo = &local_pLabelInfo.s;
    pBoxedInfo->pvkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
// return type: VkResult(4 bytes)
void vk_CreateDebugUtilsMessengerEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDebugUtilsMessengerCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDebugUtilsMessengerEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDebugUtilsMessengerEXT tmp_pMessenger = (VkDebugUtilsMessengerEXT) cpu->memory->readq(ARG4);
    VkDebugUtilsMessengerEXT* pMessenger = &tmp_pMessenger;
    pBoxedInfo->debugUtilsCallbacks[(U64)tmp_pMessenger] = local_pCreateInfo.s.pUserData;
    EAX = (U32)pBoxedInfo->pvkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
    cpu->memory->writeq(ARG4, (U64)tmp_pMessenger);
}
void vk_DestroyDebugUtilsMessengerEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDebugUtilsMessengerEXT messenger = (VkDebugUtilsMessengerEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDebugUtilsMessengerEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    delete pBoxedInfo->debugUtilsCallbacks[(U64)messenger];
    pBoxedInfo->debugUtilsCallbacks.erase((U64)messenger);
    pBoxedInfo->pvkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
}
void vk_SubmitDebugUtilsMessageEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity = (VkDebugUtilsMessageSeverityFlagBitsEXT)ARG2;
    VkDebugUtilsMessageTypeFlagsEXT messageTypes = (VkDebugUtilsMessageTypeFlagsEXT)ARG3;
    MarshalVkDebugUtilsMessengerCallbackDataEXT local_pCallbackData(pBoxedInfo, cpu->memory, ARG4);
    VkDebugUtilsMessengerCallbackDataEXT* pCallbackData = &local_pCallbackData.s;
    pBoxedInfo->pvkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
}
// return type: VkResult(4 bytes)
void vk_GetMemoryHostPointerPropertiesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkExternalMemoryHandleTypeFlagBits handleType = (VkExternalMemoryHandleTypeFlagBits)ARG2;
    void* pHostPointer;
    kpanic("vkGetMemoryHostPointerPropertiesEXT not implemented");
    MarshalVkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties(pBoxedInfo, cpu->memory, ARG4);
    EAX = (U32)pBoxedInfo->pvkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, &pMemoryHostPointerProperties.s);
    MarshalVkMemoryHostPointerPropertiesEXT::write(pBoxedInfo, cpu->memory, ARG4, &pMemoryHostPointerProperties.s);
}
void vk_CmdWriteBufferMarkerAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t marker = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = (U32)pBoxedInfo->pvkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2KHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = (U32)pBoxedInfo->pvkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_CmdBeginRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(pBoxedInfo, cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdBeginRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(pBoxedInfo, cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(pBoxedInfo, cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdNextSubpass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(pBoxedInfo, cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdNextSubpass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(pBoxedInfo, cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG3);
    uint64_t* pValue = &tmp_pValue;
    EAX = (U32)pBoxedInfo->pvkGetSemaphoreCounterValue(device, semaphore, pValue);
    cpu->memory->writeq(ARG3, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValueKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG3);
    uint64_t* pValue = &tmp_pValue;
    EAX = (U32)pBoxedInfo->pvkGetSemaphoreCounterValueKHR(device, semaphore, pValue);
    cpu->memory->writeq(ARG3, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphores(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    EAX = (U32)pBoxedInfo->pvkWaitSemaphores(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphoresKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    EAX = (U32)pBoxedInfo->pvkWaitSemaphoresKHR(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = (U32)pBoxedInfo->pvkSignalSemaphore(device, pSignalInfo);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphoreKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = (U32)pBoxedInfo->pvkSignalSemaphoreKHR(device, pSignalInfo);
}
void vk_CmdDrawIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdSetCheckpointNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    void* pCheckpointMarker;
    kpanic("vkCmdSetCheckpointNV not implemented");
    pBoxedInfo->pvkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
}
void vk_GetQueueCheckpointDataNV(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCheckpointDataCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCheckpointDataCount = &tmp_pCheckpointDataCount;
    VkCheckpointDataNV* pCheckpointData = NULL;
    if (ARG3) {
        pCheckpointData = new VkCheckpointDataNV[*pCheckpointDataCount];
    }
    pBoxedInfo->pvkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
    cpu->memory->writed(ARG2, (U32)tmp_pCheckpointDataCount);
    if (ARG3) {
        for (U32 i=0;i<*pCheckpointDataCount;i++) {
            MarshalVkCheckpointDataNV::write(pBoxedInfo, cpu->memory, ARG3 + i * 16, &pCheckpointData[i]);
        }
        delete[] pCheckpointData;
    }
}
void vk_CmdBindTransformFeedbackBuffersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pSizes = nullptr;
    if (ARG6) {
        pSizes = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pSizes, ARG6, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
}
void vk_CmdBeginTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = nullptr;
    if (ARG4) {
        pCounterBuffers = new VkBuffer[counterBufferCount];
        cpu->memory->memcpy(pCounterBuffers, ARG4, (U32)counterBufferCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pCounterBufferOffsets = nullptr;
    if (ARG5) {
        pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
        cpu->memory->memcpy(pCounterBufferOffsets, ARG5, (U32)counterBufferCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdEndTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = nullptr;
    if (ARG4) {
        pCounterBuffers = new VkBuffer[counterBufferCount];
        cpu->memory->memcpy(pCounterBuffers, ARG4, (U32)counterBufferCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pCounterBufferOffsets = nullptr;
    if (ARG5) {
        pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
        cpu->memory->memcpy(pCounterBufferOffsets, ARG5, (U32)counterBufferCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdBeginQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG4;
    uint32_t index = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
}
void vk_CmdEndQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    uint32_t index = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
}
void vk_CmdDrawIndirectByteCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t instanceCount = (uint32_t)ARG2;
    uint32_t firstInstance = (uint32_t)ARG3;
    VkBuffer counterBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize counterBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t counterOffset = (uint32_t)ARG6;
    uint32_t vertexStride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
void vk_CmdSetExclusiveScissorNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstExclusiveScissor = (uint32_t)ARG2;
    uint32_t exclusiveScissorCount = (uint32_t)ARG3;
    VkRect2D* pExclusiveScissors = NULL;
    if (ARG4) {
        pExclusiveScissors = new VkRect2D[exclusiveScissorCount];
        for (U32 i=0;i<exclusiveScissorCount;i++) {
            MarshalVkRect2D::read(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pExclusiveScissors[i]);
        }
    }
    pBoxedInfo->pvkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
    if (pExclusiveScissors) {
        delete[] pExclusiveScissors;
    }
}
void vk_CmdSetExclusiveScissorEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstExclusiveScissor = (uint32_t)ARG2;
    uint32_t exclusiveScissorCount = (uint32_t)ARG3;
    VkBool32* pExclusiveScissorEnables = nullptr;
    if (ARG4) {
        pExclusiveScissorEnables = new VkBool32[exclusiveScissorCount];
        cpu->memory->memcpy(pExclusiveScissorEnables, ARG4, (U32)exclusiveScissorCount * sizeof(VkBool32));
    }
    pBoxedInfo->pvkCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
    delete[] pExclusiveScissorEnables;
}
void vk_CmdBindShadingRateImageNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    pBoxedInfo->pvkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
}
void vk_CmdSetViewportShadingRatePaletteNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkShadingRatePaletteNV* pShadingRatePalettes = NULL;
    if (ARG4) {
        pShadingRatePalettes = new VkShadingRatePaletteNV[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkShadingRatePaletteNV::read(pBoxedInfo, cpu->memory, ARG4 + i * 8, &pShadingRatePalettes[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
    if (pShadingRatePalettes) {
        delete[] pShadingRatePalettes;
    }
}
void vk_CmdSetCoarseSampleOrderNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCoarseSampleOrderTypeNV sampleOrderType = (VkCoarseSampleOrderTypeNV)ARG2;
    uint32_t customSampleOrderCount = (uint32_t)ARG3;
    VkCoarseSampleOrderCustomNV* pCustomSampleOrders = NULL;
    if (ARG4) {
        pCustomSampleOrders = new VkCoarseSampleOrderCustomNV[customSampleOrderCount];
        for (U32 i=0;i<customSampleOrderCount;i++) {
            MarshalVkCoarseSampleOrderCustomNV::read(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pCustomSampleOrders[i]);
        }
    }
    pBoxedInfo->pvkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
    if (pCustomSampleOrders) {
        delete[] pCustomSampleOrders;
    }
}
void vk_CmdDrawMeshTasksNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t taskCount = (uint32_t)ARG2;
    uint32_t firstTask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
}
void vk_CmdDrawMeshTasksIndirectNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawMeshTasksIndirectCountNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawMeshTasksEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t groupCountX = (uint32_t)ARG2;
    uint32_t groupCountY = (uint32_t)ARG3;
    uint32_t groupCountZ = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDrawMeshTasksIndirectEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawMeshTasksIndirectCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
// return type: VkResult(4 bytes)
void vk_CompileDeferredNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t shader = (uint32_t)ARG3;
    EAX = (U32)pBoxedInfo->pvkCompileDeferredNV(device, pipeline, shader);
}
// return type: VkResult(4 bytes)
void vk_CreateAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureCreateInfoNV local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkAccelerationStructureNV tmp_pAccelerationStructure = (VkAccelerationStructureNV) cpu->memory->readq(ARG4);
    VkAccelerationStructureNV* pAccelerationStructure = &tmp_pAccelerationStructure;
    EAX = (U32)pBoxedInfo->pvkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
    cpu->memory->writeq(ARG4, (U64)tmp_pAccelerationStructure);
}
void vk_CmdBindInvocationMaskHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    pBoxedInfo->pvkCmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
}
void vk_DestroyAccelerationStructureKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureKHR accelerationStructure = (VkAccelerationStructureKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyAccelerationStructureKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
}
void vk_DestroyAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
}
void vk_GetAccelerationStructureMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureMemoryRequirementsInfoNV local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_BindAccelerationStructureMemoryNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindAccelerationStructureMemoryInfoNV* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindAccelerationStructureMemoryInfoNV[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindAccelerationStructureMemoryInfoNV::read(pBoxedInfo, cpu->memory, ARG3 + i * 40, &pBindInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdCopyAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)cpu->memory->readq(ARG3);
    VkCopyAccelerationStructureModeKHR mode = (VkCopyAccelerationStructureModeKHR)ARG4;
    pBoxedInfo->pvkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
}
void vk_CmdCopyAccelerationStructureKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyAccelerationStructureInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyAccelerationStructureInfoKHR* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyAccelerationStructureKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyAccelerationStructureInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyAccelerationStructureInfoKHR* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyAccelerationStructureKHR(device, deferredOperation, pInfo);
}
void vk_CmdCopyAccelerationStructureToMemoryKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyAccelerationStructureToMemoryInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyAccelerationStructureToMemoryInfoKHR* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyAccelerationStructureToMemoryKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyAccelerationStructureToMemoryInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyAccelerationStructureToMemoryInfoKHR* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
}
void vk_CmdCopyMemoryToAccelerationStructureKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMemoryToAccelerationStructureInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMemoryToAccelerationStructureInfoKHR* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyMemoryToAccelerationStructureKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyMemoryToAccelerationStructureInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyMemoryToAccelerationStructureInfoKHR* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
}
void vk_CmdWriteAccelerationStructuresPropertiesKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t accelerationStructureCount = (uint32_t)ARG2;
    VkAccelerationStructureKHR* pAccelerationStructures = nullptr;
    if (ARG3) {
        pAccelerationStructures = new VkAccelerationStructureKHR[accelerationStructureCount];
        cpu->memory->memcpy(pAccelerationStructures, ARG3, (U32)accelerationStructureCount * sizeof(VkAccelerationStructureKHR));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG5);
    uint32_t firstQuery = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    delete[] pAccelerationStructures;
}
void vk_CmdWriteAccelerationStructuresPropertiesNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t accelerationStructureCount = (uint32_t)ARG2;
    VkAccelerationStructureNV* pAccelerationStructures = nullptr;
    if (ARG3) {
        pAccelerationStructures = new VkAccelerationStructureNV[accelerationStructureCount];
        cpu->memory->memcpy(pAccelerationStructures, ARG3, (U32)accelerationStructureCount * sizeof(VkAccelerationStructureNV));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG5);
    uint32_t firstQuery = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    delete[] pAccelerationStructures;
}
void vk_CmdBuildAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureInfoNV local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureInfoNV* pInfo = &local_pInfo.s;
    VkBuffer instanceData = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize instanceOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkBool32 update = (VkBool32)ARG5;
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)cpu->memory->readq(ARG6);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)cpu->memory->readq(ARG7);
    VkBuffer scratch = (VkBuffer)cpu->memory->readq(ARG8);
    VkDeviceSize scratchOffset = (VkDeviceSize)cpu->memory->readq(ARG9);
    pBoxedInfo->pvkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
// return type: VkResult(4 bytes)
void vk_WriteAccelerationStructuresPropertiesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t accelerationStructureCount = (uint32_t)ARG2;
    VkAccelerationStructureKHR* pAccelerationStructures = nullptr;
    if (ARG3) {
        pAccelerationStructures = new VkAccelerationStructureKHR[accelerationStructureCount];
        cpu->memory->memcpy(pAccelerationStructures, ARG3, (U32)accelerationStructureCount * sizeof(VkAccelerationStructureKHR));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    size_t stride = (size_t)ARG7;
    EAX = (U32)pBoxedInfo->pvkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
    delete[] pAccelerationStructures;
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_CmdTraceRaysKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkStridedDeviceAddressRegionKHR local_pRaygenShaderBindingTable(pBoxedInfo, cpu->memory, ARG2);
    VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable = &local_pRaygenShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pMissShaderBindingTable(pBoxedInfo, cpu->memory, ARG3);
    VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable = &local_pMissShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pHitShaderBindingTable(pBoxedInfo, cpu->memory, ARG4);
    VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable = &local_pHitShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pCallableShaderBindingTable(pBoxedInfo, cpu->memory, ARG5);
    VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable = &local_pCallableShaderBindingTable.s;
    uint32_t width = (uint32_t)ARG6;
    uint32_t height = (uint32_t)ARG7;
    uint32_t depth = (uint32_t)ARG8;
    pBoxedInfo->pvkCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
void vk_CmdTraceRaysNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer raygenShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize raygenShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer missShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize missShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    VkDeviceSize missShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG6);
    VkBuffer hitShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG7);
    VkDeviceSize hitShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG8);
    VkDeviceSize hitShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG9);
    VkBuffer callableShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG10);
    VkDeviceSize callableShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG11);
    VkDeviceSize callableShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG12);
    uint32_t width = (uint32_t)ARG13;
    uint32_t height = (uint32_t)ARG14;
    uint32_t depth = (uint32_t)ARG15;
    pBoxedInfo->pvkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
// return type: VkResult(4 bytes)
void vk_GetRayTracingShaderGroupHandlesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t firstGroup = (uint32_t)ARG3;
    uint32_t groupCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_GetRayTracingShaderGroupHandlesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t firstGroup = (uint32_t)ARG3;
    uint32_t groupCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_GetRayTracingCaptureReplayShaderGroupHandlesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t firstGroup = (uint32_t)ARG3;
    uint32_t groupCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (pData) {
        pBoxedInfo->rayTracingCaptureReplayShaderGroupHandles[ARG6] = pData;
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
}
// return type: VkResult(4 bytes)
void vk_GetAccelerationStructureHandleNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    size_t dataSize = (size_t)ARG3;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)dataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_CreateRayTracingPipelinesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkRayTracingPipelineCreateInfoNV* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkRayTracingPipelineCreateInfoNV[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkRayTracingPipelineCreateInfoNV::read(pBoxedInfo, cpu->memory, ARG4 + i * 52, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateRayTracingPipelinesNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = (U32)pBoxedInfo->pvkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_CreateRayTracingPipelinesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG3);
    uint32_t createInfoCount = (uint32_t)ARG4;
    VkRayTracingPipelineCreateInfoKHR* pCreateInfos = NULL;
    if (ARG5) {
        pCreateInfos = new VkRayTracingPipelineCreateInfoKHR[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkRayTracingPipelineCreateInfoKHR::read(pBoxedInfo, cpu->memory, ARG5 + i * 64, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG6) { klog("vkCreateRayTracingPipelinesKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG7) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG7, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = (U32)pBoxedInfo->pvkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG7, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCooperativeMatrixPropertiesNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkCooperativeMatrixPropertiesNV* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkCooperativeMatrixPropertiesNV[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkCooperativeMatrixPropertiesNV::write(pBoxedInfo, cpu->memory, ARG3 + i * 40, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_CmdTraceRaysIndirectKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkStridedDeviceAddressRegionKHR local_pRaygenShaderBindingTable(pBoxedInfo, cpu->memory, ARG2);
    VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable = &local_pRaygenShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pMissShaderBindingTable(pBoxedInfo, cpu->memory, ARG3);
    VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable = &local_pMissShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pHitShaderBindingTable(pBoxedInfo, cpu->memory, ARG4);
    VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable = &local_pHitShaderBindingTable.s;
    MarshalVkStridedDeviceAddressRegionKHR local_pCallableShaderBindingTable(pBoxedInfo, cpu->memory, ARG5);
    VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable = &local_pCallableShaderBindingTable.s;
    VkDeviceAddress indirectDeviceAddress = (VkDeviceAddress)cpu->memory->readq(ARG6);
    pBoxedInfo->pvkCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
void vk_CmdTraceRaysIndirect2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceAddress indirectDeviceAddress = (VkDeviceAddress)cpu->memory->readq(ARG2);
    pBoxedInfo->pvkCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
}
void vk_GetDeviceAccelerationStructureCompatibilityKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureVersionInfoKHR local_pVersionInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureVersionInfoKHR* pVersionInfo = &local_pVersionInfo.s;
    VkAccelerationStructureCompatibilityKHR tmp_pCompatibility = (VkAccelerationStructureCompatibilityKHR) cpu->memory->readd(ARG3);
    VkAccelerationStructureCompatibilityKHR* pCompatibility = &tmp_pCompatibility;
    pBoxedInfo->pvkGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
    cpu->memory->writed(ARG3, (U32)tmp_pCompatibility);
}
// return type: VkDeviceSize(8 bytes)
void vk_GetRayTracingShaderGroupStackSizeKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t group = (uint32_t)ARG3;
    VkShaderGroupShaderKHR groupShader = (VkShaderGroupShaderKHR)ARG4;
    VkDeviceSize result = pBoxedInfo->pvkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
void vk_CmdSetRayTracingPipelineStackSizeKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t pipelineStackSize = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
}
// return type: uint32_t(4 bytes)
void vk_GetImageViewHandleNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewHandleInfoNVX local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageViewHandleInfoNVX* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkGetImageViewHandleNVX(device, pInfo);
}
// return type: uint64_t(8 bytes)
void vk_GetImageViewHandle64NVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewHandleInfoNVX local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageViewHandleInfoNVX* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetImageViewHandle64NVX(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_GetImageViewAddressNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    MarshalVkImageViewAddressPropertiesNVX pProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetImageViewAddressNVX(device, imageView, &pProperties.s);
    MarshalVkImageViewAddressPropertiesNVX::write(pBoxedInfo, cpu->memory, ARG3, &pProperties.s);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t tmp_pCounterCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pCounterCount = &tmp_pCounterCount;
    VkPerformanceCounterKHR* pCounters = NULL;
    if (ARG4) {
        pCounters = new VkPerformanceCounterKHR[*pCounterCount];
    }
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions = NULL;
    if (ARG5) {
        pCounterDescriptions = new VkPerformanceCounterDescriptionKHR[*pCounterCount];
    }
    EAX = (U32)pBoxedInfo->pvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    cpu->memory->writed(ARG3, (U32)tmp_pCounterCount);
    if (ARG4) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 36, &pCounters[i]);
        }
        delete[] pCounters;
    }
    if (ARG5) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterDescriptionKHR::write(pBoxedInfo, cpu->memory, ARG5 + i * 780, &pCounterDescriptions[i]);
        }
        delete[] pCounterDescriptions;
    }
}
void vk_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolPerformanceCreateInfoKHR local_pPerformanceQueryCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo = &local_pPerformanceQueryCreateInfo.s;
    uint32_t tmp_pNumPasses = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pNumPasses = &tmp_pNumPasses;
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
    cpu->memory->writed(ARG3, (U32)tmp_pNumPasses);
}
// return type: VkResult(4 bytes)
void vk_AcquireProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireProfilingLockInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAcquireProfilingLockInfoKHR* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkAcquireProfilingLockKHR(device, pInfo);
}
void vk_ReleaseProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkReleaseProfilingLockKHR(device);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressEXT(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCombinationCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCombinationCount = &tmp_pCombinationCount;
    VkFramebufferMixedSamplesCombinationNV* pCombinations = NULL;
    if (ARG3) {
        pCombinations = new VkFramebufferMixedSamplesCombinationNV[*pCombinationCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
    cpu->memory->writed(ARG2, (U32)tmp_pCombinationCount);
    if (ARG3) {
        for (U32 i=0;i<*pCombinationCount;i++) {
            MarshalVkFramebufferMixedSamplesCombinationNV::write(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pCombinations[i]);
        }
        delete[] pCombinations;
    }
}
// return type: VkResult(4 bytes)
void vk_InitializePerformanceApiINTEL(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkInitializePerformanceApiInfoINTEL local_pInitializeInfo(pBoxedInfo, cpu->memory, ARG2);
    VkInitializePerformanceApiInfoINTEL* pInitializeInfo = &local_pInitializeInfo.s;
    EAX = (U32)pBoxedInfo->pvkInitializePerformanceApiINTEL(device, pInitializeInfo);
}
void vk_UninitializePerformanceApiINTEL(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkUninitializePerformanceApiINTEL(device);
}
// return type: VkResult(4 bytes)
void vk_CmdSetPerformanceMarkerINTEL(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPerformanceMarkerInfoINTEL local_pMarkerInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPerformanceMarkerInfoINTEL* pMarkerInfo = &local_pMarkerInfo.s;
    EAX = (U32)pBoxedInfo->pvkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
}
// return type: VkResult(4 bytes)
void vk_CmdSetPerformanceStreamMarkerINTEL(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPerformanceStreamMarkerInfoINTEL local_pMarkerInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo = &local_pMarkerInfo.s;
    EAX = (U32)pBoxedInfo->pvkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
}
// return type: VkResult(4 bytes)
void vk_CmdSetPerformanceOverrideINTEL(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPerformanceOverrideInfoINTEL local_pOverrideInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPerformanceOverrideInfoINTEL* pOverrideInfo = &local_pOverrideInfo.s;
    EAX = (U32)pBoxedInfo->pvkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
}
// return type: VkResult(4 bytes)
void vk_AcquirePerformanceConfigurationINTEL(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPerformanceConfigurationAcquireInfoINTEL local_pAcquireInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo = &local_pAcquireInfo.s;
    VkPerformanceConfigurationINTEL tmp_pConfiguration = (VkPerformanceConfigurationINTEL) cpu->memory->readq(ARG3);
    VkPerformanceConfigurationINTEL* pConfiguration = &tmp_pConfiguration;
    EAX = (U32)pBoxedInfo->pvkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
    cpu->memory->writeq(ARG3, (U64)tmp_pConfiguration);
}
// return type: VkResult(4 bytes)
void vk_ReleasePerformanceConfigurationINTEL(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPerformanceConfigurationINTEL configuration = (VkPerformanceConfigurationINTEL)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkReleasePerformanceConfigurationINTEL(device, configuration);
}
// return type: VkResult(4 bytes)
void vk_QueueSetPerformanceConfigurationINTEL(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPerformanceConfigurationINTEL configuration = (VkPerformanceConfigurationINTEL)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkQueueSetPerformanceConfigurationINTEL(queue, configuration);
}
// return type: VkResult(4 bytes)
void vk_GetPerformanceParameterINTEL(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPerformanceParameterTypeINTEL parameter = (VkPerformanceParameterTypeINTEL)ARG2;
    MarshalVkPerformanceValueINTEL pValue(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPerformanceParameterINTEL(device, parameter, &pValue.s);
    MarshalVkPerformanceValueINTEL::write(pBoxedInfo, cpu->memory, ARG3, &pValue.s);
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineExecutablePropertiesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineInfoKHR local_pPipelineInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineInfoKHR* pPipelineInfo = &local_pPipelineInfo.s;
    uint32_t tmp_pExecutableCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pExecutableCount = &tmp_pExecutableCount;
    VkPipelineExecutablePropertiesKHR* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkPipelineExecutablePropertiesKHR[*pExecutableCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pExecutableCount);
    if (ARG4) {
        for (U32 i=0;i<*pExecutableCount;i++) {
            MarshalVkPipelineExecutablePropertiesKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 528, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPipelineExecutableStatisticsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineExecutableInfoKHR local_pExecutableInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineExecutableInfoKHR* pExecutableInfo = &local_pExecutableInfo.s;
    uint32_t tmp_pStatisticCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pStatisticCount = &tmp_pStatisticCount;
    VkPipelineExecutableStatisticKHR* pStatistics = NULL;
    if (ARG4) {
        pStatistics = new VkPipelineExecutableStatisticKHR[*pStatisticCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
    cpu->memory->writed(ARG3, (U32)tmp_pStatisticCount);
    if (ARG4) {
        for (U32 i=0;i<*pStatisticCount;i++) {
            MarshalVkPipelineExecutableStatisticKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 532, &pStatistics[i]);
        }
        delete[] pStatistics;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPipelineExecutableInternalRepresentationsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineExecutableInfoKHR local_pExecutableInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineExecutableInfoKHR* pExecutableInfo = &local_pExecutableInfo.s;
    uint32_t tmp_pInternalRepresentationCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pInternalRepresentationCount = &tmp_pInternalRepresentationCount;
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations = NULL;
    if (ARG4) {
        pInternalRepresentations = new VkPipelineExecutableInternalRepresentationKHR[*pInternalRepresentationCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
    cpu->memory->writed(ARG3, (U32)tmp_pInternalRepresentationCount);
    if (ARG4) {
        for (U32 i=0;i<*pInternalRepresentationCount;i++) {
            MarshalVkPipelineExecutableInternalRepresentationKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 532, &pInternalRepresentations[i]);
        }
        delete[] pInternalRepresentations;
    }
}
void vk_CmdSetLineStipple(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t lineStippleFactor = (uint32_t)ARG2;
    uint16_t lineStipplePattern = (uint16_t)ARG3;
    pBoxedInfo->pvkCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern);
}
void vk_CmdSetLineStippleKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t lineStippleFactor = (uint32_t)ARG2;
    uint16_t lineStipplePattern = (uint16_t)ARG3;
    pBoxedInfo->pvkCmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern);
}
void vk_CmdSetLineStippleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t lineStippleFactor = (uint32_t)ARG2;
    uint16_t lineStipplePattern = (uint16_t)ARG3;
    pBoxedInfo->pvkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceToolProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pToolCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pToolCount = &tmp_pToolCount;
    VkPhysicalDeviceToolProperties* pToolProperties = NULL;
    if (ARG3) {
        pToolProperties = new VkPhysicalDeviceToolProperties[*pToolCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pToolCount);
    if (ARG3) {
        for (U32 i=0;i<*pToolCount;i++) {
            MarshalVkPhysicalDeviceToolProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 1036, &pToolProperties[i]);
        }
        delete[] pToolProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceToolPropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pToolCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pToolCount = &tmp_pToolCount;
    VkPhysicalDeviceToolProperties* pToolProperties = NULL;
    if (ARG3) {
        pToolProperties = new VkPhysicalDeviceToolProperties[*pToolCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pToolCount);
    if (ARG3) {
        for (U32 i=0;i<*pToolCount;i++) {
            MarshalVkPhysicalDeviceToolProperties::write(pBoxedInfo, cpu->memory, ARG3 + i * 1036, &pToolProperties[i]);
        }
        delete[] pToolProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateAccelerationStructureKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureCreateInfoKHR local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateAccelerationStructureKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkAccelerationStructureKHR tmp_pAccelerationStructure = (VkAccelerationStructureKHR) cpu->memory->readq(ARG4);
    VkAccelerationStructureKHR* pAccelerationStructure = &tmp_pAccelerationStructure;
    EAX = (U32)pBoxedInfo->pvkCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
    cpu->memory->writeq(ARG4, (U64)tmp_pAccelerationStructure);
}
void vk_CmdBuildAccelerationStructuresKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t infoCount = (uint32_t)ARG2;
    VkAccelerationStructureBuildGeometryInfoKHR* pInfos = NULL;
    if (ARG3) {
        pInfos = new VkAccelerationStructureBuildGeometryInfoKHR[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            MarshalVkAccelerationStructureBuildGeometryInfoKHR::read(pBoxedInfo, cpu->memory, ARG3 + i * 56, &pInfos[i]);
        }
    }
    VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos = NULL;
    if (ARG4) {
        ppBuildRangeInfos = new VkAccelerationStructureBuildRangeInfoKHR*[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            ppBuildRangeInfos[i] = new VkAccelerationStructureBuildRangeInfoKHR[pInfos[i].geometryCount];
            U32 address = cpu->memory->readd(ARG4 + i * 4);
            for (U32 j=0;j<pInfos[i].geometryCount;j++) {
                MarshalVkAccelerationStructureBuildRangeInfoKHR::read(pBoxedInfo, cpu->memory, address + j * 4, &ppBuildRangeInfos[i][j]);
            }
        }
    }
    pBoxedInfo->pvkCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
    if (pInfos) {
        delete[] pInfos;
    }
    if (ppBuildRangeInfos) {
        for (U32 i=0;i<infoCount;i++) {
            delete[] ppBuildRangeInfos[i];
        }
        delete[] ppBuildRangeInfos;
    }
}
void vk_CmdBuildAccelerationStructuresIndirectKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t infoCount = (uint32_t)ARG2;
    VkAccelerationStructureBuildGeometryInfoKHR* pInfos = NULL;
    if (ARG3) {
        pInfos = new VkAccelerationStructureBuildGeometryInfoKHR[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            MarshalVkAccelerationStructureBuildGeometryInfoKHR::read(pBoxedInfo, cpu->memory, ARG3 + i * 56, &pInfos[i]);
        }
    }
    VkDeviceAddress* pIndirectDeviceAddresses = nullptr;
    if (ARG4) {
        pIndirectDeviceAddresses = new VkDeviceAddress[infoCount];
        cpu->memory->memcpy(pIndirectDeviceAddresses, ARG4, (U32)infoCount * sizeof(VkDeviceAddress));
    }
    uint32_t* pIndirectStrides = nullptr;
    if (ARG5) {
        pIndirectStrides = new uint32_t[infoCount];
        cpu->memory->memcpy(pIndirectStrides, ARG5, (U32)infoCount * sizeof(uint32_t));
    }
    uint32_t** ppMaxPrimitiveCounts = nullptr;
    if (ARG6) {
        ppMaxPrimitiveCounts = new uint32_t*[infoCount];
        U32 ppMaxPrimitiveCountsCount = infoCount;
        for (U32 i = 0; i < ppMaxPrimitiveCountsCount; i++) {
            ppMaxPrimitiveCounts[i] = new uint32_t[pInfos[i].geometryCount];
            U32 ppMaxPrimitiveCountsAddress = cpu->memory->readd(ARG6 + i * 4);
            cpu->memory->memcpy(ppMaxPrimitiveCounts[i], ppMaxPrimitiveCountsAddress, (U32)pInfos[i].geometryCount * sizeof(uint32_t));
        }
    }
    pBoxedInfo->pvkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
    if (pInfos) {
        delete[] pInfos;
    }
    delete[] pIndirectDeviceAddresses;
    delete[] pIndirectStrides;
    if (ppMaxPrimitiveCounts) {
        for (U32 i = 0; i < infoCount; i++) {
            delete[] ppMaxPrimitiveCounts[i];
        }
    }
    delete[] ppMaxPrimitiveCounts;
}
// return type: VkResult(4 bytes)
void vk_BuildAccelerationStructuresKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    uint32_t infoCount = (uint32_t)ARG3;
    VkAccelerationStructureBuildGeometryInfoKHR* pInfos = NULL;
    if (ARG4) {
        pInfos = new VkAccelerationStructureBuildGeometryInfoKHR[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            MarshalVkAccelerationStructureBuildGeometryInfoKHR::read(pBoxedInfo, cpu->memory, ARG4 + i * 56, &pInfos[i]);
        }
    }
    VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos = NULL;
    if (ARG5) {
        ppBuildRangeInfos = new VkAccelerationStructureBuildRangeInfoKHR*[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            ppBuildRangeInfos[i] = new VkAccelerationStructureBuildRangeInfoKHR[pInfos[i].geometryCount];
            U32 address = cpu->memory->readd(ARG5 + i * 4);
            for (U32 j=0;j<pInfos[i].geometryCount;j++) {
                MarshalVkAccelerationStructureBuildRangeInfoKHR::read(pBoxedInfo, cpu->memory, address + j * 4, &ppBuildRangeInfos[i][j]);
            }
        }
    }
    EAX = (U32)pBoxedInfo->pvkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
    if (pInfos) {
        delete[] pInfos;
    }
    if (ppBuildRangeInfos) {
        for (U32 i=0;i<infoCount;i++) {
            delete[] ppBuildRangeInfos[i];
        }
        delete[] ppBuildRangeInfos;
    }
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetAccelerationStructureDeviceAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureDeviceAddressInfoKHR local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureDeviceAddressInfoKHR* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetAccelerationStructureDeviceAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_CreateDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkCreateDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeferredOperationKHR tmp_pDeferredOperation = (VkDeferredOperationKHR) cpu->memory->readq(ARG3);
    VkDeferredOperationKHR* pDeferredOperation = &tmp_pDeferredOperation;
    EAX = (U32)pBoxedInfo->pvkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
    cpu->memory->writeq(ARG3, (U64)tmp_pDeferredOperation);
}
void vk_DestroyDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDeferredOperationKHR(device, operation, pAllocator);
}
// return type: uint32_t(4 bytes)
void vk_GetDeferredOperationMaxConcurrencyKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkGetDeferredOperationMaxConcurrencyKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_GetDeferredOperationResultKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkGetDeferredOperationResultKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_DeferredOperationJoinKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = (U32)pBoxedInfo->pvkDeferredOperationJoinKHR(device, operation);
}
void vk_GetPipelineIndirectMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkComputePipelineCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkComputePipelineCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(pBoxedInfo, cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetPipelineIndirectDeviceAddressNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineIndirectDeviceAddressInfoNV local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineIndirectDeviceAddressInfoNV* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetPipelineIndirectDeviceAddressNV(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
void vk_AntiLagUpdateAMD(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAntiLagDataAMD local_pData(pBoxedInfo, cpu->memory, ARG2);
    VkAntiLagDataAMD* pData = &local_pData.s;
    pBoxedInfo->pvkAntiLagUpdateAMD(device, pData);
}
void vk_CmdSetCullMode(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCullModeFlags cullMode = (VkCullModeFlags)ARG2;
    pBoxedInfo->pvkCmdSetCullMode(commandBuffer, cullMode);
}
void vk_CmdSetCullModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCullModeFlags cullMode = (VkCullModeFlags)ARG2;
    pBoxedInfo->pvkCmdSetCullModeEXT(commandBuffer, cullMode);
}
void vk_CmdSetFrontFace(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFrontFace frontFace = (VkFrontFace)ARG2;
    pBoxedInfo->pvkCmdSetFrontFace(commandBuffer, frontFace);
}
void vk_CmdSetFrontFaceEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFrontFace frontFace = (VkFrontFace)ARG2;
    pBoxedInfo->pvkCmdSetFrontFaceEXT(commandBuffer, frontFace);
}
void vk_CmdSetPrimitiveTopology(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrimitiveTopology primitiveTopology = (VkPrimitiveTopology)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
void vk_CmdSetPrimitiveTopologyEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrimitiveTopology primitiveTopology = (VkPrimitiveTopology)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
}
void vk_CmdSetViewportWithCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t viewportCount = (uint32_t)ARG2;
    VkViewport* pViewports = NULL;
    if (ARG3) {
        pViewports = new VkViewport[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkViewport::read(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pViewports[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
    if (pViewports) {
        delete[] pViewports;
    }
}
void vk_CmdSetViewportWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t viewportCount = (uint32_t)ARG2;
    VkViewport* pViewports = NULL;
    if (ARG3) {
        pViewports = new VkViewport[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkViewport::read(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pViewports[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
    if (pViewports) {
        delete[] pViewports;
    }
}
void vk_CmdSetScissorWithCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t scissorCount = (uint32_t)ARG2;
    VkRect2D* pScissors = NULL;
    if (ARG3) {
        pScissors = new VkRect2D[scissorCount];
        for (U32 i=0;i<scissorCount;i++) {
            MarshalVkRect2D::read(pBoxedInfo, cpu->memory, ARG3 + i * 16, &pScissors[i]);
        }
    }
    pBoxedInfo->pvkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
    if (pScissors) {
        delete[] pScissors;
    }
}
void vk_CmdSetScissorWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t scissorCount = (uint32_t)ARG2;
    VkRect2D* pScissors = NULL;
    if (ARG3) {
        pScissors = new VkRect2D[scissorCount];
        for (U32 i=0;i<scissorCount;i++) {
            MarshalVkRect2D::read(pBoxedInfo, cpu->memory, ARG3 + i * 16, &pScissors[i]);
        }
    }
    pBoxedInfo->pvkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
    if (pScissors) {
        delete[] pScissors;
    }
}
void vk_CmdBindIndexBuffer2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkIndexType indexType = (VkIndexType)ARG5;
    pBoxedInfo->pvkCmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType);
}
void vk_CmdBindIndexBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkIndexType indexType = (VkIndexType)ARG5;
    pBoxedInfo->pvkCmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType);
}
void vk_CmdBindVertexBuffers2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pSizes = nullptr;
    if (ARG6) {
        pSizes = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pSizes, ARG6, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pStrides = nullptr;
    if (ARG7) {
        pStrides = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pStrides, ARG7, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
    delete[] pStrides;
}
void vk_CmdBindVertexBuffers2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pSizes = nullptr;
    if (ARG6) {
        pSizes = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pSizes, ARG6, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pStrides = nullptr;
    if (ARG7) {
        pStrides = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pStrides, ARG7, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
    delete[] pStrides;
}
void vk_CmdSetDepthTestEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
void vk_CmdSetDepthTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
}
void vk_CmdSetDepthWriteEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthWriteEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
void vk_CmdSetDepthWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthWriteEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
}
void vk_CmdSetDepthCompareOp(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCompareOp depthCompareOp = (VkCompareOp)ARG2;
    pBoxedInfo->pvkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
void vk_CmdSetDepthCompareOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCompareOp depthCompareOp = (VkCompareOp)ARG2;
    pBoxedInfo->pvkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
}
void vk_CmdSetDepthBoundsTestEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBoundsTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
void vk_CmdSetDepthBoundsTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBoundsTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
}
void vk_CmdSetStencilTestEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 stencilTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
void vk_CmdSetStencilTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 stencilTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
}
void vk_CmdSetStencilOp(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    VkStencilOp failOp = (VkStencilOp)ARG3;
    VkStencilOp passOp = (VkStencilOp)ARG4;
    VkStencilOp depthFailOp = (VkStencilOp)ARG5;
    VkCompareOp compareOp = (VkCompareOp)ARG6;
    pBoxedInfo->pvkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
void vk_CmdSetStencilOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    VkStencilOp failOp = (VkStencilOp)ARG3;
    VkStencilOp passOp = (VkStencilOp)ARG4;
    VkStencilOp depthFailOp = (VkStencilOp)ARG5;
    VkCompareOp compareOp = (VkCompareOp)ARG6;
    pBoxedInfo->pvkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
void vk_CmdSetPatchControlPointsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t patchControlPoints = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
}
void vk_CmdSetRasterizerDiscardEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 rasterizerDiscardEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
void vk_CmdSetRasterizerDiscardEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 rasterizerDiscardEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
}
void vk_CmdSetDepthBiasEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBiasEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
void vk_CmdSetDepthBiasEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBiasEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
}
void vk_CmdSetLogicOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkLogicOp logicOp = (VkLogicOp)ARG2;
    pBoxedInfo->pvkCmdSetLogicOpEXT(commandBuffer, logicOp);
}
void vk_CmdSetPrimitiveRestartEnable(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 primitiveRestartEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
void vk_CmdSetPrimitiveRestartEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 primitiveRestartEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
}
void vk_CmdSetTessellationDomainOriginEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkTessellationDomainOrigin domainOrigin = (VkTessellationDomainOrigin)ARG2;
    pBoxedInfo->pvkCmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
}
void vk_CmdSetDepthClampEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthClampEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
}
void vk_CmdSetPolygonModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPolygonMode polygonMode = (VkPolygonMode)ARG2;
    pBoxedInfo->pvkCmdSetPolygonModeEXT(commandBuffer, polygonMode);
}
void vk_CmdSetRasterizationSamplesEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampleCountFlagBits rasterizationSamples = (VkSampleCountFlagBits)ARG2;
    pBoxedInfo->pvkCmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
}
void vk_CmdSetSampleMaskEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG2;
    VkSampleMask tmp_pSampleMask = (VkSampleMask) cpu->memory->readd(ARG3);
    VkSampleMask* pSampleMask = &tmp_pSampleMask;
    pBoxedInfo->pvkCmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
}
void vk_CmdSetAlphaToCoverageEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 alphaToCoverageEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
}
void vk_CmdSetAlphaToOneEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 alphaToOneEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
}
void vk_CmdSetLogicOpEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 logicOpEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
}
void vk_CmdSetColorBlendEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstAttachment = (uint32_t)ARG2;
    uint32_t attachmentCount = (uint32_t)ARG3;
    VkBool32* pColorBlendEnables = nullptr;
    if (ARG4) {
        pColorBlendEnables = new VkBool32[attachmentCount];
        cpu->memory->memcpy(pColorBlendEnables, ARG4, (U32)attachmentCount * sizeof(VkBool32));
    }
    pBoxedInfo->pvkCmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
    delete[] pColorBlendEnables;
}
void vk_CmdSetColorBlendEquationEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstAttachment = (uint32_t)ARG2;
    uint32_t attachmentCount = (uint32_t)ARG3;
    VkColorBlendEquationEXT* pColorBlendEquations = NULL;
    if (ARG4) {
        pColorBlendEquations = new VkColorBlendEquationEXT[attachmentCount];
        for (U32 i=0;i<attachmentCount;i++) {
            MarshalVkColorBlendEquationEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 24, &pColorBlendEquations[i]);
        }
    }
    pBoxedInfo->pvkCmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
    if (pColorBlendEquations) {
        delete[] pColorBlendEquations;
    }
}
void vk_CmdSetColorWriteMaskEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstAttachment = (uint32_t)ARG2;
    uint32_t attachmentCount = (uint32_t)ARG3;
    VkColorComponentFlags* pColorWriteMasks = nullptr;
    if (ARG4) {
        pColorWriteMasks = new VkColorComponentFlags[attachmentCount];
        cpu->memory->memcpy(pColorWriteMasks, ARG4, (U32)attachmentCount * sizeof(VkColorComponentFlags));
    }
    pBoxedInfo->pvkCmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
    delete[] pColorWriteMasks;
}
void vk_CmdSetRasterizationStreamEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t rasterizationStream = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
}
void vk_CmdSetConservativeRasterizationModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkConservativeRasterizationModeEXT conservativeRasterizationMode = (VkConservativeRasterizationModeEXT)ARG2;
    pBoxedInfo->pvkCmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
}
void vk_CmdSetExtraPrimitiveOverestimationSizeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalFloat extraPrimitiveOverestimationSizeFloat;
    extraPrimitiveOverestimationSizeFloat.i = ARG2;
    float extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSizeFloat.f;
    pBoxedInfo->pvkCmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
}
void vk_CmdSetDepthClipEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthClipEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
}
void vk_CmdSetSampleLocationsEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 sampleLocationsEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
}
void vk_CmdSetColorBlendAdvancedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstAttachment = (uint32_t)ARG2;
    uint32_t attachmentCount = (uint32_t)ARG3;
    VkColorBlendAdvancedEXT* pColorBlendAdvanced = NULL;
    if (ARG4) {
        pColorBlendAdvanced = new VkColorBlendAdvancedEXT[attachmentCount];
        for (U32 i=0;i<attachmentCount;i++) {
            MarshalVkColorBlendAdvancedEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 20, &pColorBlendAdvanced[i]);
        }
    }
    pBoxedInfo->pvkCmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
    if (pColorBlendAdvanced) {
        delete[] pColorBlendAdvanced;
    }
}
void vk_CmdSetProvokingVertexModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkProvokingVertexModeEXT provokingVertexMode = (VkProvokingVertexModeEXT)ARG2;
    pBoxedInfo->pvkCmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
}
void vk_CmdSetLineRasterizationModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkLineRasterizationModeEXT lineRasterizationMode = (VkLineRasterizationMode)ARG2;
    pBoxedInfo->pvkCmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
}
void vk_CmdSetLineStippleEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 stippledLineEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
}
void vk_CmdSetDepthClipNegativeOneToOneEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 negativeOneToOne = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
}
void vk_CmdSetViewportWScalingEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 viewportWScalingEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
}
void vk_CmdSetViewportSwizzleNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewportSwizzleNV* pViewportSwizzles = NULL;
    if (ARG4) {
        pViewportSwizzles = new VkViewportSwizzleNV[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkViewportSwizzleNV::read(pBoxedInfo, cpu->memory, ARG4 + i * 16, &pViewportSwizzles[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
    if (pViewportSwizzles) {
        delete[] pViewportSwizzles;
    }
}
void vk_CmdSetCoverageToColorEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 coverageToColorEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
}
void vk_CmdSetCoverageToColorLocationNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t coverageToColorLocation = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
}
void vk_CmdSetCoverageModulationModeNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCoverageModulationModeNV coverageModulationMode = (VkCoverageModulationModeNV)ARG2;
    pBoxedInfo->pvkCmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
}
void vk_CmdSetCoverageModulationTableEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 coverageModulationTableEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
}
void vk_CmdSetCoverageModulationTableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t coverageModulationTableCount = (uint32_t)ARG2;
    float* pCoverageModulationTable = nullptr;
    if (ARG3) {
        pCoverageModulationTable = new float[coverageModulationTableCount];
        cpu->memory->memcpy(pCoverageModulationTable, ARG3, (U32)coverageModulationTableCount * sizeof(float));
    }
    pBoxedInfo->pvkCmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
    delete[] pCoverageModulationTable;
}
void vk_CmdSetShadingRateImageEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 shadingRateImageEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
}
void vk_CmdSetCoverageReductionModeNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCoverageReductionModeNV coverageReductionMode = (VkCoverageReductionModeNV)ARG2;
    pBoxedInfo->pvkCmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
}
void vk_CmdSetRepresentativeFragmentTestEnableNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 representativeFragmentTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
}
// return type: VkResult(4 bytes)
void vk_CreatePrivateDataSlot(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPrivateDataSlotCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPrivateDataSlotCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePrivateDataSlot:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPrivateDataSlot tmp_pPrivateDataSlot = (VkPrivateDataSlot) cpu->memory->readq(ARG4);
    VkPrivateDataSlot* pPrivateDataSlot = &tmp_pPrivateDataSlot;
    EAX = (U32)pBoxedInfo->pvkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    cpu->memory->writeq(ARG4, (U64)tmp_pPrivateDataSlot);
}
// return type: VkResult(4 bytes)
void vk_CreatePrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPrivateDataSlotCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPrivateDataSlotCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPrivateDataSlot tmp_pPrivateDataSlot = (VkPrivateDataSlot) cpu->memory->readq(ARG4);
    VkPrivateDataSlot* pPrivateDataSlot = &tmp_pPrivateDataSlot;
    EAX = (U32)pBoxedInfo->pvkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    cpu->memory->writeq(ARG4, (U64)tmp_pPrivateDataSlot);
}
void vk_DestroyPrivateDataSlot(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPrivateDataSlot:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
void vk_DestroyPrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_SetPrivateData(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG4);
    uint64_t data = (uint64_t)cpu->memory->readq(ARG5);
    EAX = (U32)pBoxedInfo->pvkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
}
// return type: VkResult(4 bytes)
void vk_SetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG4);
    uint64_t data = (uint64_t)cpu->memory->readq(ARG5);
    EAX = (U32)pBoxedInfo->pvkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
}
void vk_GetPrivateData(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG4);
    uint64_t tmp_pData = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pData = &tmp_pData;
    pBoxedInfo->pvkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
    cpu->memory->writeq(ARG5, (U64)tmp_pData);
}
void vk_GetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlot privateDataSlot = (VkPrivateDataSlot)cpu->memory->readq(ARG4);
    uint64_t tmp_pData = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pData = &tmp_pData;
    pBoxedInfo->pvkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
    cpu->memory->writeq(ARG5, (U64)tmp_pData);
}
void vk_CmdCopyBuffer2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferInfo2 local_pCopyBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyBufferInfo2* pCopyBufferInfo = &local_pCopyBufferInfo.s;
    pBoxedInfo->pvkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
void vk_CmdCopyBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferInfo2 local_pCopyBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyBufferInfo2* pCopyBufferInfo = &local_pCopyBufferInfo.s;
    pBoxedInfo->pvkCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
}
void vk_CmdCopyImage2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageInfo2 local_pCopyImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageInfo2* pCopyImageInfo = &local_pCopyImageInfo.s;
    pBoxedInfo->pvkCmdCopyImage2(commandBuffer, pCopyImageInfo);
}
void vk_CmdCopyImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageInfo2 local_pCopyImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageInfo2* pCopyImageInfo = &local_pCopyImageInfo.s;
    pBoxedInfo->pvkCmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
}
void vk_CmdBlitImage2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBlitImageInfo2 local_pBlitImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBlitImageInfo2* pBlitImageInfo = &local_pBlitImageInfo.s;
    pBoxedInfo->pvkCmdBlitImage2(commandBuffer, pBlitImageInfo);
}
void vk_CmdBlitImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBlitImageInfo2 local_pBlitImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBlitImageInfo2* pBlitImageInfo = &local_pBlitImageInfo.s;
    pBoxedInfo->pvkCmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
}
void vk_CmdCopyBufferToImage2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferToImageInfo2 local_pCopyBufferToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyBufferToImageInfo2* pCopyBufferToImageInfo = &local_pCopyBufferToImageInfo.s;
    pBoxedInfo->pvkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
void vk_CmdCopyBufferToImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferToImageInfo2 local_pCopyBufferToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyBufferToImageInfo2* pCopyBufferToImageInfo = &local_pCopyBufferToImageInfo.s;
    pBoxedInfo->pvkCmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
}
void vk_CmdCopyImageToBuffer2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToBufferInfo2 local_pCopyImageToBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToBufferInfo2* pCopyImageToBufferInfo = &local_pCopyImageToBufferInfo.s;
    pBoxedInfo->pvkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
void vk_CmdCopyImageToBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToBufferInfo2 local_pCopyImageToBufferInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToBufferInfo2* pCopyImageToBufferInfo = &local_pCopyImageToBufferInfo.s;
    pBoxedInfo->pvkCmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
}
void vk_CmdResolveImage2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkResolveImageInfo2 local_pResolveImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkResolveImageInfo2* pResolveImageInfo = &local_pResolveImageInfo.s;
    pBoxedInfo->pvkCmdResolveImage2(commandBuffer, pResolveImageInfo);
}
void vk_CmdResolveImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkResolveImageInfo2 local_pResolveImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkResolveImageInfo2* pResolveImageInfo = &local_pResolveImageInfo.s;
    pBoxedInfo->pvkCmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
}
void vk_CmdSetFragmentShadingRateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkExtent2D local_pFragmentSize(pBoxedInfo, cpu->memory, ARG2);
    VkExtent2D* pFragmentSize = &local_pFragmentSize.s;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = nullptr;
    if (ARG3) {
        combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
        cpu->memory->memcpy(combinerOps, ARG3, (U32)2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    }
    pBoxedInfo->pvkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceFragmentShadingRatesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pFragmentShadingRateCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pFragmentShadingRateCount = &tmp_pFragmentShadingRateCount;
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates = NULL;
    if (ARG3) {
        pFragmentShadingRates = new VkPhysicalDeviceFragmentShadingRateKHR[*pFragmentShadingRateCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    cpu->memory->writed(ARG2, (U32)tmp_pFragmentShadingRateCount);
    if (ARG3) {
        for (U32 i=0;i<*pFragmentShadingRateCount;i++) {
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(pBoxedInfo, cpu->memory, ARG3 + i * 20, &pFragmentShadingRates[i]);
        }
        delete[] pFragmentShadingRates;
    }
}
void vk_CmdSetFragmentShadingRateEnumNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFragmentShadingRateNV shadingRate = (VkFragmentShadingRateNV)ARG2;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = nullptr;
    if (ARG3) {
        combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
        cpu->memory->memcpy(combinerOps, ARG3, (U32)2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    }
    pBoxedInfo->pvkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
}
void vk_GetAccelerationStructureBuildSizesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureBuildTypeKHR buildType = (VkAccelerationStructureBuildTypeKHR)ARG2;
    MarshalVkAccelerationStructureBuildGeometryInfoKHR local_pBuildInfo(pBoxedInfo, cpu->memory, ARG3);
    VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo = &local_pBuildInfo.s;
    uint32_t* pMaxPrimitiveCounts = nullptr;
    if (ARG4) {
        pMaxPrimitiveCounts = new uint32_t[pBuildInfo->geometryCount];
        cpu->memory->memcpy(pMaxPrimitiveCounts, ARG4, (U32)pBuildInfo->geometryCount * sizeof(uint32_t));
    }
    MarshalVkAccelerationStructureBuildSizesInfoKHR pSizeInfo(pBoxedInfo, cpu->memory, ARG5);
    pBoxedInfo->pvkGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, &pSizeInfo.s);
    delete[] pMaxPrimitiveCounts;
    MarshalVkAccelerationStructureBuildSizesInfoKHR::write(pBoxedInfo, cpu->memory, ARG5, &pSizeInfo.s);
}
void vk_CmdSetVertexInputEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexBindingDescriptionCount = (uint32_t)ARG2;
    VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions = NULL;
    if (ARG3) {
        pVertexBindingDescriptions = new VkVertexInputBindingDescription2EXT[vertexBindingDescriptionCount];
        for (U32 i=0;i<vertexBindingDescriptionCount;i++) {
            MarshalVkVertexInputBindingDescription2EXT::read(pBoxedInfo, cpu->memory, ARG3 + i * 24, &pVertexBindingDescriptions[i]);
        }
    }
    uint32_t vertexAttributeDescriptionCount = (uint32_t)ARG4;
    VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions = NULL;
    if (ARG5) {
        pVertexAttributeDescriptions = new VkVertexInputAttributeDescription2EXT[vertexAttributeDescriptionCount];
        for (U32 i=0;i<vertexAttributeDescriptionCount;i++) {
            MarshalVkVertexInputAttributeDescription2EXT::read(pBoxedInfo, cpu->memory, ARG5 + i * 24, &pVertexAttributeDescriptions[i]);
        }
    }
    pBoxedInfo->pvkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
    if (pVertexBindingDescriptions) {
        delete[] pVertexBindingDescriptions;
    }
    if (pVertexAttributeDescriptions) {
        delete[] pVertexAttributeDescriptions;
    }
}
void vk_CmdSetColorWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkBool32* pColorWriteEnables = nullptr;
    if (ARG3) {
        pColorWriteEnables = new VkBool32[attachmentCount];
        cpu->memory->memcpy(pColorWriteEnables, ARG3, (U32)attachmentCount * sizeof(VkBool32));
    }
    pBoxedInfo->pvkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
    delete[] pColorWriteEnables;
}
void vk_CmdSetEvent2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    MarshalVkDependencyInfo local_pDependencyInfo(pBoxedInfo, cpu->memory, ARG3);
    VkDependencyInfo* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
void vk_CmdSetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    MarshalVkDependencyInfo local_pDependencyInfo(pBoxedInfo, cpu->memory, ARG3);
    VkDependencyInfo* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
}
void vk_CmdResetEvent2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags2 stageMask = (VkPipelineStageFlags2)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdResetEvent2(commandBuffer, event, stageMask);
}
void vk_CmdResetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags2 stageMask = (VkPipelineStageFlags2)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdResetEvent2KHR(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = nullptr;
    if (ARG3) {
        pEvents = new VkEvent[eventCount];
        cpu->memory->memcpy(pEvents, ARG3, (U32)eventCount * sizeof(VkEvent));
    }
    VkDependencyInfo* pDependencyInfos = NULL;
    if (ARG4) {
        pDependencyInfos = new VkDependencyInfo[eventCount];
        for (U32 i=0;i<eventCount;i++) {
            MarshalVkDependencyInfo::read(pBoxedInfo, cpu->memory, ARG4 + i * 36, &pDependencyInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
    delete[] pEvents;
    if (pDependencyInfos) {
        delete[] pDependencyInfos;
    }
}
void vk_CmdWaitEvents2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = nullptr;
    if (ARG3) {
        pEvents = new VkEvent[eventCount];
        cpu->memory->memcpy(pEvents, ARG3, (U32)eventCount * sizeof(VkEvent));
    }
    VkDependencyInfo* pDependencyInfos = NULL;
    if (ARG4) {
        pDependencyInfos = new VkDependencyInfo[eventCount];
        for (U32 i=0;i<eventCount;i++) {
            MarshalVkDependencyInfo::read(pBoxedInfo, cpu->memory, ARG4 + i * 36, &pDependencyInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
    delete[] pEvents;
    if (pDependencyInfos) {
        delete[] pDependencyInfos;
    }
}
void vk_CmdPipelineBarrier2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDependencyInfo local_pDependencyInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDependencyInfo* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
void vk_CmdPipelineBarrier2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDependencyInfo local_pDependencyInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDependencyInfo* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit2(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo2* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo2[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo2::read(pBoxedInfo, cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkQueueSubmit2(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit2KHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo2* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo2[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo2::read(pBoxedInfo, cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkQueueSubmit2KHR(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
void vk_CmdWriteTimestamp2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2 stage = (VkPipelineStageFlags2)cpu->memory->readq(ARG2);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
void vk_CmdWriteTimestamp2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2 stage = (VkPipelineStageFlags2)cpu->memory->readq(ARG2);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
}
void vk_CmdWriteBufferMarker2AMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2 stage = (VkPipelineStageFlags2)cpu->memory->readq(ARG2);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t marker = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
void vk_GetQueueCheckpointData2NV(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCheckpointDataCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCheckpointDataCount = &tmp_pCheckpointDataCount;
    VkCheckpointData2NV* pCheckpointData = NULL;
    if (ARG3) {
        pCheckpointData = new VkCheckpointData2NV[*pCheckpointDataCount];
    }
    pBoxedInfo->pvkGetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
    cpu->memory->writed(ARG2, (U32)tmp_pCheckpointDataCount);
    if (ARG3) {
        for (U32 i=0;i<*pCheckpointDataCount;i++) {
            MarshalVkCheckpointData2NV::write(pBoxedInfo, cpu->memory, ARG3 + i * 20, &pCheckpointData[i]);
        }
        delete[] pCheckpointData;
    }
}
// return type: VkResult(4 bytes)
void vk_CopyMemoryToImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMemoryToImageInfo local_pCopyMemoryToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo = &local_pCopyMemoryToImageInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMemoryToImage(device, pCopyMemoryToImageInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyMemoryToImageEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMemoryToImageInfo local_pCopyMemoryToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo = &local_pCopyMemoryToImageInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMemoryToImageEXT(device, pCopyMemoryToImageInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyImageToMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToMemoryInfo local_pCopyImageToMemoryInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo = &local_pCopyImageToMemoryInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyImageToMemory(device, pCopyImageToMemoryInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyImageToMemoryEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToMemoryInfo local_pCopyImageToMemoryInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo = &local_pCopyImageToMemoryInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyImageToMemoryEXT(device, pCopyImageToMemoryInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyImageToImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToImageInfo local_pCopyImageToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToImageInfo* pCopyImageToImageInfo = &local_pCopyImageToImageInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyImageToImage(device, pCopyImageToImageInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyImageToImageEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToImageInfo local_pCopyImageToImageInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyImageToImageInfo* pCopyImageToImageInfo = &local_pCopyImageToImageInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyImageToImageEXT(device, pCopyImageToImageInfo);
}
// return type: VkResult(4 bytes)
void vk_TransitionImageLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t transitionCount = (uint32_t)ARG2;
    VkHostImageLayoutTransitionInfo* pTransitions = NULL;
    if (ARG3) {
        pTransitions = new VkHostImageLayoutTransitionInfo[transitionCount];
        for (U32 i=0;i<transitionCount;i++) {
            MarshalVkHostImageLayoutTransitionInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 44, &pTransitions[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkTransitionImageLayout(device, transitionCount, pTransitions);
    if (pTransitions) {
        delete[] pTransitions;
    }
}
// return type: VkResult(4 bytes)
void vk_TransitionImageLayoutEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t transitionCount = (uint32_t)ARG2;
    VkHostImageLayoutTransitionInfo* pTransitions = NULL;
    if (ARG3) {
        pTransitions = new VkHostImageLayoutTransitionInfo[transitionCount];
        for (U32 i=0;i<transitionCount;i++) {
            MarshalVkHostImageLayoutTransitionInfo::read(pBoxedInfo, cpu->memory, ARG3 + i * 44, &pTransitions[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkTransitionImageLayoutEXT(device, transitionCount, pTransitions);
    if (pTransitions) {
        delete[] pTransitions;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceVideoCapabilitiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoProfileInfoKHR local_pVideoProfile(pBoxedInfo, cpu->memory, ARG2);
    VkVideoProfileInfoKHR* pVideoProfile = &local_pVideoProfile.s;
    MarshalVkVideoCapabilitiesKHR pCapabilities(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, &pCapabilities.s);
    MarshalVkVideoCapabilitiesKHR::write(pBoxedInfo, cpu->memory, ARG3, &pCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceVideoFormatPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceVideoFormatInfoKHR local_pVideoFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo = &local_pVideoFormatInfo.s;
    uint32_t tmp_pVideoFormatPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pVideoFormatPropertyCount = &tmp_pVideoFormatPropertyCount;
    VkVideoFormatPropertiesKHR* pVideoFormatProperties = NULL;
    if (ARG4) {
        pVideoFormatProperties = new VkVideoFormatPropertiesKHR[*pVideoFormatPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pVideoFormatPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pVideoFormatPropertyCount;i++) {
            MarshalVkVideoFormatPropertiesKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 44, &pVideoFormatProperties[i]);
        }
        delete[] pVideoFormatProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR local_pQualityLevelInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo = &local_pQualityLevelInfo.s;
    MarshalVkVideoEncodeQualityLevelPropertiesKHR pQualityLevelProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, &pQualityLevelProperties.s);
    MarshalVkVideoEncodeQualityLevelPropertiesKHR::write(pBoxedInfo, cpu->memory, ARG3, &pQualityLevelProperties.s);
}
// return type: VkResult(4 bytes)
void vk_CreateVideoSessionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoSessionCreateInfoKHR local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoSessionCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateVideoSessionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkVideoSessionKHR tmp_pVideoSession = (VkVideoSessionKHR) cpu->memory->readq(ARG4);
    VkVideoSessionKHR* pVideoSession = &tmp_pVideoSession;
    EAX = (U32)pBoxedInfo->pvkCreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
    cpu->memory->writeq(ARG4, (U64)tmp_pVideoSession);
}
void vk_DestroyVideoSessionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkVideoSessionKHR videoSession = (VkVideoSessionKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyVideoSessionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyVideoSessionKHR(device, videoSession, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateVideoSessionParametersKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoSessionParametersCreateInfoKHR local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoSessionParametersCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateVideoSessionParametersKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkVideoSessionParametersKHR tmp_pVideoSessionParameters = (VkVideoSessionParametersKHR) cpu->memory->readq(ARG4);
    VkVideoSessionParametersKHR* pVideoSessionParameters = &tmp_pVideoSessionParameters;
    EAX = (U32)pBoxedInfo->pvkCreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
    cpu->memory->writeq(ARG4, (U64)tmp_pVideoSessionParameters);
}
// return type: VkResult(4 bytes)
void vk_UpdateVideoSessionParametersKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkVideoSessionParametersKHR videoSessionParameters = (VkVideoSessionParametersKHR)cpu->memory->readq(ARG2);
    MarshalVkVideoSessionParametersUpdateInfoKHR local_pUpdateInfo(pBoxedInfo, cpu->memory, ARG3);
    VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo = &local_pUpdateInfo.s;
    EAX = (U32)pBoxedInfo->pvkUpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
}
// return type: VkResult(4 bytes)
void vk_GetEncodedVideoSessionParametersKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoEncodeSessionParametersGetInfoKHR local_pVideoSessionParametersInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo = &local_pVideoSessionParametersInfo.s;
    MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR pFeedbackInfo(pBoxedInfo, cpu->memory, ARG3);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG4);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG5) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG5, (U32)*pDataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, &pFeedbackInfo.s, pDataSize, pData);
    MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::write(pBoxedInfo, cpu->memory, ARG3, &pFeedbackInfo.s);
    cpu->memory->writed(ARG4, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG5, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_DestroyVideoSessionParametersKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkVideoSessionParametersKHR videoSessionParameters = (VkVideoSessionParametersKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyVideoSessionParametersKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetVideoSessionMemoryRequirementsKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkVideoSessionKHR videoSession = (VkVideoSessionKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pMemoryRequirementsCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pMemoryRequirementsCount = &tmp_pMemoryRequirementsCount;
    VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements = NULL;
    if (ARG4) {
        pMemoryRequirements = new VkVideoSessionMemoryRequirementsKHR[*pMemoryRequirementsCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pMemoryRequirementsCount);
    if (ARG4) {
        for (U32 i=0;i<*pMemoryRequirementsCount;i++) {
            MarshalVkVideoSessionMemoryRequirementsKHR::write(pBoxedInfo, cpu->memory, ARG4 + i * 32, &pMemoryRequirements[i]);
        }
        delete[] pMemoryRequirements;
    }
}
// return type: VkResult(4 bytes)
void vk_BindVideoSessionMemoryKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkVideoSessionKHR videoSession = (VkVideoSessionKHR)cpu->memory->readq(ARG2);
    uint32_t bindSessionMemoryInfoCount = (uint32_t)ARG3;
    VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos = NULL;
    if (ARG4) {
        pBindSessionMemoryInfos = new VkBindVideoSessionMemoryInfoKHR[bindSessionMemoryInfoCount];
        for (U32 i=0;i<bindSessionMemoryInfoCount;i++) {
            MarshalVkBindVideoSessionMemoryInfoKHR::read(pBoxedInfo, cpu->memory, ARG4 + i * 36, &pBindSessionMemoryInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
    if (pBindSessionMemoryInfos) {
        delete[] pBindSessionMemoryInfos;
    }
}
void vk_CmdDecodeVideoKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoDecodeInfoKHR local_pDecodeInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoDecodeInfoKHR* pDecodeInfo = &local_pDecodeInfo.s;
    pBoxedInfo->pvkCmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
}
void vk_CmdBeginVideoCodingKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoBeginCodingInfoKHR local_pBeginInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoBeginCodingInfoKHR* pBeginInfo = &local_pBeginInfo.s;
    pBoxedInfo->pvkCmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
}
void vk_CmdControlVideoCodingKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoCodingControlInfoKHR local_pCodingControlInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoCodingControlInfoKHR* pCodingControlInfo = &local_pCodingControlInfo.s;
    pBoxedInfo->pvkCmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
}
void vk_CmdEndVideoCodingKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoEndCodingInfoKHR local_pEndCodingInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoEndCodingInfoKHR* pEndCodingInfo = &local_pEndCodingInfo.s;
    pBoxedInfo->pvkCmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
}
void vk_CmdEncodeVideoKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkVideoEncodeInfoKHR local_pEncodeInfo(pBoxedInfo, cpu->memory, ARG2);
    VkVideoEncodeInfoKHR* pEncodeInfo = &local_pEncodeInfo.s;
    pBoxedInfo->pvkCmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
}
void vk_CmdDecompressMemoryNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t decompressRegionCount = (uint32_t)ARG2;
    VkDecompressMemoryRegionNV* pDecompressMemoryRegions = NULL;
    if (ARG3) {
        pDecompressMemoryRegions = new VkDecompressMemoryRegionNV[decompressRegionCount];
        for (U32 i=0;i<decompressRegionCount;i++) {
            MarshalVkDecompressMemoryRegionNV::read(pBoxedInfo, cpu->memory, ARG3 + i * 40, &pDecompressMemoryRegions[i]);
        }
    }
    pBoxedInfo->pvkCmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
    if (pDecompressMemoryRegions) {
        delete[] pDecompressMemoryRegions;
    }
}
void vk_CmdDecompressMemoryIndirectCountNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceAddress indirectCommandsAddress = (VkDeviceAddress)cpu->memory->readq(ARG2);
    VkDeviceAddress indirectCommandsCountAddress = (VkDeviceAddress)cpu->memory->readq(ARG3);
    uint32_t stride = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
// return type: VkResult(4 bytes)
void vk_CreateCuModuleNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCuModuleCreateInfoNVX local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCuModuleCreateInfoNVX* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCuModuleNVX:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCuModuleNVX tmp_pModule = (VkCuModuleNVX) cpu->memory->readq(ARG4);
    VkCuModuleNVX* pModule = &tmp_pModule;
    EAX = (U32)pBoxedInfo->pvkCreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
    cpu->memory->writeq(ARG4, (U64)tmp_pModule);
}
// return type: VkResult(4 bytes)
void vk_CreateCuFunctionNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCuFunctionCreateInfoNVX local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCuFunctionCreateInfoNVX* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCuFunctionNVX:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCuFunctionNVX tmp_pFunction = (VkCuFunctionNVX) cpu->memory->readq(ARG4);
    VkCuFunctionNVX* pFunction = &tmp_pFunction;
    EAX = (U32)pBoxedInfo->pvkCreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
    cpu->memory->writeq(ARG4, (U64)tmp_pFunction);
}
void vk_DestroyCuModuleNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCuModuleNVX module = (VkCuModuleNVX)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCuModuleNVX:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCuModuleNVX(device, module, pAllocator);
}
void vk_DestroyCuFunctionNVX(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCuFunctionNVX function = (VkCuFunctionNVX)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCuFunctionNVX:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCuFunctionNVX(device, function, pAllocator);
}
void vk_CmdCuLaunchKernelNVX(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCuLaunchInfoNVX local_pLaunchInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCuLaunchInfoNVX* pLaunchInfo = &local_pLaunchInfo.s;
    pBoxedInfo->pvkCmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
}
void vk_GetDescriptorSetLayoutSizeEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSetLayout layout = (VkDescriptorSetLayout)cpu->memory->readq(ARG2);
    VkDeviceSize tmp_pLayoutSizeInBytes = (VkDeviceSize) cpu->memory->readq(ARG3);
    VkDeviceSize* pLayoutSizeInBytes = &tmp_pLayoutSizeInBytes;
    pBoxedInfo->pvkGetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
    cpu->memory->writeq(ARG3, (U64)tmp_pLayoutSizeInBytes);
}
void vk_GetDescriptorSetLayoutBindingOffsetEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSetLayout layout = (VkDescriptorSetLayout)cpu->memory->readq(ARG2);
    uint32_t binding = (uint32_t)ARG3;
    VkDeviceSize tmp_pOffset = (VkDeviceSize) cpu->memory->readq(ARG4);
    VkDeviceSize* pOffset = &tmp_pOffset;
    pBoxedInfo->pvkGetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
    cpu->memory->writeq(ARG4, (U64)tmp_pOffset);
}
void vk_GetDescriptorEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorGetInfoEXT local_pDescriptorInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorGetInfoEXT* pDescriptorInfo = &local_pDescriptorInfo.s;
    size_t dataSize = (size_t)ARG3;
    void* pDescriptor = nullptr;
    if (ARG4) {
        pDescriptor = new char[dataSize];
        cpu->memory->memcpy(pDescriptor, ARG4, (U32)dataSize * sizeof(char));
    }
    pBoxedInfo->pvkGetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
    if (pDescriptor) {
        cpu->memory->memcpy(ARG4, pDescriptor, (U32)dataSize * sizeof(char));
    }
    delete[] pDescriptor;
}
void vk_CmdBindDescriptorBuffersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bufferCount = (uint32_t)ARG2;
    VkDescriptorBufferBindingInfoEXT* pBindingInfos = NULL;
    if (ARG3) {
        pBindingInfos = new VkDescriptorBufferBindingInfoEXT[bufferCount];
        for (U32 i=0;i<bufferCount;i++) {
            MarshalVkDescriptorBufferBindingInfoEXT::read(pBoxedInfo, cpu->memory, ARG3 + i * 20, &pBindingInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
    if (pBindingInfos) {
        delete[] pBindingInfos;
    }
}
void vk_CmdSetDescriptorBufferOffsetsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t firstSet = (uint32_t)ARG4;
    uint32_t setCount = (uint32_t)ARG5;
    uint32_t* pBufferIndices = nullptr;
    if (ARG6) {
        pBufferIndices = new uint32_t[setCount];
        cpu->memory->memcpy(pBufferIndices, ARG6, (U32)setCount * sizeof(uint32_t));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG7) {
        pOffsets = new VkDeviceSize[setCount];
        cpu->memory->memcpy(pOffsets, ARG7, (U32)setCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
    delete[] pBufferIndices;
    delete[] pOffsets;
}
void vk_CmdBindDescriptorBufferEmbeddedSamplersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
}
// return type: VkResult(4 bytes)
void vk_GetBufferOpaqueCaptureDescriptorDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferCaptureDescriptorDataInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBufferCaptureDescriptorDataInfoEXT* pInfo = &local_pInfo.s;
    void* pData;
    kpanic("vkGetBufferOpaqueCaptureDescriptorDataEXT not implemented");
    EAX = (U32)pBoxedInfo->pvkGetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
// return type: VkResult(4 bytes)
void vk_GetImageOpaqueCaptureDescriptorDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageCaptureDescriptorDataInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageCaptureDescriptorDataInfoEXT* pInfo = &local_pInfo.s;
    void* pData;
    kpanic("vkGetImageOpaqueCaptureDescriptorDataEXT not implemented");
    EAX = (U32)pBoxedInfo->pvkGetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
// return type: VkResult(4 bytes)
void vk_GetImageViewOpaqueCaptureDescriptorDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewCaptureDescriptorDataInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkImageViewCaptureDescriptorDataInfoEXT* pInfo = &local_pInfo.s;
    void* pData;
    kpanic("vkGetImageViewOpaqueCaptureDescriptorDataEXT not implemented");
    EAX = (U32)pBoxedInfo->pvkGetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
// return type: VkResult(4 bytes)
void vk_GetSamplerOpaqueCaptureDescriptorDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerCaptureDescriptorDataInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSamplerCaptureDescriptorDataInfoEXT* pInfo = &local_pInfo.s;
    void* pData;
    kpanic("vkGetSamplerOpaqueCaptureDescriptorDataEXT not implemented");
    EAX = (U32)pBoxedInfo->pvkGetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
// return type: VkResult(4 bytes)
void vk_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo = &local_pInfo.s;
    void* pData;
    kpanic("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT not implemented");
    EAX = (U32)pBoxedInfo->pvkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
void vk_SetDeviceMemoryPriorityEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    MarshalFloat priorityFloat;
    priorityFloat.i = ARG3;
    float priority = priorityFloat.f;
    pBoxedInfo->pvkSetDeviceMemoryPriorityEXT(device, memory, priority);
}
// return type: VkResult(4 bytes)
void vk_AcquireDrmDisplayEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    int32_t drmFd = (int32_t)ARG2;
    VkDisplayKHR display = (VkDisplayKHR)cpu->memory->readq(ARG3);
    EAX = (U32)pBoxedInfo->pvkAcquireDrmDisplayEXT(physicalDevice, drmFd, display);
}
// return type: VkResult(4 bytes)
void vk_GetDrmDisplayEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    int32_t drmFd = (int32_t)ARG2;
    uint32_t connectorId = (uint32_t)ARG3;
    VkDisplayKHR tmp_display = (VkDisplayKHR) cpu->memory->readq(ARG4);
    VkDisplayKHR* display = &tmp_display;
    EAX = (U32)pBoxedInfo->pvkGetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
    cpu->memory->writeq(ARG4, (U64)tmp_display);
}
// return type: VkResult(4 bytes)
void vk_WaitForPresentKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    uint64_t presentId = (uint64_t)cpu->memory->readq(ARG3);
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG4);
    EAX = (U32)pBoxedInfo->pvkWaitForPresentKHR(device, swapchain, presentId, timeout);
}
// return type: VkResult(4 bytes)
void vk_CreateCudaModuleNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCudaModuleCreateInfoNV local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCudaModuleCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCudaModuleNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCudaModuleNV tmp_pModule = (VkCudaModuleNV) cpu->memory->readq(ARG4);
    VkCudaModuleNV* pModule = &tmp_pModule;
    EAX = (U32)pBoxedInfo->pvkCreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule);
    cpu->memory->writeq(ARG4, (U64)tmp_pModule);
}
// return type: VkResult(4 bytes)
void vk_GetCudaModuleCacheNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCudaModuleNV module = (VkCudaModuleNV)cpu->memory->readq(ARG2);
    size_t tmp_pCacheSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pCacheSize = &tmp_pCacheSize;
    void* pCacheData = nullptr;
    if (ARG4) {
        pCacheData = new char[*pCacheSize];
        cpu->memory->memcpy(pCacheData, ARG4, (U32)*pCacheSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetCudaModuleCacheNV(device, module, pCacheSize, pCacheData);
    cpu->memory->writed(ARG3, (U32)tmp_pCacheSize);
    if (pCacheData) {
        cpu->memory->memcpy(ARG4, pCacheData, (U32)*pCacheSize * sizeof(char));
    }
    delete[] pCacheData;
}
// return type: VkResult(4 bytes)
void vk_CreateCudaFunctionNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCudaFunctionCreateInfoNV local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCudaFunctionCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCudaFunctionNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCudaFunctionNV tmp_pFunction = (VkCudaFunctionNV) cpu->memory->readq(ARG4);
    VkCudaFunctionNV* pFunction = &tmp_pFunction;
    EAX = (U32)pBoxedInfo->pvkCreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction);
    cpu->memory->writeq(ARG4, (U64)tmp_pFunction);
}
void vk_DestroyCudaModuleNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCudaModuleNV module = (VkCudaModuleNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCudaModuleNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCudaModuleNV(device, module, pAllocator);
}
void vk_DestroyCudaFunctionNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCudaFunctionNV function = (VkCudaFunctionNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCudaFunctionNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCudaFunctionNV(device, function, pAllocator);
}
void vk_CmdCudaLaunchKernelNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCudaLaunchInfoNV local_pLaunchInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCudaLaunchInfoNV* pLaunchInfo = &local_pLaunchInfo.s;
    pBoxedInfo->pvkCmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo);
}
void vk_CmdBeginRendering(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingInfo local_pRenderingInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingInfo* pRenderingInfo = &local_pRenderingInfo.s;
    pBoxedInfo->pvkCmdBeginRendering(commandBuffer, pRenderingInfo);
}
void vk_CmdBeginRenderingKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingInfo local_pRenderingInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingInfo* pRenderingInfo = &local_pRenderingInfo.s;
    pBoxedInfo->pvkCmdBeginRenderingKHR(commandBuffer, pRenderingInfo);
}
void vk_CmdEndRendering(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndRendering(commandBuffer);
}
void vk_CmdEndRenderingKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndRenderingKHR(commandBuffer);
}
void vk_GetDescriptorSetLayoutHostMappingInfoVALVE(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetBindingReferenceVALVE local_pBindingReference(pBoxedInfo, cpu->memory, ARG2);
    VkDescriptorSetBindingReferenceVALVE* pBindingReference = &local_pBindingReference.s;
    MarshalVkDescriptorSetLayoutHostMappingInfoVALVE pHostMapping(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, &pHostMapping.s);
    MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::write(pBoxedInfo, cpu->memory, ARG3, &pHostMapping.s);
}
void vk_GetDescriptorSetHostMappingVALVE(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)cpu->memory->readq(ARG2);
    void** ppData;
    kpanic("vkGetDescriptorSetHostMappingVALVE not implemented");
    pBoxedInfo->pvkGetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
}
// return type: VkResult(4 bytes)
void vk_CreateMicromapEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMicromapCreateInfoEXT local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMicromapCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateMicromapEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkMicromapEXT tmp_pMicromap = (VkMicromapEXT) cpu->memory->readq(ARG4);
    VkMicromapEXT* pMicromap = &tmp_pMicromap;
    EAX = (U32)pBoxedInfo->pvkCreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
    cpu->memory->writeq(ARG4, (U64)tmp_pMicromap);
}
void vk_CmdBuildMicromapsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t infoCount = (uint32_t)ARG2;
    VkMicromapBuildInfoEXT* pInfos = NULL;
    if (ARG3) {
        pInfos = new VkMicromapBuildInfoEXT[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            MarshalVkMicromapBuildInfoEXT::read(pBoxedInfo, cpu->memory, ARG3 + i * 72, &pInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
    if (pInfos) {
        delete[] pInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BuildMicromapsEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    uint32_t infoCount = (uint32_t)ARG3;
    VkMicromapBuildInfoEXT* pInfos = NULL;
    if (ARG4) {
        pInfos = new VkMicromapBuildInfoEXT[infoCount];
        for (U32 i=0;i<infoCount;i++) {
            MarshalVkMicromapBuildInfoEXT::read(pBoxedInfo, cpu->memory, ARG4 + i * 72, &pInfos[i]);
        }
    }
    EAX = (U32)pBoxedInfo->pvkBuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
    if (pInfos) {
        delete[] pInfos;
    }
}
void vk_DestroyMicromapEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkMicromapEXT micromap = (VkMicromapEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyMicromapEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyMicromapEXT(device, micromap, pAllocator);
}
void vk_CmdCopyMicromapEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMicromapInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMicromapInfoEXT* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyMicromapEXT(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyMicromapEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyMicromapInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyMicromapInfoEXT* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMicromapEXT(device, deferredOperation, pInfo);
}
void vk_CmdCopyMicromapToMemoryEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMicromapToMemoryInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMicromapToMemoryInfoEXT* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyMicromapToMemoryEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyMicromapToMemoryInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyMicromapToMemoryInfoEXT* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
}
void vk_CmdCopyMemoryToMicromapEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyMemoryToMicromapInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkCopyMemoryToMicromapInfoEXT* pInfo = &local_pInfo.s;
    pBoxedInfo->pvkCmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
}
// return type: VkResult(4 bytes)
void vk_CopyMemoryToMicromapEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR deferredOperation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    MarshalVkCopyMemoryToMicromapInfoEXT local_pInfo(pBoxedInfo, cpu->memory, ARG3);
    VkCopyMemoryToMicromapInfoEXT* pInfo = &local_pInfo.s;
    EAX = (U32)pBoxedInfo->pvkCopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
}
void vk_CmdWriteMicromapsPropertiesEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t micromapCount = (uint32_t)ARG2;
    VkMicromapEXT* pMicromaps = nullptr;
    if (ARG3) {
        pMicromaps = new VkMicromapEXT[micromapCount];
        cpu->memory->memcpy(pMicromaps, ARG3, (U32)micromapCount * sizeof(VkMicromapEXT));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG5);
    uint32_t firstQuery = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
    delete[] pMicromaps;
}
// return type: VkResult(4 bytes)
void vk_WriteMicromapsPropertiesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t micromapCount = (uint32_t)ARG2;
    VkMicromapEXT* pMicromaps = nullptr;
    if (ARG3) {
        pMicromaps = new VkMicromapEXT[micromapCount];
        cpu->memory->memcpy(pMicromaps, ARG3, (U32)micromapCount * sizeof(VkMicromapEXT));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    size_t stride = (size_t)ARG7;
    EAX = (U32)pBoxedInfo->pvkWriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
    delete[] pMicromaps;
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_GetDeviceMicromapCompatibilityEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMicromapVersionInfoEXT local_pVersionInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMicromapVersionInfoEXT* pVersionInfo = &local_pVersionInfo.s;
    VkAccelerationStructureCompatibilityKHR tmp_pCompatibility = (VkAccelerationStructureCompatibilityKHR) cpu->memory->readd(ARG3);
    VkAccelerationStructureCompatibilityKHR* pCompatibility = &tmp_pCompatibility;
    pBoxedInfo->pvkGetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
    cpu->memory->writed(ARG3, (U32)tmp_pCompatibility);
}
void vk_GetMicromapBuildSizesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureBuildTypeKHR buildType = (VkAccelerationStructureBuildTypeKHR)ARG2;
    MarshalVkMicromapBuildInfoEXT local_pBuildInfo(pBoxedInfo, cpu->memory, ARG3);
    VkMicromapBuildInfoEXT* pBuildInfo = &local_pBuildInfo.s;
    MarshalVkMicromapBuildSizesInfoEXT pSizeInfo(pBoxedInfo, cpu->memory, ARG4);
    pBoxedInfo->pvkGetMicromapBuildSizesEXT(device, buildType, pBuildInfo, &pSizeInfo.s);
    MarshalVkMicromapBuildSizesInfoEXT::write(pBoxedInfo, cpu->memory, ARG4, &pSizeInfo.s);
}
void vk_GetShaderModuleIdentifierEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderModule shaderModule = (VkShaderModule)cpu->memory->readq(ARG2);
    MarshalVkShaderModuleIdentifierEXT pIdentifier(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetShaderModuleIdentifierEXT(device, shaderModule, &pIdentifier.s);
    MarshalVkShaderModuleIdentifierEXT::write(pBoxedInfo, cpu->memory, ARG3, &pIdentifier.s);
}
void vk_GetShaderModuleCreateInfoIdentifierEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkShaderModuleCreateInfo local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkShaderModuleCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkShaderModuleIdentifierEXT pIdentifier(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, &pIdentifier.s);
    MarshalVkShaderModuleIdentifierEXT::write(pBoxedInfo, cpu->memory, ARG3, &pIdentifier.s);
}
void vk_GetImageSubresourceLayout2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    MarshalVkImageSubresource2 local_pSubresource(pBoxedInfo, cpu->memory, ARG3);
    VkImageSubresource2* pSubresource = &local_pSubresource.s;
    MarshalVkSubresourceLayout2 pLayout(pBoxedInfo, cpu->memory, ARG4);
    pBoxedInfo->pvkGetImageSubresourceLayout2(device, image, pSubresource, &pLayout.s);
    MarshalVkSubresourceLayout2::write(pBoxedInfo, cpu->memory, ARG4, &pLayout.s);
}
void vk_GetImageSubresourceLayout2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    MarshalVkImageSubresource2 local_pSubresource(pBoxedInfo, cpu->memory, ARG3);
    VkImageSubresource2* pSubresource = &local_pSubresource.s;
    MarshalVkSubresourceLayout2 pLayout(pBoxedInfo, cpu->memory, ARG4);
    pBoxedInfo->pvkGetImageSubresourceLayout2KHR(device, image, pSubresource, &pLayout.s);
    MarshalVkSubresourceLayout2::write(pBoxedInfo, cpu->memory, ARG4, &pLayout.s);
}
void vk_GetImageSubresourceLayout2EXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    MarshalVkImageSubresource2 local_pSubresource(pBoxedInfo, cpu->memory, ARG3);
    VkImageSubresource2* pSubresource = &local_pSubresource.s;
    MarshalVkSubresourceLayout2 pLayout(pBoxedInfo, cpu->memory, ARG4);
    pBoxedInfo->pvkGetImageSubresourceLayout2EXT(device, image, pSubresource, &pLayout.s);
    MarshalVkSubresourceLayout2::write(pBoxedInfo, cpu->memory, ARG4, &pLayout.s);
}
// return type: VkResult(4 bytes)
void vk_GetPipelinePropertiesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineInfoKHR local_pPipelineInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPipelineInfoKHR* pPipelineInfo = &local_pPipelineInfo.s;
    MarshalVkBaseOutStructure pPipelineProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetPipelinePropertiesEXT(device, pPipelineInfo, &pPipelineProperties.s);
    MarshalVkBaseOutStructure::write(pBoxedInfo, cpu->memory, ARG3, &pPipelineProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetFramebufferTilePropertiesQCOM(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFramebuffer framebuffer = (VkFramebuffer)cpu->memory->readq(ARG2);
    uint32_t tmp_pPropertiesCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertiesCount = &tmp_pPropertiesCount;
    VkTilePropertiesQCOM* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkTilePropertiesQCOM[*pPropertiesCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertiesCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertiesCount;i++) {
            MarshalVkTilePropertiesQCOM::write(pBoxedInfo, cpu->memory, ARG4 + i * 36, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_GetDynamicRenderingTilePropertiesQCOM(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingInfo local_pRenderingInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingInfo* pRenderingInfo = &local_pRenderingInfo.s;
    MarshalVkTilePropertiesQCOM pProperties(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, &pProperties.s);
    MarshalVkTilePropertiesQCOM::write(pBoxedInfo, cpu->memory, ARG3, &pProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceOpticalFlowImageFormatsNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkOpticalFlowImageFormatInfoNV local_pOpticalFlowImageFormatInfo(pBoxedInfo, cpu->memory, ARG2);
    VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo = &local_pOpticalFlowImageFormatInfo.s;
    uint32_t tmp_pFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pFormatCount = &tmp_pFormatCount;
    VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties = NULL;
    if (ARG4) {
        pImageFormatProperties = new VkOpticalFlowImageFormatPropertiesNV[*pFormatCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pFormatCount;i++) {
            MarshalVkOpticalFlowImageFormatPropertiesNV::write(pBoxedInfo, cpu->memory, ARG4 + i * 12, &pImageFormatProperties[i]);
        }
        delete[] pImageFormatProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateOpticalFlowSessionNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkOpticalFlowSessionCreateInfoNV local_pCreateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkOpticalFlowSessionCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateOpticalFlowSessionNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkOpticalFlowSessionNV tmp_pSession = (VkOpticalFlowSessionNV) cpu->memory->readq(ARG4);
    VkOpticalFlowSessionNV* pSession = &tmp_pSession;
    EAX = (U32)pBoxedInfo->pvkCreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
    cpu->memory->writeq(ARG4, (U64)tmp_pSession);
}
void vk_DestroyOpticalFlowSessionNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkOpticalFlowSessionNV session = (VkOpticalFlowSessionNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyOpticalFlowSessionNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyOpticalFlowSessionNV(device, session, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_BindOpticalFlowSessionImageNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkOpticalFlowSessionNV session = (VkOpticalFlowSessionNV)cpu->memory->readq(ARG2);
    VkOpticalFlowSessionBindingPointNV bindingPoint = (VkOpticalFlowSessionBindingPointNV)ARG3;
    VkImageView view = (VkImageView)cpu->memory->readq(ARG4);
    VkImageLayout layout = (VkImageLayout)ARG5;
    EAX = (U32)pBoxedInfo->pvkBindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
}
void vk_CmdOpticalFlowExecuteNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkOpticalFlowSessionNV session = (VkOpticalFlowSessionNV)cpu->memory->readq(ARG2);
    MarshalVkOpticalFlowExecuteInfoNV local_pExecuteInfo(pBoxedInfo, cpu->memory, ARG3);
    VkOpticalFlowExecuteInfoNV* pExecuteInfo = &local_pExecuteInfo.s;
    pBoxedInfo->pvkCmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceFaultInfoEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceFaultCountsEXT pFaultCounts(pBoxedInfo, cpu->memory, ARG2);
    MarshalVkDeviceFaultInfoEXT pFaultInfo(pBoxedInfo, cpu->memory, ARG3);
    EAX = (U32)pBoxedInfo->pvkGetDeviceFaultInfoEXT(device, &pFaultCounts.s, &pFaultInfo.s);
    MarshalVkDeviceFaultCountsEXT::write(pBoxedInfo, cpu->memory, ARG2, &pFaultCounts.s);
    MarshalVkDeviceFaultInfoEXT::write(pBoxedInfo, cpu->memory, ARG3, &pFaultInfo.s);
}
void vk_CmdSetDepthBias2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDepthBiasInfoEXT local_pDepthBiasInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDepthBiasInfoEXT* pDepthBiasInfo = &local_pDepthBiasInfo.s;
    pBoxedInfo->pvkCmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo);
}
// return type: VkResult(4 bytes)
void vk_ReleaseSwapchainImagesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkReleaseSwapchainImagesInfoEXT local_pReleaseInfo(pBoxedInfo, cpu->memory, ARG2);
    VkReleaseSwapchainImagesInfoEXT* pReleaseInfo = &local_pReleaseInfo.s;
    EAX = (U32)pBoxedInfo->pvkReleaseSwapchainImagesEXT(device, pReleaseInfo);
}
void vk_GetDeviceImageSubresourceLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageSubresourceInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageSubresourceInfo* pInfo = &local_pInfo.s;
    MarshalVkSubresourceLayout2 pLayout(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceImageSubresourceLayout(device, pInfo, &pLayout.s);
    MarshalVkSubresourceLayout2::write(pBoxedInfo, cpu->memory, ARG3, &pLayout.s);
}
void vk_GetDeviceImageSubresourceLayoutKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceImageSubresourceInfo local_pInfo(pBoxedInfo, cpu->memory, ARG2);
    VkDeviceImageSubresourceInfo* pInfo = &local_pInfo.s;
    MarshalVkSubresourceLayout2 pLayout(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetDeviceImageSubresourceLayoutKHR(device, pInfo, &pLayout.s);
    MarshalVkSubresourceLayout2::write(pBoxedInfo, cpu->memory, ARG3, &pLayout.s);
}
// return type: VkResult(4 bytes)
void vk_MapMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryMapInfo local_pMemoryMapInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMemoryMapInfo* pMemoryMapInfo = &local_pMemoryMapInfo.s;
    void *pData = NULL;
    EAX = (U32)pBoxedInfo->pvkMapMemory2(device, pMemoryMapInfo, &pData);
    if (EAX == 0) {
        cpu->memory->writed(ARG3, mapVkMemory(pMemoryMapInfo->memory, pData, pMemoryMapInfo->size));
    }
}
// return type: VkResult(4 bytes)
void vk_MapMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryMapInfo local_pMemoryMapInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMemoryMapInfo* pMemoryMapInfo = &local_pMemoryMapInfo.s;
    void *pData = NULL;
    EAX = (U32)pBoxedInfo->pvkMapMemory2KHR(device, pMemoryMapInfo, &pData);
    if (EAX == 0) {
        cpu->memory->writed(ARG3, mapVkMemory(pMemoryMapInfo->memory, pData, pMemoryMapInfo->size));
    }
}
// return type: VkResult(4 bytes)
void vk_UnmapMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryUnmapInfo local_pMemoryUnmapInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMemoryUnmapInfo* pMemoryUnmapInfo = &local_pMemoryUnmapInfo.s;
    EAX = (U32)pBoxedInfo->pvkUnmapMemory2(device, pMemoryUnmapInfo);
}
// return type: VkResult(4 bytes)
void vk_UnmapMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryUnmapInfo local_pMemoryUnmapInfo(pBoxedInfo, cpu->memory, ARG2);
    VkMemoryUnmapInfo* pMemoryUnmapInfo = &local_pMemoryUnmapInfo.s;
    EAX = (U32)pBoxedInfo->pvkUnmapMemory2KHR(device, pMemoryUnmapInfo);
}
// return type: VkResult(4 bytes)
void vk_CreateShadersEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t createInfoCount = (uint32_t)ARG2;
    VkShaderCreateInfoEXT* pCreateInfos = NULL;
    if (ARG3) {
        pCreateInfos = new VkShaderCreateInfoEXT[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkShaderCreateInfoEXT::read(pBoxedInfo, cpu->memory, ARG3 + i * 56, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG4) { klog("vkCreateShadersEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkShaderEXT* pShaders = nullptr;
    if (ARG5) {
        pShaders = new VkShaderEXT[createInfoCount];
        cpu->memory->memcpy(pShaders, ARG5, (U32)createInfoCount * sizeof(VkShaderEXT));
    }
    EAX = (U32)pBoxedInfo->pvkCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pShaders) {
        cpu->memory->memcpy(ARG5, pShaders, (U32)createInfoCount * sizeof(VkShaderEXT));
    }
    delete[] pShaders;
}
void vk_DestroyShaderEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderEXT shader = (VkShaderEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyShaderEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyShaderEXT(device, shader, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetShaderBinaryDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderEXT shader = (VkShaderEXT)cpu->memory->readq(ARG2);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)*pDataSize * sizeof(char));
    }
    EAX = (U32)pBoxedInfo->pvkGetShaderBinaryDataEXT(device, shader, pDataSize, pData);
    cpu->memory->writed(ARG3, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_CmdBindShadersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t stageCount = (uint32_t)ARG2;
    static_assert (sizeof(VkShaderStageFlagBits) == 4, "unhandled enum size");
    VkShaderStageFlagBits* pStages = nullptr;
    if (ARG3) {
        pStages = new VkShaderStageFlagBits[stageCount];
        cpu->memory->memcpy(pStages, ARG3, (U32)stageCount * sizeof(VkShaderStageFlagBits));
    }
    VkShaderEXT* pShaders = nullptr;
    if (ARG4) {
        pShaders = new VkShaderEXT[stageCount];
        cpu->memory->memcpy(pShaders, ARG4, (U32)stageCount * sizeof(VkShaderEXT));
    }
    pBoxedInfo->pvkCmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders);
    delete[] pShaders;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCooperativeMatrixPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkCooperativeMatrixPropertiesKHR* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkCooperativeMatrixPropertiesKHR[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkCooperativeMatrixPropertiesKHR::write(pBoxedInfo, cpu->memory, ARG3 + i * 44, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_CmdBindDescriptorSets2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBindDescriptorSetsInfo local_pBindDescriptorSetsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo = &local_pBindDescriptorSetsInfo.s;
    pBoxedInfo->pvkCmdBindDescriptorSets2(commandBuffer, pBindDescriptorSetsInfo);
}
void vk_CmdBindDescriptorSets2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBindDescriptorSetsInfo local_pBindDescriptorSetsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo = &local_pBindDescriptorSetsInfo.s;
    pBoxedInfo->pvkCmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo);
}
void vk_CmdPushConstants2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushConstantsInfo local_pPushConstantsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushConstantsInfo* pPushConstantsInfo = &local_pPushConstantsInfo.s;
    pBoxedInfo->pvkCmdPushConstants2(commandBuffer, pPushConstantsInfo);
}
void vk_CmdPushConstants2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushConstantsInfo local_pPushConstantsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushConstantsInfo* pPushConstantsInfo = &local_pPushConstantsInfo.s;
    pBoxedInfo->pvkCmdPushConstants2KHR(commandBuffer, pPushConstantsInfo);
}
void vk_CmdPushDescriptorSet2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushDescriptorSetInfo local_pPushDescriptorSetInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushDescriptorSetInfo* pPushDescriptorSetInfo = &local_pPushDescriptorSetInfo.s;
    pBoxedInfo->pvkCmdPushDescriptorSet2(commandBuffer, pPushDescriptorSetInfo);
}
void vk_CmdPushDescriptorSet2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushDescriptorSetInfo local_pPushDescriptorSetInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushDescriptorSetInfo* pPushDescriptorSetInfo = &local_pPushDescriptorSetInfo.s;
    pBoxedInfo->pvkCmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo);
}
void vk_CmdPushDescriptorSetWithTemplate2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushDescriptorSetWithTemplateInfo local_pPushDescriptorSetWithTemplateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo = &local_pPushDescriptorSetWithTemplateInfo.s;
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplate2(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
void vk_CmdPushDescriptorSetWithTemplate2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPushDescriptorSetWithTemplateInfo local_pPushDescriptorSetWithTemplateInfo(pBoxedInfo, cpu->memory, ARG2);
    VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo = &local_pPushDescriptorSetWithTemplateInfo.s;
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
void vk_CmdSetDescriptorBufferOffsets2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSetDescriptorBufferOffsetsInfoEXT local_pSetDescriptorBufferOffsetsInfo(pBoxedInfo, cpu->memory, ARG2);
    VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo = &local_pSetDescriptorBufferOffsetsInfo.s;
    pBoxedInfo->pvkCmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo);
}
void vk_CmdBindDescriptorBufferEmbeddedSamplers2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT local_pBindDescriptorBufferEmbeddedSamplersInfo(pBoxedInfo, cpu->memory, ARG2);
    VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo = &local_pBindDescriptorBufferEmbeddedSamplersInfo.s;
    pBoxedInfo->pvkCmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
}
// return type: VkResult(4 bytes)
void vk_SetLatencySleepModeNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    MarshalVkLatencySleepModeInfoNV local_pSleepModeInfo(pBoxedInfo, cpu->memory, ARG3);
    VkLatencySleepModeInfoNV* pSleepModeInfo = &local_pSleepModeInfo.s;
    EAX = (U32)pBoxedInfo->pvkSetLatencySleepModeNV(device, swapchain, pSleepModeInfo);
}
// return type: VkResult(4 bytes)
void vk_LatencySleepNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    MarshalVkLatencySleepInfoNV local_pSleepInfo(pBoxedInfo, cpu->memory, ARG3);
    VkLatencySleepInfoNV* pSleepInfo = &local_pSleepInfo.s;
    EAX = (U32)pBoxedInfo->pvkLatencySleepNV(device, swapchain, pSleepInfo);
}
void vk_SetLatencyMarkerNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    MarshalVkSetLatencyMarkerInfoNV local_pLatencyMarkerInfo(pBoxedInfo, cpu->memory, ARG3);
    VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo = &local_pLatencyMarkerInfo.s;
    pBoxedInfo->pvkSetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo);
}
void vk_GetLatencyTimingsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    MarshalVkGetLatencyMarkerInfoNV pLatencyMarkerInfo(pBoxedInfo, cpu->memory, ARG3);
    pBoxedInfo->pvkGetLatencyTimingsNV(device, swapchain, &pLatencyMarkerInfo.s);
    MarshalVkGetLatencyMarkerInfoNV::write(pBoxedInfo, cpu->memory, ARG3, &pLatencyMarkerInfo.s);
}
void vk_QueueNotifyOutOfBandNV(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkOutOfBandQueueTypeInfoNV local_pQueueTypeInfo(pBoxedInfo, cpu->memory, ARG2);
    VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo = &local_pQueueTypeInfo.s;
    pBoxedInfo->pvkQueueNotifyOutOfBandNV(queue, pQueueTypeInfo);
}
void vk_CmdSetRenderingAttachmentLocations(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingAttachmentLocationInfo local_pLocationInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingAttachmentLocationInfo* pLocationInfo = &local_pLocationInfo.s;
    pBoxedInfo->pvkCmdSetRenderingAttachmentLocations(commandBuffer, pLocationInfo);
}
void vk_CmdSetRenderingAttachmentLocationsKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingAttachmentLocationInfo local_pLocationInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingAttachmentLocationInfo* pLocationInfo = &local_pLocationInfo.s;
    pBoxedInfo->pvkCmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo);
}
void vk_CmdSetRenderingInputAttachmentIndices(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingInputAttachmentIndexInfo local_pInputAttachmentIndexInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo = &local_pInputAttachmentIndexInfo.s;
    pBoxedInfo->pvkCmdSetRenderingInputAttachmentIndices(commandBuffer, pInputAttachmentIndexInfo);
}
void vk_CmdSetRenderingInputAttachmentIndicesKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderingInputAttachmentIndexInfo local_pInputAttachmentIndexInfo(pBoxedInfo, cpu->memory, ARG2);
    VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo = &local_pInputAttachmentIndexInfo.s;
    pBoxedInfo->pvkCmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo);
}
void vk_CmdSetDepthClampRangeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDepthClampModeEXT depthClampMode = (VkDepthClampModeEXT)ARG2;
    MarshalVkDepthClampRangeEXT local_pDepthClampRange(pBoxedInfo, cpu->memory, ARG3);
    VkDepthClampRangeEXT* pDepthClampRange = &local_pDepthClampRange.s;
    pBoxedInfo->pvkCmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkCooperativeMatrixFlexibleDimensionsPropertiesNV[*pPropertyCount];
    }
    EAX = (U32)pBoxedInfo->pvkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::write(pBoxedInfo, cpu->memory, ARG3 + i * 48, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
VkBaseOutStructure* vulkanGetNextPtr(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address) {
    if (address == 0) {
        return NULL;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* p = new VkPipelineRasterizationProvokingVertexStateCreateInfoEXT();
            MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: {
            VkAccelerationStructureBuildSizesInfoKHR* p = new VkAccelerationStructureBuildSizesInfoKHR();
            MarshalVkAccelerationStructureBuildSizesInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT* p = new VkPhysicalDevicePipelinePropertiesFeaturesEXT();
            MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* p = new VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT();
            MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_NV: {
            VkGeometryNV* p = new VkGeometryNV();
            MarshalVkGeometryNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            VkPhysicalDeviceExternalImageFormatInfo* p = new VkPhysicalDeviceExternalImageFormatInfo();
            MarshalVkPhysicalDeviceExternalImageFormatInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES: {
            VkPhysicalDeviceIndexTypeUint8Features* p = new VkPhysicalDeviceIndexTypeUint8Features();
            MarshalVkPhysicalDeviceIndexTypeUint8Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
            VkSwapchainPresentFenceInfoEXT* p = new VkSwapchainPresentFenceInfoEXT();
            MarshalVkSwapchainPresentFenceInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: {
            VkSparseImageMemoryRequirements2* p = new VkSparseImageMemoryRequirements2();
            MarshalVkSparseImageMemoryRequirements2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT: {
            VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* p = new VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT();
            MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: {
            VkSwapchainCreateInfoKHR* p = new VkSwapchainCreateInfoKHR();
            MarshalVkSwapchainCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV: {
            VkPhysicalDeviceMemoryDecompressionPropertiesNV* p = new VkPhysicalDeviceMemoryDecompressionPropertiesNV();
            MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM: {
            VkRenderPassStripeBeginInfoARM* p = new VkRenderPassStripeBeginInfoARM();
            MarshalVkRenderPassStripeBeginInfoARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES: {
            VkPhysicalDeviceShaderSubgroupRotateFeatures* p = new VkPhysicalDeviceShaderSubgroupRotateFeatures();
            MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: {
            VkDisplayProperties2KHR* p = new VkDisplayProperties2KHR();
            MarshalVkDisplayProperties2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV: {
            VkComputePipelineIndirectBufferInfoNV* p = new VkComputePipelineIndirectBufferInfoNV();
            MarshalVkComputePipelineIndirectBufferInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: {
            VkDebugMarkerObjectTagInfoEXT* p = new VkDebugMarkerObjectTagInfoEXT();
            MarshalVkDebugMarkerObjectTagInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV: {
            VkPhysicalDeviceRayTracingValidationFeaturesNV* p = new VkPhysicalDeviceRayTracingValidationFeaturesNV();
            MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM: {
            VkSamplerCubicWeightsCreateInfoQCOM* p = new VkSamplerCubicWeightsCreateInfoQCOM();
            MarshalVkSamplerCubicWeightsCreateInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: {
            VkQueryPoolCreateInfo* p = new VkQueryPoolCreateInfo();
            MarshalVkQueryPoolCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: {
            VkRenderPassBeginInfo* p = new VkRenderPassBeginInfo();
            MarshalVkRenderPassBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: {
            VkPhysicalDeviceMaintenance4Properties* p = new VkPhysicalDeviceMaintenance4Properties();
            MarshalVkPhysicalDeviceMaintenance4Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {
            VkPipelineViewportShadingRateImageStateCreateInfoNV* p = new VkPipelineViewportShadingRateImageStateCreateInfoNV();
            MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR: {
            VkVideoFormatQuantizationMapPropertiesKHR* p = new VkVideoFormatQuantizationMapPropertiesKHR();
            MarshalVkVideoFormatQuantizationMapPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR: {
            VkVideoEncodeAV1QualityLevelPropertiesKHR* p = new VkVideoEncodeAV1QualityLevelPropertiesKHR();
            MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            VkDeviceGroupCommandBufferBeginInfo* p = new VkDeviceGroupCommandBufferBeginInfo();
            MarshalVkDeviceGroupCommandBufferBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2: {
            VkSubresourceLayout2* p = new VkSubresourceLayout2();
            MarshalVkSubresourceLayout2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR* p = new VkPhysicalDeviceFragmentShadingRateFeaturesKHR();
            MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: {
            VkPhysicalDeviceExternalBufferInfo* p = new VkPhysicalDeviceExternalBufferInfo();
            MarshalVkPhysicalDeviceExternalBufferInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {
            VkFormatProperties3* p = new VkFormatProperties3();
            MarshalVkFormatProperties3::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: {
            VkFormatProperties2* p = new VkFormatProperties2();
            MarshalVkFormatProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM: {
            VkPhysicalDeviceRenderPassStripedFeaturesARM* p = new VkPhysicalDeviceRenderPassStripedFeaturesARM();
            MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            VkPhysicalDeviceVariablePointersFeatures* p = new VkPhysicalDeviceVariablePointersFeatures();
            MarshalVkPhysicalDeviceVariablePointersFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: {
            VkGeometryAABBNV* p = new VkGeometryAABBNV();
            MarshalVkGeometryAABBNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT: {
            VkShaderModuleIdentifierEXT* p = new VkShaderModuleIdentifierEXT();
            MarshalVkShaderModuleIdentifierEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* p = new VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures();
            MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {
            VkRenderingFragmentDensityMapAttachmentInfoEXT* p = new VkRenderingFragmentDensityMapAttachmentInfoEXT();
            MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT: {
            VkIndirectCommandsLayoutCreateInfoEXT* p = new VkIndirectCommandsLayoutCreateInfoEXT();
            MarshalVkIndirectCommandsLayoutCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            VkValidationCacheCreateInfoEXT* p = new VkValidationCacheCreateInfoEXT();
            MarshalVkValidationCacheCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR: {
            VkVideoEncodeAV1SessionCreateInfoKHR* p = new VkVideoEncodeAV1SessionCreateInfoKHR();
            MarshalVkVideoEncodeAV1SessionCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES: {
            VkPhysicalDeviceMaintenance5Properties* p = new VkPhysicalDeviceMaintenance5Properties();
            MarshalVkPhysicalDeviceMaintenance5Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: {
            VkVideoDecodeH265PictureInfoKHR* p = new VkVideoDecodeH265PictureInfoKHR();
            MarshalVkVideoDecodeH265PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* p = new VkPhysicalDeviceSubpassShadingPropertiesHUAWEI();
            MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: {
            VkPerformanceStreamMarkerInfoINTEL* p = new VkPerformanceStreamMarkerInfoINTEL();
            MarshalVkPerformanceStreamMarkerInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: {
            VkDebugMarkerObjectNameInfoEXT* p = new VkDebugMarkerObjectNameInfoEXT();
            MarshalVkDebugMarkerObjectNameInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: {
            VkDeviceImageMemoryRequirements* p = new VkDeviceImageMemoryRequirements();
            MarshalVkDeviceImageMemoryRequirements::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
            VkCommandBufferInheritanceRenderingInfo* p = new VkCommandBufferInheritanceRenderingInfo();
            MarshalVkCommandBufferInheritanceRenderingInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            VkDeviceGroupDeviceCreateInfo* p = new VkDeviceGroupDeviceCreateInfo();
            MarshalVkDeviceGroupDeviceCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: {
            VkRenderPassCreationControlEXT* p = new VkRenderPassCreationControlEXT();
            MarshalVkRenderPassCreationControlEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES: {
            VkPhysicalDeviceMaintenance6Properties* p = new VkPhysicalDeviceMaintenance6Properties();
            MarshalVkPhysicalDeviceMaintenance6Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
            VkPipelineRenderingCreateInfo* p = new VkPipelineRenderingCreateInfo();
            MarshalVkPipelineRenderingCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: {
            VkRayTracingPipelineCreateInfoKHR* p = new VkRayTracingPipelineCreateInfoKHR();
            MarshalVkRayTracingPipelineCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            VkBufferOpaqueCaptureAddressCreateInfo* p = new VkBufferOpaqueCaptureAddressCreateInfo();
            MarshalVkBufferOpaqueCaptureAddressCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2: {
            VkImageSubresource2* p = new VkImageSubresource2();
            MarshalVkImageSubresource2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: {
            VkPipelineVertexInputStateCreateInfo* p = new VkPipelineVertexInputStateCreateInfo();
            MarshalVkPipelineVertexInputStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: {
            VkPhysicalDeviceMeshShaderPropertiesNV* p = new VkPhysicalDeviceMeshShaderPropertiesNV();
            MarshalVkPhysicalDeviceMeshShaderPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {
            VkVideoEncodeH264SessionParametersAddInfoKHR* p = new VkVideoEncodeH264SessionParametersAddInfoKHR();
            MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: {
            VkPipelineDepthStencilStateCreateInfo* p = new VkPipelineDepthStencilStateCreateInfo();
            MarshalVkPipelineDepthStencilStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: {
            VkDeviceQueueCreateInfo* p = new VkDeviceQueueCreateInfo();
            MarshalVkDeviceQueueCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: {
            VkAccelerationStructureGeometryInstancesDataKHR* p = new VkAccelerationStructureGeometryInstancesDataKHR();
            MarshalVkAccelerationStructureGeometryInstancesDataKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: {
            VkDisplayPlaneCapabilities2KHR* p = new VkDisplayPlaneCapabilities2KHR();
            MarshalVkDisplayPlaneCapabilities2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: {
            VkAccelerationStructureCreateInfoKHR* p = new VkAccelerationStructureCreateInfoKHR();
            MarshalVkAccelerationStructureCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV* p = new VkPhysicalDeviceLinearColorAttachmentFeaturesNV();
            MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            VkPhysicalDeviceFloatControlsProperties* p = new VkPhysicalDeviceFloatControlsProperties();
            MarshalVkPhysicalDeviceFloatControlsProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV: {
            VkOutOfBandQueueTypeInfoNV* p = new VkOutOfBandQueueTypeInfoNV();
            MarshalVkOutOfBandQueueTypeInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {
            VkValidationFeaturesEXT* p = new VkValidationFeaturesEXT();
            MarshalVkValidationFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR: {
            VkVideoDecodeAV1CapabilitiesKHR* p = new VkVideoDecodeAV1CapabilitiesKHR();
            MarshalVkVideoDecodeAV1CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR: {
            VkVideoEncodeH264ProfileInfoKHR* p = new VkVideoEncodeH264ProfileInfoKHR();
            MarshalVkVideoEncodeH264ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: {
            VkImageMemoryRequirementsInfo2* p = new VkImageMemoryRequirementsInfo2();
            MarshalVkImageMemoryRequirementsInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT* p = new VkOpaqueCaptureDescriptorDataCreateInfoEXT();
            MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO: {
            VkCopyImageToImageInfo* p = new VkCopyImageToImageInfo();
            MarshalVkCopyImageToImageInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES: {
            VkPhysicalDeviceDynamicRenderingLocalReadFeatures* p = new VkPhysicalDeviceDynamicRenderingLocalReadFeatures();
            MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: {
            VkAccelerationStructureMemoryRequirementsInfoNV* p = new VkAccelerationStructureMemoryRequirementsInfoNV();
            MarshalVkAccelerationStructureMemoryRequirementsInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: {
            VkOpticalFlowSessionCreatePrivateDataInfoNV* p = new VkOpticalFlowSessionCreatePrivateDataInfoNV();
            MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: {
            VkRayTracingShaderGroupCreateInfoNV* p = new VkRayTracingShaderGroupCreateInfoNV();
            MarshalVkRayTracingShaderGroupCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: {
            VkDebugReportCallbackCreateInfoEXT* p = new VkDebugReportCallbackCreateInfoEXT();
            MarshalVkDebugReportCallbackCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV: {
            VkPhysicalDeviceCooperativeMatrix2FeaturesNV* p = new VkPhysicalDeviceCooperativeMatrix2FeaturesNV();
            MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {
            VkSwapchainPresentModesCreateInfoEXT* p = new VkSwapchainPresentModesCreateInfoEXT();
            MarshalVkSwapchainPresentModesCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: {
            VkSubpassFragmentDensityMapOffsetEndInfoQCOM* p = new VkSubpassFragmentDensityMapOffsetEndInfoQCOM();
            MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT* p = new VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
            MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: {
            VkPhysicalDeviceToolProperties* p = new VkPhysicalDeviceToolProperties();
            MarshalVkPhysicalDeviceToolProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: {
            VkImageSparseMemoryRequirementsInfo2* p = new VkImageSparseMemoryRequirementsInfo2();
            MarshalVkImageSparseMemoryRequirementsInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
            VkWriteDescriptorSet* p = new VkWriteDescriptorSet();
            MarshalVkWriteDescriptorSet::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            VkPhysicalDeviceTimelineSemaphoreProperties* p = new VkPhysicalDeviceTimelineSemaphoreProperties();
            MarshalVkPhysicalDeviceTimelineSemaphoreProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV: {
            VkPhysicalDevicePerStageDescriptorSetFeaturesNV* p = new VkPhysicalDevicePerStageDescriptorSetFeaturesNV();
            MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: {
            VkRenderPassCreateInfo* p = new VkRenderPassCreateInfo();
            MarshalVkRenderPassCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR: {
            VkVideoEncodeH265QualityLevelPropertiesKHR* p = new VkVideoEncodeH265QualityLevelPropertiesKHR();
            MarshalVkVideoEncodeH265QualityLevelPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* p = new VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM: {
            VkPhysicalDeviceRenderPassStripedPropertiesARM* p = new VkPhysicalDeviceRenderPassStripedPropertiesARM();
            MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: {
            VkAccelerationStructureCreateInfoNV* p = new VkAccelerationStructureCreateInfoNV();
            MarshalVkAccelerationStructureCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
            VkDedicatedAllocationImageCreateInfoNV* p = new VkDedicatedAllocationImageCreateInfoNV();
            MarshalVkDedicatedAllocationImageCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT: {
            VkPhysicalDeviceDepthClampControlFeaturesEXT* p = new VkPhysicalDeviceDepthClampControlFeaturesEXT();
            MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {
            VkSwapchainPresentModeInfoEXT* p = new VkSwapchainPresentModeInfoEXT();
            MarshalVkSwapchainPresentModeInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
            VkMemoryBarrier* p = new VkMemoryBarrier();
            MarshalVkMemoryBarrier::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: {
            VkFrameBoundaryEXT* p = new VkFrameBoundaryEXT();
            MarshalVkFrameBoundaryEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            VkBindImagePlaneMemoryInfo* p = new VkBindImagePlaneMemoryInfo();
            MarshalVkBindImagePlaneMemoryInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* p = new VkPipelineShaderStageRequiredSubgroupSizeCreateInfo();
            MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT* p = new VkPhysicalDeviceColorWriteEnableFeaturesEXT();
            MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: {
            VkCommandBufferSubmitInfo* p = new VkCommandBufferSubmitInfo();
            MarshalVkCommandBufferSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO: {
            VkPushConstantsInfo* p = new VkPushConstantsInfo();
            MarshalVkPushConstantsInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT: {
            VkWriteIndirectExecutionSetPipelineEXT* p = new VkWriteIndirectExecutionSetPipelineEXT();
            MarshalVkWriteIndirectExecutionSetPipelineEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {
            VkPhysicalDeviceRobustness2FeaturesEXT* p = new VkPhysicalDeviceRobustness2FeaturesEXT();
            MarshalVkPhysicalDeviceRobustness2FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT: {
            VkCopyMemoryToMicromapInfoEXT* p = new VkCopyMemoryToMicromapInfoEXT();
            MarshalVkCopyMemoryToMicromapInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: {
            VkVideoDecodeH264ProfileInfoKHR* p = new VkVideoDecodeH264ProfileInfoKHR();
            MarshalVkVideoDecodeH264ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            VkPipelineRasterizationStateStreamCreateInfoEXT* p = new VkPipelineRasterizationStateStreamCreateInfoEXT();
            MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* p = new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
            MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* p = new VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
            MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* p = new VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT();
            MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD: {
            VkPhysicalDeviceAntiLagFeaturesAMD* p = new VkPhysicalDeviceAntiLagFeaturesAMD();
            MarshalVkPhysicalDeviceAntiLagFeaturesAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageModulationStateCreateInfoNV* p = new VkPipelineCoverageModulationStateCreateInfoNV();
            MarshalVkPipelineCoverageModulationStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV: {
            VkSwapchainLatencyCreateInfoNV* p = new VkSwapchainLatencyCreateInfoNV();
            MarshalVkSwapchainLatencyCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: {
            VkDebugMarkerMarkerInfoEXT* p = new VkDebugMarkerMarkerInfoEXT();
            MarshalVkDebugMarkerMarkerInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT: {
            VkBindDescriptorBufferEmbeddedSamplersInfoEXT* p = new VkBindDescriptorBufferEmbeddedSamplersInfoEXT();
            MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO: {
            VkPushDescriptorSetInfo* p = new VkPushDescriptorSetInfo();
            MarshalVkPushDescriptorSetInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            VkPhysicalDeviceProtectedMemoryFeatures* p = new VkPhysicalDeviceProtectedMemoryFeatures();
            MarshalVkPhysicalDeviceProtectedMemoryFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: {
            VkPhysicalDeviceMemoryProperties2* p = new VkPhysicalDeviceMemoryProperties2();
            MarshalVkPhysicalDeviceMemoryProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* p = new VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT();
            MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT: {
            VkPhysicalDeviceDescriptorBufferPropertiesEXT* p = new VkPhysicalDeviceDescriptorBufferPropertiesEXT();
            MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            VkPhysicalDeviceMultiviewFeatures* p = new VkPhysicalDeviceMultiviewFeatures();
            MarshalVkPhysicalDeviceMultiviewFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR: {
            VkVideoEncodeH265DpbSlotInfoKHR* p = new VkVideoEncodeH265DpbSlotInfoKHR();
            MarshalVkVideoEncodeH265DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: {
            VkVideoProfileInfoKHR* p = new VkVideoProfileInfoKHR();
            MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR: {
            VkVideoCapabilitiesKHR* p = new VkVideoCapabilitiesKHR();
            MarshalVkVideoCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {
            VkAttachmentSampleCountInfoAMD* p = new VkAttachmentSampleCountInfoAMD();
            MarshalVkAttachmentSampleCountInfoAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            VkBufferCaptureDescriptorDataInfoEXT* p = new VkBufferCaptureDescriptorDataInfoEXT();
            MarshalVkBufferCaptureDescriptorDataInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {
            VkPhysicalDeviceExclusiveScissorFeaturesNV* p = new VkPhysicalDeviceExclusiveScissorFeaturesNV();
            MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: {
            VkVertexInputAttributeDescription2EXT* p = new VkVertexInputAttributeDescription2EXT();
            MarshalVkVertexInputAttributeDescription2EXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
            VkDescriptorSetAllocateInfo* p = new VkDescriptorSetAllocateInfo();
            MarshalVkDescriptorSetAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: {
            VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* p = new VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT();
            MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR: {
            VkPipelineCreateInfoKHR* p = new VkPipelineCreateInfoKHR();
            MarshalVkPipelineCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* p = new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
            MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM: {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM* p = new VkPhysicalDeviceCubicWeightsFeaturesQCOM();
            MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: {
            VkImageCreateInfo* p = new VkImageCreateInfo();
            MarshalVkImageCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR: {
            VkVideoPictureResourceInfoKHR* p = new VkVideoPictureResourceInfoKHR();
            MarshalVkVideoPictureResourceInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            VkPhysicalDevicePCIBusInfoPropertiesEXT* p = new VkPhysicalDevicePCIBusInfoPropertiesEXT();
            MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: {
            VkPipelineExecutablePropertiesKHR* p = new VkPipelineExecutablePropertiesKHR();
            MarshalVkPipelineExecutablePropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            VkDeviceGroupRenderPassBeginInfo* p = new VkDeviceGroupRenderPassBeginInfo();
            MarshalVkDeviceGroupRenderPassBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: {
            VkAcquireProfilingLockInfoKHR* p = new VkAcquireProfilingLockInfoKHR();
            MarshalVkAcquireProfilingLockInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: {
            VkCopyDescriptorSet* p = new VkCopyDescriptorSet();
            MarshalVkCopyDescriptorSet::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI: {
            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* p = new VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI();
            MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR: {
            VkVideoEncodeRateControlLayerInfoKHR* p = new VkVideoEncodeRateControlLayerInfoKHR();
            MarshalVkVideoEncodeRateControlLayerInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR* p = new VkPhysicalDeviceAccelerationStructurePropertiesKHR();
            MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV* p = new VkPhysicalDeviceCooperativeMatrixPropertiesNV();
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            VkSamplerReductionModeCreateInfo* p = new VkSamplerReductionModeCreateInfo();
            MarshalVkSamplerReductionModeCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM: {
            VkSamplerBlockMatchWindowCreateInfoQCOM* p = new VkSamplerBlockMatchWindowCreateInfoQCOM();
            MarshalVkSamplerBlockMatchWindowCreateInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            VkDescriptorSetVariableDescriptorCountLayoutSupport* p = new VkDescriptorSetVariableDescriptorCountLayoutSupport();
            MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: {
            VkCopyMemoryToAccelerationStructureInfoKHR* p = new VkCopyMemoryToAccelerationStructureInfoKHR();
            MarshalVkCopyMemoryToAccelerationStructureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: {
            VkPerformanceConfigurationAcquireInfoINTEL* p = new VkPerformanceConfigurationAcquireInfoINTEL();
            MarshalVkPerformanceConfigurationAcquireInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
            VkImageMemoryBarrier* p = new VkImageMemoryBarrier();
            MarshalVkImageMemoryBarrier::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            VkExternalMemoryBufferCreateInfo* p = new VkExternalMemoryBufferCreateInfo();
            MarshalVkExternalMemoryBufferCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: {
            VkIndirectCommandsLayoutTokenNV* p = new VkIndirectCommandsLayoutTokenNV();
            MarshalVkIndirectCommandsLayoutTokenNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            VkQueueFamilyCheckpointProperties2NV* p = new VkQueueFamilyCheckpointProperties2NV();
            MarshalVkQueueFamilyCheckpointProperties2NV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV: {
            VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* p = new VkPhysicalDeviceCommandBufferInheritanceFeaturesNV();
            MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: {
            VkBindAccelerationStructureMemoryInfoNV* p = new VkBindAccelerationStructureMemoryInfoNV();
            MarshalVkBindAccelerationStructureMemoryInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR: {
            VkVideoEncodeH264QualityLevelPropertiesKHR* p = new VkVideoEncodeH264QualityLevelPropertiesKHR();
            MarshalVkVideoEncodeH264QualityLevelPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            VkPhysicalDevice4444FormatsFeaturesEXT* p = new VkPhysicalDevice4444FormatsFeaturesEXT();
            MarshalVkPhysicalDevice4444FormatsFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX: {
            VkCuLaunchInfoNVX* p = new VkCuLaunchInfoNVX();
            MarshalVkCuLaunchInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            VkPresentRegionsKHR* p = new VkPresentRegionsKHR();
            MarshalVkPresentRegionsKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT: {
            VkShaderCreateInfoEXT* p = new VkShaderCreateInfoEXT();
            MarshalVkShaderCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* p = new VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT();
            MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: {
            VkImageCompressionControlEXT* p = new VkImageCompressionControlEXT();
            MarshalVkImageCompressionControlEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV: {
            VkOpticalFlowSessionCreateInfoNV* p = new VkOpticalFlowSessionCreateInfoNV();
            MarshalVkOpticalFlowSessionCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            VkExportSemaphoreCreateInfo* p = new VkExportSemaphoreCreateInfo();
            MarshalVkExportSemaphoreCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR: {
            VkVideoEncodeH265SessionParametersGetInfoKHR* p = new VkVideoEncodeH265SessionParametersGetInfoKHR();
            MarshalVkVideoEncodeH265SessionParametersGetInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR: {
            VkVideoEncodeAV1DpbSlotInfoKHR* p = new VkVideoEncodeAV1DpbSlotInfoKHR();
            MarshalVkVideoEncodeAV1DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR: {
            VkVideoEncodeQuantizationMapInfoKHR* p = new VkVideoEncodeQuantizationMapInfoKHR();
            MarshalVkVideoEncodeQuantizationMapInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures* p = new VkPhysicalDeviceTextureCompressionASTCHDRFeatures();
            MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: {
            VkPipelineRasterizationStateCreateInfo* p = new VkPipelineRasterizationStateCreateInfo();
            MarshalVkPipelineRasterizationStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: {
            VkImageMemoryBarrier2* p = new VkImageMemoryBarrier2();
            MarshalVkImageMemoryBarrier2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* p = new VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR();
            MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR: {
            VkPhysicalDeviceCooperativeMatrixPropertiesKHR* p = new VkPhysicalDeviceCooperativeMatrixPropertiesKHR();
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {
            VkSwapchainCounterCreateInfoEXT* p = new VkSwapchainCounterCreateInfoEXT();
            MarshalVkSwapchainCounterCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM* p = new VkPhysicalDeviceTilePropertiesFeaturesQCOM();
            MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT: {
            VkPhysicalDeviceShaderTileImagePropertiesEXT* p = new VkPhysicalDeviceShaderTileImagePropertiesEXT();
            MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM: {
            VkImageViewSampleWeightCreateInfoQCOM* p = new VkImageViewSampleWeightCreateInfoQCOM();
            MarshalVkImageViewSampleWeightCreateInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: {
            VkMultisamplePropertiesEXT* p = new VkMultisamplePropertiesEXT();
            MarshalVkMultisamplePropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR: {
            VkVideoEncodeAV1RateControlInfoKHR* p = new VkVideoEncodeAV1RateControlInfoKHR();
            MarshalVkVideoEncodeAV1RateControlInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM: {
            VkPhysicalDeviceImageProcessing2PropertiesQCOM* p = new VkPhysicalDeviceImageProcessing2PropertiesQCOM();
            MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* p = new VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT();
            MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: {
            VkBufferImageCopy2* p = new VkBufferImageCopy2();
            MarshalVkBufferImageCopy2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
            VkMemoryPriorityAllocateInfoEXT* p = new VkMemoryPriorityAllocateInfoEXT();
            MarshalVkMemoryPriorityAllocateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: {
            VkSubpassResolvePerformanceQueryEXT* p = new VkSubpassResolvePerformanceQueryEXT();
            MarshalVkSubpassResolvePerformanceQueryEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: {
            VkCommandBufferBeginInfo* p = new VkCommandBufferBeginInfo();
            MarshalVkCommandBufferBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            VkPhysicalDeviceShaderDrawParametersFeatures* p = new VkPhysicalDeviceShaderDrawParametersFeatures();
            MarshalVkPhysicalDeviceShaderDrawParametersFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            VkPhysicalDeviceMultiviewProperties* p = new VkPhysicalDeviceMultiviewProperties();
            MarshalVkPhysicalDeviceMultiviewProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT: {
            VkPhysicalDeviceLayeredDriverPropertiesMSFT* p = new VkPhysicalDeviceLayeredDriverPropertiesMSFT();
            MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: {
            VkPhysicalDeviceDepthClipControlFeaturesEXT* p = new VkPhysicalDeviceDepthClipControlFeaturesEXT();
            MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* p = new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
            MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV* p = new VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
            MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* p = new VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT();
            MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            VkPhysicalDeviceSamplerFilterMinmaxProperties* p = new VkPhysicalDeviceSamplerFilterMinmaxProperties();
            MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: {
            VkPhysicalDevicePresentBarrierFeaturesNV* p = new VkPhysicalDevicePresentBarrierFeaturesNV();
            MarshalVkPhysicalDevicePresentBarrierFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR: {
            VkVideoEncodeH264CapabilitiesKHR* p = new VkVideoEncodeH264CapabilitiesKHR();
            MarshalVkVideoEncodeH264CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: {
            VkSwapchainPresentBarrierCreateInfoNV* p = new VkSwapchainPresentBarrierCreateInfoNV();
            MarshalVkSwapchainPresentBarrierCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: {
            VkImageFormatProperties2* p = new VkImageFormatProperties2();
            MarshalVkImageFormatProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT* p = new VkPhysicalDeviceDescriptorBufferFeaturesEXT();
            MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: {
            VkPhysicalDeviceOpticalFlowFeaturesNV* p = new VkPhysicalDeviceOpticalFlowFeaturesNV();
            MarshalVkPhysicalDeviceOpticalFlowFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT* p = new VkPhysicalDeviceCustomBorderColorFeaturesEXT();
            MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR: {
            VkVideoDecodeAV1DpbSlotInfoKHR* p = new VkVideoDecodeAV1DpbSlotInfoKHR();
            MarshalVkVideoDecodeAV1DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* p = new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            VkImageViewUsageCreateInfo* p = new VkImageViewUsageCreateInfo();
            MarshalVkImageViewUsageCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* p = new VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT();
            MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* p = new VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM();
            MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            VkDescriptorSetVariableDescriptorCountAllocateInfo* p = new VkDescriptorSetVariableDescriptorCountAllocateInfo();
            MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {
            VkAccelerationStructureMotionInfoNV* p = new VkAccelerationStructureMotionInfoNV();
            MarshalVkAccelerationStructureMotionInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR: {
            VkPipelineBinaryCreateInfoKHR* p = new VkPipelineBinaryCreateInfoKHR();
            MarshalVkPipelineBinaryCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: {
            VkPhysicalDeviceSampleLocationsPropertiesEXT* p = new VkPhysicalDeviceSampleLocationsPropertiesEXT();
            MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: {
            VkPhysicalDeviceMeshShaderFeaturesEXT* p = new VkPhysicalDeviceMeshShaderFeaturesEXT();
            MarshalVkPhysicalDeviceMeshShaderFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COPY_2: {
            VkBufferCopy2* p = new VkBufferCopy2();
            MarshalVkBufferCopy2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV: {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* p = new VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV();
            MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT: {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT* p = new VkPhysicalDeviceNestedCommandBufferFeaturesEXT();
            MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: {
            VkDescriptorPoolCreateInfo* p = new VkDescriptorPoolCreateInfo();
            MarshalVkDescriptorPoolCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            VkImageStencilUsageCreateInfo* p = new VkImageStencilUsageCreateInfo();
            MarshalVkImageStencilUsageCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {
            VkCommandBufferInheritanceViewportScissorInfoNV* p = new VkCommandBufferInheritanceViewportScissorInfoNV();
            MarshalVkCommandBufferInheritanceViewportScissorInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: {
            VkBlitImageCubicWeightsInfoQCOM* p = new VkBlitImageCubicWeightsInfoQCOM();
            MarshalVkBlitImageCubicWeightsInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: {
            VkDebugUtilsObjectTagInfoEXT* p = new VkDebugUtilsObjectTagInfoEXT();
            MarshalVkDebugUtilsObjectTagInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* p = new VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT();
            MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: {
            VkPipelineExecutableStatisticKHR* p = new VkPipelineExecutableStatisticKHR();
            MarshalVkPipelineExecutableStatisticKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
            VkPhysicalDevicePresentWaitFeaturesKHR* p = new VkPhysicalDevicePresentWaitFeaturesKHR();
            MarshalVkPhysicalDevicePresentWaitFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* p = new VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR();
            MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: {
            VkSurfaceCapabilities2EXT* p = new VkSurfaceCapabilities2EXT();
            MarshalVkSurfaceCapabilities2EXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: {
            VkPresentIdKHR* p = new VkPresentIdKHR();
            MarshalVkPresentIdKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR: {
            VkVideoInlineQueryInfoKHR* p = new VkVideoInlineQueryInfoKHR();
            MarshalVkVideoInlineQueryInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: {
            VkMemoryHostPointerPropertiesEXT* p = new VkMemoryHostPointerPropertiesEXT();
            MarshalVkMemoryHostPointerPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
            VkMemoryBarrier2* p = new VkMemoryBarrier2();
            MarshalVkMemoryBarrier2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
            VkPhysicalDeviceShaderIntegerDotProductFeatures* p = new VkPhysicalDeviceShaderIntegerDotProductFeatures();
            MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV: {
            VkCudaModuleCreateInfoNV* p = new VkCudaModuleCreateInfoNV();
            MarshalVkCudaModuleCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
            VkPhysicalDevicePresentIdFeaturesKHR* p = new VkPhysicalDevicePresentIdFeaturesKHR();
            MarshalVkPhysicalDevicePresentIdFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: {
            VkVideoEncodeQualityLevelInfoKHR* p = new VkVideoEncodeQualityLevelInfoKHR();
            MarshalVkVideoEncodeQualityLevelInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA: {
            VkPhysicalDeviceImageAlignmentControlPropertiesMESA* p = new VkPhysicalDeviceImageAlignmentControlPropertiesMESA();
            MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* p = new VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
            MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR: {
            VkVideoReferenceSlotInfoKHR* p = new VkVideoReferenceSlotInfoKHR();
            MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR: {
            VkVideoEncodeH265NaluSliceSegmentInfoKHR* p = new VkVideoEncodeH265NaluSliceSegmentInfoKHR();
            MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM: {
            VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* p = new VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM();
            MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {
            VkPipelineViewportExclusiveScissorStateCreateInfoNV* p = new VkPipelineViewportExclusiveScissorStateCreateInfoNV();
            MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* p = new VkPhysicalDeviceBorderColorSwizzleFeaturesEXT();
            MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR: {
            VkVideoDecodeH264CapabilitiesKHR* p = new VkVideoDecodeH264CapabilitiesKHR();
            MarshalVkVideoDecodeH264CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {
            VkSubpassShadingPipelineCreateInfoHUAWEI* p = new VkSubpassShadingPipelineCreateInfoHUAWEI();
            MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM* p = new VkCommandBufferInheritanceRenderPassTransformInfoQCOM();
            MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: {
            VkCommandPoolCreateInfo* p = new VkCommandPoolCreateInfo();
            MarshalVkCommandPoolCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR: {
            VkPipelineBinaryInfoKHR* p = new VkPipelineBinaryInfoKHR();
            MarshalVkPipelineBinaryInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: {
            VkPhysicalDeviceFragmentShadingRateKHR* p = new VkPhysicalDeviceFragmentShadingRateKHR();
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
            VkGraphicsPipelineCreateInfo* p = new VkGraphicsPipelineCreateInfo();
            MarshalVkGraphicsPipelineCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            VkMemoryDedicatedAllocateInfo* p = new VkMemoryDedicatedAllocateInfo();
            MarshalVkMemoryDedicatedAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            VkAttachmentReferenceStencilLayout* p = new VkAttachmentReferenceStencilLayout();
            MarshalVkAttachmentReferenceStencilLayout::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR: {
            VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* p = new VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR();
            MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {
            VkRenderPassSampleLocationsBeginInfoEXT* p = new VkRenderPassSampleLocationsBeginInfoEXT();
            MarshalVkRenderPassSampleLocationsBeginInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            VkExternalMemoryImageCreateInfo* p = new VkExternalMemoryImageCreateInfo();
            MarshalVkExternalMemoryImageCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
            VkPipelineSampleLocationsStateCreateInfoEXT* p = new VkPipelineSampleLocationsStateCreateInfoEXT();
            MarshalVkPipelineSampleLocationsStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* p = new VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT();
            MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {
            VkCommandBufferInheritanceConditionalRenderingInfoEXT* p = new VkCommandBufferInheritanceConditionalRenderingInfoEXT();
            MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: {
            VkVideoEncodeRateControlInfoKHR* p = new VkVideoEncodeRateControlInfoKHR();
            MarshalVkVideoEncodeRateControlInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: {
            VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* p = new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
            MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {
            VkExportMemoryAllocateInfoNV* p = new VkExportMemoryAllocateInfoNV();
            MarshalVkExportMemoryAllocateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationConservativeStateCreateInfoEXT* p = new VkPipelineRasterizationConservativeStateCreateInfoEXT();
            MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT: {
            VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* p = new VkPhysicalDeviceMapMemoryPlacedFeaturesEXT();
            MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {
            VkPhysicalDeviceShadingRateImageFeaturesNV* p = new VkPhysicalDeviceShadingRateImageFeaturesNV();
            MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV* p = new VkPhysicalDeviceDiagnosticsConfigFeaturesNV();
            MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: {
            VkQueueFamilyProperties2* p = new VkQueueFamilyProperties2();
            MarshalVkQueueFamilyProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            VkPhysicalDeviceImagelessFramebufferFeatures* p = new VkPhysicalDeviceImagelessFramebufferFeatures();
            MarshalVkPhysicalDeviceImagelessFramebufferFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR: {
            VkVideoDecodeInfoKHR* p = new VkVideoDecodeInfoKHR();
            MarshalVkVideoDecodeInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: {
            VkVertexInputBindingDescription2EXT* p = new VkVertexInputBindingDescription2EXT();
            MarshalVkVertexInputBindingDescription2EXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: {
            VkCopyAccelerationStructureInfoKHR* p = new VkCopyAccelerationStructureInfoKHR();
            MarshalVkCopyAccelerationStructureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
            VkDebugUtilsObjectNameInfoEXT* p = new VkDebugUtilsObjectNameInfoEXT();
            MarshalVkDebugUtilsObjectNameInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* p = new VkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* p = new VkPhysicalDeviceRayTracingMotionBlurFeaturesNV();
            MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* p = new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
            MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            VkPhysicalDeviceScalarBlockLayoutFeatures* p = new VkPhysicalDeviceScalarBlockLayoutFeatures();
            MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO: {
            VkRenderingInputAttachmentIndexInfo* p = new VkRenderingInputAttachmentIndexInfo();
            MarshalVkRenderingInputAttachmentIndexInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: {
            VkSurfacePresentModeEXT* p = new VkSurfacePresentModeEXT();
            MarshalVkSurfacePresentModeEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            VkMemoryOpaqueCaptureAddressAllocateInfo* p = new VkMemoryOpaqueCaptureAddressAllocateInfo();
            MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {
            VkImageViewASTCDecodeModeEXT* p = new VkImageViewASTCDecodeModeEXT();
            MarshalVkImageViewASTCDecodeModeEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV* p = new VkPhysicalDeviceCooperativeMatrixFeaturesNV();
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO: {
            VkDeviceQueueGlobalPriorityCreateInfo* p = new VkDeviceQueueGlobalPriorityCreateInfo();
            MarshalVkDeviceQueueGlobalPriorityCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT: {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* p = new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_BLIT_2: {
            VkImageBlit2* p = new VkImageBlit2();
            MarshalVkImageBlit2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV* p = new VkPhysicalDeviceMemoryDecompressionFeaturesNV();
            MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: {
            VkPipelineDynamicStateCreateInfo* p = new VkPipelineDynamicStateCreateInfo();
            MarshalVkPipelineDynamicStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            VkProtectedSubmitInfo* p = new VkProtectedSubmitInfo();
            MarshalVkProtectedSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR: {
            VkPipelineBinaryKeyKHR* p = new VkPipelineBinaryKeyKHR();
            MarshalVkPipelineBinaryKeyKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS: {
            VkBindMemoryStatus* p = new VkBindMemoryStatus();
            MarshalVkBindMemoryStatus::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: {
            VkGraphicsShaderGroupCreateInfoNV* p = new VkGraphicsShaderGroupCreateInfoNV();
            MarshalVkGraphicsShaderGroupCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR: {
            VkVideoEncodeAV1ProfileInfoKHR* p = new VkVideoEncodeAV1ProfileInfoKHR();
            MarshalVkVideoEncodeAV1ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR: {
            VkVideoCodingControlInfoKHR* p = new VkVideoCodingControlInfoKHR();
            MarshalVkVideoCodingControlInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR: {
            VkVideoEncodeAV1CapabilitiesKHR* p = new VkVideoEncodeAV1CapabilitiesKHR();
            MarshalVkVideoEncodeAV1CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoDecodeH264SessionParametersCreateInfoKHR* p = new VkVideoDecodeH264SessionParametersCreateInfoKHR();
            MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageToColorStateCreateInfoNV* p = new VkPipelineCoverageToColorStateCreateInfoNV();
            MarshalVkPipelineCoverageToColorStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR: {
            VkPhysicalDeviceVideoFormatInfoKHR* p = new VkPhysicalDeviceVideoFormatInfoKHR();
            MarshalVkPhysicalDeviceVideoFormatInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            VkRenderPassMultiviewCreateInfo* p = new VkRenderPassMultiviewCreateInfo();
            MarshalVkRenderPassMultiviewCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: {
            VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* p = new VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM();
            MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: {
            VkPipelineViewportDepthClipControlCreateInfoEXT* p = new VkPipelineViewportDepthClipControlCreateInfoEXT();
            MarshalVkPipelineViewportDepthClipControlCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            VkDescriptorSetLayoutBindingFlagsCreateInfo* p = new VkDescriptorSetLayoutBindingFlagsCreateInfo();
            MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* p = new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
            MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            VkSubpassDescriptionDepthStencilResolve* p = new VkSubpassDescriptionDepthStencilResolve();
            MarshalVkSubpassDescriptionDepthStencilResolve::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: {
            VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* p = new VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM();
            MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR: {
            VkPhysicalDevicePipelineBinaryFeaturesKHR* p = new VkPhysicalDevicePipelineBinaryFeaturesKHR();
            MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX: {
            VkCuModuleTexturingModeCreateInfoNVX* p = new VkCuModuleTexturingModeCreateInfoNVX();
            MarshalVkCuModuleTexturingModeCreateInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM: {
            VkPhysicalDeviceSchedulingControlsFeaturesARM* p = new VkPhysicalDeviceSchedulingControlsFeaturesARM();
            MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {
            VkDevicePrivateDataCreateInfo* p = new VkDevicePrivateDataCreateInfo();
            MarshalVkDevicePrivateDataCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES: {
            VkPhysicalDeviceMaintenance6Features* p = new VkPhysicalDeviceMaintenance6Features();
            MarshalVkPhysicalDeviceMaintenance6Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {
            VkPhysicalDeviceCornerSampledImageFeaturesNV* p = new VkPhysicalDeviceCornerSampledImageFeaturesNV();
            MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            VkPhysicalDeviceDepthStencilResolveProperties* p = new VkPhysicalDeviceDepthStencilResolveProperties();
            MarshalVkPhysicalDeviceDepthStencilResolveProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: {
            VkBufferCreateInfo* p = new VkBufferCreateInfo();
            MarshalVkBufferCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: {
            VkExternalFenceProperties* p = new VkExternalFenceProperties();
            MarshalVkExternalFenceProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV* p = new VkPhysicalDeviceInheritedViewportScissorFeaturesNV();
            MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            VkImageCaptureDescriptorDataInfoEXT* p = new VkImageCaptureDescriptorDataInfoEXT();
            MarshalVkImageCaptureDescriptorDataInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR: {
            VkVideoFormatPropertiesKHR* p = new VkVideoFormatPropertiesKHR();
            MarshalVkVideoFormatPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI: {
            VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* p = new VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI();
            MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT: {
            VkMicromapVersionInfoEXT* p = new VkMicromapVersionInfoEXT();
            MarshalVkMicromapVersionInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE: {
            VkDescriptorSetLayoutHostMappingInfoVALVE* p = new VkDescriptorSetLayoutHostMappingInfoVALVE();
            MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: {
            VkPhysicalDeviceShadingRateImagePropertiesNV* p = new VkPhysicalDeviceShadingRateImagePropertiesNV();
            MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT: {
            VkPhysicalDeviceNestedCommandBufferPropertiesEXT* p = new VkPhysicalDeviceNestedCommandBufferPropertiesEXT();
            MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* p = new VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM();
            MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV: {
            VkPhysicalDeviceCudaKernelLaunchFeaturesNV* p = new VkPhysicalDeviceCudaKernelLaunchFeaturesNV();
            MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR: {
            VkVideoSessionParametersUpdateInfoKHR* p = new VkVideoSessionParametersUpdateInfoKHR();
            MarshalVkVideoSessionParametersUpdateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO: {
            VkRenderingAttachmentLocationInfo* p = new VkRenderingAttachmentLocationInfo();
            MarshalVkRenderingAttachmentLocationInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV: {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* p = new VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: {
            VkImageCompressionPropertiesEXT* p = new VkImageCompressionPropertiesEXT();
            MarshalVkImageCompressionPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR: {
            VkVideoEncodeH265SessionCreateInfoKHR* p = new VkVideoEncodeH265SessionCreateInfoKHR();
            MarshalVkVideoEncodeH265SessionCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES: {
            VkPhysicalDevicePipelineRobustnessProperties* p = new VkPhysicalDevicePipelineRobustnessProperties();
            MarshalVkPhysicalDevicePipelineRobustnessProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO: {
            VkMemoryMapInfo* p = new VkMemoryMapInfo();
            MarshalVkMemoryMapInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT: {
            VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* p = new VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT();
            MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoEncodeAV1SessionParametersCreateInfoKHR* p = new VkVideoEncodeAV1SessionParametersCreateInfoKHR();
            MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES: {
            VkPhysicalDevicePushDescriptorProperties* p = new VkPhysicalDevicePushDescriptorProperties();
            MarshalVkPhysicalDevicePushDescriptorProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: {
            VkSemaphoreSubmitInfo* p = new VkSemaphoreSubmitInfo();
            MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* p = new VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR();
            MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: {
            VkAccelerationStructureVersionInfoKHR* p = new VkAccelerationStructureVersionInfoKHR();
            MarshalVkAccelerationStructureVersionInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: {
            VkDisplayPlaneInfo2KHR* p = new VkDisplayPlaneInfo2KHR();
            MarshalVkDisplayPlaneInfo2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: {
            VkRenderPassSubpassFeedbackCreateInfoEXT* p = new VkRenderPassSubpassFeedbackCreateInfoEXT();
            MarshalVkRenderPassSubpassFeedbackCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {
            VkVideoDecodeH265SessionParametersAddInfoKHR* p = new VkVideoDecodeH265SessionParametersAddInfoKHR();
            MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
            VkDebugUtilsMessengerCallbackDataEXT* p = new VkDebugUtilsMessengerCallbackDataEXT();
            MarshalVkDebugUtilsMessengerCallbackDataEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            VkMemoryDedicatedRequirements* p = new VkMemoryDedicatedRequirements();
            MarshalVkMemoryDedicatedRequirements::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES: {
            VkPhysicalDeviceVulkan14Features* p = new VkPhysicalDeviceVulkan14Features();
            MarshalVkPhysicalDeviceVulkan14Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            VkPhysicalDeviceHostQueryResetFeatures* p = new VkPhysicalDeviceHostQueryResetFeatures();
            MarshalVkPhysicalDeviceHostQueryResetFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            VkSamplerCaptureDescriptorDataInfoEXT* p = new VkSamplerCaptureDescriptorDataInfoEXT();
            MarshalVkSamplerCaptureDescriptorDataInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {
            VkExternalMemoryImageCreateInfoNV* p = new VkExternalMemoryImageCreateInfoNV();
            MarshalVkExternalMemoryImageCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: {
            VkPhysicalDeviceShaderTileImageFeaturesEXT* p = new VkPhysicalDeviceShaderTileImageFeaturesEXT();
            MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
            VkPhysicalDeviceImageRobustnessFeatures* p = new VkPhysicalDeviceImageRobustnessFeatures();
            MarshalVkPhysicalDeviceImageRobustnessFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: {
            VkDisplayPlaneProperties2KHR* p = new VkDisplayPlaneProperties2KHR();
            MarshalVkDisplayPlaneProperties2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: {
            VkBindBufferMemoryInfo* p = new VkBindBufferMemoryInfo();
            MarshalVkBindBufferMemoryInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: {
            VkImageViewMinLodCreateInfoEXT* p = new VkImageViewMinLodCreateInfoEXT();
            MarshalVkImageViewMinLodCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: {
            VkDeviceMemoryOpaqueCaptureAddressInfo* p = new VkDeviceMemoryOpaqueCaptureAddressInfo();
            MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_APPLICATION_INFO: {
            VkApplicationInfo* p = new VkApplicationInfo();
            MarshalVkApplicationInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: {
            VkPhysicalDeviceRobustness2PropertiesEXT* p = new VkPhysicalDeviceRobustness2PropertiesEXT();
            MarshalVkPhysicalDeviceRobustness2PropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* p = new VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT();
            MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* p = new VkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {
            VkRenderPassTransformBeginInfoQCOM* p = new VkRenderPassTransformBeginInfoQCOM();
            MarshalVkRenderPassTransformBeginInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: {
            VkPipelineMultisampleStateCreateInfo* p = new VkPipelineMultisampleStateCreateInfo();
            MarshalVkPipelineMultisampleStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
            VkPipelineCreationFeedbackCreateInfo* p = new VkPipelineCreationFeedbackCreateInfo();
            MarshalVkPipelineCreationFeedbackCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM: {
            VkDeviceQueueShaderCoreControlCreateInfoARM* p = new VkDeviceQueueShaderCoreControlCreateInfoARM();
            MarshalVkDeviceQueueShaderCoreControlCreateInfoARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {
            VkQueryPoolPerformanceCreateInfoKHR* p = new VkQueryPoolPerformanceCreateInfoKHR();
            MarshalVkQueryPoolPerformanceCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* p = new VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT();
            MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            VkPhysicalDeviceDriverProperties* p = new VkPhysicalDeviceDriverProperties();
            MarshalVkPhysicalDeviceDriverProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
            VkPipelineColorWriteCreateInfoEXT* p = new VkPipelineColorWriteCreateInfoEXT();
            MarshalVkPipelineColorWriteCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: {
            VkRenderPassCreateInfo2* p = new VkRenderPassCreateInfo2();
            MarshalVkRenderPassCreateInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: {
            VkExternalBufferProperties* p = new VkExternalBufferProperties();
            MarshalVkExternalBufferProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            VkSamplerCustomBorderColorCreateInfoEXT* p = new VkSamplerCustomBorderColorCreateInfoEXT();
            MarshalVkSamplerCustomBorderColorCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: {
            VkMemoryRequirements2* p = new VkMemoryRequirements2();
            MarshalVkMemoryRequirements2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT* p = new VkPhysicalDeviceMemoryBudgetPropertiesEXT();
            MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT: {
            VkDescriptorAddressInfoEXT* p = new VkDescriptorAddressInfoEXT();
            MarshalVkDescriptorAddressInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: {
            VkPhysicalDeviceShaderIntegerDotProductProperties* p = new VkPhysicalDeviceShaderIntegerDotProductProperties();
            MarshalVkPhysicalDeviceShaderIntegerDotProductProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR: {
            VkPipelineBinaryDataInfoKHR* p = new VkPipelineBinaryDataInfoKHR();
            MarshalVkPipelineBinaryDataInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT: {
            VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* p = new VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT();
            MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* p = new VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT();
            MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT: {
            VkDescriptorGetInfoEXT* p = new VkDescriptorGetInfoEXT();
            MarshalVkDescriptorGetInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* p = new VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures();
            MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            VkVideoEncodeH264SessionParametersFeedbackInfoKHR* p = new VkVideoEncodeH264SessionParametersFeedbackInfoKHR();
            MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES: {
            VkPhysicalDeviceVertexAttributeDivisorFeatures* p = new VkPhysicalDeviceVertexAttributeDivisorFeatures();
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            VkRenderPassInputAttachmentAspectCreateInfo* p = new VkRenderPassInputAttachmentAspectCreateInfo();
            MarshalVkRenderPassInputAttachmentAspectCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {
            VkPhysicalDeviceMultiDrawFeaturesEXT* p = new VkPhysicalDeviceMultiDrawFeaturesEXT();
            MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {
            VkBufferDeviceAddressCreateInfoEXT* p = new VkBufferDeviceAddressCreateInfoEXT();
            MarshalVkBufferDeviceAddressCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: {
            VkPhysicalDeviceProperties2* p = new VkPhysicalDeviceProperties2();
            MarshalVkPhysicalDeviceProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT: {
            VkSetDescriptorBufferOffsetsInfoEXT* p = new VkSetDescriptorBufferOffsetsInfoEXT();
            MarshalVkSetDescriptorBufferOffsetsInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE: {
            VkSubresourceHostMemcpySize* p = new VkSubresourceHostMemcpySize();
            MarshalVkSubresourceHostMemcpySize::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            VkVideoEncodeH264QuantizationMapCapabilitiesKHR* p = new VkVideoEncodeH264QuantizationMapCapabilitiesKHR();
            MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT: {
            VkIndirectExecutionSetShaderInfoEXT* p = new VkIndirectExecutionSetShaderInfoEXT();
            MarshalVkIndirectExecutionSetShaderInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES: {
            VkQueueFamilyGlobalPriorityProperties* p = new VkQueueFamilyGlobalPriorityProperties();
            MarshalVkQueueFamilyGlobalPriorityProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* p = new VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT();
            MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: {
            VkDisplayModeProperties2KHR* p = new VkDisplayModeProperties2KHR();
            MarshalVkDisplayModeProperties2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: {
            VkPhysicalDeviceSubgroupSizeControlProperties* p = new VkPhysicalDeviceSubgroupSizeControlProperties();
            MarshalVkPhysicalDeviceSubgroupSizeControlProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT: {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT* p = new VkPhysicalDeviceDepthBiasControlFeaturesEXT();
            MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT: {
            VkDeviceFaultCountsEXT* p = new VkDeviceFaultCountsEXT();
            MarshalVkDeviceFaultCountsEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT: {
            VkImageViewSlicedCreateInfoEXT* p = new VkImageViewSlicedCreateInfoEXT();
            MarshalVkImageViewSlicedCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO: {
            VkPipelineVertexInputDivisorStateCreateInfo* p = new VkPipelineVertexInputDivisorStateCreateInfo();
            MarshalVkPipelineVertexInputDivisorStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: {
            VkPerformanceCounterKHR* p = new VkPerformanceCounterKHR();
            MarshalVkPerformanceCounterKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* p = new VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT();
            MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* p = new VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT();
            MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR: {
            VkVideoDecodeAV1PictureInfoKHR* p = new VkVideoDecodeAV1PictureInfoKHR();
            MarshalVkVideoDecodeAV1PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            VkPhysicalDevicePointClippingProperties* p = new VkPhysicalDevicePointClippingProperties();
            MarshalVkPhysicalDevicePointClippingProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: {
            VkImageResolve2* p = new VkImageResolve2();
            MarshalVkImageResolve2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR: {
            VkVideoBeginCodingInfoKHR* p = new VkVideoBeginCodingInfoKHR();
            MarshalVkVideoBeginCodingInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: {
            VkMutableDescriptorTypeCreateInfoEXT* p = new VkMutableDescriptorTypeCreateInfoEXT();
            MarshalVkMutableDescriptorTypeCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* p = new VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT();
            MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: {
            VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* p = new VkQueryPoolVideoEncodeFeedbackCreateInfoKHR();
            MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* p = new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
            MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            VkImageFormatListCreateInfo* p = new VkImageFormatListCreateInfo();
            MarshalVkImageFormatListCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
            VkDedicatedAllocationMemoryAllocateInfoNV* p = new VkDedicatedAllocationMemoryAllocateInfoNV();
            MarshalVkDedicatedAllocationMemoryAllocateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* p = new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
            MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            VkPhysicalDevice16BitStorageFeatures* p = new VkPhysicalDevice16BitStorageFeatures();
            MarshalVkPhysicalDevice16BitStorageFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
            VkSubmitInfo* p = new VkSubmitInfo();
            MarshalVkSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR: {
            VkVideoFormatAV1QuantizationMapPropertiesKHR* p = new VkVideoFormatAV1QuantizationMapPropertiesKHR();
            MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoDecodeAV1SessionParametersCreateInfoKHR* p = new VkVideoDecodeAV1SessionParametersCreateInfoKHR();
            MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT* p = new VkPhysicalDeviceImageCompressionControlFeaturesEXT();
            MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: {
            VkVideoDecodeH264DpbSlotInfoKHR* p = new VkVideoDecodeH264DpbSlotInfoKHR();
            MarshalVkVideoDecodeH264DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT: {
            VkGeneratedCommandsInfoEXT* p = new VkGeneratedCommandsInfoEXT();
            MarshalVkGeneratedCommandsInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: {
            VkDebugUtilsMessengerCreateInfoEXT* p = new VkDebugUtilsMessengerCreateInfoEXT();
            MarshalVkDebugUtilsMessengerCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: {
            VkSubpassDependency2* p = new VkSubpassDependency2();
            MarshalVkSubpassDependency2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: {
            VkCopyImageToBufferInfo2* p = new VkCopyImageToBufferInfo2();
            MarshalVkCopyImageToBufferInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {
            VkTextureLODGatherFormatPropertiesAMD* p = new VkTextureLODGatherFormatPropertiesAMD();
            MarshalVkTextureLODGatherFormatPropertiesAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR: {
            VkVideoFormatH265QuantizationMapPropertiesKHR* p = new VkVideoFormatH265QuantizationMapPropertiesKHR();
            MarshalVkVideoFormatH265QuantizationMapPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG: {
            VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* p = new VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG();
            MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: {
            VkDeviceEventInfoEXT* p = new VkDeviceEventInfoEXT();
            MarshalVkDeviceEventInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: {
            VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* p = new VkPhysicalDeviceDepthClampZeroOneFeaturesEXT();
            MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV: {
            VkPhysicalDeviceRawAccessChainsFeaturesNV* p = new VkPhysicalDeviceRawAccessChainsFeaturesNV();
            MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR: {
            VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* p = new VkPhysicalDeviceVideoEncodeAV1FeaturesKHR();
            MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {
            VkRenderPassFragmentDensityMapCreateInfoEXT* p = new VkRenderPassFragmentDensityMapCreateInfoEXT();
            MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: {
            VkDisplayEventInfoEXT* p = new VkDisplayEventInfoEXT();
            MarshalVkDisplayEventInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            VkShaderModuleValidationCacheCreateInfoEXT* p = new VkShaderModuleValidationCacheCreateInfoEXT();
            MarshalVkShaderModuleValidationCacheCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: {
            VkPipelineInfoKHR* p = new VkPipelineInfoKHR();
            MarshalVkPipelineInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: {
            VkSubpassBeginInfo* p = new VkSubpassBeginInfo();
            MarshalVkSubpassBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT: {
            VkGeneratedCommandsMemoryRequirementsInfoEXT* p = new VkGeneratedCommandsMemoryRequirementsInfoEXT();
            MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV* p = new VkPipelineFragmentShadingRateEnumStateCreateInfoNV();
            MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR: {
            VkVideoEncodeH264SessionParametersGetInfoKHR* p = new VkVideoEncodeH264SessionParametersGetInfoKHR();
            MarshalVkVideoEncodeH264SessionParametersGetInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: {
            VkCheckpointDataNV* p = new VkCheckpointDataNV();
            MarshalVkCheckpointDataNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: {
            VkAttachmentDescription2* p = new VkAttachmentDescription2();
            MarshalVkAttachmentDescription2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COPY_2: {
            VkImageCopy2* p = new VkImageCopy2();
            MarshalVkImageCopy2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT* p = new VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT* p = new VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR: {
            VkVideoEncodeQualityLevelPropertiesKHR* p = new VkVideoEncodeQualityLevelPropertiesKHR();
            MarshalVkVideoEncodeQualityLevelPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            VkPhysicalDeviceShaderAtomicInt64Features* p = new VkPhysicalDeviceShaderAtomicInt64Features();
            MarshalVkPhysicalDeviceShaderAtomicInt64Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
            VkBufferMemoryBarrier* p = new VkBufferMemoryBarrier();
            MarshalVkBufferMemoryBarrier::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV: {
            VkSetLatencyMarkerInfoNV* p = new VkSetLatencyMarkerInfoNV();
            MarshalVkSetLatencyMarkerInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT* p = new VkPhysicalDeviceConditionalRenderingFeaturesEXT();
            MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT* p = new VkPhysicalDeviceDepthClipEnableFeaturesEXT();
            MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* p = new VkPhysicalDeviceImage2DViewOf3DFeaturesEXT();
            MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: {
            VkBufferDeviceAddressInfo* p = new VkBufferDeviceAddressInfo();
            MarshalVkBufferDeviceAddressInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV* p = new VkPhysicalDeviceShaderImageFootprintFeaturesNV();
            MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR: {
            VkVideoEncodeH265RateControlInfoKHR* p = new VkVideoEncodeH265RateControlInfoKHR();
            MarshalVkVideoEncodeH265RateControlInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT: {
            VkLayerSettingsCreateInfoEXT* p = new VkLayerSettingsCreateInfoEXT();
            MarshalVkLayerSettingsCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {
            VkSampleLocationsInfoEXT* p = new VkSampleLocationsInfoEXT();
            MarshalVkSampleLocationsInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT: {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT* p = new VkPhysicalDeviceFrameBoundaryFeaturesEXT();
            MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES: {
            VkPhysicalDeviceMaintenance5Features* p = new VkPhysicalDeviceMaintenance5Features();
            MarshalVkPhysicalDeviceMaintenance5Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {
            VkDisplayPresentInfoKHR* p = new VkDisplayPresentInfoKHR();
            MarshalVkDisplayPresentInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: {
            VkAccelerationStructureGeometryKHR* p = new VkAccelerationStructureGeometryKHR();
            MarshalVkAccelerationStructureGeometryKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR: {
            VkVideoSessionCreateInfoKHR* p = new VkVideoSessionCreateInfoKHR();
            MarshalVkVideoSessionCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationDepthClipStateCreateInfoEXT* p = new VkPipelineRasterizationDepthClipStateCreateInfoEXT();
            MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: {
            VkAccelerationStructureGeometryAabbsDataKHR* p = new VkAccelerationStructureGeometryAabbsDataKHR();
            MarshalVkAccelerationStructureGeometryAabbsDataKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM: {
            VkPhysicalDeviceShaderCorePropertiesARM* p = new VkPhysicalDeviceShaderCorePropertiesARM();
            MarshalVkPhysicalDeviceShaderCorePropertiesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: {
            VkPrivateDataSlotCreateInfo* p = new VkPrivateDataSlotCreateInfo();
            MarshalVkPrivateDataSlotCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV: {
            VkDisplaySurfaceStereoCreateInfoNV* p = new VkDisplaySurfaceStereoCreateInfoNV();
            MarshalVkDisplaySurfaceStereoCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV: {
            VkOpticalFlowExecuteInfoNV* p = new VkOpticalFlowExecuteInfoNV();
            MarshalVkOpticalFlowExecuteInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {
            VkPhysicalDeviceMeshShaderFeaturesNV* p = new VkPhysicalDeviceMeshShaderFeaturesNV();
            MarshalVkPhysicalDeviceMeshShaderFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR* p = new VkPhysicalDeviceRayTracingPipelineFeaturesKHR();
            MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: {
            VkCuFunctionCreateInfoNVX* p = new VkCuFunctionCreateInfoNVX();
            MarshalVkCuFunctionCreateInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
            VkSurfacePresentModeCompatibilityEXT* p = new VkSurfacePresentModeCompatibilityEXT();
            MarshalVkSurfacePresentModeCompatibilityEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* p = new VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV();
            MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: {
            VkBufferViewCreateInfo* p = new VkBufferViewCreateInfo();
            MarshalVkBufferViewCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR: {
            VkCooperativeMatrixPropertiesKHR* p = new VkCooperativeMatrixPropertiesKHR();
            MarshalVkCooperativeMatrixPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            VkSamplerYcbcrConversionInfo* p = new VkSamplerYcbcrConversionInfo();
            MarshalVkSamplerYcbcrConversionInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* p = new VkPhysicalDeviceSubpassShadingFeaturesHUAWEI();
            MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT: {
            VkDeviceFaultInfoEXT* p = new VkDeviceFaultInfoEXT();
            MarshalVkDeviceFaultInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: {
            VkIndirectCommandsLayoutCreateInfoNV* p = new VkIndirectCommandsLayoutCreateInfoNV();
            MarshalVkIndirectCommandsLayoutCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: {
            VkMultisampledRenderToSingleSampledInfoEXT* p = new VkMultisampledRenderToSingleSampledInfoEXT();
            MarshalVkMultisampledRenderToSingleSampledInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
            VkPhysicalDeviceSynchronization2Features* p = new VkPhysicalDeviceSynchronization2Features();
            MarshalVkPhysicalDeviceSynchronization2Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO: {
            VkBindDescriptorSetsInfo* p = new VkBindDescriptorSetsInfo();
            MarshalVkBindDescriptorSetsInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* p = new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
            MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
            VkPhysicalDeviceVulkan13Features* p = new VkPhysicalDeviceVulkan13Features();
            MarshalVkPhysicalDeviceVulkan13Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            VkPhysicalDeviceProtectedMemoryProperties* p = new VkPhysicalDeviceProtectedMemoryProperties();
            MarshalVkPhysicalDeviceProtectedMemoryProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            VkSemaphoreTypeCreateInfo* p = new VkSemaphoreTypeCreateInfo();
            MarshalVkSemaphoreTypeCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV: {
            VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* p = new VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV();
            MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT: {
            VkPhysicalDeviceMeshShaderPropertiesEXT* p = new VkPhysicalDeviceMeshShaderPropertiesEXT();
            MarshalVkPhysicalDeviceMeshShaderPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            VkPhysicalDevice8BitStorageFeatures* p = new VkPhysicalDevice8BitStorageFeatures();
            MarshalVkPhysicalDevice8BitStorageFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* p = new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
            MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO: {
            VkPipelineRasterizationLineStateCreateInfo* p = new VkPipelineRasterizationLineStateCreateInfo();
            MarshalVkPipelineRasterizationLineStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM: {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM* p = new VkPhysicalDeviceImageProcessing2FeaturesQCOM();
            MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* p = new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT: {
            VkMicromapCreateInfoEXT* p = new VkMicromapCreateInfoEXT();
            MarshalVkMicromapCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: {
            VkPhysicalDevicePerformanceQueryPropertiesKHR* p = new VkPhysicalDevicePerformanceQueryPropertiesKHR();
            MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO: {
            VkSubpassEndInfo* p = new VkSubpassEndInfo();
            MarshalVkSubpassEndInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: {
            VkPerformanceCounterDescriptionKHR* p = new VkPerformanceCounterDescriptionKHR();
            MarshalVkPerformanceCounterDescriptionKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR: {
            VkVideoEncodeH265RateControlLayerInfoKHR* p = new VkVideoEncodeH265RateControlLayerInfoKHR();
            MarshalVkVideoEncodeH265RateControlLayerInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* p = new VkPhysicalDeviceCopyMemoryIndirectFeaturesNV();
            MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
            VkPipelineLayoutCreateInfo* p = new VkPipelineLayoutCreateInfo();
            MarshalVkPipelineLayoutCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {
            VkMultiviewPerViewAttributesInfoNVX* p = new VkMultiviewPerViewAttributesInfoNVX();
            MarshalVkMultiviewPerViewAttributesInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV* p = new VkPhysicalDeviceCoverageReductionModeFeaturesNV();
            MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoDecodeH265SessionParametersCreateInfoKHR* p = new VkVideoDecodeH265SessionParametersCreateInfoKHR();
            MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: {
            VkPhysicalDeviceInlineUniformBlockProperties* p = new VkPhysicalDeviceInlineUniformBlockProperties();
            MarshalVkPhysicalDeviceInlineUniformBlockProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            VkPhysicalDeviceDescriptorIndexingProperties* p = new VkPhysicalDeviceDescriptorIndexingProperties();
            MarshalVkPhysicalDeviceDescriptorIndexingProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM: {
            VkPhysicalDeviceCubicClampFeaturesQCOM* p = new VkPhysicalDeviceCubicClampFeaturesQCOM();
            MarshalVkPhysicalDeviceCubicClampFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES: {
            VkPhysicalDeviceHostImageCopyProperties* p = new VkPhysicalDeviceHostImageCopyProperties();
            MarshalVkPhysicalDeviceHostImageCopyProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: {
            VkInstanceCreateInfo* p = new VkInstanceCreateInfo();
            MarshalVkInstanceCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: {
            VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* p = new VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR();
            MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT: {
            VkGeneratedCommandsShaderInfoEXT* p = new VkGeneratedCommandsShaderInfoEXT();
            MarshalVkGeneratedCommandsShaderInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: {
            VkDeviceCreateInfo* p = new VkDeviceCreateInfo();
            MarshalVkDeviceCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* p = new VkPhysicalDeviceInvocationMaskFeaturesHUAWEI();
            MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD: {
            VkAntiLagPresentationInfoAMD* p = new VkAntiLagPresentationInfoAMD();
            MarshalVkAntiLagPresentationInfoAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            VkBindBufferMemoryDeviceGroupInfo* p = new VkBindBufferMemoryDeviceGroupInfo();
            MarshalVkBindBufferMemoryDeviceGroupInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT* p = new VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
            MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: {
            VkAttachmentReference2* p = new VkAttachmentReference2();
            MarshalVkAttachmentReference2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO: {
            VkHostImageLayoutTransitionInfo* p = new VkHostImageLayoutTransitionInfo();
            MarshalVkHostImageLayoutTransitionInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR: {
            VkVideoEndCodingInfoKHR* p = new VkVideoEndCodingInfoKHR();
            MarshalVkVideoEndCodingInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR: {
            VkVideoEncodeH264DpbSlotInfoKHR* p = new VkVideoEncodeH264DpbSlotInfoKHR();
            MarshalVkVideoEncodeH264DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV: {
            VkCudaLaunchInfoNV* p = new VkCudaLaunchInfoNV();
            MarshalVkCudaLaunchInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV: {
            VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* p = new VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV();
            MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: {
            VkPipelineShaderStageModuleIdentifierCreateInfoEXT* p = new VkPipelineShaderStageModuleIdentifierCreateInfoEXT();
            MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {
            VkDeviceMemoryOverallocationCreateInfoAMD* p = new VkDeviceMemoryOverallocationCreateInfoAMD();
            MarshalVkDeviceMemoryOverallocationCreateInfoAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM: {
            VkRenderPassStripeInfoARM* p = new VkRenderPassStripeInfoARM();
            MarshalVkRenderPassStripeInfoARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR: {
            VkVideoEncodeH264PictureInfoKHR* p = new VkVideoEncodeH264PictureInfoKHR();
            MarshalVkVideoEncodeH264PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {
            VkFilterCubicImageViewImageFormatPropertiesEXT* p = new VkFilterCubicImageViewImageFormatPropertiesEXT();
            MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
            VkPipelineColorBlendAdvancedStateCreateInfoEXT* p = new VkPipelineColorBlendAdvancedStateCreateInfoEXT();
            MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR: {
            VkVideoEncodeH265ProfileInfoKHR* p = new VkVideoEncodeH265ProfileInfoKHR();
            MarshalVkVideoEncodeH265ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT: {
            VkPhysicalDeviceShaderObjectPropertiesEXT* p = new VkPhysicalDeviceShaderObjectPropertiesEXT();
            MarshalVkPhysicalDeviceShaderObjectPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            VkRenderPassCreationFeedbackCreateInfoEXT* p = new VkRenderPassCreationFeedbackCreateInfoEXT();
            MarshalVkRenderPassCreationFeedbackCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
            VkPhysicalDeviceDynamicRenderingFeatures* p = new VkPhysicalDeviceDynamicRenderingFeatures();
            MarshalVkPhysicalDeviceDynamicRenderingFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* p = new VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR();
            MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR: {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR* p = new VkPhysicalDeviceCooperativeMatrixFeaturesKHR();
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR: {
            VkVideoEncodeH265CapabilitiesKHR* p = new VkVideoEncodeH265CapabilitiesKHR();
            MarshalVkVideoEncodeH265CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: {
            VkDeviceBufferMemoryRequirements* p = new VkDeviceBufferMemoryRequirements();
            MarshalVkDeviceBufferMemoryRequirements::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV: {
            VkLatencySleepModeInfoNV* p = new VkLatencySleepModeInfoNV();
            MarshalVkLatencySleepModeInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {
            VkCopyCommandTransformInfoQCOM* p = new VkCopyCommandTransformInfoQCOM();
            MarshalVkCopyCommandTransformInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: {
            VkPipelineTessellationStateCreateInfo* p = new VkPipelineTessellationStateCreateInfo();
            MarshalVkPipelineTessellationStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: {
            VkLatencySubmissionPresentIdNV* p = new VkLatencySubmissionPresentIdNV();
            MarshalVkLatencySubmissionPresentIdNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            VkDeviceGroupSubmitInfo* p = new VkDeviceGroupSubmitInfo();
            MarshalVkDeviceGroupSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* p = new VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD();
            MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT: {
            VkIndirectExecutionSetShaderLayoutInfoEXT* p = new VkIndirectExecutionSetShaderLayoutInfoEXT();
            MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: {
            VkSamplerYcbcrConversionCreateInfo* p = new VkSamplerYcbcrConversionCreateInfo();
            MarshalVkSamplerYcbcrConversionCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI: {
            VkHdrVividDynamicMetadataHUAWEI* p = new VkHdrVividDynamicMetadataHUAWEI();
            MarshalVkHdrVividDynamicMetadataHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            VkVideoEncodeH265SessionParametersFeedbackInfoKHR* p = new VkVideoEncodeH265SessionParametersFeedbackInfoKHR();
            MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR: {
            VkVideoEncodeH264RateControlLayerInfoKHR* p = new VkVideoEncodeH264RateControlLayerInfoKHR();
            MarshalVkVideoEncodeH264RateControlLayerInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {
            VkPipelineViewportSwizzleStateCreateInfoNV* p = new VkPipelineViewportSwizzleStateCreateInfoNV();
            MarshalVkPipelineViewportSwizzleStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT: {
            VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* p = new VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT();
            MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* p = new VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT();
            MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR: {
            VkPipelineBinaryHandlesInfoKHR* p = new VkPipelineBinaryHandlesInfoKHR();
            MarshalVkPipelineBinaryHandlesInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: {
            VkPhysicalDeviceMultiDrawPropertiesEXT* p = new VkPhysicalDeviceMultiDrawPropertiesEXT();
            MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: {
            VkPhysicalDeviceShaderCoreProperties2AMD* p = new VkPhysicalDeviceShaderCoreProperties2AMD();
            MarshalVkPhysicalDeviceShaderCoreProperties2AMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            VkImageViewCaptureDescriptorDataInfoEXT* p = new VkImageViewCaptureDescriptorDataInfoEXT();
            MarshalVkImageViewCaptureDescriptorDataInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV: {
            VkGetLatencyMarkerInfoNV* p = new VkGetLatencyMarkerInfoNV();
            MarshalVkGetLatencyMarkerInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            VkRenderPassAttachmentBeginInfo* p = new VkRenderPassAttachmentBeginInfo();
            MarshalVkRenderPassAttachmentBeginInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: {
            VkPhysicalDeviceSurfaceInfo2KHR* p = new VkPhysicalDeviceSurfaceInfo2KHR();
            MarshalVkPhysicalDeviceSurfaceInfo2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            VkPhysicalDeviceShaderCorePropertiesAMD* p = new VkPhysicalDeviceShaderCorePropertiesAMD();
            MarshalVkPhysicalDeviceShaderCorePropertiesAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT: {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* p = new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: {
            VkVideoEncodeUsageInfoKHR* p = new VkVideoEncodeUsageInfoKHR();
            MarshalVkVideoEncodeUsageInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: {
            VkCopyAccelerationStructureToMemoryInfoKHR* p = new VkCopyAccelerationStructureToMemoryInfoKHR();
            MarshalVkCopyAccelerationStructureToMemoryInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: {
            VkPipelineExecutableInternalRepresentationKHR* p = new VkPipelineExecutableInternalRepresentationKHR();
            MarshalVkPipelineExecutableInternalRepresentationKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: {
            VkQueryLowLatencySupportNV* p = new VkQueryLowLatencySupportNV();
            MarshalVkQueryLowLatencySupportNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT: {
            VkReleaseSwapchainImagesInfoEXT* p = new VkReleaseSwapchainImagesInfoEXT();
            MarshalVkReleaseSwapchainImagesInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO_2: {
            VkSubmitInfo2* p = new VkSubmitInfo2();
            MarshalVkSubmitInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: {
            VkVideoDecodeH264PictureInfoKHR* p = new VkVideoDecodeH264PictureInfoKHR();
            MarshalVkVideoDecodeH264PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            VkVideoEncodeH265QuantizationMapCapabilitiesKHR* p = new VkVideoEncodeH265QuantizationMapCapabilitiesKHR();
            MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR: {
            VkVideoDecodeH265ProfileInfoKHR* p = new VkVideoDecodeH265ProfileInfoKHR();
            MarshalVkVideoDecodeH265ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT: {
            VkIndirectCommandsLayoutTokenEXT* p = new VkIndirectCommandsLayoutTokenEXT();
            MarshalVkIndirectCommandsLayoutTokenEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: {
            VkDisplayPowerInfoEXT* p = new VkDisplayPowerInfoEXT();
            MarshalVkDisplayPowerInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR: {
            VkVideoDecodeH265CapabilitiesKHR* p = new VkVideoDecodeH265CapabilitiesKHR();
            MarshalVkVideoDecodeH265CapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* p = new VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT();
            MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: {
            VkImageViewAddressPropertiesNVX* p = new VkImageViewAddressPropertiesNVX();
            MarshalVkImageViewAddressPropertiesNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT: {
            VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* p = new VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT();
            MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX: {
            VkCuModuleCreateInfoNVX* p = new VkCuModuleCreateInfoNVX();
            MarshalVkCuModuleCreateInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            VkExportMemoryAllocateInfo* p = new VkExportMemoryAllocateInfo();
            MarshalVkExportMemoryAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: {
            VkGeometryTrianglesNV* p = new VkGeometryTrianglesNV();
            MarshalVkGeometryTrianglesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* p = new VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
            MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: {
            VkBufferUsageFlags2CreateInfo* p = new VkBufferUsageFlags2CreateInfo();
            MarshalVkBufferUsageFlags2CreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {
            VkDescriptorPoolInlineUniformBlockCreateInfo* p = new VkDescriptorPoolInlineUniformBlockCreateInfo();
            MarshalVkDescriptorPoolInlineUniformBlockCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT: {
            VkDepthBiasInfoEXT* p = new VkDepthBiasInfoEXT();
            MarshalVkDepthBiasInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            VkPhysicalDeviceShaderClockFeaturesKHR* p = new VkPhysicalDeviceShaderClockFeaturesKHR();
            MarshalVkPhysicalDeviceShaderClockFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR: {
            VkVideoEncodeH264SessionCreateInfoKHR* p = new VkVideoEncodeH264SessionCreateInfoKHR();
            MarshalVkVideoEncodeH264SessionCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: {
            VkPipelineCacheCreateInfo* p = new VkPipelineCacheCreateInfo();
            MarshalVkPipelineCacheCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: {
            VkPhysicalDeviceImageProcessingFeaturesQCOM* p = new VkPhysicalDeviceImageProcessingFeaturesQCOM();
            MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: {
            VkResolveImageInfo2* p = new VkResolveImageInfo2();
            MarshalVkResolveImageInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM: {
            VkTilePropertiesQCOM* p = new VkTilePropertiesQCOM();
            MarshalVkTilePropertiesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {
            VkGraphicsPipelineShaderGroupsCreateInfoNV* p = new VkGraphicsPipelineShaderGroupsCreateInfoNV();
            MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEPENDENCY_INFO: {
            VkDependencyInfo* p = new VkDependencyInfo();
            MarshalVkDependencyInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA: {
            VkPhysicalDeviceImageAlignmentControlFeaturesMESA* p = new VkPhysicalDeviceImageAlignmentControlFeaturesMESA();
            MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
            VkPresentInfoKHR* p = new VkPresentInfoKHR();
            MarshalVkPresentInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR: {
            VkVideoEncodeAV1GopRemainingFrameInfoKHR* p = new VkVideoEncodeAV1GopRemainingFrameInfoKHR();
            MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            VkImageSwapchainCreateInfoKHR* p = new VkImageSwapchainCreateInfoKHR();
            MarshalVkImageSwapchainCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: {
            VkSamplerCreateInfo* p = new VkSamplerCreateInfo();
            MarshalVkSamplerCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: {
            VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* p = new VkDescriptorBufferBindingPushDescriptorBufferHandleEXT();
            MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR: {
            VkPhysicalDevicePipelineBinaryPropertiesKHR* p = new VkPhysicalDevicePipelineBinaryPropertiesKHR();
            MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT: {
            VkMemoryMapPlacedInfoEXT* p = new VkMemoryMapPlacedInfoEXT();
            MarshalVkMemoryMapPlacedInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES: {
            VkPhysicalDevicePipelineRobustnessFeatures* p = new VkPhysicalDevicePipelineRobustnessFeatures();
            MarshalVkPhysicalDevicePipelineRobustnessFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: {
            VkPhysicalDeviceShaderObjectFeaturesEXT* p = new VkPhysicalDeviceShaderObjectFeaturesEXT();
            MarshalVkPhysicalDeviceShaderObjectFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES: {
            VkPhysicalDevicePipelineProtectedAccessFeatures* p = new VkPhysicalDevicePipelineProtectedAccessFeatures();
            MarshalVkPhysicalDevicePipelineProtectedAccessFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            VkFramebufferAttachmentsCreateInfo* p = new VkFramebufferAttachmentsCreateInfo();
            MarshalVkFramebufferAttachmentsCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT: {
            VkHdrMetadataEXT* p = new VkHdrMetadataEXT();
            MarshalVkHdrMetadataEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {
            VkVideoDecodeH264SessionParametersAddInfoKHR* p = new VkVideoDecodeH264SessionParametersAddInfoKHR();
            MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: {
            VkAccelerationStructureGeometryTrianglesDataKHR* p = new VkAccelerationStructureGeometryTrianglesDataKHR();
            MarshalVkAccelerationStructureGeometryTrianglesDataKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            VkImagePlaneMemoryRequirementsInfo* p = new VkImagePlaneMemoryRequirementsInfo();
            MarshalVkImagePlaneMemoryRequirementsInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
            VkPhysicalDeviceMaintenance4Features* p = new VkPhysicalDeviceMaintenance4Features();
            MarshalVkPhysicalDeviceMaintenance4Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: {
            VkSemaphoreSignalInfo* p = new VkSemaphoreSignalInfo();
            MarshalVkSemaphoreSignalInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR: {
            VkPhysicalDeviceVideoMaintenance1FeaturesKHR* p = new VkPhysicalDeviceVideoMaintenance1FeaturesKHR();
            MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: {
            VkRayTracingPipelineCreateInfoNV* p = new VkRayTracingPipelineCreateInfoNV();
            MarshalVkRayTracingPipelineCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT: {
            VkMicromapBuildInfoEXT* p = new VkMicromapBuildInfoEXT();
            MarshalVkMicromapBuildInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR* p = new VkPhysicalDeviceRayTracingPipelinePropertiesKHR();
            MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {
            VkSwapchainPresentScalingCreateInfoEXT* p = new VkSwapchainPresentScalingCreateInfoEXT();
            MarshalVkSwapchainPresentScalingCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: {
            VkRenderingAttachmentInfo* p = new VkRenderingAttachmentInfo();
            MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {
            VkQueueFamilyCheckpointPropertiesNV* p = new VkQueueFamilyCheckpointPropertiesNV();
            MarshalVkQueueFamilyCheckpointPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INFO: {
            VkRenderingInfo* p = new VkRenderingInfo();
            MarshalVkRenderingInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* p = new VkPhysicalDeviceExtendedDynamicState2FeaturesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* p = new VkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
            MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            VkVideoEncodeSessionParametersFeedbackInfoKHR* p = new VkVideoEncodeSessionParametersFeedbackInfoKHR();
            MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            VkPhysicalDeviceProvokingVertexFeaturesEXT* p = new VkPhysicalDeviceProvokingVertexFeaturesEXT();
            MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR: {
            VkVideoEncodeAV1PictureInfoKHR* p = new VkVideoEncodeAV1PictureInfoKHR();
            MarshalVkVideoEncodeAV1PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT* p = new VkPhysicalDeviceOpacityMicromapFeaturesEXT();
            MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoEncodeH264SessionParametersCreateInfoKHR* p = new VkVideoEncodeH264SessionParametersCreateInfoKHR();
            MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV: {
            VkDisplayModeStereoPropertiesNV* p = new VkDisplayModeStereoPropertiesNV();
            MarshalVkDisplayModeStereoPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM: {
            VkPhysicalDeviceSchedulingControlsPropertiesARM* p = new VkPhysicalDeviceSchedulingControlsPropertiesARM();
            MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT: {
            VkIndirectExecutionSetCreateInfoEXT* p = new VkIndirectExecutionSetCreateInfoEXT();
            MarshalVkIndirectExecutionSetCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: {
            VkSurfaceCapabilitiesPresentBarrierNV* p = new VkSurfaceCapabilitiesPresentBarrierNV();
            MarshalVkSurfaceCapabilitiesPresentBarrierNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO: {
            VkMemoryUnmapInfo* p = new VkMemoryUnmapInfo();
            MarshalVkMemoryUnmapInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoSessionParametersCreateInfoKHR* p = new VkVideoSessionParametersCreateInfoKHR();
            MarshalVkVideoSessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            VkPhysicalDeviceVulkan12Features* p = new VkPhysicalDeviceVulkan12Features();
            MarshalVkPhysicalDeviceVulkan12Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* p = new VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR();
            MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* p = new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
            MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            VkPhysicalDeviceFeatures2* p = new VkPhysicalDeviceFeatures2();
            MarshalVkPhysicalDeviceFeatures2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            VkPhysicalDeviceVulkan11Properties* p = new VkPhysicalDeviceVulkan11Properties();
            MarshalVkPhysicalDeviceVulkan11Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* p = new VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR();
            MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {
            VkPipelineViewportWScalingStateCreateInfoNV* p = new VkPipelineViewportWScalingStateCreateInfoNV();
            MarshalVkPipelineViewportWScalingStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES: {
            VkPhysicalDeviceShaderFloatControls2Features* p = new VkPhysicalDeviceShaderFloatControls2Features();
            MarshalVkPhysicalDeviceShaderFloatControls2Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            VkBindImageMemorySwapchainInfoKHR* p = new VkBindImageMemorySwapchainInfoKHR();
            MarshalVkBindImageMemorySwapchainInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO: {
            VkRenderingAreaInfo* p = new VkRenderingAreaInfo();
            MarshalVkRenderingAreaInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* p = new VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM();
            MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT: {
            VkMicromapBuildSizesInfoEXT* p = new VkMicromapBuildSizesInfoEXT();
            MarshalVkMicromapBuildSizesInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: {
            VkPerformanceOverrideInfoINTEL* p = new VkPerformanceOverrideInfoINTEL();
            MarshalVkPerformanceOverrideInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT: {
            VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* p = new VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT();
            MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* p = new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
            MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV: {
            VkPhysicalDeviceCudaKernelLaunchPropertiesNV* p = new VkPhysicalDeviceCudaKernelLaunchPropertiesNV();
            MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR: {
            VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* p = new VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR();
            MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR: {
            VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* p = new VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR();
            MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: {
            VkDepthBiasRepresentationInfoEXT* p = new VkDepthBiasRepresentationInfoEXT();
            MarshalVkDepthBiasRepresentationInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT: {
            VkPipelinePropertiesIdentifierEXT* p = new VkPipelinePropertiesIdentifierEXT();
            MarshalVkPipelinePropertiesIdentifierEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: {
            VkPipelineInputAssemblyStateCreateInfo* p = new VkPipelineInputAssemblyStateCreateInfo();
            MarshalVkPipelineInputAssemblyStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM: {
            VkRenderPassStripeSubmitInfoARM* p = new VkRenderPassStripeSubmitInfoARM();
            MarshalVkRenderPassStripeSubmitInfoARM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
            VkSemaphoreWaitInfo* p = new VkSemaphoreWaitInfo();
            MarshalVkSemaphoreWaitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: {
            VkDescriptorSetLayoutSupport* p = new VkDescriptorSetLayoutSupport();
            MarshalVkDescriptorSetLayoutSupport::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {
            VkVideoEncodeH265SessionParametersAddInfoKHR* p = new VkVideoEncodeH265SessionParametersAddInfoKHR();
            MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT: {
            VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* p = new VkPhysicalDeviceMapMemoryPlacedPropertiesEXT();
            MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: {
            VkCopyImageInfo2* p = new VkCopyImageInfo2();
            MarshalVkCopyImageInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES: {
            VkPhysicalDeviceVertexAttributeDivisorProperties* p = new VkPhysicalDeviceVertexAttributeDivisorProperties();
            MarshalVkPhysicalDeviceVertexAttributeDivisorProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: {
            VkBufferMemoryBarrier2* p = new VkBufferMemoryBarrier2();
            MarshalVkBufferMemoryBarrier2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR: {
            VkVideoSessionMemoryRequirementsKHR* p = new VkVideoSessionMemoryRequirementsKHR();
            MarshalVkVideoSessionMemoryRequirementsKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR: {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* p = new VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR();
            MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR: {
            VkVideoEncodeH265GopRemainingFrameInfoKHR* p = new VkVideoEncodeH265GopRemainingFrameInfoKHR();
            MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
            VkFramebufferCreateInfo* p = new VkFramebufferCreateInfo();
            MarshalVkFramebufferCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            VkPhysicalDeviceVulkan12Properties* p = new VkPhysicalDeviceVulkan12Properties();
            MarshalVkPhysicalDeviceVulkan12Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {
            VkDeviceDiagnosticsConfigCreateInfoNV* p = new VkDeviceDiagnosticsConfigCreateInfoNV();
            MarshalVkDeviceDiagnosticsConfigCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT: {
            VkCopyMicromapInfoEXT* p = new VkCopyMicromapInfoEXT();
            MarshalVkCopyMicromapInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE: {
            VkDescriptorSetBindingReferenceVALVE* p = new VkDescriptorSetBindingReferenceVALVE();
            MarshalVkDescriptorSetBindingReferenceVALVE::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {
            VkPhysicalDeviceRayQueryFeaturesKHR* p = new VkPhysicalDeviceRayQueryFeaturesKHR();
            MarshalVkPhysicalDeviceRayQueryFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {
            VkGraphicsPipelineLibraryCreateInfoEXT* p = new VkGraphicsPipelineLibraryCreateInfoEXT();
            MarshalVkGraphicsPipelineLibraryCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY: {
            VkHostImageCopyDevicePerformanceQuery* p = new VkHostImageCopyDevicePerformanceQuery();
            MarshalVkHostImageCopyDevicePerformanceQuery::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* p = new VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT();
            MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR* p = new VkPhysicalDeviceFragmentShadingRatePropertiesKHR();
            MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {
            VkAccelerationStructureGeometryMotionTrianglesDataNV* p = new VkAccelerationStructureGeometryMotionTrianglesDataNV();
            MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            VkVideoEncodeQuantizationMapCapabilitiesKHR* p = new VkVideoEncodeQuantizationMapCapabilitiesKHR();
            MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV: {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* p = new VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV();
            MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: {
            VkSurfaceFormat2KHR* p = new VkSurfaceFormat2KHR();
            MarshalVkSurfaceFormat2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM: {
            VkPhysicalDeviceImageProcessingPropertiesQCOM* p = new VkPhysicalDeviceImageProcessingPropertiesQCOM();
            MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR: {
            VkPhysicalDeviceShaderQuadControlFeaturesKHR* p = new VkPhysicalDeviceShaderQuadControlFeaturesKHR();
            MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            VkCooperativeMatrixPropertiesNV* p = new VkCooperativeMatrixPropertiesNV();
            MarshalVkCooperativeMatrixPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
            VkComputePipelineCreateInfo* p = new VkComputePipelineCreateInfo();
            MarshalVkComputePipelineCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageReductionStateCreateInfoNV* p = new VkPipelineCoverageReductionStateCreateInfoNV();
            MarshalVkPipelineCoverageReductionStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: {
            VkPhysicalDeviceGroupProperties* p = new VkPhysicalDeviceGroupProperties();
            MarshalVkPhysicalDeviceGroupProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV: {
            VkOpticalFlowImageFormatPropertiesNV* p = new VkOpticalFlowImageFormatPropertiesNV();
            MarshalVkOpticalFlowImageFormatPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {
            VkPipelineRasterizationStateRasterizationOrderAMD* p = new VkPipelineRasterizationStateRasterizationOrderAMD();
            MarshalVkPipelineRasterizationStateRasterizationOrderAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV: {
            VkCheckpointData2NV* p = new VkCheckpointData2NV();
            MarshalVkCheckpointData2NV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            VkMemoryAllocateFlagsInfo* p = new VkMemoryAllocateFlagsInfo();
            MarshalVkMemoryAllocateFlagsInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: {
            VkPhysicalDeviceVulkan13Properties* p = new VkPhysicalDeviceVulkan13Properties();
            MarshalVkPhysicalDeviceVulkan13Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            VkExternalImageFormatProperties* p = new VkExternalImageFormatProperties();
            MarshalVkExternalImageFormatProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: {
            VkPipelineColorBlendStateCreateInfo* p = new VkPipelineColorBlendStateCreateInfo();
            MarshalVkPipelineColorBlendStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR: {
            VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* p = new VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR();
            MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            VkTimelineSemaphoreSubmitInfo* p = new VkTimelineSemaphoreSubmitInfo();
            MarshalVkTimelineSemaphoreSubmitInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
            VkPhysicalDevicePipelineCreationCacheControlFeatures* p = new VkPhysicalDevicePipelineCreationCacheControlFeatures();
            MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures* p = new VkPhysicalDeviceSamplerYcbcrConversionFeatures();
            MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV: {
            VkLatencyTimingsFrameReportNV* p = new VkLatencyTimingsFrameReportNV();
            MarshalVkLatencyTimingsFrameReportNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* p = new VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT();
            MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR: {
            VkDevicePipelineBinaryInternalCacheControlKHR* p = new VkDevicePipelineBinaryInternalCacheControlKHR();
            MarshalVkDevicePipelineBinaryInternalCacheControlKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: {
            VkAccelerationStructureBuildGeometryInfoKHR* p = new VkAccelerationStructureBuildGeometryInfoKHR();
            MarshalVkAccelerationStructureBuildGeometryInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT: {
            VkGeneratedCommandsPipelineInfoEXT* p = new VkGeneratedCommandsPipelineInfoEXT();
            MarshalVkGeneratedCommandsPipelineInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
            VkPipelineFragmentShadingRateStateCreateInfoKHR* p = new VkPipelineFragmentShadingRateStateCreateInfoKHR();
            MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD: {
            VkAntiLagDataAMD* p = new VkAntiLagDataAMD();
            MarshalVkAntiLagDataAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
            VkPhysicalDeviceASTCDecodeFeaturesEXT* p = new VkPhysicalDeviceASTCDecodeFeaturesEXT();
            MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES: {
            VkPhysicalDeviceVulkan14Properties* p = new VkPhysicalDeviceVulkan14Properties();
            MarshalVkPhysicalDeviceVulkan14Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: {
            VkConditionalRenderingBeginInfoEXT* p = new VkConditionalRenderingBeginInfoEXT();
            MarshalVkConditionalRenderingBeginInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: {
            VkBlitImageInfo2* p = new VkBlitImageInfo2();
            MarshalVkBlitImageInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES: {
            VkPhysicalDeviceShaderExpectAssumeFeatures* p = new VkPhysicalDeviceShaderExpectAssumeFeatures();
            MarshalVkPhysicalDeviceShaderExpectAssumeFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            VkPhysicalDeviceDescriptorIndexingFeatures* p = new VkPhysicalDeviceDescriptorIndexingFeatures();
            MarshalVkPhysicalDeviceDescriptorIndexingFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            VkPhysicalDeviceIDProperties* p = new VkPhysicalDeviceIDProperties();
            MarshalVkPhysicalDeviceIDProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* p = new VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE();
            MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR: {
            VkReleaseCapturedPipelineDataInfoKHR* p = new VkReleaseCapturedPipelineDataInfoKHR();
            MarshalVkReleaseCapturedPipelineDataInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT* p = new VkPhysicalDeviceTransformFeedbackPropertiesEXT();
            MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {
            VkQueryPoolPerformanceQueryCreateInfoINTEL* p = new VkQueryPoolPerformanceQueryCreateInfoINTEL();
            MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT: {
            VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* p = new VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT();
            MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: {
            VkPhysicalDeviceTexelBufferAlignmentProperties* p = new VkPhysicalDeviceTexelBufferAlignmentProperties();
            MarshalVkPhysicalDeviceTexelBufferAlignmentProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
            VkPipelineRobustnessCreateInfo* p = new VkPipelineRobustnessCreateInfo();
            MarshalVkPipelineRobustnessCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT: {
            VkWriteIndirectExecutionSetShaderEXT* p = new VkWriteIndirectExecutionSetShaderEXT();
            MarshalVkWriteIndirectExecutionSetShaderEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: {
            VkAccelerationStructureTrianglesOpacityMicromapEXT* p = new VkAccelerationStructureTrianglesOpacityMicromapEXT();
            MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            VkDeviceGroupSwapchainCreateInfoKHR* p = new VkDeviceGroupSwapchainCreateInfoKHR();
            MarshalVkDeviceGroupSwapchainCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: {
            VkSemaphoreCreateInfo* p = new VkSemaphoreCreateInfo();
            MarshalVkSemaphoreCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: {
            VkPhysicalDeviceSparseImageFormatInfo2* p = new VkPhysicalDeviceSparseImageFormatInfo2();
            MarshalVkPhysicalDeviceSparseImageFormatInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV: {
            VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* p = new VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV();
            MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            VkPhysicalDeviceSubgroupProperties* p = new VkPhysicalDeviceSubgroupProperties();
            MarshalVkPhysicalDeviceSubgroupProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: {
            VkMemoryAllocateInfo* p = new VkMemoryAllocateInfo();
            MarshalVkMemoryAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: {
            VkSurfaceCapabilities2KHR* p = new VkSurfaceCapabilities2KHR();
            MarshalVkSurfaceCapabilities2KHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            VkPhysicalDeviceShaderFloat16Int8Features* p = new VkPhysicalDeviceShaderFloat16Int8Features();
            MarshalVkPhysicalDeviceShaderFloat16Int8Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR: {
            VkVideoEncodeH264GopRemainingFrameInfoKHR* p = new VkVideoEncodeH264GopRemainingFrameInfoKHR();
            MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: {
            VkVideoDecodeUsageInfoKHR* p = new VkVideoDecodeUsageInfoKHR();
            MarshalVkVideoDecodeUsageInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV: {
            VkCooperativeMatrixFlexibleDimensionsPropertiesNV* p = new VkCooperativeMatrixFlexibleDimensionsPropertiesNV();
            MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: {
            VkCommandBufferAllocateInfo* p = new VkCommandBufferAllocateInfo();
            MarshalVkCommandBufferAllocateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: {
            VkGeneratedCommandsInfoNV* p = new VkGeneratedCommandsInfoNV();
            MarshalVkGeneratedCommandsInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: {
            VkPhysicalDeviceExternalFenceInfo* p = new VkPhysicalDeviceExternalFenceInfo();
            MarshalVkPhysicalDeviceExternalFenceInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT* p = new VkPhysicalDeviceMemoryPriorityFeaturesEXT();
            MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT: {
            VkExternalMemoryAcquireUnmodifiedEXT* p = new VkExternalMemoryAcquireUnmodifiedEXT();
            MarshalVkExternalMemoryAcquireUnmodifiedEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: {
            VkDebugUtilsLabelEXT* p = new VkDebugUtilsLabelEXT();
            MarshalVkDebugUtilsLabelEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: {
            VkMappedMemoryRange* p = new VkMappedMemoryRange();
            MarshalVkMappedMemoryRange::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: {
            VkCommandBufferInheritanceInfo* p = new VkCommandBufferInheritanceInfo();
            MarshalVkCommandBufferInheritanceInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* p = new VkVideoEncodeAV1QuantizationMapCapabilitiesKHR();
            MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: {
            VkImportMemoryHostPointerInfoEXT* p = new VkImportMemoryHostPointerInfoEXT();
            MarshalVkImportMemoryHostPointerInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO: {
            VkPushDescriptorSetWithTemplateInfo* p = new VkPushDescriptorSetWithTemplateInfo();
            MarshalVkPushDescriptorSetWithTemplateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD* p = new VkPhysicalDeviceCoherentMemoryFeaturesAMD();
            MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: {
            VkCopyBufferInfo2* p = new VkCopyBufferInfo2();
            MarshalVkCopyBufferInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
            VkDedicatedAllocationBufferCreateInfoNV* p = new VkDedicatedAllocationBufferCreateInfoNV();
            MarshalVkDedicatedAllocationBufferCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {
            VkPipelineLibraryCreateInfoKHR* p = new VkPipelineLibraryCreateInfoKHR();
            MarshalVkPipelineLibraryCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            VkShaderModuleCreateInfo* p = new VkShaderModuleCreateInfo();
            MarshalVkShaderModuleCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV: {
            VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* p = new VkPhysicalDeviceCopyMemoryIndirectPropertiesNV();
            MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: {
            VkOpticalFlowImageFormatInfoNV* p = new VkOpticalFlowImageFormatInfoNV();
            MarshalVkOpticalFlowImageFormatInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: {
            VkVideoProfileListInfoKHR* p = new VkVideoProfileListInfoKHR();
            MarshalVkVideoProfileListInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV: {
            VkCudaFunctionCreateInfoNV* p = new VkCudaFunctionCreateInfoNV();
            MarshalVkCudaFunctionCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: {
            VkSamplerBorderColorComponentMappingCreateInfoEXT* p = new VkSamplerBorderColorComponentMappingCreateInfoEXT();
            MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
            VkPhysicalDevicePerformanceQueryFeaturesKHR* p = new VkPhysicalDevicePerformanceQueryFeaturesKHR();
            MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: {
            VkPipelineExecutableInfoKHR* p = new VkPipelineExecutableInfoKHR();
            MarshalVkPipelineExecutableInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR: {
            VkVideoEncodeH264RateControlInfoKHR* p = new VkVideoEncodeH264RateControlInfoKHR();
            MarshalVkVideoEncodeH264RateControlInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV: {
            VkPhysicalDeviceCooperativeMatrix2PropertiesNV* p = new VkPhysicalDeviceCooperativeMatrix2PropertiesNV();
            MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV: {
            VkLatencySurfaceCapabilitiesNV* p = new VkLatencySurfaceCapabilitiesNV();
            MarshalVkLatencySurfaceCapabilitiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* p = new VkPhysicalDeviceExtendedDynamicState3FeaturesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            VkSamplerYcbcrConversionImageFormatProperties* p = new VkSamplerYcbcrConversionImageFormatProperties();
            MarshalVkSamplerYcbcrConversionImageFormatProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR: {
            VkQueueFamilyQueryResultStatusPropertiesKHR* p = new VkQueueFamilyQueryResultStatusPropertiesKHR();
            MarshalVkQueueFamilyQueryResultStatusPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
            VkPhysicalDevicePrivateDataFeatures* p = new VkPhysicalDevicePrivateDataFeatures();
            MarshalVkPhysicalDevicePrivateDataFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT: {
            VkDescriptorBufferBindingInfoEXT* p = new VkDescriptorBufferBindingInfoEXT();
            MarshalVkDescriptorBufferBindingInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
            VkPipelineDiscardRectangleStateCreateInfoEXT* p = new VkPipelineDiscardRectangleStateCreateInfoEXT();
            MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
            VkBindSparseInfo* p = new VkBindSparseInfo();
            MarshalVkBindSparseInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT* p = new VkPhysicalDeviceTransformFeedbackFeaturesEXT();
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
            VkPhysicalDeviceInlineUniformBlockFeatures* p = new VkPhysicalDeviceInlineUniformBlockFeatures();
            MarshalVkPhysicalDeviceInlineUniformBlockFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: {
            VkVideoDecodeH265DpbSlotInfoKHR* p = new VkVideoDecodeH265DpbSlotInfoKHR();
            MarshalVkVideoDecodeH265DpbSlotInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
            VkDescriptorSetLayoutCreateInfo* p = new VkDescriptorSetLayoutCreateInfo();
            MarshalVkDescriptorSetLayoutCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: {
            VkDescriptorUpdateTemplateCreateInfo* p = new VkDescriptorUpdateTemplateCreateInfo();
            MarshalVkDescriptorUpdateTemplateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: {
            VkImageViewHandleInfoNVX* p = new VkImageViewHandleInfoNVX();
            MarshalVkImageViewHandleInfoNVX::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT: {
            VkIndirectExecutionSetPipelineInfoEXT* p = new VkIndirectExecutionSetPipelineInfoEXT();
            MarshalVkIndirectExecutionSetPipelineInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            VkAttachmentDescriptionStencilLayout* p = new VkAttachmentDescriptionStencilLayout();
            MarshalVkAttachmentDescriptionStencilLayout::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* p = new VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR: {
            VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* p = new VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR();
            MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR* p = new VkPhysicalDeviceAccelerationStructureFeaturesKHR();
            MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {
            VkWriteDescriptorSetInlineUniformBlock* p = new VkWriteDescriptorSetInlineUniformBlock();
            MarshalVkWriteDescriptorSetInlineUniformBlock::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO: {
            VkDeviceImageSubresourceInfo* p = new VkDeviceImageSubresourceInfo();
            MarshalVkDeviceImageSubresourceInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* p = new VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
            MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {
            VkValidationFlagsEXT* p = new VkValidationFlagsEXT();
            MarshalVkValidationFlagsEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: {
            VkDeviceAddressBindingCallbackDataEXT* p = new VkDeviceAddressBindingCallbackDataEXT();
            MarshalVkDeviceAddressBindingCallbackDataEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: {
            VkBindImageMemoryInfo* p = new VkBindImageMemoryInfo();
            MarshalVkBindImageMemoryInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {
            VkWriteDescriptorSetAccelerationStructureNV* p = new VkWriteDescriptorSetAccelerationStructureNV();
            MarshalVkWriteDescriptorSetAccelerationStructureNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: {
            VkExternalSemaphoreProperties* p = new VkExternalSemaphoreProperties();
            MarshalVkExternalSemaphoreProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: {
            VkQueueFamilyVideoPropertiesKHR* p = new VkQueueFamilyVideoPropertiesKHR();
            MarshalVkQueueFamilyVideoPropertiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
            VkSurfacePresentScalingCapabilitiesEXT* p = new VkSurfacePresentScalingCapabilitiesEXT();
            MarshalVkSurfacePresentScalingCapabilitiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
            VkPhysicalDeviceShaderTerminateInvocationFeatures* p = new VkPhysicalDeviceShaderTerminateInvocationFeatures();
            MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT: {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* p = new VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT();
            MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: {
            VkRayTracingPipelineInterfaceCreateInfoKHR* p = new VkRayTracingPipelineInterfaceCreateInfoKHR();
            MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV: {
            VkPhysicalDeviceOpticalFlowPropertiesNV* p = new VkPhysicalDeviceOpticalFlowPropertiesNV();
            MarshalVkPhysicalDeviceOpticalFlowPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            VkPhysicalDeviceProvokingVertexPropertiesEXT* p = new VkPhysicalDeviceProvokingVertexPropertiesEXT();
            MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: {
            VkPipelineViewportStateCreateInfo* p = new VkPipelineViewportStateCreateInfo();
            MarshalVkPipelineViewportStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: {
            VkDeviceGroupPresentCapabilitiesKHR* p = new VkDeviceGroupPresentCapabilitiesKHR();
            MarshalVkDeviceGroupPresentCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {
            VkPhysicalDeviceImageViewImageFormatInfoEXT* p = new VkPhysicalDeviceImageViewImageFormatInfoEXT();
            MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: {
            VkPhysicalDeviceRayTracingPropertiesNV* p = new VkPhysicalDeviceRayTracingPropertiesNV();
            MarshalVkPhysicalDeviceRayTracingPropertiesNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
            VkPhysicalDeviceSubgroupSizeControlFeatures* p = new VkPhysicalDeviceSubgroupSizeControlFeatures();
            MarshalVkPhysicalDeviceSubgroupSizeControlFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR: {
            VkBindVideoSessionMemoryInfoKHR* p = new VkBindVideoSessionMemoryInfoKHR();
            MarshalVkBindVideoSessionMemoryInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            VkPhysicalDeviceVulkan11Features* p = new VkPhysicalDeviceVulkan11Features();
            MarshalVkPhysicalDeviceVulkan11Features::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            VkPhysicalDeviceVulkanMemoryModelFeatures* p = new VkPhysicalDeviceVulkanMemoryModelFeatures();
            MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: {
            VkSubpassDescription2* p = new VkSubpassDescription2();
            MarshalVkSubpassDescription2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES: {
            VkPhysicalDeviceLineRasterizationFeatures* p = new VkPhysicalDeviceLineRasterizationFeatures();
            MarshalVkPhysicalDeviceLineRasterizationFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT* p = new VkPhysicalDeviceAddressBindingReportFeaturesEXT();
            MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR: {
            VkVideoDecodeCapabilitiesKHR* p = new VkVideoDecodeCapabilitiesKHR();
            MarshalVkVideoDecodeCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT: {
            VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* p = new VkPhysicalDeviceExtendedDynamicState3PropertiesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {
            VkWriteDescriptorSetAccelerationStructureKHR* p = new VkWriteDescriptorSetAccelerationStructureKHR();
            MarshalVkWriteDescriptorSetAccelerationStructureKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: {
            VkDeviceQueueInfo2* p = new VkDeviceQueueInfo2();
            MarshalVkDeviceQueueInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: {
            VkPerformanceMarkerInfoINTEL* p = new VkPerformanceMarkerInfoINTEL();
            MarshalVkPerformanceMarkerInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            VkPipelineTessellationDomainOriginStateCreateInfo* p = new VkPipelineTessellationDomainOriginStateCreateInfo();
            MarshalVkPipelineTessellationDomainOriginStateCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR: {
            VkVideoDecodeAV1ProfileInfoKHR* p = new VkVideoDecodeAV1ProfileInfoKHR();
            MarshalVkVideoDecodeAV1ProfileInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES: {
            VkPhysicalDeviceGlobalPriorityQueryFeatures* p = new VkPhysicalDeviceGlobalPriorityQueryFeatures();
            MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: {
            VkAccelerationStructureInfoNV* p = new VkAccelerationStructureInfoNV();
            MarshalVkAccelerationStructureInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: {
            VkSparseImageFormatProperties2* p = new VkSparseImageFormatProperties2();
            MarshalVkSparseImageFormatProperties2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: {
            VkFenceCreateInfo* p = new VkFenceCreateInfo();
            MarshalVkFenceCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: {
            VkPhysicalDeviceFaultFeaturesEXT* p = new VkPhysicalDeviceFaultFeaturesEXT();
            MarshalVkPhysicalDeviceFaultFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM: {
            VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* p = new VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM();
            MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: {
            VkCopyBufferToImageInfo2* p = new VkCopyBufferToImageInfo2();
            MarshalVkCopyBufferToImageInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI: {
            VkPhysicalDeviceHdrVividFeaturesHUAWEI* p = new VkPhysicalDeviceHdrVividFeaturesHUAWEI();
            MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR: {
            VkCalibratedTimestampInfoKHR* p = new VkCalibratedTimestampInfoKHR();
            MarshalVkCalibratedTimestampInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* p = new VkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            VkPhysicalDeviceTimelineSemaphoreFeatures* p = new VkPhysicalDeviceTimelineSemaphoreFeatures();
            MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            VkBindImageMemoryDeviceGroupInfo* p = new VkBindImageMemoryDeviceGroupInfo();
            MarshalVkBindImageMemoryDeviceGroupInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR: {
            VkVideoEncodeSessionParametersGetInfoKHR* p = new VkVideoEncodeSessionParametersGetInfoKHR();
            MarshalVkVideoEncodeSessionParametersGetInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: {
            VkImageAlignmentControlCreateInfoMESA* p = new VkImageAlignmentControlCreateInfoMESA();
            MarshalVkImageAlignmentControlCreateInfoMESA::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT* p = new VkPhysicalDeviceLegacyDitheringFeaturesEXT();
            MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: {
            VkGeneratedCommandsMemoryRequirementsInfoNV* p = new VkGeneratedCommandsMemoryRequirementsInfoNV();
            MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV: {
            VkLatencySleepInfoNV* p = new VkLatencySleepInfoNV();
            MarshalVkLatencySleepInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* p = new VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
            MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: {
            VkAcquireNextImageInfoKHR* p = new VkAcquireNextImageInfoKHR();
            MarshalVkAcquireNextImageInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures* p = new VkPhysicalDeviceUniformBufferStandardLayoutFeatures();
            MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT: {
            VkCopyMicromapToMemoryInfoEXT* p = new VkCopyMicromapToMemoryInfoEXT();
            MarshalVkCopyMicromapToMemoryInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* p = new VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM();
            MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
            VkPipelineCreateFlags2CreateInfo* p = new VkPipelineCreateFlags2CreateInfo();
            MarshalVkPipelineCreateFlags2CreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR: {
            VkVideoEncodeCapabilitiesKHR* p = new VkVideoEncodeCapabilitiesKHR();
            MarshalVkVideoEncodeCapabilitiesKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            VkDeviceGroupPresentInfoKHR* p = new VkDeviceGroupPresentInfoKHR();
            MarshalVkDeviceGroupPresentInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT* p = new VkPhysicalDeviceCustomBorderColorPropertiesEXT();
            MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT* p = new VkPhysicalDeviceImageViewMinLodFeaturesEXT();
            MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* p = new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
            MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: {
            VkFramebufferMixedSamplesCombinationNV* p = new VkFramebufferMixedSamplesCombinationNV();
            MarshalVkFramebufferMixedSamplesCombinationNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR: {
            VkVideoEncodeInfoKHR* p = new VkVideoEncodeInfoKHR();
            MarshalVkVideoEncodeInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            VkPhysicalDeviceBufferDeviceAddressFeatures* p = new VkPhysicalDeviceBufferDeviceAddressFeatures();
            MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: {
            VkPhysicalDeviceExternalSemaphoreInfo* p = new VkPhysicalDeviceExternalSemaphoreInfo();
            MarshalVkPhysicalDeviceExternalSemaphoreInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: {
            VkRayTracingShaderGroupCreateInfoKHR* p = new VkRayTracingShaderGroupCreateInfoKHR();
            MarshalVkRayTracingShaderGroupCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            VkAccelerationStructureCaptureDescriptorDataInfoEXT* p = new VkAccelerationStructureCaptureDescriptorDataInfoEXT();
            MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* p = new VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI();
            MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: {
            VkFramebufferAttachmentImageInfo* p = new VkFramebufferAttachmentImageInfo();
            MarshalVkFramebufferAttachmentImageInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: {
            VkBufferMemoryRequirementsInfo2* p = new VkBufferMemoryRequirementsInfo2();
            MarshalVkBufferMemoryRequirementsInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES: {
            VkPhysicalDeviceHostImageCopyFeatures* p = new VkPhysicalDeviceHostImageCopyFeatures();
            MarshalVkPhysicalDeviceHostImageCopyFeatures::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            VkVideoEncodeH265SessionParametersCreateInfoKHR* p = new VkVideoEncodeH265SessionParametersCreateInfoKHR();
            MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR: {
            VkVideoEncodeH264NaluSliceInfoKHR* p = new VkVideoEncodeH264NaluSliceInfoKHR();
            MarshalVkVideoEncodeH264NaluSliceInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: {
            VkInitializePerformanceApiInfoINTEL* p = new VkInitializePerformanceApiInfoINTEL();
            MarshalVkInitializePerformanceApiInfoINTEL::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {
            VkPerformanceQuerySubmitInfoKHR* p = new VkPerformanceQuerySubmitInfoKHR();
            MarshalVkPerformanceQuerySubmitInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: {
            VkPhysicalDeviceImageFormatInfo2* p = new VkPhysicalDeviceImageFormatInfo2();
            MarshalVkPhysicalDeviceImageFormatInfo2::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT: {
            VkPipelineViewportDepthClampControlCreateInfoEXT* p = new VkPipelineViewportDepthClampControlCreateInfoEXT();
            MarshalVkPipelineViewportDepthClampControlCreateInfoEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            VkExportFenceCreateInfo* p = new VkExportFenceCreateInfo();
            MarshalVkExportFenceCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {
            VkPipelineCompilerControlCreateInfoAMD* p = new VkPipelineCompilerControlCreateInfoAMD();
            MarshalVkPipelineCompilerControlCreateInfoAMD::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT* p = new VkPhysicalDeviceDiscardRectanglePropertiesEXT();
            MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: {
            VkImageViewCreateInfo* p = new VkImageViewCreateInfo();
            MarshalVkImageViewCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: {
            VkPipelineShaderStageCreateInfo* p = new VkPipelineShaderStageCreateInfo();
            MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM: {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* p = new VkPhysicalDeviceYcbcrDegammaFeaturesQCOM();
            MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            VkDeviceGroupBindSparseInfo* p = new VkDeviceGroupBindSparseInfo();
            MarshalVkDeviceGroupBindSparseInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            VkFragmentShadingRateAttachmentInfoKHR* p = new VkFragmentShadingRateAttachmentInfoKHR();
            MarshalVkFragmentShadingRateAttachmentInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR: {
            VkVideoEncodeAV1RateControlLayerInfoKHR* p = new VkVideoEncodeAV1RateControlLayerInfoKHR();
            MarshalVkVideoEncodeAV1RateControlLayerInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES: {
            VkPhysicalDeviceLineRasterizationProperties* p = new VkPhysicalDeviceLineRasterizationProperties();
            MarshalVkPhysicalDeviceLineRasterizationProperties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT: {
            VkPhysicalDeviceOpacityMicromapPropertiesEXT* p = new VkPhysicalDeviceOpacityMicromapPropertiesEXT();
            MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            VkPhysicalDeviceMaintenance3Properties* p = new VkPhysicalDeviceMaintenance3Properties();
            MarshalVkPhysicalDeviceMaintenance3Properties::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: {
            VkAccelerationStructureDeviceAddressInfoKHR* p = new VkAccelerationStructureDeviceAddressInfoKHR();
            MarshalVkAccelerationStructureDeviceAddressInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV: {
            VkPipelineIndirectDeviceAddressInfoNV* p = new VkPipelineIndirectDeviceAddressInfoNV();
            MarshalVkPipelineIndirectDeviceAddressInfoNV::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR: {
            VkVideoEncodeH265PictureInfoKHR* p = new VkVideoEncodeH265PictureInfoKHR();
            MarshalVkVideoEncodeH265PictureInfoKHR::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: {
            VkEventCreateInfo* p = new VkEventCreateInfo();
            MarshalVkEventCreateInfo::read(pBoxedInfo, memory, address, p);
            return (VkBaseOutStructure*)p;
        }
       default:
            kpanic("vulkanGetNextPtr not implemented for %d", type);
    }
}
void vulkanWriteNextPtr(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, const void* p) {
    if (address == 0) {
        return;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: {
            MarshalVkAccelerationStructureBuildSizesInfoKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureBuildSizesInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: {
            MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelinePropertiesFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_NV: {
            MarshalVkGeometryNV::write(pBoxedInfo, memory, address, (VkGeometryNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            MarshalVkPhysicalDeviceExternalImageFormatInfo::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExternalImageFormatInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES: {
            MarshalVkPhysicalDeviceIndexTypeUint8Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceIndexTypeUint8Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
            MarshalVkSwapchainPresentFenceInfoEXT::write(pBoxedInfo, memory, address, (VkSwapchainPresentFenceInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: {
            MarshalVkSparseImageMemoryRequirements2::write(pBoxedInfo, memory, address, (VkSparseImageMemoryRequirements2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkSwapchainCreateInfoKHR::write(pBoxedInfo, memory, address, (VkSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMemoryDecompressionPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM: {
            MarshalVkRenderPassStripeBeginInfoARM::write(pBoxedInfo, memory, address, (VkRenderPassStripeBeginInfoARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES: {
            MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderSubgroupRotateFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: {
            MarshalVkDisplayProperties2KHR::write(pBoxedInfo, memory, address, (VkDisplayProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV: {
            MarshalVkComputePipelineIndirectBufferInfoNV::write(pBoxedInfo, memory, address, (VkComputePipelineIndirectBufferInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: {
            MarshalVkDebugMarkerObjectTagInfoEXT::write(pBoxedInfo, memory, address, (VkDebugMarkerObjectTagInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV: {
            MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingValidationFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM: {
            MarshalVkSamplerCubicWeightsCreateInfoQCOM::write(pBoxedInfo, memory, address, (VkSamplerCubicWeightsCreateInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: {
            MarshalVkQueryPoolCreateInfo::write(pBoxedInfo, memory, address, (VkQueryPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: {
            MarshalVkRenderPassBeginInfo::write(pBoxedInfo, memory, address, (VkRenderPassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: {
            MarshalVkPhysicalDeviceMaintenance4Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance4Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineViewportShadingRateImageStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR: {
            MarshalVkVideoFormatQuantizationMapPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoFormatQuantizationMapPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR: {
            MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1QualityLevelPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            MarshalVkDeviceGroupCommandBufferBeginInfo::write(pBoxedInfo, memory, address, (VkDeviceGroupCommandBufferBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2: {
            MarshalVkSubresourceLayout2::write(pBoxedInfo, memory, address, (VkSubresourceLayout2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: {
            MarshalVkPhysicalDeviceExternalBufferInfo::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExternalBufferInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {
            MarshalVkFormatProperties3::write(pBoxedInfo, memory, address, (VkFormatProperties3*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: {
            MarshalVkFormatProperties2::write(pBoxedInfo, memory, address, (VkFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM: {
            MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRenderPassStripedFeaturesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            MarshalVkPhysicalDeviceVariablePointersFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVariablePointersFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: {
            MarshalVkGeometryAABBNV::write(pBoxedInfo, memory, address, (VkGeometryAABBNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT: {
            MarshalVkShaderModuleIdentifierEXT::write(pBoxedInfo, memory, address, (VkShaderModuleIdentifierEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
            MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {
            MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT::write(pBoxedInfo, memory, address, (VkRenderingFragmentDensityMapAttachmentInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT: {
            MarshalVkIndirectCommandsLayoutCreateInfoEXT::write(pBoxedInfo, memory, address, (VkIndirectCommandsLayoutCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            MarshalVkValidationCacheCreateInfoEXT::write(pBoxedInfo, memory, address, (VkValidationCacheCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeAV1SessionCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1SessionCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES: {
            MarshalVkPhysicalDeviceMaintenance5Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance5Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: {
            MarshalVkVideoDecodeH265PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: {
            MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: {
            MarshalVkPerformanceStreamMarkerInfoINTEL::write(pBoxedInfo, memory, address, (VkPerformanceStreamMarkerInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: {
            MarshalVkDebugMarkerObjectNameInfoEXT::write(pBoxedInfo, memory, address, (VkDebugMarkerObjectNameInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: {
            MarshalVkDeviceImageMemoryRequirements::write(pBoxedInfo, memory, address, (VkDeviceImageMemoryRequirements*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
            MarshalVkCommandBufferInheritanceRenderingInfo::write(pBoxedInfo, memory, address, (VkCommandBufferInheritanceRenderingInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            MarshalVkDeviceGroupDeviceCreateInfo::write(pBoxedInfo, memory, address, (VkDeviceGroupDeviceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: {
            MarshalVkRenderPassCreationControlEXT::write(pBoxedInfo, memory, address, (VkRenderPassCreationControlEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES: {
            MarshalVkPhysicalDeviceMaintenance6Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance6Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
            MarshalVkPipelineRenderingCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineRenderingCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: {
            MarshalVkRayTracingPipelineCreateInfoKHR::write(pBoxedInfo, memory, address, (VkRayTracingPipelineCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            MarshalVkBufferOpaqueCaptureAddressCreateInfo::write(pBoxedInfo, memory, address, (VkBufferOpaqueCaptureAddressCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2: {
            MarshalVkImageSubresource2::write(pBoxedInfo, memory, address, (VkImageSubresource2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: {
            MarshalVkPipelineVertexInputStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineVertexInputStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceMeshShaderPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMeshShaderPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {
            MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264SessionParametersAddInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: {
            MarshalVkPipelineDepthStencilStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineDepthStencilStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: {
            MarshalVkDeviceQueueCreateInfo::write(pBoxedInfo, memory, address, (VkDeviceQueueCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryInstancesDataKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureGeometryInstancesDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: {
            MarshalVkDisplayPlaneCapabilities2KHR::write(pBoxedInfo, memory, address, (VkDisplayPlaneCapabilities2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: {
            MarshalVkAccelerationStructureCreateInfoKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: {
            MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            MarshalVkPhysicalDeviceFloatControlsProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFloatControlsProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV: {
            MarshalVkOutOfBandQueueTypeInfoNV::write(pBoxedInfo, memory, address, (VkOutOfBandQueueTypeInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {
            MarshalVkValidationFeaturesEXT::write(pBoxedInfo, memory, address, (VkValidationFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR: {
            MarshalVkVideoDecodeAV1CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeAV1CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR: {
            MarshalVkVideoEncodeH264ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkImageMemoryRequirementsInfo2::write(pBoxedInfo, memory, address, (VkImageMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: {
            MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::write(pBoxedInfo, memory, address, (VkOpaqueCaptureDescriptorDataCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO: {
            MarshalVkCopyImageToImageInfo::write(pBoxedInfo, memory, address, (VkCopyImageToImageInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES: {
            MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDynamicRenderingLocalReadFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: {
            MarshalVkAccelerationStructureMemoryRequirementsInfoNV::write(pBoxedInfo, memory, address, (VkAccelerationStructureMemoryRequirementsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: {
            MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::write(pBoxedInfo, memory, address, (VkOpticalFlowSessionCreatePrivateDataInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: {
            MarshalVkRayTracingShaderGroupCreateInfoNV::write(pBoxedInfo, memory, address, (VkRayTracingShaderGroupCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: {
            MarshalVkDebugReportCallbackCreateInfoEXT::write(pBoxedInfo, memory, address, (VkDebugReportCallbackCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrix2FeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {
            MarshalVkSwapchainPresentModesCreateInfoEXT::write(pBoxedInfo, memory, address, (VkSwapchainPresentModesCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: {
            MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM::write(pBoxedInfo, memory, address, (VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: {
            MarshalVkPhysicalDeviceToolProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceToolProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkImageSparseMemoryRequirementsInfo2::write(pBoxedInfo, memory, address, (VkImageSparseMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
            MarshalVkWriteDescriptorSet::write(pBoxedInfo, memory, address, (VkWriteDescriptorSet*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            MarshalVkPhysicalDeviceTimelineSemaphoreProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTimelineSemaphoreProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV: {
            MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDevicePerStageDescriptorSetFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: {
            MarshalVkRenderPassCreateInfo::write(pBoxedInfo, memory, address, (VkRenderPassCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR: {
            MarshalVkVideoEncodeH265QualityLevelPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265QualityLevelPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM: {
            MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRenderPassStripedPropertiesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: {
            MarshalVkAccelerationStructureCreateInfoNV::write(pBoxedInfo, memory, address, (VkAccelerationStructureCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
            MarshalVkDedicatedAllocationImageCreateInfoNV::write(pBoxedInfo, memory, address, (VkDedicatedAllocationImageCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthClampControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {
            MarshalVkSwapchainPresentModeInfoEXT::write(pBoxedInfo, memory, address, (VkSwapchainPresentModeInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
            MarshalVkMemoryBarrier::write(pBoxedInfo, memory, address, (VkMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: {
            MarshalVkFrameBoundaryEXT::write(pBoxedInfo, memory, address, (VkFrameBoundaryEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            MarshalVkBindImagePlaneMemoryInfo::write(pBoxedInfo, memory, address, (VkBindImagePlaneMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
            MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceColorWriteEnableFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: {
            MarshalVkCommandBufferSubmitInfo::write(pBoxedInfo, memory, address, (VkCommandBufferSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO: {
            MarshalVkPushConstantsInfo::write(pBoxedInfo, memory, address, (VkPushConstantsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT: {
            MarshalVkWriteIndirectExecutionSetPipelineEXT::write(pBoxedInfo, memory, address, (VkWriteIndirectExecutionSetPipelineEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceRobustness2FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRobustness2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT: {
            MarshalVkCopyMemoryToMicromapInfoEXT::write(pBoxedInfo, memory, address, (VkCopyMemoryToMicromapInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: {
            MarshalVkVideoDecodeH264ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineRasterizationStateStreamCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: {
            MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD: {
            MarshalVkPhysicalDeviceAntiLagFeaturesAMD::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAntiLagFeaturesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageModulationStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineCoverageModulationStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV: {
            MarshalVkSwapchainLatencyCreateInfoNV::write(pBoxedInfo, memory, address, (VkSwapchainLatencyCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: {
            MarshalVkDebugMarkerMarkerInfoEXT::write(pBoxedInfo, memory, address, (VkDebugMarkerMarkerInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT: {
            MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT::write(pBoxedInfo, memory, address, (VkBindDescriptorBufferEmbeddedSamplersInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO: {
            MarshalVkPushDescriptorSetInfo::write(pBoxedInfo, memory, address, (VkPushDescriptorSetInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            MarshalVkPhysicalDeviceProtectedMemoryFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceProtectedMemoryFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: {
            MarshalVkPhysicalDeviceMemoryProperties2::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMemoryProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorBufferPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            MarshalVkPhysicalDeviceMultiviewFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiviewFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoEncodeH265DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: {
            MarshalVkVideoProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR: {
            MarshalVkVideoCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {
            MarshalVkAttachmentSampleCountInfoAMD::write(pBoxedInfo, memory, address, (VkAttachmentSampleCountInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            MarshalVkBufferCaptureDescriptorDataInfoEXT::write(pBoxedInfo, memory, address, (VkBufferCaptureDescriptorDataInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {
            MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExclusiveScissorFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: {
            MarshalVkVertexInputAttributeDescription2EXT::write(pBoxedInfo, memory, address, (VkVertexInputAttributeDescription2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
            MarshalVkDescriptorSetAllocateInfo::write(pBoxedInfo, memory, address, (VkDescriptorSetAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR: {
            MarshalVkPipelineCreateInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCubicWeightsFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: {
            MarshalVkImageCreateInfo::write(pBoxedInfo, memory, address, (VkImageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR: {
            MarshalVkVideoPictureResourceInfoKHR::write(pBoxedInfo, memory, address, (VkVideoPictureResourceInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePCIBusInfoPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: {
            MarshalVkPipelineExecutablePropertiesKHR::write(pBoxedInfo, memory, address, (VkPipelineExecutablePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            MarshalVkDeviceGroupRenderPassBeginInfo::write(pBoxedInfo, memory, address, (VkDeviceGroupRenderPassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: {
            MarshalVkAcquireProfilingLockInfoKHR::write(pBoxedInfo, memory, address, (VkAcquireProfilingLockInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: {
            MarshalVkCopyDescriptorSet::write(pBoxedInfo, memory, address, (VkCopyDescriptorSet*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI: {
            MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR: {
            MarshalVkVideoEncodeRateControlLayerInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeRateControlLayerInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAccelerationStructurePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrixPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            MarshalVkSamplerReductionModeCreateInfo::write(pBoxedInfo, memory, address, (VkSamplerReductionModeCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM: {
            MarshalVkSamplerBlockMatchWindowCreateInfoQCOM::write(pBoxedInfo, memory, address, (VkSamplerBlockMatchWindowCreateInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::write(pBoxedInfo, memory, address, (VkDescriptorSetVariableDescriptorCountLayoutSupport*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: {
            MarshalVkCopyMemoryToAccelerationStructureInfoKHR::write(pBoxedInfo, memory, address, (VkCopyMemoryToAccelerationStructureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: {
            MarshalVkPerformanceConfigurationAcquireInfoINTEL::write(pBoxedInfo, memory, address, (VkPerformanceConfigurationAcquireInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
            MarshalVkImageMemoryBarrier::write(pBoxedInfo, memory, address, (VkImageMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            MarshalVkExternalMemoryBufferCreateInfo::write(pBoxedInfo, memory, address, (VkExternalMemoryBufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: {
            MarshalVkIndirectCommandsLayoutTokenNV::write(pBoxedInfo, memory, address, (VkIndirectCommandsLayoutTokenNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            MarshalVkQueueFamilyCheckpointProperties2NV::write(pBoxedInfo, memory, address, (VkQueueFamilyCheckpointProperties2NV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV: {
            MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: {
            MarshalVkBindAccelerationStructureMemoryInfoNV::write(pBoxedInfo, memory, address, (VkBindAccelerationStructureMemoryInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR: {
            MarshalVkVideoEncodeH264QualityLevelPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264QualityLevelPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            MarshalVkPhysicalDevice4444FormatsFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevice4444FormatsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX: {
            MarshalVkCuLaunchInfoNVX::write(pBoxedInfo, memory, address, (VkCuLaunchInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            MarshalVkPresentRegionsKHR::write(pBoxedInfo, memory, address, (VkPresentRegionsKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT: {
            MarshalVkShaderCreateInfoEXT::write(pBoxedInfo, memory, address, (VkShaderCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: {
            MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: {
            MarshalVkImageCompressionControlEXT::write(pBoxedInfo, memory, address, (VkImageCompressionControlEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV: {
            MarshalVkOpticalFlowSessionCreateInfoNV::write(pBoxedInfo, memory, address, (VkOpticalFlowSessionCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            MarshalVkExportSemaphoreCreateInfo::write(pBoxedInfo, memory, address, (VkExportSemaphoreCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR: {
            MarshalVkVideoEncodeH265SessionParametersGetInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265SessionParametersGetInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoEncodeAV1DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR: {
            MarshalVkVideoEncodeQuantizationMapInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeQuantizationMapInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
            MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: {
            MarshalVkPipelineRasterizationStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineRasterizationStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: {
            MarshalVkImageMemoryBarrier2::write(pBoxedInfo, memory, address, (VkImageMemoryBarrier2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrixPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {
            MarshalVkSwapchainCounterCreateInfoEXT::write(pBoxedInfo, memory, address, (VkSwapchainCounterCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTilePropertiesFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderTileImagePropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM: {
            MarshalVkImageViewSampleWeightCreateInfoQCOM::write(pBoxedInfo, memory, address, (VkImageViewSampleWeightCreateInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: {
            MarshalVkMultisamplePropertiesEXT::write(pBoxedInfo, memory, address, (VkMultisamplePropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR: {
            MarshalVkVideoEncodeAV1RateControlInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1RateControlInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM: {
            MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageProcessing2PropertiesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {
            MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: {
            MarshalVkBufferImageCopy2::write(pBoxedInfo, memory, address, (VkBufferImageCopy2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
            MarshalVkMemoryPriorityAllocateInfoEXT::write(pBoxedInfo, memory, address, (VkMemoryPriorityAllocateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: {
            MarshalVkSubpassResolvePerformanceQueryEXT::write(pBoxedInfo, memory, address, (VkSubpassResolvePerformanceQueryEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: {
            MarshalVkCommandBufferBeginInfo::write(pBoxedInfo, memory, address, (VkCommandBufferBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            MarshalVkPhysicalDeviceShaderDrawParametersFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderDrawParametersFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            MarshalVkPhysicalDeviceMultiviewProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiviewProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT: {
            MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLayeredDriverPropertiesMSFT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthClipControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: {
            MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSamplerFilterMinmaxProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: {
            MarshalVkPhysicalDevicePresentBarrierFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDevicePresentBarrierFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeH264CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: {
            MarshalVkSwapchainPresentBarrierCreateInfoNV::write(pBoxedInfo, memory, address, (VkSwapchainPresentBarrierCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: {
            MarshalVkImageFormatProperties2::write(pBoxedInfo, memory, address, (VkImageFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorBufferFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: {
            MarshalVkPhysicalDeviceOpticalFlowFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceOpticalFlowFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCustomBorderColorFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoDecodeAV1DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeAV1DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            MarshalVkImageViewUsageCreateInfo::write(pBoxedInfo, memory, address, (VkImageViewUsageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::write(pBoxedInfo, memory, address, (VkDescriptorSetVariableDescriptorCountAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {
            MarshalVkAccelerationStructureMotionInfoNV::write(pBoxedInfo, memory, address, (VkAccelerationStructureMotionInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR: {
            MarshalVkPipelineBinaryCreateInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineBinaryCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSampleLocationsPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMeshShaderFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMeshShaderFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COPY_2: {
            MarshalVkBufferCopy2::write(pBoxedInfo, memory, address, (VkBufferCopy2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV: {
            MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT: {
            MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceNestedCommandBufferFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: {
            MarshalVkDescriptorPoolCreateInfo::write(pBoxedInfo, memory, address, (VkDescriptorPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            MarshalVkImageStencilUsageCreateInfo::write(pBoxedInfo, memory, address, (VkImageStencilUsageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {
            MarshalVkCommandBufferInheritanceViewportScissorInfoNV::write(pBoxedInfo, memory, address, (VkCommandBufferInheritanceViewportScissorInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: {
            MarshalVkBlitImageCubicWeightsInfoQCOM::write(pBoxedInfo, memory, address, (VkBlitImageCubicWeightsInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: {
            MarshalVkDebugUtilsObjectTagInfoEXT::write(pBoxedInfo, memory, address, (VkDebugUtilsObjectTagInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: {
            MarshalVkPipelineExecutableStatisticKHR::write(pBoxedInfo, memory, address, (VkPipelineExecutableStatisticKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
            MarshalVkPhysicalDevicePresentWaitFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePresentWaitFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: {
            MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: {
            MarshalVkSurfaceCapabilities2EXT::write(pBoxedInfo, memory, address, (VkSurfaceCapabilities2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: {
            MarshalVkPresentIdKHR::write(pBoxedInfo, memory, address, (VkPresentIdKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR: {
            MarshalVkVideoInlineQueryInfoKHR::write(pBoxedInfo, memory, address, (VkVideoInlineQueryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: {
            MarshalVkMemoryHostPointerPropertiesEXT::write(pBoxedInfo, memory, address, (VkMemoryHostPointerPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
            MarshalVkMemoryBarrier2::write(pBoxedInfo, memory, address, (VkMemoryBarrier2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
            MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderIntegerDotProductFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV: {
            MarshalVkCudaModuleCreateInfoNV::write(pBoxedInfo, memory, address, (VkCudaModuleCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
            MarshalVkPhysicalDevicePresentIdFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePresentIdFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: {
            MarshalVkVideoEncodeQualityLevelInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeQualityLevelInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA: {
            MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageAlignmentControlPropertiesMESA*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR: {
            MarshalVkVideoReferenceSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoReferenceSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR: {
            MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265NaluSliceSegmentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM: {
            MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineViewportExclusiveScissorStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR: {
            MarshalVkVideoDecodeH264CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {
            MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::write(pBoxedInfo, memory, address, (VkSubpassShadingPipelineCreateInfoHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {
            MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::write(pBoxedInfo, memory, address, (VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: {
            MarshalVkCommandPoolCreateInfo::write(pBoxedInfo, memory, address, (VkCommandPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR: {
            MarshalVkPipelineBinaryInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineBinaryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShadingRateKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
            MarshalVkGraphicsPipelineCreateInfo::write(pBoxedInfo, memory, address, (VkGraphicsPipelineCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            MarshalVkMemoryDedicatedAllocateInfo::write(pBoxedInfo, memory, address, (VkMemoryDedicatedAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            MarshalVkAttachmentReferenceStencilLayout::write(pBoxedInfo, memory, address, (VkAttachmentReferenceStencilLayout*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {
            MarshalVkRenderPassSampleLocationsBeginInfoEXT::write(pBoxedInfo, memory, address, (VkRenderPassSampleLocationsBeginInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            MarshalVkExternalMemoryImageCreateInfo::write(pBoxedInfo, memory, address, (VkExternalMemoryImageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineSampleLocationsStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineSampleLocationsStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {
            MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::write(pBoxedInfo, memory, address, (VkCommandBufferInheritanceConditionalRenderingInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: {
            MarshalVkVideoEncodeRateControlInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeRateControlInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: {
            MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {
            MarshalVkExportMemoryAllocateInfoNV::write(pBoxedInfo, memory, address, (VkExportMemoryAllocateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineRasterizationConservativeStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {
            MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShadingRateImageFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {
            MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: {
            MarshalVkQueueFamilyProperties2::write(pBoxedInfo, memory, address, (VkQueueFamilyProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            MarshalVkPhysicalDeviceImagelessFramebufferFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImagelessFramebufferFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR: {
            MarshalVkVideoDecodeInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: {
            MarshalVkVertexInputBindingDescription2EXT::write(pBoxedInfo, memory, address, (VkVertexInputBindingDescription2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: {
            MarshalVkCopyAccelerationStructureInfoKHR::write(pBoxedInfo, memory, address, (VkCopyAccelerationStructureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
            MarshalVkDebugUtilsObjectNameInfoEXT::write(pBoxedInfo, memory, address, (VkDebugUtilsObjectNameInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {
            MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceScalarBlockLayoutFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO: {
            MarshalVkRenderingInputAttachmentIndexInfo::write(pBoxedInfo, memory, address, (VkRenderingInputAttachmentIndexInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: {
            MarshalVkSurfacePresentModeEXT::write(pBoxedInfo, memory, address, (VkSurfacePresentModeEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::write(pBoxedInfo, memory, address, (VkMemoryOpaqueCaptureAddressAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {
            MarshalVkImageViewASTCDecodeModeEXT::write(pBoxedInfo, memory, address, (VkImageViewASTCDecodeModeEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrixFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO: {
            MarshalVkDeviceQueueGlobalPriorityCreateInfo::write(pBoxedInfo, memory, address, (VkDeviceQueueGlobalPriorityCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_BLIT_2: {
            MarshalVkImageBlit2::write(pBoxedInfo, memory, address, (VkImageBlit2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: {
            MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMemoryDecompressionFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: {
            MarshalVkPipelineDynamicStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineDynamicStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            MarshalVkProtectedSubmitInfo::write(pBoxedInfo, memory, address, (VkProtectedSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR: {
            MarshalVkPipelineBinaryKeyKHR::write(pBoxedInfo, memory, address, (VkPipelineBinaryKeyKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS: {
            MarshalVkBindMemoryStatus::write(pBoxedInfo, memory, address, (VkBindMemoryStatus*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: {
            MarshalVkGraphicsShaderGroupCreateInfoNV::write(pBoxedInfo, memory, address, (VkGraphicsShaderGroupCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR: {
            MarshalVkVideoEncodeAV1ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR: {
            MarshalVkVideoCodingControlInfoKHR::write(pBoxedInfo, memory, address, (VkVideoCodingControlInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeAV1CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageToColorStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineCoverageToColorStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR: {
            MarshalVkPhysicalDeviceVideoFormatInfoKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVideoFormatInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            MarshalVkRenderPassMultiviewCreateInfo::write(pBoxedInfo, memory, address, (VkRenderPassMultiviewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: {
            MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: {
            MarshalVkPipelineViewportDepthClipControlCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineViewportDepthClipControlCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::write(pBoxedInfo, memory, address, (VkDescriptorSetLayoutBindingFlagsCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            MarshalVkSubpassDescriptionDepthStencilResolve::write(pBoxedInfo, memory, address, (VkSubpassDescriptionDepthStencilResolve*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: {
            MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::write(pBoxedInfo, memory, address, (VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR: {
            MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineBinaryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX: {
            MarshalVkCuModuleTexturingModeCreateInfoNVX::write(pBoxedInfo, memory, address, (VkCuModuleTexturingModeCreateInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM: {
            MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSchedulingControlsFeaturesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {
            MarshalVkDevicePrivateDataCreateInfo::write(pBoxedInfo, memory, address, (VkDevicePrivateDataCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES: {
            MarshalVkPhysicalDeviceMaintenance6Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance6Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {
            MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCornerSampledImageFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            MarshalVkPhysicalDeviceDepthStencilResolveProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthStencilResolveProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: {
            MarshalVkBufferCreateInfo::write(pBoxedInfo, memory, address, (VkBufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: {
            MarshalVkExternalFenceProperties::write(pBoxedInfo, memory, address, (VkExternalFenceProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {
            MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            MarshalVkImageCaptureDescriptorDataInfoEXT::write(pBoxedInfo, memory, address, (VkImageCaptureDescriptorDataInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR: {
            MarshalVkVideoFormatPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoFormatPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT: {
            MarshalVkMicromapVersionInfoEXT::write(pBoxedInfo, memory, address, (VkMicromapVersionInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE: {
            MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::write(pBoxedInfo, memory, address, (VkDescriptorSetLayoutHostMappingInfoVALVE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShadingRateImagePropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceNestedCommandBufferPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: {
            MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV: {
            MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCudaKernelLaunchFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR: {
            MarshalVkVideoSessionParametersUpdateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoSessionParametersUpdateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO: {
            MarshalVkRenderingAttachmentLocationInfo::write(pBoxedInfo, memory, address, (VkRenderingAttachmentLocationInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: {
            MarshalVkImageCompressionPropertiesEXT::write(pBoxedInfo, memory, address, (VkImageCompressionPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeH265SessionCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265SessionCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES: {
            MarshalVkPhysicalDevicePipelineRobustnessProperties::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineRobustnessProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO: {
            MarshalVkMemoryMapInfo::write(pBoxedInfo, memory, address, (VkMemoryMapInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT: {
            MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES: {
            MarshalVkPhysicalDevicePushDescriptorProperties::write(pBoxedInfo, memory, address, (VkPhysicalDevicePushDescriptorProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: {
            MarshalVkSemaphoreSubmitInfo::write(pBoxedInfo, memory, address, (VkSemaphoreSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: {
            MarshalVkAccelerationStructureVersionInfoKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureVersionInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: {
            MarshalVkDisplayPlaneInfo2KHR::write(pBoxedInfo, memory, address, (VkDisplayPlaneInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: {
            MarshalVkRenderPassSubpassFeedbackCreateInfoEXT::write(pBoxedInfo, memory, address, (VkRenderPassSubpassFeedbackCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {
            MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265SessionParametersAddInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
            MarshalVkDebugUtilsMessengerCallbackDataEXT::write(pBoxedInfo, memory, address, (VkDebugUtilsMessengerCallbackDataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            MarshalVkMemoryDedicatedRequirements::write(pBoxedInfo, memory, address, (VkMemoryDedicatedRequirements*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES: {
            MarshalVkPhysicalDeviceVulkan14Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan14Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            MarshalVkPhysicalDeviceHostQueryResetFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceHostQueryResetFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            MarshalVkSamplerCaptureDescriptorDataInfoEXT::write(pBoxedInfo, memory, address, (VkSamplerCaptureDescriptorDataInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {
            MarshalVkExternalMemoryImageCreateInfoNV::write(pBoxedInfo, memory, address, (VkExternalMemoryImageCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderTileImageFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
            MarshalVkPhysicalDeviceImageRobustnessFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageRobustnessFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: {
            MarshalVkDisplayPlaneProperties2KHR::write(pBoxedInfo, memory, address, (VkDisplayPlaneProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: {
            MarshalVkBindBufferMemoryInfo::write(pBoxedInfo, memory, address, (VkBindBufferMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: {
            MarshalVkImageViewMinLodCreateInfoEXT::write(pBoxedInfo, memory, address, (VkImageViewMinLodCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: {
            MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::write(pBoxedInfo, memory, address, (VkDeviceMemoryOpaqueCaptureAddressInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_APPLICATION_INFO: {
            MarshalVkApplicationInfo::write(pBoxedInfo, memory, address, (VkApplicationInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceRobustness2PropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRobustness2PropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {
            MarshalVkRenderPassTransformBeginInfoQCOM::write(pBoxedInfo, memory, address, (VkRenderPassTransformBeginInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: {
            MarshalVkPipelineMultisampleStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineMultisampleStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
            MarshalVkPipelineCreationFeedbackCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineCreationFeedbackCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM: {
            MarshalVkDeviceQueueShaderCoreControlCreateInfoARM::write(pBoxedInfo, memory, address, (VkDeviceQueueShaderCoreControlCreateInfoARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {
            MarshalVkQueryPoolPerformanceCreateInfoKHR::write(pBoxedInfo, memory, address, (VkQueryPoolPerformanceCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {
            MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            MarshalVkPhysicalDeviceDriverProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDriverProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
            MarshalVkPipelineColorWriteCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineColorWriteCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: {
            MarshalVkRenderPassCreateInfo2::write(pBoxedInfo, memory, address, (VkRenderPassCreateInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: {
            MarshalVkExternalBufferProperties::write(pBoxedInfo, memory, address, (VkExternalBufferProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            MarshalVkSamplerCustomBorderColorCreateInfoEXT::write(pBoxedInfo, memory, address, (VkSamplerCustomBorderColorCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: {
            MarshalVkMemoryRequirements2::write(pBoxedInfo, memory, address, (VkMemoryRequirements2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMemoryBudgetPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT: {
            MarshalVkDescriptorAddressInfoEXT::write(pBoxedInfo, memory, address, (VkDescriptorAddressInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: {
            MarshalVkPhysicalDeviceShaderIntegerDotProductProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderIntegerDotProductProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR: {
            MarshalVkPipelineBinaryDataInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineBinaryDataInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT: {
            MarshalVkDescriptorGetInfoEXT::write(pBoxedInfo, memory, address, (VkDescriptorGetInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
            MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264SessionParametersFeedbackInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVertexAttributeDivisorFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            MarshalVkRenderPassInputAttachmentAspectCreateInfo::write(pBoxedInfo, memory, address, (VkRenderPassInputAttachmentAspectCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiDrawFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {
            MarshalVkBufferDeviceAddressCreateInfoEXT::write(pBoxedInfo, memory, address, (VkBufferDeviceAddressCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: {
            MarshalVkPhysicalDeviceProperties2::write(pBoxedInfo, memory, address, (VkPhysicalDeviceProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT: {
            MarshalVkSetDescriptorBufferOffsetsInfoEXT::write(pBoxedInfo, memory, address, (VkSetDescriptorBufferOffsetsInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE: {
            MarshalVkSubresourceHostMemcpySize::write(pBoxedInfo, memory, address, (VkSubresourceHostMemcpySize*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264QuantizationMapCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT: {
            MarshalVkIndirectExecutionSetShaderInfoEXT::write(pBoxedInfo, memory, address, (VkIndirectExecutionSetShaderInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES: {
            MarshalVkQueueFamilyGlobalPriorityProperties::write(pBoxedInfo, memory, address, (VkQueueFamilyGlobalPriorityProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: {
            MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: {
            MarshalVkDisplayModeProperties2KHR::write(pBoxedInfo, memory, address, (VkDisplayModeProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: {
            MarshalVkPhysicalDeviceSubgroupSizeControlProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubgroupSizeControlProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthBiasControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT: {
            MarshalVkDeviceFaultCountsEXT::write(pBoxedInfo, memory, address, (VkDeviceFaultCountsEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT: {
            MarshalVkImageViewSlicedCreateInfoEXT::write(pBoxedInfo, memory, address, (VkImageViewSlicedCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO: {
            MarshalVkPipelineVertexInputDivisorStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineVertexInputDivisorStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: {
            MarshalVkPerformanceCounterKHR::write(pBoxedInfo, memory, address, (VkPerformanceCounterKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {
            MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR: {
            MarshalVkVideoDecodeAV1PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeAV1PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            MarshalVkPhysicalDevicePointClippingProperties::write(pBoxedInfo, memory, address, (VkPhysicalDevicePointClippingProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: {
            MarshalVkImageResolve2::write(pBoxedInfo, memory, address, (VkImageResolve2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR: {
            MarshalVkVideoBeginCodingInfoKHR::write(pBoxedInfo, memory, address, (VkVideoBeginCodingInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: {
            MarshalVkMutableDescriptorTypeCreateInfoEXT::write(pBoxedInfo, memory, address, (VkMutableDescriptorTypeCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: {
            MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR::write(pBoxedInfo, memory, address, (VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {
            MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            MarshalVkImageFormatListCreateInfo::write(pBoxedInfo, memory, address, (VkImageFormatListCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
            MarshalVkDedicatedAllocationMemoryAllocateInfoNV::write(pBoxedInfo, memory, address, (VkDedicatedAllocationMemoryAllocateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            MarshalVkPhysicalDevice16BitStorageFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevice16BitStorageFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
            MarshalVkSubmitInfo::write(pBoxedInfo, memory, address, (VkSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR: {
            MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoFormatAV1QuantizationMapPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeAV1SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageCompressionControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoDecodeH264DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT: {
            MarshalVkGeneratedCommandsInfoEXT::write(pBoxedInfo, memory, address, (VkGeneratedCommandsInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: {
            MarshalVkDebugUtilsMessengerCreateInfoEXT::write(pBoxedInfo, memory, address, (VkDebugUtilsMessengerCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: {
            MarshalVkSubpassDependency2::write(pBoxedInfo, memory, address, (VkSubpassDependency2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: {
            MarshalVkCopyImageToBufferInfo2::write(pBoxedInfo, memory, address, (VkCopyImageToBufferInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {
            MarshalVkTextureLODGatherFormatPropertiesAMD::write(pBoxedInfo, memory, address, (VkTextureLODGatherFormatPropertiesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR: {
            MarshalVkVideoFormatH265QuantizationMapPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoFormatH265QuantizationMapPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG: {
            MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: {
            MarshalVkDeviceEventInfoEXT::write(pBoxedInfo, memory, address, (VkDeviceEventInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV: {
            MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRawAccessChainsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR: {
            MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVideoEncodeAV1FeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {
            MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::write(pBoxedInfo, memory, address, (VkRenderPassFragmentDensityMapCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: {
            MarshalVkDisplayEventInfoEXT::write(pBoxedInfo, memory, address, (VkDisplayEventInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            MarshalVkShaderModuleValidationCacheCreateInfoEXT::write(pBoxedInfo, memory, address, (VkShaderModuleValidationCacheCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: {
            MarshalVkPipelineInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: {
            MarshalVkSubpassBeginInfo::write(pBoxedInfo, memory, address, (VkSubpassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT: {
            MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT::write(pBoxedInfo, memory, address, (VkGeneratedCommandsMemoryRequirementsInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR: {
            MarshalVkVideoEncodeH264SessionParametersGetInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264SessionParametersGetInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: {
            MarshalVkCheckpointDataNV::write(pBoxedInfo, memory, address, (VkCheckpointDataNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: {
            MarshalVkAttachmentDescription2::write(pBoxedInfo, memory, address, (VkAttachmentDescription2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COPY_2: {
            MarshalVkImageCopy2::write(pBoxedInfo, memory, address, (VkImageCopy2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR: {
            MarshalVkVideoEncodeQualityLevelPropertiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeQualityLevelPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            MarshalVkPhysicalDeviceShaderAtomicInt64Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderAtomicInt64Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
            MarshalVkBufferMemoryBarrier::write(pBoxedInfo, memory, address, (VkBufferMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV: {
            MarshalVkSetLatencyMarkerInfoNV::write(pBoxedInfo, memory, address, (VkSetLatencyMarkerInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {
            MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceConditionalRenderingFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDepthClipEnableFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: {
            MarshalVkBufferDeviceAddressInfo::write(pBoxedInfo, memory, address, (VkBufferDeviceAddressInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {
            MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderImageFootprintFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR: {
            MarshalVkVideoEncodeH265RateControlInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265RateControlInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT: {
            MarshalVkLayerSettingsCreateInfoEXT::write(pBoxedInfo, memory, address, (VkLayerSettingsCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {
            MarshalVkSampleLocationsInfoEXT::write(pBoxedInfo, memory, address, (VkSampleLocationsInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFrameBoundaryFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES: {
            MarshalVkPhysicalDeviceMaintenance5Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance5Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {
            MarshalVkDisplayPresentInfoKHR::write(pBoxedInfo, memory, address, (VkDisplayPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: {
            MarshalVkAccelerationStructureGeometryKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureGeometryKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR: {
            MarshalVkVideoSessionCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoSessionCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineRasterizationDepthClipStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryAabbsDataKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureGeometryAabbsDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM: {
            MarshalVkPhysicalDeviceShaderCorePropertiesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderCorePropertiesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: {
            MarshalVkPrivateDataSlotCreateInfo::write(pBoxedInfo, memory, address, (VkPrivateDataSlotCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV: {
            MarshalVkDisplaySurfaceStereoCreateInfoNV::write(pBoxedInfo, memory, address, (VkDisplaySurfaceStereoCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV: {
            MarshalVkOpticalFlowExecuteInfoNV::write(pBoxedInfo, memory, address, (VkOpticalFlowExecuteInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {
            MarshalVkPhysicalDeviceMeshShaderFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMeshShaderFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: {
            MarshalVkCuFunctionCreateInfoNVX::write(pBoxedInfo, memory, address, (VkCuFunctionCreateInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
            MarshalVkSurfacePresentModeCompatibilityEXT::write(pBoxedInfo, memory, address, (VkSurfacePresentModeCompatibilityEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: {
            MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: {
            MarshalVkBufferViewCreateInfo::write(pBoxedInfo, memory, address, (VkBufferViewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR: {
            MarshalVkCooperativeMatrixPropertiesKHR::write(pBoxedInfo, memory, address, (VkCooperativeMatrixPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            MarshalVkSamplerYcbcrConversionInfo::write(pBoxedInfo, memory, address, (VkSamplerYcbcrConversionInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT: {
            MarshalVkDeviceFaultInfoEXT::write(pBoxedInfo, memory, address, (VkDeviceFaultInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: {
            MarshalVkIndirectCommandsLayoutCreateInfoNV::write(pBoxedInfo, memory, address, (VkIndirectCommandsLayoutCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: {
            MarshalVkMultisampledRenderToSingleSampledInfoEXT::write(pBoxedInfo, memory, address, (VkMultisampledRenderToSingleSampledInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
            MarshalVkPhysicalDeviceSynchronization2Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSynchronization2Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO: {
            MarshalVkBindDescriptorSetsInfo::write(pBoxedInfo, memory, address, (VkBindDescriptorSetsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
            MarshalVkPhysicalDeviceVulkan13Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan13Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            MarshalVkPhysicalDeviceProtectedMemoryProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceProtectedMemoryProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            MarshalVkSemaphoreTypeCreateInfo::write(pBoxedInfo, memory, address, (VkSemaphoreTypeCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMeshShaderPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMeshShaderPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            MarshalVkPhysicalDevice8BitStorageFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevice8BitStorageFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {
            MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO: {
            MarshalVkPipelineRasterizationLineStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineRasterizationLineStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageProcessing2FeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT: {
            MarshalVkMicromapCreateInfoEXT::write(pBoxedInfo, memory, address, (VkMicromapCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: {
            MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePerformanceQueryPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO: {
            MarshalVkSubpassEndInfo::write(pBoxedInfo, memory, address, (VkSubpassEndInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: {
            MarshalVkPerformanceCounterDescriptionKHR::write(pBoxedInfo, memory, address, (VkPerformanceCounterDescriptionKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR: {
            MarshalVkVideoEncodeH265RateControlLayerInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265RateControlLayerInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: {
            MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
            MarshalVkPipelineLayoutCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineLayoutCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {
            MarshalVkMultiviewPerViewAttributesInfoNVX::write(pBoxedInfo, memory, address, (VkMultiviewPerViewAttributesInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {
            MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCoverageReductionModeFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: {
            MarshalVkPhysicalDeviceInlineUniformBlockProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceInlineUniformBlockProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            MarshalVkPhysicalDeviceDescriptorIndexingProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorIndexingProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceCubicClampFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCubicClampFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES: {
            MarshalVkPhysicalDeviceHostImageCopyProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceHostImageCopyProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: {
            MarshalVkInstanceCreateInfo::write(pBoxedInfo, memory, address, (VkInstanceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: {
            MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT: {
            MarshalVkGeneratedCommandsShaderInfoEXT::write(pBoxedInfo, memory, address, (VkGeneratedCommandsShaderInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: {
            MarshalVkDeviceCreateInfo::write(pBoxedInfo, memory, address, (VkDeviceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD: {
            MarshalVkAntiLagPresentationInfoAMD::write(pBoxedInfo, memory, address, (VkAntiLagPresentationInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            MarshalVkBindBufferMemoryDeviceGroupInfo::write(pBoxedInfo, memory, address, (VkBindBufferMemoryDeviceGroupInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: {
            MarshalVkAttachmentReference2::write(pBoxedInfo, memory, address, (VkAttachmentReference2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO: {
            MarshalVkHostImageLayoutTransitionInfo::write(pBoxedInfo, memory, address, (VkHostImageLayoutTransitionInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR: {
            MarshalVkVideoEndCodingInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEndCodingInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoEncodeH264DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV: {
            MarshalVkCudaLaunchInfoNV::write(pBoxedInfo, memory, address, (VkCudaLaunchInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: {
            MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {
            MarshalVkDeviceMemoryOverallocationCreateInfoAMD::write(pBoxedInfo, memory, address, (VkDeviceMemoryOverallocationCreateInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM: {
            MarshalVkRenderPassStripeInfoARM::write(pBoxedInfo, memory, address, (VkRenderPassStripeInfoARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR: {
            MarshalVkVideoEncodeH264PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {
            MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::write(pBoxedInfo, memory, address, (VkFilterCubicImageViewImageFormatPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineColorBlendAdvancedStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR: {
            MarshalVkVideoEncodeH265ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceShaderObjectPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderObjectPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            MarshalVkRenderPassCreationFeedbackCreateInfoEXT::write(pBoxedInfo, memory, address, (VkRenderPassCreationFeedbackCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
            MarshalVkPhysicalDeviceDynamicRenderingFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDynamicRenderingFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {
            MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR: {
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeH265CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: {
            MarshalVkDeviceBufferMemoryRequirements::write(pBoxedInfo, memory, address, (VkDeviceBufferMemoryRequirements*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV: {
            MarshalVkLatencySleepModeInfoNV::write(pBoxedInfo, memory, address, (VkLatencySleepModeInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {
            MarshalVkCopyCommandTransformInfoQCOM::write(pBoxedInfo, memory, address, (VkCopyCommandTransformInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: {
            MarshalVkPipelineTessellationStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineTessellationStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: {
            MarshalVkLatencySubmissionPresentIdNV::write(pBoxedInfo, memory, address, (VkLatencySubmissionPresentIdNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            MarshalVkDeviceGroupSubmitInfo::write(pBoxedInfo, memory, address, (VkDeviceGroupSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: {
            MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT: {
            MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::write(pBoxedInfo, memory, address, (VkIndirectExecutionSetShaderLayoutInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: {
            MarshalVkSamplerYcbcrConversionCreateInfo::write(pBoxedInfo, memory, address, (VkSamplerYcbcrConversionCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI: {
            MarshalVkHdrVividDynamicMetadataHUAWEI::write(pBoxedInfo, memory, address, (VkHdrVividDynamicMetadataHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265SessionParametersFeedbackInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR: {
            MarshalVkVideoEncodeH264RateControlLayerInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264RateControlLayerInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportSwizzleStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineViewportSwizzleStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR: {
            MarshalVkPipelineBinaryHandlesInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineBinaryHandlesInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiDrawPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: {
            MarshalVkPhysicalDeviceShaderCoreProperties2AMD::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderCoreProperties2AMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            MarshalVkImageViewCaptureDescriptorDataInfoEXT::write(pBoxedInfo, memory, address, (VkImageViewCaptureDescriptorDataInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV: {
            MarshalVkGetLatencyMarkerInfoNV::write(pBoxedInfo, memory, address, (VkGetLatencyMarkerInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            MarshalVkRenderPassAttachmentBeginInfo::write(pBoxedInfo, memory, address, (VkRenderPassAttachmentBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: {
            MarshalVkPhysicalDeviceSurfaceInfo2KHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSurfaceInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            MarshalVkPhysicalDeviceShaderCorePropertiesAMD::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderCorePropertiesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: {
            MarshalVkVideoEncodeUsageInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeUsageInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: {
            MarshalVkCopyAccelerationStructureToMemoryInfoKHR::write(pBoxedInfo, memory, address, (VkCopyAccelerationStructureToMemoryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: {
            MarshalVkPipelineExecutableInternalRepresentationKHR::write(pBoxedInfo, memory, address, (VkPipelineExecutableInternalRepresentationKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: {
            MarshalVkQueryLowLatencySupportNV::write(pBoxedInfo, memory, address, (VkQueryLowLatencySupportNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT: {
            MarshalVkReleaseSwapchainImagesInfoEXT::write(pBoxedInfo, memory, address, (VkReleaseSwapchainImagesInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO_2: {
            MarshalVkSubmitInfo2::write(pBoxedInfo, memory, address, (VkSubmitInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: {
            MarshalVkVideoDecodeH264PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265QuantizationMapCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR: {
            MarshalVkVideoDecodeH265ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT: {
            MarshalVkIndirectCommandsLayoutTokenEXT::write(pBoxedInfo, memory, address, (VkIndirectCommandsLayoutTokenEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: {
            MarshalVkDisplayPowerInfoEXT::write(pBoxedInfo, memory, address, (VkDisplayPowerInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR: {
            MarshalVkVideoDecodeH265CapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265CapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: {
            MarshalVkImageViewAddressPropertiesNVX::write(pBoxedInfo, memory, address, (VkImageViewAddressPropertiesNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX: {
            MarshalVkCuModuleCreateInfoNVX::write(pBoxedInfo, memory, address, (VkCuModuleCreateInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            MarshalVkExportMemoryAllocateInfo::write(pBoxedInfo, memory, address, (VkExportMemoryAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: {
            MarshalVkGeometryTrianglesNV::write(pBoxedInfo, memory, address, (VkGeometryTrianglesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {
            MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: {
            MarshalVkBufferUsageFlags2CreateInfo::write(pBoxedInfo, memory, address, (VkBufferUsageFlags2CreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {
            MarshalVkDescriptorPoolInlineUniformBlockCreateInfo::write(pBoxedInfo, memory, address, (VkDescriptorPoolInlineUniformBlockCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT: {
            MarshalVkDepthBiasInfoEXT::write(pBoxedInfo, memory, address, (VkDepthBiasInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderClockFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderClockFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeH264SessionCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264SessionCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: {
            MarshalVkPipelineCacheCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineCacheCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageProcessingFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: {
            MarshalVkResolveImageInfo2::write(pBoxedInfo, memory, address, (VkResolveImageInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM: {
            MarshalVkTilePropertiesQCOM::write(pBoxedInfo, memory, address, (VkTilePropertiesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {
            MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::write(pBoxedInfo, memory, address, (VkGraphicsPipelineShaderGroupsCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEPENDENCY_INFO: {
            MarshalVkDependencyInfo::write(pBoxedInfo, memory, address, (VkDependencyInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA: {
            MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageAlignmentControlFeaturesMESA*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
            MarshalVkPresentInfoKHR::write(pBoxedInfo, memory, address, (VkPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR: {
            MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1GopRemainingFrameInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkImageSwapchainCreateInfoKHR::write(pBoxedInfo, memory, address, (VkImageSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: {
            MarshalVkSamplerCreateInfo::write(pBoxedInfo, memory, address, (VkSamplerCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: {
            MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT::write(pBoxedInfo, memory, address, (VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR: {
            MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineBinaryPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT: {
            MarshalVkMemoryMapPlacedInfoEXT::write(pBoxedInfo, memory, address, (VkMemoryMapPlacedInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES: {
            MarshalVkPhysicalDevicePipelineRobustnessFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineRobustnessFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderObjectFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderObjectFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES: {
            MarshalVkPhysicalDevicePipelineProtectedAccessFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineProtectedAccessFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            MarshalVkFramebufferAttachmentsCreateInfo::write(pBoxedInfo, memory, address, (VkFramebufferAttachmentsCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT: {
            MarshalVkHdrMetadataEXT::write(pBoxedInfo, memory, address, (VkHdrMetadataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {
            MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH264SessionParametersAddInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryTrianglesDataKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureGeometryTrianglesDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            MarshalVkImagePlaneMemoryRequirementsInfo::write(pBoxedInfo, memory, address, (VkImagePlaneMemoryRequirementsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
            MarshalVkPhysicalDeviceMaintenance4Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance4Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: {
            MarshalVkSemaphoreSignalInfo::write(pBoxedInfo, memory, address, (VkSemaphoreSignalInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR: {
            MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVideoMaintenance1FeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: {
            MarshalVkRayTracingPipelineCreateInfoNV::write(pBoxedInfo, memory, address, (VkRayTracingPipelineCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT: {
            MarshalVkMicromapBuildInfoEXT::write(pBoxedInfo, memory, address, (VkMicromapBuildInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {
            MarshalVkSwapchainPresentScalingCreateInfoEXT::write(pBoxedInfo, memory, address, (VkSwapchainPresentScalingCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: {
            MarshalVkRenderingAttachmentInfo::write(pBoxedInfo, memory, address, (VkRenderingAttachmentInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {
            MarshalVkQueueFamilyCheckpointPropertiesNV::write(pBoxedInfo, memory, address, (VkQueueFamilyCheckpointPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INFO: {
            MarshalVkRenderingInfo::write(pBoxedInfo, memory, address, (VkRenderingInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {
            MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeSessionParametersFeedbackInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceProvokingVertexFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR: {
            MarshalVkVideoEncodeAV1PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: {
            MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceOpacityMicromapFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV: {
            MarshalVkDisplayModeStereoPropertiesNV::write(pBoxedInfo, memory, address, (VkDisplayModeStereoPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM: {
            MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSchedulingControlsPropertiesARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT: {
            MarshalVkIndirectExecutionSetCreateInfoEXT::write(pBoxedInfo, memory, address, (VkIndirectExecutionSetCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: {
            MarshalVkSurfaceCapabilitiesPresentBarrierNV::write(pBoxedInfo, memory, address, (VkSurfaceCapabilitiesPresentBarrierNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO: {
            MarshalVkMemoryUnmapInfo::write(pBoxedInfo, memory, address, (VkMemoryUnmapInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoSessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoSessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            MarshalVkPhysicalDeviceVulkan12Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan12Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            MarshalVkPhysicalDeviceFeatures2::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFeatures2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan11Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan11Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportWScalingStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineViewportWScalingStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES: {
            MarshalVkPhysicalDeviceShaderFloatControls2Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderFloatControls2Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            MarshalVkBindImageMemorySwapchainInfoKHR::write(pBoxedInfo, memory, address, (VkBindImageMemorySwapchainInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO: {
            MarshalVkRenderingAreaInfo::write(pBoxedInfo, memory, address, (VkRenderingAreaInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT: {
            MarshalVkMicromapBuildSizesInfoEXT::write(pBoxedInfo, memory, address, (VkMicromapBuildSizesInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: {
            MarshalVkPerformanceOverrideInfoINTEL::write(pBoxedInfo, memory, address, (VkPerformanceOverrideInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT: {
            MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {
            MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCudaKernelLaunchPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR: {
            MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: {
            MarshalVkDepthBiasRepresentationInfoEXT::write(pBoxedInfo, memory, address, (VkDepthBiasRepresentationInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT: {
            MarshalVkPipelinePropertiesIdentifierEXT::write(pBoxedInfo, memory, address, (VkPipelinePropertiesIdentifierEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: {
            MarshalVkPipelineInputAssemblyStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineInputAssemblyStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM: {
            MarshalVkRenderPassStripeSubmitInfoARM::write(pBoxedInfo, memory, address, (VkRenderPassStripeSubmitInfoARM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
            MarshalVkSemaphoreWaitInfo::write(pBoxedInfo, memory, address, (VkSemaphoreWaitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: {
            MarshalVkDescriptorSetLayoutSupport::write(pBoxedInfo, memory, address, (VkDescriptorSetLayoutSupport*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {
            MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265SessionParametersAddInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: {
            MarshalVkCopyImageInfo2::write(pBoxedInfo, memory, address, (VkCopyImageInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVertexAttributeDivisorProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: {
            MarshalVkBufferMemoryBarrier2::write(pBoxedInfo, memory, address, (VkBufferMemoryBarrier2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR: {
            MarshalVkVideoSessionMemoryRequirementsKHR::write(pBoxedInfo, memory, address, (VkVideoSessionMemoryRequirementsKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR: {
            MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR: {
            MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265GopRemainingFrameInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
            MarshalVkFramebufferCreateInfo::write(pBoxedInfo, memory, address, (VkFramebufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan12Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan12Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {
            MarshalVkDeviceDiagnosticsConfigCreateInfoNV::write(pBoxedInfo, memory, address, (VkDeviceDiagnosticsConfigCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT: {
            MarshalVkCopyMicromapInfoEXT::write(pBoxedInfo, memory, address, (VkCopyMicromapInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE: {
            MarshalVkDescriptorSetBindingReferenceVALVE::write(pBoxedInfo, memory, address, (VkDescriptorSetBindingReferenceVALVE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayQueryFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayQueryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {
            MarshalVkGraphicsPipelineLibraryCreateInfoEXT::write(pBoxedInfo, memory, address, (VkGraphicsPipelineLibraryCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY: {
            MarshalVkHostImageCopyDevicePerformanceQuery::write(pBoxedInfo, memory, address, (VkHostImageCopyDevicePerformanceQuery*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {
            MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::write(pBoxedInfo, memory, address, (VkAccelerationStructureGeometryMotionTrianglesDataNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeQuantizationMapCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV: {
            MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: {
            MarshalVkSurfaceFormat2KHR::write(pBoxedInfo, memory, address, (VkSurfaceFormat2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM: {
            MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageProcessingPropertiesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderQuadControlFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            MarshalVkCooperativeMatrixPropertiesNV::write(pBoxedInfo, memory, address, (VkCooperativeMatrixPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
            MarshalVkComputePipelineCreateInfo::write(pBoxedInfo, memory, address, (VkComputePipelineCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageReductionStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineCoverageReductionStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: {
            MarshalVkPhysicalDeviceGroupProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceGroupProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV: {
            MarshalVkOpticalFlowImageFormatPropertiesNV::write(pBoxedInfo, memory, address, (VkOpticalFlowImageFormatPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {
            MarshalVkPipelineRasterizationStateRasterizationOrderAMD::write(pBoxedInfo, memory, address, (VkPipelineRasterizationStateRasterizationOrderAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV: {
            MarshalVkCheckpointData2NV::write(pBoxedInfo, memory, address, (VkCheckpointData2NV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            MarshalVkMemoryAllocateFlagsInfo::write(pBoxedInfo, memory, address, (VkMemoryAllocateFlagsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan13Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan13Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            MarshalVkExternalImageFormatProperties::write(pBoxedInfo, memory, address, (VkExternalImageFormatProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: {
            MarshalVkPipelineColorBlendStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineColorBlendStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            MarshalVkTimelineSemaphoreSubmitInfo::write(pBoxedInfo, memory, address, (VkTimelineSemaphoreSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
            MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevicePipelineCreationCacheControlFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSamplerYcbcrConversionFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV: {
            MarshalVkLatencyTimingsFrameReportNV::write(pBoxedInfo, memory, address, (VkLatencyTimingsFrameReportNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR: {
            MarshalVkDevicePipelineBinaryInternalCacheControlKHR::write(pBoxedInfo, memory, address, (VkDevicePipelineBinaryInternalCacheControlKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: {
            MarshalVkAccelerationStructureBuildGeometryInfoKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureBuildGeometryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT: {
            MarshalVkGeneratedCommandsPipelineInfoEXT::write(pBoxedInfo, memory, address, (VkGeneratedCommandsPipelineInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
            MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineFragmentShadingRateStateCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD: {
            MarshalVkAntiLagDataAMD::write(pBoxedInfo, memory, address, (VkAntiLagDataAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceASTCDecodeFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan14Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan14Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: {
            MarshalVkConditionalRenderingBeginInfoEXT::write(pBoxedInfo, memory, address, (VkConditionalRenderingBeginInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: {
            MarshalVkBlitImageInfo2::write(pBoxedInfo, memory, address, (VkBlitImageInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES: {
            MarshalVkPhysicalDeviceShaderExpectAssumeFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderExpectAssumeFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            MarshalVkPhysicalDeviceDescriptorIndexingFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorIndexingFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            MarshalVkPhysicalDeviceIDProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceIDProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: {
            MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR: {
            MarshalVkReleaseCapturedPipelineDataInfoKHR::write(pBoxedInfo, memory, address, (VkReleaseCapturedPipelineDataInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTransformFeedbackPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {
            MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::write(pBoxedInfo, memory, address, (VkQueryPoolPerformanceQueryCreateInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: {
            MarshalVkPhysicalDeviceTexelBufferAlignmentProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTexelBufferAlignmentProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {
            MarshalVkPipelineRobustnessCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineRobustnessCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT: {
            MarshalVkWriteIndirectExecutionSetShaderEXT::write(pBoxedInfo, memory, address, (VkWriteIndirectExecutionSetShaderEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: {
            MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::write(pBoxedInfo, memory, address, (VkAccelerationStructureTrianglesOpacityMicromapEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkDeviceGroupSwapchainCreateInfoKHR::write(pBoxedInfo, memory, address, (VkDeviceGroupSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: {
            MarshalVkSemaphoreCreateInfo::write(pBoxedInfo, memory, address, (VkSemaphoreCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: {
            MarshalVkPhysicalDeviceSparseImageFormatInfo2::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSparseImageFormatInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV: {
            MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            MarshalVkPhysicalDeviceSubgroupProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubgroupProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: {
            MarshalVkMemoryAllocateInfo::write(pBoxedInfo, memory, address, (VkMemoryAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: {
            MarshalVkSurfaceCapabilities2KHR::write(pBoxedInfo, memory, address, (VkSurfaceCapabilities2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            MarshalVkPhysicalDeviceShaderFloat16Int8Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderFloat16Int8Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR: {
            MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264GopRemainingFrameInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: {
            MarshalVkVideoDecodeUsageInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeUsageInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV: {
            MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::write(pBoxedInfo, memory, address, (VkCooperativeMatrixFlexibleDimensionsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: {
            MarshalVkCommandBufferAllocateInfo::write(pBoxedInfo, memory, address, (VkCommandBufferAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: {
            MarshalVkGeneratedCommandsInfoNV::write(pBoxedInfo, memory, address, (VkGeneratedCommandsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: {
            MarshalVkPhysicalDeviceExternalFenceInfo::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExternalFenceInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMemoryPriorityFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT: {
            MarshalVkExternalMemoryAcquireUnmodifiedEXT::write(pBoxedInfo, memory, address, (VkExternalMemoryAcquireUnmodifiedEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: {
            MarshalVkDebugUtilsLabelEXT::write(pBoxedInfo, memory, address, (VkDebugUtilsLabelEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: {
            MarshalVkMappedMemoryRange::write(pBoxedInfo, memory, address, (VkMappedMemoryRange*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: {
            MarshalVkCommandBufferInheritanceInfo::write(pBoxedInfo, memory, address, (VkCommandBufferInheritanceInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1QuantizationMapCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: {
            MarshalVkImportMemoryHostPointerInfoEXT::write(pBoxedInfo, memory, address, (VkImportMemoryHostPointerInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO: {
            MarshalVkPushDescriptorSetWithTemplateInfo::write(pBoxedInfo, memory, address, (VkPushDescriptorSetWithTemplateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {
            MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCoherentMemoryFeaturesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: {
            MarshalVkCopyBufferInfo2::write(pBoxedInfo, memory, address, (VkCopyBufferInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
            MarshalVkDedicatedAllocationBufferCreateInfoNV::write(pBoxedInfo, memory, address, (VkDedicatedAllocationBufferCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {
            MarshalVkPipelineLibraryCreateInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineLibraryCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            MarshalVkShaderModuleCreateInfo::write(pBoxedInfo, memory, address, (VkShaderModuleCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: {
            MarshalVkOpticalFlowImageFormatInfoNV::write(pBoxedInfo, memory, address, (VkOpticalFlowImageFormatInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: {
            MarshalVkVideoProfileListInfoKHR::write(pBoxedInfo, memory, address, (VkVideoProfileListInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV: {
            MarshalVkCudaFunctionCreateInfoNV::write(pBoxedInfo, memory, address, (VkCudaFunctionCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: {
            MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT::write(pBoxedInfo, memory, address, (VkSamplerBorderColorComponentMappingCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
            MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDevicePerformanceQueryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: {
            MarshalVkPipelineExecutableInfoKHR::write(pBoxedInfo, memory, address, (VkPipelineExecutableInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR: {
            MarshalVkVideoEncodeH264RateControlInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264RateControlInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCooperativeMatrix2PropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV: {
            MarshalVkLatencySurfaceCapabilitiesNV::write(pBoxedInfo, memory, address, (VkLatencySurfaceCapabilitiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            MarshalVkSamplerYcbcrConversionImageFormatProperties::write(pBoxedInfo, memory, address, (VkSamplerYcbcrConversionImageFormatProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR: {
            MarshalVkQueueFamilyQueryResultStatusPropertiesKHR::write(pBoxedInfo, memory, address, (VkQueueFamilyQueryResultStatusPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
            MarshalVkPhysicalDevicePrivateDataFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDevicePrivateDataFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT: {
            MarshalVkDescriptorBufferBindingInfoEXT::write(pBoxedInfo, memory, address, (VkDescriptorBufferBindingInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineDiscardRectangleStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
            MarshalVkBindSparseInfo::write(pBoxedInfo, memory, address, (VkBindSparseInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTransformFeedbackFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
            MarshalVkPhysicalDeviceInlineUniformBlockFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceInlineUniformBlockFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: {
            MarshalVkVideoDecodeH265DpbSlotInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeH265DpbSlotInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
            MarshalVkDescriptorSetLayoutCreateInfo::write(pBoxedInfo, memory, address, (VkDescriptorSetLayoutCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: {
            MarshalVkDescriptorUpdateTemplateCreateInfo::write(pBoxedInfo, memory, address, (VkDescriptorUpdateTemplateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: {
            MarshalVkImageViewHandleInfoNVX::write(pBoxedInfo, memory, address, (VkImageViewHandleInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT: {
            MarshalVkIndirectExecutionSetPipelineInfoEXT::write(pBoxedInfo, memory, address, (VkIndirectExecutionSetPipelineInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            MarshalVkAttachmentDescriptionStencilLayout::write(pBoxedInfo, memory, address, (VkAttachmentDescriptionStencilLayout*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAccelerationStructureFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {
            MarshalVkWriteDescriptorSetInlineUniformBlock::write(pBoxedInfo, memory, address, (VkWriteDescriptorSetInlineUniformBlock*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO: {
            MarshalVkDeviceImageSubresourceInfo::write(pBoxedInfo, memory, address, (VkDeviceImageSubresourceInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {
            MarshalVkValidationFlagsEXT::write(pBoxedInfo, memory, address, (VkValidationFlagsEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: {
            MarshalVkDeviceAddressBindingCallbackDataEXT::write(pBoxedInfo, memory, address, (VkDeviceAddressBindingCallbackDataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: {
            MarshalVkBindImageMemoryInfo::write(pBoxedInfo, memory, address, (VkBindImageMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {
            MarshalVkWriteDescriptorSetAccelerationStructureNV::write(pBoxedInfo, memory, address, (VkWriteDescriptorSetAccelerationStructureNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: {
            MarshalVkExternalSemaphoreProperties::write(pBoxedInfo, memory, address, (VkExternalSemaphoreProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: {
            MarshalVkQueueFamilyVideoPropertiesKHR::write(pBoxedInfo, memory, address, (VkQueueFamilyVideoPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
            MarshalVkSurfacePresentScalingCapabilitiesEXT::write(pBoxedInfo, memory, address, (VkSurfacePresentScalingCapabilitiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
            MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceShaderTerminateInvocationFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: {
            MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::write(pBoxedInfo, memory, address, (VkRayTracingPipelineInterfaceCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceOpticalFlowPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceOpticalFlowPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceProvokingVertexPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: {
            MarshalVkPipelineViewportStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineViewportStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: {
            MarshalVkDeviceGroupPresentCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkDeviceGroupPresentCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {
            MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageViewImageFormatInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceRayTracingPropertiesNV::write(pBoxedInfo, memory, address, (VkPhysicalDeviceRayTracingPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
            MarshalVkPhysicalDeviceSubgroupSizeControlFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSubgroupSizeControlFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR: {
            MarshalVkBindVideoSessionMemoryInfoKHR::write(pBoxedInfo, memory, address, (VkBindVideoSessionMemoryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            MarshalVkPhysicalDeviceVulkan11Features::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkan11Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceVulkanMemoryModelFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: {
            MarshalVkSubpassDescription2::write(pBoxedInfo, memory, address, (VkSubpassDescription2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES: {
            MarshalVkPhysicalDeviceLineRasterizationFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLineRasterizationFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceAddressBindingReportFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR: {
            MarshalVkVideoDecodeCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {
            MarshalVkWriteDescriptorSetAccelerationStructureKHR::write(pBoxedInfo, memory, address, (VkWriteDescriptorSetAccelerationStructureKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: {
            MarshalVkDeviceQueueInfo2::write(pBoxedInfo, memory, address, (VkDeviceQueueInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: {
            MarshalVkPerformanceMarkerInfoINTEL::write(pBoxedInfo, memory, address, (VkPerformanceMarkerInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            MarshalVkPipelineTessellationDomainOriginStateCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineTessellationDomainOriginStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR: {
            MarshalVkVideoDecodeAV1ProfileInfoKHR::write(pBoxedInfo, memory, address, (VkVideoDecodeAV1ProfileInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES: {
            MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceGlobalPriorityQueryFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: {
            MarshalVkAccelerationStructureInfoNV::write(pBoxedInfo, memory, address, (VkAccelerationStructureInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: {
            MarshalVkSparseImageFormatProperties2::write(pBoxedInfo, memory, address, (VkSparseImageFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: {
            MarshalVkFenceCreateInfo::write(pBoxedInfo, memory, address, (VkFenceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFaultFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFaultFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM: {
            MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::write(pBoxedInfo, memory, address, (VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: {
            MarshalVkCopyBufferToImageInfo2::write(pBoxedInfo, memory, address, (VkCopyBufferToImageInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceHdrVividFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR: {
            MarshalVkCalibratedTimestampInfoKHR::write(pBoxedInfo, memory, address, (VkCalibratedTimestampInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceTimelineSemaphoreFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            MarshalVkBindImageMemoryDeviceGroupInfo::write(pBoxedInfo, memory, address, (VkBindImageMemoryDeviceGroupInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR: {
            MarshalVkVideoEncodeSessionParametersGetInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeSessionParametersGetInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: {
            MarshalVkImageAlignmentControlCreateInfoMESA::write(pBoxedInfo, memory, address, (VkImageAlignmentControlCreateInfoMESA*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: {
            MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLegacyDitheringFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: {
            MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::write(pBoxedInfo, memory, address, (VkGeneratedCommandsMemoryRequirementsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV: {
            MarshalVkLatencySleepInfoNV::write(pBoxedInfo, memory, address, (VkLatencySleepInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: {
            MarshalVkAcquireNextImageInfoKHR::write(pBoxedInfo, memory, address, (VkAcquireNextImageInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT: {
            MarshalVkCopyMicromapToMemoryInfoEXT::write(pBoxedInfo, memory, address, (VkCopyMicromapToMemoryInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {
            MarshalVkPipelineCreateFlags2CreateInfo::write(pBoxedInfo, memory, address, (VkPipelineCreateFlags2CreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR: {
            MarshalVkVideoEncodeCapabilitiesKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            MarshalVkDeviceGroupPresentInfoKHR::write(pBoxedInfo, memory, address, (VkDeviceGroupPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceCustomBorderColorPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageViewMinLodFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::write(pBoxedInfo, memory, address, (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: {
            MarshalVkFramebufferMixedSamplesCombinationNV::write(pBoxedInfo, memory, address, (VkFramebufferMixedSamplesCombinationNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR: {
            MarshalVkVideoEncodeInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceBufferDeviceAddressFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: {
            MarshalVkPhysicalDeviceExternalSemaphoreInfo::write(pBoxedInfo, memory, address, (VkPhysicalDeviceExternalSemaphoreInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: {
            MarshalVkRayTracingShaderGroupCreateInfoKHR::write(pBoxedInfo, memory, address, (VkRayTracingShaderGroupCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: {
            MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT::write(pBoxedInfo, memory, address, (VkAccelerationStructureCaptureDescriptorDataInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::write(pBoxedInfo, memory, address, (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: {
            MarshalVkFramebufferAttachmentImageInfo::write(pBoxedInfo, memory, address, (VkFramebufferAttachmentImageInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkBufferMemoryRequirementsInfo2::write(pBoxedInfo, memory, address, (VkBufferMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES: {
            MarshalVkPhysicalDeviceHostImageCopyFeatures::write(pBoxedInfo, memory, address, (VkPhysicalDeviceHostImageCopyFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265SessionParametersCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR: {
            MarshalVkVideoEncodeH264NaluSliceInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH264NaluSliceInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: {
            MarshalVkInitializePerformanceApiInfoINTEL::write(pBoxedInfo, memory, address, (VkInitializePerformanceApiInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {
            MarshalVkPerformanceQuerySubmitInfoKHR::write(pBoxedInfo, memory, address, (VkPerformanceQuerySubmitInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: {
            MarshalVkPhysicalDeviceImageFormatInfo2::write(pBoxedInfo, memory, address, (VkPhysicalDeviceImageFormatInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT: {
            MarshalVkPipelineViewportDepthClampControlCreateInfoEXT::write(pBoxedInfo, memory, address, (VkPipelineViewportDepthClampControlCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            MarshalVkExportFenceCreateInfo::write(pBoxedInfo, memory, address, (VkExportFenceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {
            MarshalVkPipelineCompilerControlCreateInfoAMD::write(pBoxedInfo, memory, address, (VkPipelineCompilerControlCreateInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceDiscardRectanglePropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: {
            MarshalVkImageViewCreateInfo::write(pBoxedInfo, memory, address, (VkImageViewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: {
            MarshalVkPipelineShaderStageCreateInfo::write(pBoxedInfo, memory, address, (VkPipelineShaderStageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM: {
            MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM::write(pBoxedInfo, memory, address, (VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            MarshalVkDeviceGroupBindSparseInfo::write(pBoxedInfo, memory, address, (VkDeviceGroupBindSparseInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            MarshalVkFragmentShadingRateAttachmentInfoKHR::write(pBoxedInfo, memory, address, (VkFragmentShadingRateAttachmentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR: {
            MarshalVkVideoEncodeAV1RateControlLayerInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeAV1RateControlLayerInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES: {
            MarshalVkPhysicalDeviceLineRasterizationProperties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceLineRasterizationProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT::write(pBoxedInfo, memory, address, (VkPhysicalDeviceOpacityMicromapPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            MarshalVkPhysicalDeviceMaintenance3Properties::write(pBoxedInfo, memory, address, (VkPhysicalDeviceMaintenance3Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: {
            MarshalVkAccelerationStructureDeviceAddressInfoKHR::write(pBoxedInfo, memory, address, (VkAccelerationStructureDeviceAddressInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV: {
            MarshalVkPipelineIndirectDeviceAddressInfoNV::write(pBoxedInfo, memory, address, (VkPipelineIndirectDeviceAddressInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR: {
            MarshalVkVideoEncodeH265PictureInfoKHR::write(pBoxedInfo, memory, address, (VkVideoEncodeH265PictureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: {
            MarshalVkEventCreateInfo::write(pBoxedInfo, memory, address, (VkEventCreateInfo*)p);
            break;
        }
       default:
            kpanic("vulkanWriteNextPtr not implemented for %d", type);
    }
}
#endif

