// DON'T MODIFY, this is autogenerated
#include "boxedwine.h"
#ifdef BOXEDWINE_VULKAN
#include <SDL.h>
#include <SDL_vulkan.h>
#define VK_NO_PROTOTYPES
#include "vk/vulkan.h"
#include "vk/vulkan_core.h"
#define BOXED_VK_EXTERN
#include "vk_host.h"

void initVulkan();
void* getVulkanPtr(KMemory* memory, U32 address);
U32 createVulkanPtr(KMemory* memory, U64 value, BoxedVulkanInfo* info);
BoxedVulkanInfo* getInfoFromHandle(KMemory* memory, U32 address);
void freeVulkanPtr(KMemory* memory, U32 p);
void registerVkMemoryAllocation(VkDeviceMemory memory, VkDeviceSize size);
void unregisterVkMemoryAllocation(VkDeviceMemory memory);
U32 mapVkMemory(VkDeviceMemory memory, void* pData, VkDeviceSize len);
void unmapVkMemory(VkDeviceMemory memory);

#define ARG1 cpu->peek32(1)
#define ARG2 cpu->peek32(2)
#define ARG3 cpu->peek32(3)
#define ARG4 cpu->peek32(4)
#define ARG5 cpu->peek32(5)
#define ARG6 cpu->peek32(6)
#define ARG7 cpu->peek32(7)
#define ARG8 cpu->peek32(8)
#define ARG9 cpu->peek32(9)
#define ARG10 cpu->peek32(10)
#define ARG11 cpu->peek32(11)
#define ARG12 cpu->peek32(12)
#define ARG13 cpu->peek32(13)
#define ARG14 cpu->peek32(14)
#define ARG15 cpu->peek32(15)
#define ARG16 cpu->peek32(16)
#define ARG17 cpu->peek32(17)
#define ARG18 cpu->peek32(18)
#define ARG19 cpu->peek32(19)
#define ARG20 cpu->peek32(20)
#define ARG21 cpu->peek32(21)
#define ARG22 cpu->peek32(22)
#define ARG23 cpu->peek32(23)
#define ARG24 cpu->peek32(24)
#define ARG25 cpu->peek32(25)
#define ARG26 cpu->peek32(26)
#define ARG64(lo, hi) ((U64)lo | ((U64)hi << 32))
void* vulkanGetNextPtr(KMemory* memory, U32 address);
void vulkanWriteNextPtr(KMemory* memory, U32 address, const void* pNext);
class MarshalVkPhysicalDeviceFeatures {
public:
    MarshalVkPhysicalDeviceFeatures() {}
    VkPhysicalDeviceFeatures s;
    MarshalVkPhysicalDeviceFeatures(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceFeatures* s) {
        s->robustBufferAccess = (VkBool32)memory->readd(address);address+=4;
        s->fullDrawIndexUint32 = (VkBool32)memory->readd(address);address+=4;
        s->imageCubeArray = (VkBool32)memory->readd(address);address+=4;
        s->independentBlend = (VkBool32)memory->readd(address);address+=4;
        s->geometryShader = (VkBool32)memory->readd(address);address+=4;
        s->tessellationShader = (VkBool32)memory->readd(address);address+=4;
        s->sampleRateShading = (VkBool32)memory->readd(address);address+=4;
        s->dualSrcBlend = (VkBool32)memory->readd(address);address+=4;
        s->logicOp = (VkBool32)memory->readd(address);address+=4;
        s->multiDrawIndirect = (VkBool32)memory->readd(address);address+=4;
        s->drawIndirectFirstInstance = (VkBool32)memory->readd(address);address+=4;
        s->depthClamp = (VkBool32)memory->readd(address);address+=4;
        s->depthBiasClamp = (VkBool32)memory->readd(address);address+=4;
        s->fillModeNonSolid = (VkBool32)memory->readd(address);address+=4;
        s->depthBounds = (VkBool32)memory->readd(address);address+=4;
        s->wideLines = (VkBool32)memory->readd(address);address+=4;
        s->largePoints = (VkBool32)memory->readd(address);address+=4;
        s->alphaToOne = (VkBool32)memory->readd(address);address+=4;
        s->multiViewport = (VkBool32)memory->readd(address);address+=4;
        s->samplerAnisotropy = (VkBool32)memory->readd(address);address+=4;
        s->textureCompressionETC2 = (VkBool32)memory->readd(address);address+=4;
        s->textureCompressionASTC_LDR = (VkBool32)memory->readd(address);address+=4;
        s->textureCompressionBC = (VkBool32)memory->readd(address);address+=4;
        s->occlusionQueryPrecise = (VkBool32)memory->readd(address);address+=4;
        s->pipelineStatisticsQuery = (VkBool32)memory->readd(address);address+=4;
        s->vertexPipelineStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
        s->fragmentStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
        s->shaderTessellationAndGeometryPointSize = (VkBool32)memory->readd(address);address+=4;
        s->shaderImageGatherExtended = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageImageExtendedFormats = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageImageMultisample = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageImageReadWithoutFormat = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageImageWriteWithoutFormat = (VkBool32)memory->readd(address);address+=4;
        s->shaderUniformBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
        s->shaderSampledImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
        s->shaderStorageImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
        s->shaderClipDistance = (VkBool32)memory->readd(address);address+=4;
        s->shaderCullDistance = (VkBool32)memory->readd(address);address+=4;
        s->shaderFloat64 = (VkBool32)memory->readd(address);address+=4;
        s->shaderInt64 = (VkBool32)memory->readd(address);address+=4;
        s->shaderInt16 = (VkBool32)memory->readd(address);address+=4;
        s->shaderResourceResidency = (VkBool32)memory->readd(address);address+=4;
        s->shaderResourceMinLod = (VkBool32)memory->readd(address);address+=4;
        s->sparseBinding = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidencyBuffer = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidencyImage2D = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidencyImage3D = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidency2Samples = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidency4Samples = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidency8Samples = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidency16Samples = (VkBool32)memory->readd(address);address+=4;
        s->sparseResidencyAliased = (VkBool32)memory->readd(address);address+=4;
        s->variableMultisampleRate = (VkBool32)memory->readd(address);address+=4;
        s->inheritedQueries = (VkBool32)memory->readd(address);address+=4;
    }
};

class MarshalVkPhysicalDeviceLimits {
public:
    MarshalVkPhysicalDeviceLimits() {}
    VkPhysicalDeviceLimits s;
    MarshalVkPhysicalDeviceLimits(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceLimits* s) {
        s->maxImageDimension1D = (uint32_t)memory->readd(address);address+=4;
        s->maxImageDimension2D = (uint32_t)memory->readd(address);address+=4;
        s->maxImageDimension3D = (uint32_t)memory->readd(address);address+=4;
        s->maxImageDimensionCube = (uint32_t)memory->readd(address);address+=4;
        s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
        s->maxTexelBufferElements = (uint32_t)memory->readd(address);address+=4;
        s->maxUniformBufferRange = (uint32_t)memory->readd(address);address+=4;
        s->maxStorageBufferRange = (uint32_t)memory->readd(address);address+=4;
        s->maxPushConstantsSize = (uint32_t)memory->readd(address);address+=4;
        s->maxMemoryAllocationCount = (uint32_t)memory->readd(address);address+=4;
        s->maxSamplerAllocationCount = (uint32_t)memory->readd(address);address+=4;
        s->bufferImageGranularity = (VkDeviceSize)memory->readq(address);address+=8;
        s->sparseAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
        s->maxBoundDescriptorSets = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorSamplers = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorUniformBuffers = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorStorageBuffers = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorSampledImages = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorStorageImages = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageDescriptorInputAttachments = (uint32_t)memory->readd(address);address+=4;
        s->maxPerStageResources = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetSamplers = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetUniformBuffers = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetStorageBuffers = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetSampledImages = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetStorageImages = (uint32_t)memory->readd(address);address+=4;
        s->maxDescriptorSetInputAttachments = (uint32_t)memory->readd(address);address+=4;
        s->maxVertexInputAttributes = (uint32_t)memory->readd(address);address+=4;
        s->maxVertexInputBindings = (uint32_t)memory->readd(address);address+=4;
        s->maxVertexInputAttributeOffset = (uint32_t)memory->readd(address);address+=4;
        s->maxVertexInputBindingStride = (uint32_t)memory->readd(address);address+=4;
        s->maxVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationGenerationLevel = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationPatchSize = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationControlPerVertexInputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationControlPerVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationControlPerPatchOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationControlTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationEvaluationInputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxTessellationEvaluationOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxGeometryShaderInvocations = (uint32_t)memory->readd(address);address+=4;
        s->maxGeometryInputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxGeometryOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxGeometryOutputVertices = (uint32_t)memory->readd(address);address+=4;
        s->maxGeometryTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxFragmentInputComponents = (uint32_t)memory->readd(address);address+=4;
        s->maxFragmentOutputAttachments = (uint32_t)memory->readd(address);address+=4;
        s->maxFragmentDualSrcAttachments = (uint32_t)memory->readd(address);address+=4;
        s->maxFragmentCombinedOutputResources = (uint32_t)memory->readd(address);address+=4;
        s->maxComputeSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->maxComputeWorkGroupCount, address, 3);address+=3;
        s->maxComputeWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->maxComputeWorkGroupSize, address, 3);address+=3;
        s->subPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
        s->subTexelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
        s->mipmapPrecisionBits = (uint32_t)memory->readd(address);address+=4;
        s->maxDrawIndexedIndexValue = (uint32_t)memory->readd(address);address+=4;
        s->maxDrawIndirectCount = (uint32_t)memory->readd(address);address+=4;
        s->maxSamplerLodBias = (float)memory->readd(address);address+=4;
        s->maxSamplerAnisotropy = (float)memory->readd(address);address+=4;
        s->maxViewports = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->maxViewportDimensions, address, 2);address+=2;
        memory->memcpy(&s->viewportBoundsRange, address, 2);address+=2;
        s->viewportSubPixelBits = (uint32_t)memory->readd(address);address+=4;
        s->minMemoryMapAlignment = (size_t)memory->readd(address);address+=4;
        s->minTexelBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
        s->minUniformBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
        s->minStorageBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
        s->minTexelOffset = (int32_t)memory->readd(address);address+=4;
        s->maxTexelOffset = (uint32_t)memory->readd(address);address+=4;
        s->minTexelGatherOffset = (int32_t)memory->readd(address);address+=4;
        s->maxTexelGatherOffset = (uint32_t)memory->readd(address);address+=4;
        s->minInterpolationOffset = (float)memory->readd(address);address+=4;
        s->maxInterpolationOffset = (float)memory->readd(address);address+=4;
        s->subPixelInterpolationOffsetBits = (uint32_t)memory->readd(address);address+=4;
        s->maxFramebufferWidth = (uint32_t)memory->readd(address);address+=4;
        s->maxFramebufferHeight = (uint32_t)memory->readd(address);address+=4;
        s->maxFramebufferLayers = (uint32_t)memory->readd(address);address+=4;
        s->framebufferColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->framebufferDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->framebufferStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->framebufferNoAttachmentsSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->maxColorAttachments = (uint32_t)memory->readd(address);address+=4;
        s->sampledImageColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->sampledImageIntegerSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->sampledImageDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->sampledImageStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->storageImageSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
        s->maxSampleMaskWords = (uint32_t)memory->readd(address);address+=4;
        s->timestampComputeAndGraphics = (VkBool32)memory->readd(address);address+=4;
        s->timestampPeriod = (float)memory->readd(address);address+=4;
        s->maxClipDistances = (uint32_t)memory->readd(address);address+=4;
        s->maxCullDistances = (uint32_t)memory->readd(address);address+=4;
        s->maxCombinedClipAndCullDistances = (uint32_t)memory->readd(address);address+=4;
        s->discreteQueuePriorities = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->pointSizeRange, address, 2);address+=2;
        memory->memcpy(&s->lineWidthRange, address, 2);address+=2;
        s->pointSizeGranularity = (float)memory->readd(address);address+=4;
        s->lineWidthGranularity = (float)memory->readd(address);address+=4;
        s->strictLines = (VkBool32)memory->readd(address);address+=4;
        s->standardSampleLocations = (VkBool32)memory->readd(address);address+=4;
        s->optimalBufferCopyOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
        s->optimalBufferCopyRowPitchAlignment = (VkDeviceSize)memory->readq(address);address+=8;
        s->nonCoherentAtomSize = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkComponentMapping {
public:
    MarshalVkComponentMapping() {}
    VkComponentMapping s;
    MarshalVkComponentMapping(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkComponentMapping* s) {
        s->r = (VkComponentSwizzle)memory->readd(address);address+=4;
        s->g = (VkComponentSwizzle)memory->readd(address);address+=4;
        s->b = (VkComponentSwizzle)memory->readd(address);address+=4;
        s->a = (VkComponentSwizzle)memory->readd(address);address+=4;
    }
};

class MarshalVkPhysicalDeviceProperties {
public:
    MarshalVkPhysicalDeviceProperties() {}
    VkPhysicalDeviceProperties s;
    MarshalVkPhysicalDeviceProperties(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
        s->apiVersion = (uint32_t)memory->readd(address);address+=4;
        s->driverVersion = (uint32_t)memory->readd(address);address+=4;
        s->vendorID = (uint32_t)memory->readd(address);address+=4;
        s->deviceID = (uint32_t)memory->readd(address);address+=4;
        s->deviceType = (VkPhysicalDeviceType)memory->readd(address);address+=4;
        memory->memcpy(&s->deviceName, address, 256);address+=256;
        memory->memcpy(&s->pipelineCacheUUID, address, 16);address+=16;
        MarshalVkPhysicalDeviceLimits::read(memory, address, &s->limits); address+=488;
        memory->memcpy(&s->sparseProperties, address, 20);address+=20;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
        memory->writed(address, s->apiVersion);address+=4;
        memory->writed(address, s->driverVersion);address+=4;
        memory->writed(address, s->vendorID);address+=4;
        memory->writed(address, s->deviceID);address+=4;
        memory->writed(address, s->deviceType);address+=4;
        memory->memcpy(address, s->deviceName, 256); address+=256;
        memory->memcpy(address, s->pipelineCacheUUID, 16); address+=16;
        memory->memcpy(address, &s->limits, 488); address+=488;
        memory->memcpy(address, &s->sparseProperties, 20); address+=20;
    }
};

class MarshalVkApplicationInfo {
public:
    MarshalVkApplicationInfo() {}
    VkApplicationInfo s;
    MarshalVkApplicationInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkApplicationInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pApplicationName = NULL;
        } else {
            s->pApplicationName = new char[0 * sizeof(char)];
            memory->memcpy((char*)s->pApplicationName, paramAddress, 0 * sizeof(char));
        }
        s->applicationVersion = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pEngineName = NULL;
        } else {
            s->pEngineName = new char[0 * sizeof(char)];
            memory->memcpy((char*)s->pEngineName, paramAddress, 0 * sizeof(char));
        }
        s->engineVersion = (uint32_t)memory->readd(address);address+=4;
        s->apiVersion = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkDeviceQueueCreateInfo {
public:
    MarshalVkDeviceQueueCreateInfo() {}
    VkDeviceQueueCreateInfo s;
    MarshalVkDeviceQueueCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDeviceQueueCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
        s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->queueCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pQueuePriorities = NULL;
        } else {
            s->pQueuePriorities = new float[s->queueCount * sizeof(float)];
            memory->memcpy((float*)s->pQueuePriorities, paramAddress, s->queueCount * sizeof(float));
        }
    }
};

class MarshalVkDeviceCreateInfo {
public:
    MarshalVkDeviceCreateInfo() {}
    VkDeviceCreateInfo s;
    MarshalVkDeviceCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDeviceCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDeviceCreateFlags)memory->readd(address);address+=4;
        s->queueCreateInfoCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pQueueCreateInfos = NULL;
        } else {
            VkDeviceQueueCreateInfo* pQueueCreateInfos = new VkDeviceQueueCreateInfo[s->queueCreateInfoCount];
            for (U32 i = 0; i < s->queueCreateInfoCount; i++) {
                MarshalVkDeviceQueueCreateInfo::read(memory, paramAddress, &pQueueCreateInfos[i]);
            }
            s->pQueueCreateInfos = pQueueCreateInfos;
        }
        s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->ppEnabledLayerNames = NULL;
        } else {
            char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
            for (int i=0;i<(int)s->enabledLayerCount;i++) {
                U32 size = memory->strlen(paramAddress + i*4)+1;
                ppEnabledLayerNames[i] = new char[size];
                memory->memcpy(ppEnabledLayerNames[i], paramAddress + i*4, size);
            }
        }
        s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->ppEnabledExtensionNames = NULL;
        } else {
            char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
            for (int i=0;i<(int)s->enabledExtensionCount;i++) {
                U32 size = memory->strlen(paramAddress + i*4)+1;
                ppEnabledExtensionNames[i] = new char[size];
                memory->memcpy(ppEnabledExtensionNames[i], paramAddress + i*4, size);
            }
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pEnabledFeatures = NULL;
        } else {
            VkPhysicalDeviceFeatures* pEnabledFeatures = new VkPhysicalDeviceFeatures();
            MarshalVkPhysicalDeviceFeatures::read(memory, paramAddress, pEnabledFeatures);
            s->pEnabledFeatures = pEnabledFeatures;
        }
    }
};

class MarshalVkInstanceCreateInfo {
public:
    MarshalVkInstanceCreateInfo() {}
    VkInstanceCreateInfo s;
    MarshalVkInstanceCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkInstanceCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkInstanceCreateFlags)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pApplicationInfo = NULL;
        } else {
            VkApplicationInfo* pApplicationInfo = new VkApplicationInfo();
            MarshalVkApplicationInfo::read(memory, paramAddress, pApplicationInfo);
            s->pApplicationInfo = pApplicationInfo;
        }
        s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->ppEnabledLayerNames = NULL;
        } else {
            char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
            for (int i=0;i<(int)s->enabledLayerCount;i++) {
                U32 size = memory->strlen(paramAddress + i*4)+1;
                ppEnabledLayerNames[i] = new char[size];
                memory->memcpy(ppEnabledLayerNames[i], paramAddress + i*4, size);
            }
        }
        s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->ppEnabledExtensionNames = NULL;
        } else {
            char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
            for (int i=0;i<(int)s->enabledExtensionCount;i++) {
                U32 size = memory->strlen(paramAddress + i*4)+1;
                ppEnabledExtensionNames[i] = new char[size];
                memory->memcpy(ppEnabledExtensionNames[i], paramAddress + i*4, size);
            }
        }
    }
};

class MarshalVkMemoryAllocateInfo {
public:
    MarshalVkMemoryAllocateInfo() {}
    VkMemoryAllocateInfo s;
    MarshalVkMemoryAllocateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMemoryAllocateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->allocationSize = (VkDeviceSize)memory->readq(address);address+=8;
        s->memoryTypeIndex = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkMappedMemoryRange {
public:
    MarshalVkMappedMemoryRange() {}
    VkMappedMemoryRange s;
    MarshalVkMappedMemoryRange(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMappedMemoryRange* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
        s->size = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkDescriptorImageInfo {
public:
    MarshalVkDescriptorImageInfo() {}
    VkDescriptorImageInfo s;
    MarshalVkDescriptorImageInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorImageInfo* s) {
        s->sampler = (VkSampler)memory->readq(address);address+=8;
        s->imageView = (VkImageView)memory->readq(address);address+=8;
        s->imageLayout = (VkImageLayout)memory->readd(address);address+=4;
    }
};

class MarshalVkWriteDescriptorSet {
public:
    MarshalVkWriteDescriptorSet() {}
    VkWriteDescriptorSet s;
    MarshalVkWriteDescriptorSet(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkWriteDescriptorSet* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
        s->dstBinding = (uint32_t)memory->readd(address);address+=4;
        s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
        s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
        s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImageInfo = NULL;
        } else {
            VkDescriptorImageInfo* pImageInfo = new VkDescriptorImageInfo[s->descriptorCount];
            for (U32 i = 0; i < s->descriptorCount; i++) {
                MarshalVkDescriptorImageInfo::read(memory, paramAddress, &pImageInfo[i]);
            }
            s->pImageInfo = pImageInfo;
        }
        memory->memcpy(&s->pBufferInfo, address, 24);address+=24;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pTexelBufferView = NULL;
        } else {
            s->pTexelBufferView = new VkBufferView[s->descriptorCount * sizeof(VkBufferView)];
            memory->memcpy((VkBufferView*)s->pTexelBufferView, paramAddress, s->descriptorCount * sizeof(VkBufferView));
        }
    }
};

class MarshalVkCopyDescriptorSet {
public:
    MarshalVkCopyDescriptorSet() {}
    VkCopyDescriptorSet s;
    MarshalVkCopyDescriptorSet(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCopyDescriptorSet* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcSet = (VkDescriptorSet)memory->readq(address);address+=8;
        s->srcBinding = (uint32_t)memory->readd(address);address+=4;
        s->srcArrayElement = (uint32_t)memory->readd(address);address+=4;
        s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
        s->dstBinding = (uint32_t)memory->readd(address);address+=4;
        s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
        s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkBufferCreateInfo {
public:
    MarshalVkBufferCreateInfo() {}
    VkBufferCreateInfo s;
    MarshalVkBufferCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
        s->size = (VkDeviceSize)memory->readq(address);address+=8;
        s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
        s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
        s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pQueueFamilyIndices = NULL;
        } else {
            s->pQueueFamilyIndices = new uint32_t[s->queueFamilyIndexCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, s->queueFamilyIndexCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkBufferViewCreateInfo {
public:
    MarshalVkBufferViewCreateInfo() {}
    VkBufferViewCreateInfo s;
    MarshalVkBufferViewCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferViewCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkBufferViewCreateFlags)memory->readd(address);address+=4;
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
        s->range = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkMemoryBarrier {
public:
    MarshalVkMemoryBarrier() {}
    VkMemoryBarrier s;
    MarshalVkMemoryBarrier(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMemoryBarrier* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkBufferMemoryBarrier {
public:
    MarshalVkBufferMemoryBarrier() {}
    VkBufferMemoryBarrier s;
    MarshalVkBufferMemoryBarrier(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferMemoryBarrier* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
        s->size = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkImageMemoryBarrier {
public:
    MarshalVkImageMemoryBarrier() {}
    VkImageMemoryBarrier s;
    MarshalVkImageMemoryBarrier(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageMemoryBarrier* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->image = (VkImage)memory->readq(address);address+=8;
        memory->memcpy(&s->subresourceRange, address, 20);address+=20;
    }
};

class MarshalVkImageCreateInfo {
public:
    MarshalVkImageCreateInfo() {}
    VkImageCreateInfo s;
    MarshalVkImageCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
        s->imageType = (VkImageType)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        memory->memcpy(&s->extent, address, 12);address+=12;
        s->mipLevels = (uint32_t)memory->readd(address);address+=4;
        s->arrayLayers = (uint32_t)memory->readd(address);address+=4;
        s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        s->tiling = (VkImageTiling)memory->readd(address);address+=4;
        s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
        s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
        s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pQueueFamilyIndices = NULL;
        } else {
            s->pQueueFamilyIndices = new uint32_t[s->queueFamilyIndexCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, s->queueFamilyIndexCount * sizeof(uint32_t));
        }
        s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
    }
};

class MarshalVkImageViewCreateInfo {
public:
    MarshalVkImageViewCreateInfo() {}
    VkImageViewCreateInfo s;
    MarshalVkImageViewCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageViewCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkImageViewCreateFlags)memory->readd(address);address+=4;
        s->image = (VkImage)memory->readq(address);address+=8;
        s->viewType = (VkImageViewType)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        MarshalVkComponentMapping::read(memory, address, &s->components); address+=16;
        memory->memcpy(&s->subresourceRange, address, 20);address+=20;
    }
};

class MarshalVkSparseBufferMemoryBindInfo {
public:
    MarshalVkSparseBufferMemoryBindInfo() {}
    VkSparseBufferMemoryBindInfo s;
    MarshalVkSparseBufferMemoryBindInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSparseBufferMemoryBindInfo* s) {
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->bindCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBinds = NULL;
        } else {
            s->pBinds = new VkSparseMemoryBind[s->bindCount * sizeof(VkSparseMemoryBind)];
            memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, s->bindCount * sizeof(VkSparseMemoryBind));
        }
    }
};

class MarshalVkSparseImageOpaqueMemoryBindInfo {
public:
    MarshalVkSparseImageOpaqueMemoryBindInfo() {}
    VkSparseImageOpaqueMemoryBindInfo s;
    MarshalVkSparseImageOpaqueMemoryBindInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSparseImageOpaqueMemoryBindInfo* s) {
        s->image = (VkImage)memory->readq(address);address+=8;
        s->bindCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBinds = NULL;
        } else {
            s->pBinds = new VkSparseMemoryBind[s->bindCount * sizeof(VkSparseMemoryBind)];
            memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, s->bindCount * sizeof(VkSparseMemoryBind));
        }
    }
};

class MarshalVkSparseImageMemoryBindInfo {
public:
    MarshalVkSparseImageMemoryBindInfo() {}
    VkSparseImageMemoryBindInfo s;
    MarshalVkSparseImageMemoryBindInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSparseImageMemoryBindInfo* s) {
        s->image = (VkImage)memory->readq(address);address+=8;
        s->bindCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBinds = NULL;
        } else {
            s->pBinds = new VkSparseImageMemoryBind[s->bindCount * sizeof(VkSparseImageMemoryBind)];
            memory->memcpy((VkSparseImageMemoryBind*)s->pBinds, paramAddress, s->bindCount * sizeof(VkSparseImageMemoryBind));
        }
    }
};

class MarshalVkBindSparseInfo {
public:
    MarshalVkBindSparseInfo() {}
    VkBindSparseInfo s;
    MarshalVkBindSparseInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBindSparseInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pWaitSemaphores = NULL;
        } else {
            s->pWaitSemaphores = new VkSemaphore[s->waitSemaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, s->waitSemaphoreCount * sizeof(VkSemaphore));
        }
        s->bufferBindCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBufferBinds = NULL;
        } else {
            VkSparseBufferMemoryBindInfo* pBufferBinds = new VkSparseBufferMemoryBindInfo[s->bufferBindCount];
            for (U32 i = 0; i < s->bufferBindCount; i++) {
                MarshalVkSparseBufferMemoryBindInfo::read(memory, paramAddress, &pBufferBinds[i]);
            }
            s->pBufferBinds = pBufferBinds;
        }
        s->imageOpaqueBindCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImageOpaqueBinds = NULL;
        } else {
            VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = new VkSparseImageOpaqueMemoryBindInfo[s->imageOpaqueBindCount];
            for (U32 i = 0; i < s->imageOpaqueBindCount; i++) {
                MarshalVkSparseImageOpaqueMemoryBindInfo::read(memory, paramAddress, &pImageOpaqueBinds[i]);
            }
            s->pImageOpaqueBinds = pImageOpaqueBinds;
        }
        s->imageBindCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImageBinds = NULL;
        } else {
            VkSparseImageMemoryBindInfo* pImageBinds = new VkSparseImageMemoryBindInfo[s->imageBindCount];
            for (U32 i = 0; i < s->imageBindCount; i++) {
                MarshalVkSparseImageMemoryBindInfo::read(memory, paramAddress, &pImageBinds[i]);
            }
            s->pImageBinds = pImageBinds;
        }
        s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSignalSemaphores = NULL;
        } else {
            s->pSignalSemaphores = new VkSemaphore[s->signalSemaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, s->signalSemaphoreCount * sizeof(VkSemaphore));
        }
    }
};

class MarshalVkShaderModuleCreateInfo {
public:
    MarshalVkShaderModuleCreateInfo() {}
    VkShaderModuleCreateInfo s;
    MarshalVkShaderModuleCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkShaderModuleCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkShaderModuleCreateFlags)memory->readd(address);address+=4;
        s->codeSize = (size_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pCode = NULL;
        } else {
            s->pCode = new uint32_t[s->codeSize / 4 * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pCode, paramAddress, s->codeSize / 4 * sizeof(uint32_t));
        }
    }
};

class MarshalVkDescriptorSetLayoutBinding {
public:
    MarshalVkDescriptorSetLayoutBinding() {}
    VkDescriptorSetLayoutBinding s;
    MarshalVkDescriptorSetLayoutBinding(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorSetLayoutBinding* s) {
        s->binding = (uint32_t)memory->readd(address);address+=4;
        s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
        s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
        s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImmutableSamplers = NULL;
        } else {
            s->pImmutableSamplers = new VkSampler[s->descriptorCount * sizeof(VkSampler)];
            memory->memcpy((VkSampler*)s->pImmutableSamplers, paramAddress, s->descriptorCount * sizeof(VkSampler));
        }
    }
};

class MarshalVkDescriptorSetLayoutCreateInfo {
public:
    MarshalVkDescriptorSetLayoutCreateInfo() {}
    VkDescriptorSetLayoutCreateInfo s;
    MarshalVkDescriptorSetLayoutCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorSetLayoutCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDescriptorSetLayoutCreateFlags)memory->readd(address);address+=4;
        s->bindingCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBindings = NULL;
        } else {
            VkDescriptorSetLayoutBinding* pBindings = new VkDescriptorSetLayoutBinding[s->bindingCount];
            for (U32 i = 0; i < s->bindingCount; i++) {
                MarshalVkDescriptorSetLayoutBinding::read(memory, paramAddress, &pBindings[i]);
            }
            s->pBindings = pBindings;
        }
    }
};

class MarshalVkDescriptorPoolSize {
public:
    MarshalVkDescriptorPoolSize() {}
    VkDescriptorPoolSize s;
    MarshalVkDescriptorPoolSize(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorPoolSize* s) {
        s->type = (VkDescriptorType)memory->readd(address);address+=4;
        s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkDescriptorPoolCreateInfo {
public:
    MarshalVkDescriptorPoolCreateInfo() {}
    VkDescriptorPoolCreateInfo s;
    MarshalVkDescriptorPoolCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorPoolCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDescriptorPoolCreateFlags)memory->readd(address);address+=4;
        s->maxSets = (uint32_t)memory->readd(address);address+=4;
        s->poolSizeCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pPoolSizes = NULL;
        } else {
            VkDescriptorPoolSize* pPoolSizes = new VkDescriptorPoolSize[s->poolSizeCount];
            for (U32 i = 0; i < s->poolSizeCount; i++) {
                MarshalVkDescriptorPoolSize::read(memory, paramAddress, &pPoolSizes[i]);
            }
            s->pPoolSizes = pPoolSizes;
        }
    }
};

class MarshalVkDescriptorSetAllocateInfo {
public:
    MarshalVkDescriptorSetAllocateInfo() {}
    VkDescriptorSetAllocateInfo s;
    MarshalVkDescriptorSetAllocateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorSetAllocateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->descriptorPool = (VkDescriptorPool)memory->readq(address);address+=8;
        s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSetLayouts = NULL;
        } else {
            s->pSetLayouts = new VkDescriptorSetLayout[s->descriptorSetCount * sizeof(VkDescriptorSetLayout)];
            memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, s->descriptorSetCount * sizeof(VkDescriptorSetLayout));
        }
    }
};

class MarshalVkSpecializationMapEntry {
public:
    MarshalVkSpecializationMapEntry() {}
    VkSpecializationMapEntry s;
    MarshalVkSpecializationMapEntry(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSpecializationMapEntry* s) {
        s->constantID = (uint32_t)memory->readd(address);address+=4;
        s->offset = (uint32_t)memory->readd(address);address+=4;
        s->size = (size_t)memory->readd(address);address+=4;
    }
};

class MarshalVkSpecializationInfo {
public:
    MarshalVkSpecializationInfo() {}
    VkSpecializationInfo s;
    MarshalVkSpecializationInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSpecializationInfo* s) {
        s->mapEntryCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pMapEntries = NULL;
        } else {
            VkSpecializationMapEntry* pMapEntries = new VkSpecializationMapEntry[s->mapEntryCount];
            for (U32 i = 0; i < s->mapEntryCount; i++) {
                MarshalVkSpecializationMapEntry::read(memory, paramAddress, &pMapEntries[i]);
            }
            s->pMapEntries = pMapEntries;
        }
        s->dataSize = (size_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pData = NULL;
        } else {
            s->pData = new char[s->dataSize];
            memory->memcpy((void*)s->pData, paramAddress, s->dataSize);
        }
    }
};

class MarshalVkPipelineShaderStageCreateInfo {
public:
    MarshalVkPipelineShaderStageCreateInfo() {}
    VkPipelineShaderStageCreateInfo s;
    MarshalVkPipelineShaderStageCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineShaderStageCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineShaderStageCreateFlags)memory->readd(address);address+=4;
        s->stage = (VkShaderStageFlagBits)memory->readd(address);address+=4;
        s->module = (VkShaderModule)memory->readq(address);address+=8;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pName = NULL;
        } else {
            s->pName = new char[0 * sizeof(char)];
            memory->memcpy((char*)s->pName, paramAddress, 0 * sizeof(char));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSpecializationInfo = NULL;
        } else {
            VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
            MarshalVkSpecializationInfo::read(memory, paramAddress, pSpecializationInfo);
            s->pSpecializationInfo = pSpecializationInfo;
        }
    }
};

class MarshalVkComputePipelineCreateInfo {
public:
    MarshalVkComputePipelineCreateInfo() {}
    VkComputePipelineCreateInfo s;
    MarshalVkComputePipelineCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkComputePipelineCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
        MarshalVkPipelineShaderStageCreateInfo::read(memory, address, &s->stage); address+=32;
        s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
        s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
        s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkVertexInputBindingDescription {
public:
    MarshalVkVertexInputBindingDescription() {}
    VkVertexInputBindingDescription s;
    MarshalVkVertexInputBindingDescription(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkVertexInputBindingDescription* s) {
        s->binding = (uint32_t)memory->readd(address);address+=4;
        s->stride = (uint32_t)memory->readd(address);address+=4;
        s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
    }
};

class MarshalVkVertexInputAttributeDescription {
public:
    MarshalVkVertexInputAttributeDescription() {}
    VkVertexInputAttributeDescription s;
    MarshalVkVertexInputAttributeDescription(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkVertexInputAttributeDescription* s) {
        s->location = (uint32_t)memory->readd(address);address+=4;
        s->binding = (uint32_t)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->offset = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineVertexInputStateCreateInfo {
public:
    MarshalVkPipelineVertexInputStateCreateInfo() {}
    VkPipelineVertexInputStateCreateInfo s;
    MarshalVkPipelineVertexInputStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineVertexInputStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineVertexInputStateCreateFlags)memory->readd(address);address+=4;
        s->vertexBindingDescriptionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pVertexBindingDescriptions = NULL;
        } else {
            VkVertexInputBindingDescription* pVertexBindingDescriptions = new VkVertexInputBindingDescription[s->vertexBindingDescriptionCount];
            for (U32 i = 0; i < s->vertexBindingDescriptionCount; i++) {
                MarshalVkVertexInputBindingDescription::read(memory, paramAddress, &pVertexBindingDescriptions[i]);
            }
            s->pVertexBindingDescriptions = pVertexBindingDescriptions;
        }
        s->vertexAttributeDescriptionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pVertexAttributeDescriptions = NULL;
        } else {
            VkVertexInputAttributeDescription* pVertexAttributeDescriptions = new VkVertexInputAttributeDescription[s->vertexAttributeDescriptionCount];
            for (U32 i = 0; i < s->vertexAttributeDescriptionCount; i++) {
                MarshalVkVertexInputAttributeDescription::read(memory, paramAddress, &pVertexAttributeDescriptions[i]);
            }
            s->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
        }
    }
};

class MarshalVkPipelineInputAssemblyStateCreateInfo {
public:
    MarshalVkPipelineInputAssemblyStateCreateInfo() {}
    VkPipelineInputAssemblyStateCreateInfo s;
    MarshalVkPipelineInputAssemblyStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineInputAssemblyStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineInputAssemblyStateCreateFlags)memory->readd(address);address+=4;
        s->topology = (VkPrimitiveTopology)memory->readd(address);address+=4;
        s->primitiveRestartEnable = (VkBool32)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineTessellationStateCreateInfo {
public:
    MarshalVkPipelineTessellationStateCreateInfo() {}
    VkPipelineTessellationStateCreateInfo s;
    MarshalVkPipelineTessellationStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineTessellationStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineTessellationStateCreateFlags)memory->readd(address);address+=4;
        s->patchControlPoints = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineViewportStateCreateInfo {
public:
    MarshalVkPipelineViewportStateCreateInfo() {}
    VkPipelineViewportStateCreateInfo s;
    MarshalVkPipelineViewportStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineViewportStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineViewportStateCreateFlags)memory->readd(address);address+=4;
        s->viewportCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pViewports = NULL;
        } else {
            s->pViewports = new VkViewport[s->viewportCount * sizeof(VkViewport)];
            memory->memcpy((VkViewport*)s->pViewports, paramAddress, s->viewportCount * sizeof(VkViewport));
        }
        s->scissorCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pScissors = NULL;
        } else {
            s->pScissors = new VkRect2D[s->scissorCount * sizeof(VkRect2D)];
            memory->memcpy((VkRect2D*)s->pScissors, paramAddress, s->scissorCount * sizeof(VkRect2D));
        }
    }
};

class MarshalVkPipelineRasterizationStateCreateInfo {
public:
    MarshalVkPipelineRasterizationStateCreateInfo() {}
    VkPipelineRasterizationStateCreateInfo s;
    MarshalVkPipelineRasterizationStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineRasterizationStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineRasterizationStateCreateFlags)memory->readd(address);address+=4;
        s->depthClampEnable = (VkBool32)memory->readd(address);address+=4;
        s->rasterizerDiscardEnable = (VkBool32)memory->readd(address);address+=4;
        s->polygonMode = (VkPolygonMode)memory->readd(address);address+=4;
        s->cullMode = (VkCullModeFlags)memory->readd(address);address+=4;
        s->frontFace = (VkFrontFace)memory->readd(address);address+=4;
        s->depthBiasEnable = (VkBool32)memory->readd(address);address+=4;
        s->depthBiasConstantFactor = (float)memory->readd(address);address+=4;
        s->depthBiasClamp = (float)memory->readd(address);address+=4;
        s->depthBiasSlopeFactor = (float)memory->readd(address);address+=4;
        s->lineWidth = (float)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineMultisampleStateCreateInfo {
public:
    MarshalVkPipelineMultisampleStateCreateInfo() {}
    VkPipelineMultisampleStateCreateInfo s;
    MarshalVkPipelineMultisampleStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineMultisampleStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineMultisampleStateCreateFlags)memory->readd(address);address+=4;
        s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        s->sampleShadingEnable = (VkBool32)memory->readd(address);address+=4;
        s->minSampleShading = (float)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSampleMask = NULL;
        } else {
            s->pSampleMask = new VkSampleMask[(s->rasterizationSamples + 31) / 32 * sizeof(VkSampleMask)];
            memory->memcpy((VkSampleMask*)s->pSampleMask, paramAddress, (s->rasterizationSamples + 31) / 32 * sizeof(VkSampleMask));
        }
        s->alphaToCoverageEnable = (VkBool32)memory->readd(address);address+=4;
        s->alphaToOneEnable = (VkBool32)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineColorBlendAttachmentState {
public:
    MarshalVkPipelineColorBlendAttachmentState() {}
    VkPipelineColorBlendAttachmentState s;
    MarshalVkPipelineColorBlendAttachmentState(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineColorBlendAttachmentState* s) {
        s->blendEnable = (VkBool32)memory->readd(address);address+=4;
        s->srcColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
        s->dstColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
        s->colorBlendOp = (VkBlendOp)memory->readd(address);address+=4;
        s->srcAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
        s->dstAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
        s->alphaBlendOp = (VkBlendOp)memory->readd(address);address+=4;
        s->colorWriteMask = (VkColorComponentFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineColorBlendStateCreateInfo {
public:
    MarshalVkPipelineColorBlendStateCreateInfo() {}
    VkPipelineColorBlendStateCreateInfo s;
    MarshalVkPipelineColorBlendStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineColorBlendStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineColorBlendStateCreateFlags)memory->readd(address);address+=4;
        s->logicOpEnable = (VkBool32)memory->readd(address);address+=4;
        s->logicOp = (VkLogicOp)memory->readd(address);address+=4;
        s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pAttachments = NULL;
        } else {
            VkPipelineColorBlendAttachmentState* pAttachments = new VkPipelineColorBlendAttachmentState[s->attachmentCount];
            for (U32 i = 0; i < s->attachmentCount; i++) {
                MarshalVkPipelineColorBlendAttachmentState::read(memory, paramAddress, &pAttachments[i]);
            }
            s->pAttachments = pAttachments;
        }
        memory->memcpy(&s->blendConstants, address, 4);address+=4;
    }
};

class MarshalVkPipelineDynamicStateCreateInfo {
public:
    MarshalVkPipelineDynamicStateCreateInfo() {}
    VkPipelineDynamicStateCreateInfo s;
    MarshalVkPipelineDynamicStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineDynamicStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineDynamicStateCreateFlags)memory->readd(address);address+=4;
        s->dynamicStateCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDynamicStates = NULL;
        } else {
            s->pDynamicStates = new VkDynamicState[s->dynamicStateCount * sizeof(VkDynamicState)];
            memory->memcpy((VkDynamicState*)s->pDynamicStates, paramAddress, s->dynamicStateCount * sizeof(VkDynamicState));
        }
    }
};

class MarshalVkStencilOpState {
public:
    MarshalVkStencilOpState() {}
    VkStencilOpState s;
    MarshalVkStencilOpState(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkStencilOpState* s) {
        s->failOp = (VkStencilOp)memory->readd(address);address+=4;
        s->passOp = (VkStencilOp)memory->readd(address);address+=4;
        s->depthFailOp = (VkStencilOp)memory->readd(address);address+=4;
        s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
        s->compareMask = (uint32_t)memory->readd(address);address+=4;
        s->writeMask = (uint32_t)memory->readd(address);address+=4;
        s->reference = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineDepthStencilStateCreateInfo {
public:
    MarshalVkPipelineDepthStencilStateCreateInfo() {}
    VkPipelineDepthStencilStateCreateInfo s;
    MarshalVkPipelineDepthStencilStateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineDepthStencilStateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineDepthStencilStateCreateFlags)memory->readd(address);address+=4;
        s->depthTestEnable = (VkBool32)memory->readd(address);address+=4;
        s->depthWriteEnable = (VkBool32)memory->readd(address);address+=4;
        s->depthCompareOp = (VkCompareOp)memory->readd(address);address+=4;
        s->depthBoundsTestEnable = (VkBool32)memory->readd(address);address+=4;
        s->stencilTestEnable = (VkBool32)memory->readd(address);address+=4;
        MarshalVkStencilOpState::read(memory, address, &s->front); address+=28;
        MarshalVkStencilOpState::read(memory, address, &s->back); address+=28;
        s->minDepthBounds = (float)memory->readd(address);address+=4;
        s->maxDepthBounds = (float)memory->readd(address);address+=4;
    }
};

class MarshalVkGraphicsPipelineCreateInfo {
public:
    MarshalVkGraphicsPipelineCreateInfo() {}
    VkGraphicsPipelineCreateInfo s;
    MarshalVkGraphicsPipelineCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGraphicsPipelineCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
        s->stageCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pStages = NULL;
        } else {
            VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
            for (U32 i = 0; i < s->stageCount; i++) {
                MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress, &pStages[i]);
            }
            s->pStages = pStages;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pVertexInputState = NULL;
        } else {
            VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
            MarshalVkPipelineVertexInputStateCreateInfo::read(memory, paramAddress, pVertexInputState);
            s->pVertexInputState = pVertexInputState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInputAssemblyState = NULL;
        } else {
            VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo();
            MarshalVkPipelineInputAssemblyStateCreateInfo::read(memory, paramAddress, pInputAssemblyState);
            s->pInputAssemblyState = pInputAssemblyState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pTessellationState = NULL;
        } else {
            VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
            MarshalVkPipelineTessellationStateCreateInfo::read(memory, paramAddress, pTessellationState);
            s->pTessellationState = pTessellationState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pViewportState = NULL;
        } else {
            VkPipelineViewportStateCreateInfo* pViewportState = new VkPipelineViewportStateCreateInfo();
            MarshalVkPipelineViewportStateCreateInfo::read(memory, paramAddress, pViewportState);
            s->pViewportState = pViewportState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRasterizationState = NULL;
        } else {
            VkPipelineRasterizationStateCreateInfo* pRasterizationState = new VkPipelineRasterizationStateCreateInfo();
            MarshalVkPipelineRasterizationStateCreateInfo::read(memory, paramAddress, pRasterizationState);
            s->pRasterizationState = pRasterizationState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pMultisampleState = NULL;
        } else {
            VkPipelineMultisampleStateCreateInfo* pMultisampleState = new VkPipelineMultisampleStateCreateInfo();
            MarshalVkPipelineMultisampleStateCreateInfo::read(memory, paramAddress, pMultisampleState);
            s->pMultisampleState = pMultisampleState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDepthStencilState = NULL;
        } else {
            VkPipelineDepthStencilStateCreateInfo* pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo();
            MarshalVkPipelineDepthStencilStateCreateInfo::read(memory, paramAddress, pDepthStencilState);
            s->pDepthStencilState = pDepthStencilState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pColorBlendState = NULL;
        } else {
            VkPipelineColorBlendStateCreateInfo* pColorBlendState = new VkPipelineColorBlendStateCreateInfo();
            MarshalVkPipelineColorBlendStateCreateInfo::read(memory, paramAddress, pColorBlendState);
            s->pColorBlendState = pColorBlendState;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDynamicState = NULL;
        } else {
            VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
            MarshalVkPipelineDynamicStateCreateInfo::read(memory, paramAddress, pDynamicState);
            s->pDynamicState = pDynamicState;
        }
        s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
        s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
        s->subpass = (uint32_t)memory->readd(address);address+=4;
        s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
        s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPipelineCacheCreateInfo {
public:
    MarshalVkPipelineCacheCreateInfo() {}
    VkPipelineCacheCreateInfo s;
    MarshalVkPipelineCacheCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineCacheCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineCacheCreateFlags)memory->readd(address);address+=4;
        s->initialDataSize = (size_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInitialData = NULL;
        } else {
            s->pInitialData = new char[s->initialDataSize];
            memory->memcpy((void*)s->pInitialData, paramAddress, s->initialDataSize);
        }
    }
};

class MarshalVkPipelineLayoutCreateInfo {
public:
    MarshalVkPipelineLayoutCreateInfo() {}
    VkPipelineLayoutCreateInfo s;
    MarshalVkPipelineLayoutCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPipelineLayoutCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineLayoutCreateFlags)memory->readd(address);address+=4;
        s->setLayoutCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSetLayouts = NULL;
        } else {
            s->pSetLayouts = new VkDescriptorSetLayout[s->setLayoutCount * sizeof(VkDescriptorSetLayout)];
            memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, s->setLayoutCount * sizeof(VkDescriptorSetLayout));
        }
        s->pushConstantRangeCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pPushConstantRanges = NULL;
        } else {
            s->pPushConstantRanges = new VkPushConstantRange[s->pushConstantRangeCount * sizeof(VkPushConstantRange)];
            memory->memcpy((VkPushConstantRange*)s->pPushConstantRanges, paramAddress, s->pushConstantRangeCount * sizeof(VkPushConstantRange));
        }
    }
};

class MarshalVkSamplerCreateInfo {
public:
    MarshalVkSamplerCreateInfo() {}
    VkSamplerCreateInfo s;
    MarshalVkSamplerCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSamplerCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSamplerCreateFlags)memory->readd(address);address+=4;
        s->magFilter = (VkFilter)memory->readd(address);address+=4;
        s->minFilter = (VkFilter)memory->readd(address);address+=4;
        s->mipmapMode = (VkSamplerMipmapMode)memory->readd(address);address+=4;
        s->addressModeU = (VkSamplerAddressMode)memory->readd(address);address+=4;
        s->addressModeV = (VkSamplerAddressMode)memory->readd(address);address+=4;
        s->addressModeW = (VkSamplerAddressMode)memory->readd(address);address+=4;
        s->mipLodBias = (float)memory->readd(address);address+=4;
        s->anisotropyEnable = (VkBool32)memory->readd(address);address+=4;
        s->maxAnisotropy = (float)memory->readd(address);address+=4;
        s->compareEnable = (VkBool32)memory->readd(address);address+=4;
        s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
        s->minLod = (float)memory->readd(address);address+=4;
        s->maxLod = (float)memory->readd(address);address+=4;
        s->borderColor = (VkBorderColor)memory->readd(address);address+=4;
        s->unnormalizedCoordinates = (VkBool32)memory->readd(address);address+=4;
    }
};

class MarshalVkCommandPoolCreateInfo {
public:
    MarshalVkCommandPoolCreateInfo() {}
    VkCommandPoolCreateInfo s;
    MarshalVkCommandPoolCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCommandPoolCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkCommandPoolCreateFlags)memory->readd(address);address+=4;
        s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkCommandBufferAllocateInfo {
public:
    MarshalVkCommandBufferAllocateInfo() {}
    VkCommandBufferAllocateInfo s;
    MarshalVkCommandBufferAllocateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCommandBufferAllocateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->commandPool = (VkCommandPool)memory->readq(address);address+=8;
        s->level = (VkCommandBufferLevel)memory->readd(address);address+=4;
        s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkCommandBufferInheritanceInfo {
public:
    MarshalVkCommandBufferInheritanceInfo() {}
    VkCommandBufferInheritanceInfo s;
    MarshalVkCommandBufferInheritanceInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCommandBufferInheritanceInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
        s->subpass = (uint32_t)memory->readd(address);address+=4;
        s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
        s->occlusionQueryEnable = (VkBool32)memory->readd(address);address+=4;
        s->queryFlags = (VkQueryControlFlags)memory->readd(address);address+=4;
        s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkCommandBufferBeginInfo {
public:
    MarshalVkCommandBufferBeginInfo() {}
    VkCommandBufferBeginInfo s;
    MarshalVkCommandBufferBeginInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCommandBufferBeginInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkCommandBufferUsageFlags)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInheritanceInfo = NULL;
        } else {
            VkCommandBufferInheritanceInfo* pInheritanceInfo = new VkCommandBufferInheritanceInfo();
            MarshalVkCommandBufferInheritanceInfo::read(memory, paramAddress, pInheritanceInfo);
            s->pInheritanceInfo = pInheritanceInfo;
        }
    }
};

class MarshalVkRenderPassBeginInfo {
public:
    MarshalVkRenderPassBeginInfo() {}
    VkRenderPassBeginInfo s;
    MarshalVkRenderPassBeginInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkRenderPassBeginInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
        s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
        memory->memcpy(&s->renderArea, address, 16);address+=16;
        s->clearValueCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pClearValues = NULL;
        } else {
            s->pClearValues = new VkClearValue[s->clearValueCount * sizeof(VkClearValue)];
            memory->memcpy((VkClearValue*)s->pClearValues, paramAddress, s->clearValueCount * sizeof(VkClearValue));
        }
    }
};

class MarshalVkAttachmentDescription {
public:
    MarshalVkAttachmentDescription() {}
    VkAttachmentDescription s;
    MarshalVkAttachmentDescription(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAttachmentDescription* s) {
        s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
        s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
        s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
        s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
        s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
    }
};

class MarshalVkAttachmentReference {
public:
    MarshalVkAttachmentReference() {}
    VkAttachmentReference s;
    MarshalVkAttachmentReference(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAttachmentReference* s) {
        s->attachment = (uint32_t)memory->readd(address);address+=4;
        s->layout = (VkImageLayout)memory->readd(address);address+=4;
    }
};

class MarshalVkSubpassDescription {
public:
    MarshalVkSubpassDescription() {}
    VkSubpassDescription s;
    MarshalVkSubpassDescription(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubpassDescription* s) {
        s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInputAttachments = NULL;
        } else {
            VkAttachmentReference* pInputAttachments = new VkAttachmentReference[s->inputAttachmentCount];
            for (U32 i = 0; i < s->inputAttachmentCount; i++) {
                MarshalVkAttachmentReference::read(memory, paramAddress, &pInputAttachments[i]);
            }
            s->pInputAttachments = pInputAttachments;
        }
        s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pColorAttachments = NULL;
        } else {
            VkAttachmentReference* pColorAttachments = new VkAttachmentReference[s->colorAttachmentCount];
            for (U32 i = 0; i < s->colorAttachmentCount; i++) {
                MarshalVkAttachmentReference::read(memory, paramAddress, &pColorAttachments[i]);
            }
            s->pColorAttachments = pColorAttachments;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pResolveAttachments = NULL;
        } else {
            VkAttachmentReference* pResolveAttachments = new VkAttachmentReference[s->colorAttachmentCount];
            for (U32 i = 0; i < s->colorAttachmentCount; i++) {
                MarshalVkAttachmentReference::read(memory, paramAddress, &pResolveAttachments[i]);
            }
            s->pResolveAttachments = pResolveAttachments;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDepthStencilAttachment = NULL;
        } else {
            VkAttachmentReference* pDepthStencilAttachment = new VkAttachmentReference();
            MarshalVkAttachmentReference::read(memory, paramAddress, pDepthStencilAttachment);
            s->pDepthStencilAttachment = pDepthStencilAttachment;
        }
        s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pPreserveAttachments = NULL;
        } else {
            s->pPreserveAttachments = new uint32_t[s->preserveAttachmentCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, s->preserveAttachmentCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkRenderPassCreateInfo {
public:
    MarshalVkRenderPassCreateInfo() {}
    VkRenderPassCreateInfo s;
    MarshalVkRenderPassCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkRenderPassCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
        s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pAttachments = NULL;
        } else {
            VkAttachmentDescription* pAttachments = new VkAttachmentDescription[s->attachmentCount];
            for (U32 i = 0; i < s->attachmentCount; i++) {
                MarshalVkAttachmentDescription::read(memory, paramAddress, &pAttachments[i]);
            }
            s->pAttachments = pAttachments;
        }
        s->subpassCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSubpasses = NULL;
        } else {
            VkSubpassDescription* pSubpasses = new VkSubpassDescription[s->subpassCount];
            for (U32 i = 0; i < s->subpassCount; i++) {
                MarshalVkSubpassDescription::read(memory, paramAddress, &pSubpasses[i]);
            }
            s->pSubpasses = pSubpasses;
        }
        s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDependencies = NULL;
        } else {
            s->pDependencies = new VkSubpassDependency[s->dependencyCount * sizeof(VkSubpassDependency)];
            memory->memcpy((VkSubpassDependency*)s->pDependencies, paramAddress, s->dependencyCount * sizeof(VkSubpassDependency));
        }
    }
};

class MarshalVkEventCreateInfo {
public:
    MarshalVkEventCreateInfo() {}
    VkEventCreateInfo s;
    MarshalVkEventCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkEventCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkEventCreateFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkFenceCreateInfo {
public:
    MarshalVkFenceCreateInfo() {}
    VkFenceCreateInfo s;
    MarshalVkFenceCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkFenceCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkFenceCreateFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkSemaphoreCreateInfo {
public:
    MarshalVkSemaphoreCreateInfo() {}
    VkSemaphoreCreateInfo s;
    MarshalVkSemaphoreCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSemaphoreCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSemaphoreCreateFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkQueryPoolCreateInfo {
public:
    MarshalVkQueryPoolCreateInfo() {}
    VkQueryPoolCreateInfo s;
    MarshalVkQueryPoolCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkQueryPoolCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkQueryPoolCreateFlags)memory->readd(address);address+=4;
        s->queryType = (VkQueryType)memory->readd(address);address+=4;
        s->queryCount = (uint32_t)memory->readd(address);address+=4;
        s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkFramebufferCreateInfo {
public:
    MarshalVkFramebufferCreateInfo() {}
    VkFramebufferCreateInfo s;
    MarshalVkFramebufferCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkFramebufferCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkFramebufferCreateFlags)memory->readd(address);address+=4;
        s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
        s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pAttachments = NULL;
        } else {
            s->pAttachments = new VkImageView[s->attachmentCount * sizeof(VkImageView)];
            memory->memcpy((VkImageView*)s->pAttachments, paramAddress, s->attachmentCount * sizeof(VkImageView));
        }
        s->width = (uint32_t)memory->readd(address);address+=4;
        s->height = (uint32_t)memory->readd(address);address+=4;
        s->layers = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkSubmitInfo {
public:
    MarshalVkSubmitInfo() {}
    VkSubmitInfo s;
    MarshalVkSubmitInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubmitInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pWaitSemaphores = NULL;
        } else {
            s->pWaitSemaphores = new VkSemaphore[s->waitSemaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, s->waitSemaphoreCount * sizeof(VkSemaphore));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pWaitDstStageMask = NULL;
        } else {
            s->pWaitDstStageMask = new VkPipelineStageFlags[s->waitSemaphoreCount * sizeof(VkPipelineStageFlags)];
            memory->memcpy((VkPipelineStageFlags*)s->pWaitDstStageMask, paramAddress, s->waitSemaphoreCount * sizeof(VkPipelineStageFlags));
        }
        s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pCommandBuffers = NULL;
        } else {
            VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[s->commandBufferCount];
            for (int i=0;i<(int)s->commandBufferCount;i++) {
                pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(memory, paramAddress);
            }
            s->pCommandBuffers = pCommandBuffers;
        }
        s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSignalSemaphores = NULL;
        } else {
            s->pSignalSemaphores = new VkSemaphore[s->signalSemaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, s->signalSemaphoreCount * sizeof(VkSemaphore));
        }
    }
};

class MarshalVkSurfaceCapabilitiesKHR {
public:
    MarshalVkSurfaceCapabilitiesKHR() {}
    VkSurfaceCapabilitiesKHR s;
    MarshalVkSurfaceCapabilitiesKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
        s->minImageCount = (uint32_t)memory->readd(address);address+=4;
        s->maxImageCount = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->currentExtent, address, 8);address+=8;
        memory->memcpy(&s->minImageExtent, address, 8);address+=8;
        memory->memcpy(&s->maxImageExtent, address, 8);address+=8;
        s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
        s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
        s->currentTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
        s->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)memory->readd(address);address+=4;
        s->supportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
        memory->writed(address, s->minImageCount);address+=4;
        memory->writed(address, s->maxImageCount);address+=4;
        memory->memcpy(address, &s->currentExtent, 8); address+=8;
        memory->memcpy(address, &s->minImageExtent, 8); address+=8;
        memory->memcpy(address, &s->maxImageExtent, 8); address+=8;
        memory->writed(address, s->maxImageArrayLayers);address+=4;
        memory->writed(address, s->supportedTransforms);address+=4;
        memory->writed(address, s->currentTransform);address+=4;
        memory->writed(address, s->supportedCompositeAlpha);address+=4;
        memory->writed(address, s->supportedUsageFlags);address+=4;
    }
};

class MarshalVkSurfaceFormatKHR {
public:
    MarshalVkSurfaceFormatKHR() {}
    VkSurfaceFormatKHR s;
    static void write(KMemory* memory, U32 address, VkSurfaceFormatKHR* s) {
        memory->writed(address, s->format);address+=4;
        memory->writed(address, s->colorSpace);address+=4;
    }
};

class MarshalVkSwapchainCreateInfoKHR {
public:
    MarshalVkSwapchainCreateInfoKHR() {}
    VkSwapchainCreateInfoKHR s;
    MarshalVkSwapchainCreateInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSwapchainCreateInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSwapchainCreateFlagsKHR)memory->readd(address);address+=4;
        s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
        s->minImageCount = (uint32_t)memory->readd(address);address+=4;
        s->imageFormat = (VkFormat)memory->readd(address);address+=4;
        s->imageColorSpace = (VkColorSpaceKHR)memory->readd(address);address+=4;
        memory->memcpy(&s->imageExtent, address, 8);address+=8;
        s->imageArrayLayers = (uint32_t)memory->readd(address);address+=4;
        s->imageUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
        s->imageSharingMode = (VkSharingMode)memory->readd(address);address+=4;
        s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pQueueFamilyIndices = NULL;
        } else {
            s->pQueueFamilyIndices = new uint32_t[s->queueFamilyIndexCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, s->queueFamilyIndexCount * sizeof(uint32_t));
        }
        s->preTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
        s->compositeAlpha = (VkCompositeAlphaFlagBitsKHR)memory->readd(address);address+=4;
        s->presentMode = (VkPresentModeKHR)memory->readd(address);address+=4;
        s->clipped = (VkBool32)memory->readd(address);address+=4;
        s->oldSwapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    }
};

class MarshalVkPresentInfoKHR {
public:
    MarshalVkPresentInfoKHR() {}
    VkPresentInfoKHR s;
    MarshalVkPresentInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPresentInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pWaitSemaphores = NULL;
        } else {
            s->pWaitSemaphores = new VkSemaphore[s->waitSemaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, s->waitSemaphoreCount * sizeof(VkSemaphore));
        }
        s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSwapchains = NULL;
        } else {
            s->pSwapchains = new VkSwapchainKHR[s->swapchainCount * sizeof(VkSwapchainKHR)];
            memory->memcpy((VkSwapchainKHR*)s->pSwapchains, paramAddress, s->swapchainCount * sizeof(VkSwapchainKHR));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImageIndices = NULL;
        } else {
            s->pImageIndices = new uint32_t[s->swapchainCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pImageIndices, paramAddress, s->swapchainCount * sizeof(uint32_t));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pResults = NULL;
        } else {
            s->pResults = new VkResult[s->swapchainCount * sizeof(VkResult)];
            memory->memcpy((VkResult*)s->pResults, paramAddress, s->swapchainCount * sizeof(VkResult));
        }
    }
};

class MarshalVkPrivateDataSlotCreateInfoEXT {
public:
    MarshalVkPrivateDataSlotCreateInfoEXT() {}
    VkPrivateDataSlotCreateInfoEXT s;
    MarshalVkPrivateDataSlotCreateInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPrivateDataSlotCreateInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPrivateDataSlotCreateFlagsEXT)memory->readd(address);address+=4;
    }
};

class MarshalVkIndirectCommandsLayoutTokenNV {
public:
    MarshalVkIndirectCommandsLayoutTokenNV() {}
    VkIndirectCommandsLayoutTokenNV s;
    MarshalVkIndirectCommandsLayoutTokenNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->tokenType = (VkIndirectCommandsTokenTypeNV)memory->readd(address);address+=4;
        s->stream = (uint32_t)memory->readd(address);address+=4;
        s->offset = (uint32_t)memory->readd(address);address+=4;
        s->vertexBindingUnit = (uint32_t)memory->readd(address);address+=4;
        s->vertexDynamicStride = (VkBool32)memory->readd(address);address+=4;
        s->pushconstantPipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
        s->pushconstantShaderStageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
        s->pushconstantOffset = (uint32_t)memory->readd(address);address+=4;
        s->pushconstantSize = (uint32_t)memory->readd(address);address+=4;
        s->indirectStateFlags = (VkIndirectStateFlagsNV)memory->readd(address);address+=4;
        s->indexTypeCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pIndexTypes = NULL;
        } else {
            s->pIndexTypes = new VkIndexType[s->indexTypeCount * sizeof(VkIndexType)];
            memory->memcpy((VkIndexType*)s->pIndexTypes, paramAddress, s->indexTypeCount * sizeof(VkIndexType));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pIndexTypeValues = NULL;
        } else {
            s->pIndexTypeValues = new uint32_t[s->indexTypeCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pIndexTypeValues, paramAddress, s->indexTypeCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkIndirectCommandsLayoutCreateInfoNV {
public:
    MarshalVkIndirectCommandsLayoutCreateInfoNV() {}
    VkIndirectCommandsLayoutCreateInfoNV s;
    MarshalVkIndirectCommandsLayoutCreateInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkIndirectCommandsLayoutUsageFlagsNV)memory->readd(address);address+=4;
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->tokenCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pTokens = NULL;
        } else {
            VkIndirectCommandsLayoutTokenNV* pTokens = new VkIndirectCommandsLayoutTokenNV[s->tokenCount];
            for (U32 i = 0; i < s->tokenCount; i++) {
                MarshalVkIndirectCommandsLayoutTokenNV::read(memory, paramAddress, &pTokens[i]);
            }
            s->pTokens = pTokens;
        }
        s->streamCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pStreamStrides = NULL;
        } else {
            s->pStreamStrides = new uint32_t[s->streamCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pStreamStrides, paramAddress, s->streamCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkGeneratedCommandsInfoNV {
public:
    MarshalVkGeneratedCommandsInfoNV() {}
    VkGeneratedCommandsInfoNV s;
    MarshalVkGeneratedCommandsInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeneratedCommandsInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->pipeline = (VkPipeline)memory->readq(address);address+=8;
        s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
        s->streamCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pStreams = NULL;
        } else {
            s->pStreams = new VkIndirectCommandsStreamNV[s->streamCount * sizeof(VkIndirectCommandsStreamNV)];
            memory->memcpy((VkIndirectCommandsStreamNV*)s->pStreams, paramAddress, s->streamCount * sizeof(VkIndirectCommandsStreamNV));
        }
        s->sequencesCount = (uint32_t)memory->readd(address);address+=4;
        s->preprocessBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->preprocessOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->preprocessSize = (VkDeviceSize)memory->readq(address);address+=8;
        s->sequencesCountBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->sequencesCountOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->sequencesIndexBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->sequencesIndexOffset = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkGeneratedCommandsMemoryRequirementsInfoNV {
public:
    MarshalVkGeneratedCommandsMemoryRequirementsInfoNV() {}
    VkGeneratedCommandsMemoryRequirementsInfoNV s;
    MarshalVkGeneratedCommandsMemoryRequirementsInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->pipeline = (VkPipeline)memory->readq(address);address+=8;
        s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
        s->maxSequencesCount = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPhysicalDeviceFeatures2 {
public:
    MarshalVkPhysicalDeviceFeatures2() {}
    VkPhysicalDeviceFeatures2 s;
    MarshalVkPhysicalDeviceFeatures2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->features, address, 220);address+=220;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->features, 220); address+=220;
    }
};

class MarshalVkPhysicalDeviceProperties2 {
public:
    MarshalVkPhysicalDeviceProperties2() {}
    VkPhysicalDeviceProperties2 s;
    MarshalVkPhysicalDeviceProperties2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        MarshalVkPhysicalDeviceProperties::read(memory, address, &s->properties); address+=800;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->properties, 800); address+=800;
    }
};

class MarshalVkFormatProperties2 {
public:
    MarshalVkFormatProperties2() {}
    VkFormatProperties2 s;
    MarshalVkFormatProperties2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkFormatProperties2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->formatProperties, address, 12);address+=12;
    }
    static void write(KMemory* memory, U32 address, VkFormatProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->formatProperties, 12); address+=12;
    }
};

class MarshalVkImageFormatProperties2 {
public:
    MarshalVkImageFormatProperties2() {}
    VkImageFormatProperties2 s;
    MarshalVkImageFormatProperties2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageFormatProperties2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->imageFormatProperties, address, 32);address+=32;
    }
    static void write(KMemory* memory, U32 address, VkImageFormatProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->imageFormatProperties, 32); address+=32;
    }
};

class MarshalVkPhysicalDeviceImageFormatInfo2 {
public:
    MarshalVkPhysicalDeviceImageFormatInfo2() {}
    VkPhysicalDeviceImageFormatInfo2 s;
    MarshalVkPhysicalDeviceImageFormatInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceImageFormatInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->type = (VkImageType)memory->readd(address);address+=4;
        s->tiling = (VkImageTiling)memory->readd(address);address+=4;
        s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
        s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkQueueFamilyProperties2 {
public:
    MarshalVkQueueFamilyProperties2() {}
    VkQueueFamilyProperties2 s;
    static void write(KMemory* memory, U32 address, VkQueueFamilyProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->queueFamilyProperties, 24); address+=24;
    }
};

class MarshalVkPhysicalDeviceMemoryProperties2 {
public:
    MarshalVkPhysicalDeviceMemoryProperties2() {}
    VkPhysicalDeviceMemoryProperties2 s;
    MarshalVkPhysicalDeviceMemoryProperties2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->memoryProperties, address, 456);address+=456;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->memoryProperties, 456); address+=456;
    }
};

class MarshalVkSparseImageFormatProperties2 {
public:
    MarshalVkSparseImageFormatProperties2() {}
    VkSparseImageFormatProperties2 s;
    static void write(KMemory* memory, U32 address, VkSparseImageFormatProperties2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->properties, 20); address+=20;
    }
};

class MarshalVkPhysicalDeviceSparseImageFormatInfo2 {
public:
    MarshalVkPhysicalDeviceSparseImageFormatInfo2() {}
    VkPhysicalDeviceSparseImageFormatInfo2 s;
    MarshalVkPhysicalDeviceSparseImageFormatInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceSparseImageFormatInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->type = (VkImageType)memory->readd(address);address+=4;
        s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
        s->tiling = (VkImageTiling)memory->readd(address);address+=4;
    }
};

class MarshalVkPhysicalDeviceExternalBufferInfo {
public:
    MarshalVkPhysicalDeviceExternalBufferInfo() {}
    VkPhysicalDeviceExternalBufferInfo s;
    MarshalVkPhysicalDeviceExternalBufferInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceExternalBufferInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
        s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
        s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
    }
};

class MarshalVkExternalBufferProperties {
public:
    MarshalVkExternalBufferProperties() {}
    VkExternalBufferProperties s;
    MarshalVkExternalBufferProperties(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkExternalBufferProperties* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->externalMemoryProperties, address, 12);address+=12;
    }
    static void write(KMemory* memory, U32 address, VkExternalBufferProperties* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->externalMemoryProperties, 12); address+=12;
    }
};

class MarshalVkPhysicalDeviceIDProperties {
public:
    MarshalVkPhysicalDeviceIDProperties() {}
    VkPhysicalDeviceIDProperties s;
    MarshalVkPhysicalDeviceIDProperties(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->deviceUUID, address, 16);address+=16;
        memory->memcpy(&s->driverUUID, address, 16);address+=16;
        memory->memcpy(&s->deviceLUID, address, 8);address+=8;
        s->deviceNodeMask = (uint32_t)memory->readd(address);address+=4;
        s->deviceLUIDValid = (VkBool32)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, s->deviceUUID, 16); address+=16;
        memory->memcpy(address, s->driverUUID, 16); address+=16;
        memory->memcpy(address, s->deviceLUID, 8); address+=8;
        memory->writed(address, s->deviceNodeMask);address+=4;
        memory->writed(address, s->deviceLUIDValid);address+=4;
    }
};

class MarshalVkPhysicalDeviceExternalSemaphoreInfo {
public:
    MarshalVkPhysicalDeviceExternalSemaphoreInfo() {}
    VkPhysicalDeviceExternalSemaphoreInfo s;
    MarshalVkPhysicalDeviceExternalSemaphoreInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceExternalSemaphoreInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->handleType = (VkExternalSemaphoreHandleTypeFlagBits)memory->readd(address);address+=4;
    }
};

class MarshalVkExternalSemaphoreProperties {
public:
    MarshalVkExternalSemaphoreProperties() {}
    VkExternalSemaphoreProperties s;
    MarshalVkExternalSemaphoreProperties(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->exportFromImportedHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
        s->compatibleHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
        s->externalSemaphoreFeatures = (VkExternalSemaphoreFeatureFlags)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
        memory->writed(address, s->compatibleHandleTypes);address+=4;
        memory->writed(address, s->externalSemaphoreFeatures);address+=4;
    }
};

class MarshalVkPhysicalDeviceExternalFenceInfo {
public:
    MarshalVkPhysicalDeviceExternalFenceInfo() {}
    VkPhysicalDeviceExternalFenceInfo s;
    MarshalVkPhysicalDeviceExternalFenceInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceExternalFenceInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->handleType = (VkExternalFenceHandleTypeFlagBits)memory->readd(address);address+=4;
    }
};

class MarshalVkExternalFenceProperties {
public:
    MarshalVkExternalFenceProperties() {}
    VkExternalFenceProperties s;
    MarshalVkExternalFenceProperties(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkExternalFenceProperties* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->exportFromImportedHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
        s->compatibleHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
        s->externalFenceFeatures = (VkExternalFenceFeatureFlags)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkExternalFenceProperties* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
        memory->writed(address, s->compatibleHandleTypes);address+=4;
        memory->writed(address, s->externalFenceFeatures);address+=4;
    }
};

class MarshalVkPhysicalDeviceGroupProperties {
public:
    MarshalVkPhysicalDeviceGroupProperties() {}
    VkPhysicalDeviceGroupProperties s;
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceGroupProperties* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->physicalDeviceCount);address+=4;
        memory->memcpy(address, s->physicalDevices, 128); address+=128;
        memory->writed(address, s->subsetAllocation);address+=4;
    }
};

class MarshalVkBindBufferMemoryInfo {
public:
    MarshalVkBindBufferMemoryInfo() {}
    VkBindBufferMemoryInfo s;
    MarshalVkBindBufferMemoryInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBindBufferMemoryInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
        s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkBindImageMemoryInfo {
public:
    MarshalVkBindImageMemoryInfo() {}
    VkBindImageMemoryInfo s;
    MarshalVkBindImageMemoryInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBindImageMemoryInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->image = (VkImage)memory->readq(address);address+=8;
        s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
        s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkDeviceGroupPresentCapabilitiesKHR {
public:
    MarshalVkDeviceGroupPresentCapabilitiesKHR() {}
    VkDeviceGroupPresentCapabilitiesKHR s;
    MarshalVkDeviceGroupPresentCapabilitiesKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->presentMask, address, 32);address+=32;
        s->modes = (VkDeviceGroupPresentModeFlagsKHR)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, s->presentMask, 128); address+=128;
        memory->writed(address, s->modes);address+=4;
    }
};

class MarshalVkAcquireNextImageInfoKHR {
public:
    MarshalVkAcquireNextImageInfoKHR() {}
    VkAcquireNextImageInfoKHR s;
    MarshalVkAcquireNextImageInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAcquireNextImageInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
        s->timeout = (uint64_t)memory->readq(address);address+=8;
        s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
        s->fence = (VkFence)memory->readq(address);address+=8;
        s->deviceMask = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkDescriptorUpdateTemplateEntry {
public:
    MarshalVkDescriptorUpdateTemplateEntry() {}
    VkDescriptorUpdateTemplateEntry s;
    MarshalVkDescriptorUpdateTemplateEntry(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorUpdateTemplateEntry* s) {
        s->dstBinding = (uint32_t)memory->readd(address);address+=4;
        s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
        s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
        s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
        s->offset = (size_t)memory->readd(address);address+=4;
        s->stride = (size_t)memory->readd(address);address+=4;
    }
};

class MarshalVkDescriptorUpdateTemplateCreateInfo {
public:
    MarshalVkDescriptorUpdateTemplateCreateInfo() {}
    VkDescriptorUpdateTemplateCreateInfo s;
    MarshalVkDescriptorUpdateTemplateCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorUpdateTemplateCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDescriptorUpdateTemplateCreateFlags)memory->readd(address);address+=4;
        s->descriptorUpdateEntryCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDescriptorUpdateEntries = NULL;
        } else {
            VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = new VkDescriptorUpdateTemplateEntry[s->descriptorUpdateEntryCount];
            for (U32 i = 0; i < s->descriptorUpdateEntryCount; i++) {
                MarshalVkDescriptorUpdateTemplateEntry::read(memory, paramAddress, &pDescriptorUpdateEntries[i]);
            }
            s->pDescriptorUpdateEntries = pDescriptorUpdateEntries;
        }
        s->templateType = (VkDescriptorUpdateTemplateType)memory->readd(address);address+=4;
        s->descriptorSetLayout = (VkDescriptorSetLayout)memory->readq(address);address+=8;
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->pipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
        s->set = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkPhysicalDeviceSurfaceInfo2KHR {
public:
    MarshalVkPhysicalDeviceSurfaceInfo2KHR() {}
    VkPhysicalDeviceSurfaceInfo2KHR s;
    MarshalVkPhysicalDeviceSurfaceInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceSurfaceInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
    }
};

class MarshalVkSurfaceCapabilities2KHR {
public:
    MarshalVkSurfaceCapabilities2KHR() {}
    VkSurfaceCapabilities2KHR s;
    MarshalVkSurfaceCapabilities2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        MarshalVkSurfaceCapabilitiesKHR::read(memory, address, &s->surfaceCapabilities); address+=52;
    }
    static void write(KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->surfaceCapabilities, 52); address+=52;
    }
};

class MarshalVkSurfaceFormat2KHR {
public:
    MarshalVkSurfaceFormat2KHR() {}
    VkSurfaceFormat2KHR s;
    static void write(KMemory* memory, U32 address, VkSurfaceFormat2KHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->surfaceFormat, 8); address+=8;
    }
};

class MarshalVkBufferMemoryRequirementsInfo2 {
public:
    MarshalVkBufferMemoryRequirementsInfo2() {}
    VkBufferMemoryRequirementsInfo2 s;
    MarshalVkBufferMemoryRequirementsInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferMemoryRequirementsInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
    }
};

class MarshalVkImageMemoryRequirementsInfo2 {
public:
    MarshalVkImageMemoryRequirementsInfo2() {}
    VkImageMemoryRequirementsInfo2 s;
    MarshalVkImageMemoryRequirementsInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageMemoryRequirementsInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->image = (VkImage)memory->readq(address);address+=8;
    }
};

class MarshalVkImageSparseMemoryRequirementsInfo2 {
public:
    MarshalVkImageSparseMemoryRequirementsInfo2() {}
    VkImageSparseMemoryRequirementsInfo2 s;
    MarshalVkImageSparseMemoryRequirementsInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageSparseMemoryRequirementsInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->image = (VkImage)memory->readq(address);address+=8;
    }
};

class MarshalVkMemoryRequirements2 {
public:
    MarshalVkMemoryRequirements2() {}
    VkMemoryRequirements2 s;
    MarshalVkMemoryRequirements2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMemoryRequirements2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->memoryRequirements, address, 20);address+=20;
    }
    static void write(KMemory* memory, U32 address, VkMemoryRequirements2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->memoryRequirements, 20); address+=20;
    }
};

class MarshalVkSparseImageMemoryRequirements2 {
public:
    MarshalVkSparseImageMemoryRequirements2() {}
    VkSparseImageMemoryRequirements2 s;
    static void write(KMemory* memory, U32 address, VkSparseImageMemoryRequirements2* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->memoryRequirements, 48); address+=48;
    }
};

class MarshalVkSamplerYcbcrConversionCreateInfo {
public:
    MarshalVkSamplerYcbcrConversionCreateInfo() {}
    VkSamplerYcbcrConversionCreateInfo s;
    MarshalVkSamplerYcbcrConversionCreateInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSamplerYcbcrConversionCreateInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->ycbcrModel = (VkSamplerYcbcrModelConversion)memory->readd(address);address+=4;
        s->ycbcrRange = (VkSamplerYcbcrRange)memory->readd(address);address+=4;
        MarshalVkComponentMapping::read(memory, address, &s->components); address+=16;
        s->xChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
        s->yChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
        s->chromaFilter = (VkFilter)memory->readd(address);address+=4;
        s->forceExplicitReconstruction = (VkBool32)memory->readd(address);address+=4;
    }
};

class MarshalVkConditionalRenderingBeginInfoEXT {
public:
    MarshalVkConditionalRenderingBeginInfoEXT() {}
    VkConditionalRenderingBeginInfoEXT s;
    MarshalVkConditionalRenderingBeginInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkConditionalRenderingBeginInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
        s->flags = (VkConditionalRenderingFlagsEXT)memory->readd(address);address+=4;
    }
};

class MarshalVkDeviceQueueInfo2 {
public:
    MarshalVkDeviceQueueInfo2() {}
    VkDeviceQueueInfo2 s;
    MarshalVkDeviceQueueInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDeviceQueueInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
        s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->queueIndex = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkSampleLocationsInfoEXT {
public:
    MarshalVkSampleLocationsInfoEXT() {}
    VkSampleLocationsInfoEXT s;
    MarshalVkSampleLocationsInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSampleLocationsInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->sampleLocationsPerPixel = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        memory->memcpy(&s->sampleLocationGridSize, address, 8);address+=8;
        s->sampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSampleLocations = NULL;
        } else {
            s->pSampleLocations = new VkSampleLocationEXT[s->sampleLocationsCount * sizeof(VkSampleLocationEXT)];
            memory->memcpy((VkSampleLocationEXT*)s->pSampleLocations, paramAddress, s->sampleLocationsCount * sizeof(VkSampleLocationEXT));
        }
    }
};

class MarshalVkMultisamplePropertiesEXT {
public:
    MarshalVkMultisamplePropertiesEXT() {}
    VkMultisamplePropertiesEXT s;
    MarshalVkMultisamplePropertiesEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->maxSampleLocationGridSize, address, 8);address+=8;
    }
    static void write(KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, &s->maxSampleLocationGridSize, 8); address+=8;
    }
};

class MarshalVkValidationCacheCreateInfoEXT {
public:
    MarshalVkValidationCacheCreateInfoEXT() {}
    VkValidationCacheCreateInfoEXT s;
    MarshalVkValidationCacheCreateInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkValidationCacheCreateInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkValidationCacheCreateFlagsEXT)memory->readd(address);address+=4;
        s->initialDataSize = (size_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInitialData = NULL;
        } else {
            s->pInitialData = new char[s->initialDataSize];
            memory->memcpy((void*)s->pInitialData, paramAddress, s->initialDataSize);
        }
    }
};

class MarshalVkDescriptorSetLayoutSupport {
public:
    MarshalVkDescriptorSetLayoutSupport() {}
    VkDescriptorSetLayoutSupport s;
    MarshalVkDescriptorSetLayoutSupport(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->supported = (VkBool32)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->supported);address+=4;
    }
};

class MarshalVkPhysicalDeviceHostQueryResetFeatures {
public:
    MarshalVkPhysicalDeviceHostQueryResetFeatures() {}
    VkPhysicalDeviceHostQueryResetFeatures s;
    MarshalVkPhysicalDeviceHostQueryResetFeatures(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->hostQueryReset = (VkBool32)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->hostQueryReset);address+=4;
    }
};

class MarshalVkMemoryHostPointerPropertiesEXT {
public:
    MarshalVkMemoryHostPointerPropertiesEXT() {}
    VkMemoryHostPointerPropertiesEXT s;
    MarshalVkMemoryHostPointerPropertiesEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->memoryTypeBits = (uint32_t)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->memoryTypeBits);address+=4;
    }
};

class MarshalVkCalibratedTimestampInfoEXT {
public:
    MarshalVkCalibratedTimestampInfoEXT() {}
    VkCalibratedTimestampInfoEXT s;
    MarshalVkCalibratedTimestampInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCalibratedTimestampInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->timeDomain = (VkTimeDomainEXT)memory->readd(address);address+=4;
    }
};

class MarshalVkAttachmentDescription2 {
public:
    MarshalVkAttachmentDescription2() {}
    VkAttachmentDescription2 s;
    MarshalVkAttachmentDescription2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAttachmentDescription2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
        s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
        s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
        s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
        s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
        s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
    }
};

class MarshalVkAttachmentReference2 {
public:
    MarshalVkAttachmentReference2() {}
    VkAttachmentReference2 s;
    MarshalVkAttachmentReference2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAttachmentReference2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->attachment = (uint32_t)memory->readd(address);address+=4;
        s->layout = (VkImageLayout)memory->readd(address);address+=4;
        s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
    }
};

class MarshalVkSubpassDescription2 {
public:
    MarshalVkSubpassDescription2() {}
    VkSubpassDescription2 s;
    MarshalVkSubpassDescription2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubpassDescription2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
        s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
        s->viewMask = (uint32_t)memory->readd(address);address+=4;
        s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pInputAttachments = NULL;
        } else {
            VkAttachmentReference2* pInputAttachments = new VkAttachmentReference2[s->inputAttachmentCount];
            for (U32 i = 0; i < s->inputAttachmentCount; i++) {
                MarshalVkAttachmentReference2::read(memory, paramAddress, &pInputAttachments[i]);
            }
            s->pInputAttachments = pInputAttachments;
        }
        s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pColorAttachments = NULL;
        } else {
            VkAttachmentReference2* pColorAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
            for (U32 i = 0; i < s->colorAttachmentCount; i++) {
                MarshalVkAttachmentReference2::read(memory, paramAddress, &pColorAttachments[i]);
            }
            s->pColorAttachments = pColorAttachments;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pResolveAttachments = NULL;
        } else {
            VkAttachmentReference2* pResolveAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
            for (U32 i = 0; i < s->colorAttachmentCount; i++) {
                MarshalVkAttachmentReference2::read(memory, paramAddress, &pResolveAttachments[i]);
            }
            s->pResolveAttachments = pResolveAttachments;
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDepthStencilAttachment = NULL;
        } else {
            VkAttachmentReference2* pDepthStencilAttachment = new VkAttachmentReference2();
            MarshalVkAttachmentReference2::read(memory, paramAddress, pDepthStencilAttachment);
            s->pDepthStencilAttachment = pDepthStencilAttachment;
        }
        s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pPreserveAttachments = NULL;
        } else {
            s->pPreserveAttachments = new uint32_t[s->preserveAttachmentCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, s->preserveAttachmentCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkSubpassDependency2 {
public:
    MarshalVkSubpassDependency2() {}
    VkSubpassDependency2 s;
    MarshalVkSubpassDependency2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubpassDependency2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcSubpass = (uint32_t)memory->readd(address);address+=4;
        s->dstSubpass = (uint32_t)memory->readd(address);address+=4;
        s->srcStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
        s->dstStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
        s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
        s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
        s->viewOffset = (int32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkRenderPassCreateInfo2 {
public:
    MarshalVkRenderPassCreateInfo2() {}
    VkRenderPassCreateInfo2 s;
    MarshalVkRenderPassCreateInfo2(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkRenderPassCreateInfo2* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
        s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pAttachments = NULL;
        } else {
            VkAttachmentDescription2* pAttachments = new VkAttachmentDescription2[s->attachmentCount];
            for (U32 i = 0; i < s->attachmentCount; i++) {
                MarshalVkAttachmentDescription2::read(memory, paramAddress, &pAttachments[i]);
            }
            s->pAttachments = pAttachments;
        }
        s->subpassCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSubpasses = NULL;
        } else {
            VkSubpassDescription2* pSubpasses = new VkSubpassDescription2[s->subpassCount];
            for (U32 i = 0; i < s->subpassCount; i++) {
                MarshalVkSubpassDescription2::read(memory, paramAddress, &pSubpasses[i]);
            }
            s->pSubpasses = pSubpasses;
        }
        s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDependencies = NULL;
        } else {
            VkSubpassDependency2* pDependencies = new VkSubpassDependency2[s->dependencyCount];
            for (U32 i = 0; i < s->dependencyCount; i++) {
                MarshalVkSubpassDependency2::read(memory, paramAddress, &pDependencies[i]);
            }
            s->pDependencies = pDependencies;
        }
        s->correlatedViewMaskCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pCorrelatedViewMasks = NULL;
        } else {
            s->pCorrelatedViewMasks = new uint32_t[s->correlatedViewMaskCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pCorrelatedViewMasks, paramAddress, s->correlatedViewMaskCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkSubpassBeginInfo {
public:
    MarshalVkSubpassBeginInfo() {}
    VkSubpassBeginInfo s;
    MarshalVkSubpassBeginInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubpassBeginInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->contents = (VkSubpassContents)memory->readd(address);address+=4;
    }
};

class MarshalVkSubpassEndInfo {
public:
    MarshalVkSubpassEndInfo() {}
    VkSubpassEndInfo s;
    MarshalVkSubpassEndInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubpassEndInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
    }
};

class MarshalVkSemaphoreWaitInfo {
public:
    MarshalVkSemaphoreWaitInfo() {}
    VkSemaphoreWaitInfo s;
    MarshalVkSemaphoreWaitInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSemaphoreWaitInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSemaphoreWaitFlags)memory->readd(address);address+=4;
        s->semaphoreCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSemaphores = NULL;
        } else {
            s->pSemaphores = new VkSemaphore[s->semaphoreCount * sizeof(VkSemaphore)];
            memory->memcpy((VkSemaphore*)s->pSemaphores, paramAddress, s->semaphoreCount * sizeof(VkSemaphore));
        }
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pValues = NULL;
        } else {
            s->pValues = new uint64_t[s->semaphoreCount * sizeof(uint64_t)];
            memory->memcpy((uint64_t*)s->pValues, paramAddress, s->semaphoreCount * sizeof(uint64_t));
        }
    }
};

class MarshalVkSemaphoreSignalInfo {
public:
    MarshalVkSemaphoreSignalInfo() {}
    VkSemaphoreSignalInfo s;
    MarshalVkSemaphoreSignalInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSemaphoreSignalInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
        s->value = (uint64_t)memory->readq(address);address+=8;
    }
};

class MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
public:
    MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT() {}
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT s;
    MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->vertexAttributeInstanceRateDivisor = (VkBool32)memory->readd(address);address+=4;
        s->vertexAttributeInstanceRateZeroDivisor = (VkBool32)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->vertexAttributeInstanceRateDivisor);address+=4;
        memory->writed(address, s->vertexAttributeInstanceRateZeroDivisor);address+=4;
    }
};

class MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT {
public:
    MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT() {}
    VkPhysicalDeviceTransformFeedbackFeaturesEXT s;
    MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->transformFeedback = (VkBool32)memory->readd(address);address+=4;
        s->geometryStreams = (VkBool32)memory->readd(address);address+=4;
    }
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->transformFeedback);address+=4;
        memory->writed(address, s->geometryStreams);address+=4;
    }
};

class MarshalVkShadingRatePaletteNV {
public:
    MarshalVkShadingRatePaletteNV() {}
    VkShadingRatePaletteNV s;
    MarshalVkShadingRatePaletteNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkShadingRatePaletteNV* s) {
        s->shadingRatePaletteEntryCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pShadingRatePaletteEntries = NULL;
        } else {
            s->pShadingRatePaletteEntries = new VkShadingRatePaletteEntryNV[s->shadingRatePaletteEntryCount * sizeof(VkShadingRatePaletteEntryNV)];
            memory->memcpy((VkShadingRatePaletteEntryNV*)s->pShadingRatePaletteEntries, paramAddress, s->shadingRatePaletteEntryCount * sizeof(VkShadingRatePaletteEntryNV));
        }
    }
};

class MarshalVkCoarseSampleOrderCustomNV {
public:
    MarshalVkCoarseSampleOrderCustomNV() {}
    VkCoarseSampleOrderCustomNV s;
    MarshalVkCoarseSampleOrderCustomNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCoarseSampleOrderCustomNV* s) {
        s->shadingRate = (VkShadingRatePaletteEntryNV)memory->readd(address);address+=4;
        s->sampleCount = (uint32_t)memory->readd(address);address+=4;
        s->sampleLocationCount = (uint32_t)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSampleLocations = NULL;
        } else {
            s->pSampleLocations = new VkCoarseSampleLocationNV[s->sampleLocationCount * sizeof(VkCoarseSampleLocationNV)];
            memory->memcpy((VkCoarseSampleLocationNV*)s->pSampleLocations, paramAddress, s->sampleLocationCount * sizeof(VkCoarseSampleLocationNV));
        }
    }
};

class MarshalVkRayTracingShaderGroupCreateInfoNV {
public:
    MarshalVkRayTracingShaderGroupCreateInfoNV() {}
    VkRayTracingShaderGroupCreateInfoNV s;
    MarshalVkRayTracingShaderGroupCreateInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->type = (VkRayTracingShaderGroupTypeKHR)memory->readd(address);address+=4;
        s->generalShader = (uint32_t)memory->readd(address);address+=4;
        s->closestHitShader = (uint32_t)memory->readd(address);address+=4;
        s->anyHitShader = (uint32_t)memory->readd(address);address+=4;
        s->intersectionShader = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkRayTracingPipelineCreateInfoNV {
public:
    MarshalVkRayTracingPipelineCreateInfoNV() {}
    VkRayTracingPipelineCreateInfoNV s;
    MarshalVkRayTracingPipelineCreateInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
        s->stageCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pStages = NULL;
        } else {
            VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
            for (U32 i = 0; i < s->stageCount; i++) {
                MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress, &pStages[i]);
            }
            s->pStages = pStages;
        }
        s->groupCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pGroups = NULL;
        } else {
            VkRayTracingShaderGroupCreateInfoNV* pGroups = new VkRayTracingShaderGroupCreateInfoNV[s->groupCount];
            for (U32 i = 0; i < s->groupCount; i++) {
                MarshalVkRayTracingShaderGroupCreateInfoNV::read(memory, paramAddress, &pGroups[i]);
            }
            s->pGroups = pGroups;
        }
        s->maxRecursionDepth = (uint32_t)memory->readd(address);address+=4;
        s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
        s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
        s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkGeometryTrianglesNV {
public:
    MarshalVkGeometryTrianglesNV() {}
    VkGeometryTrianglesNV s;
    MarshalVkGeometryTrianglesNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeometryTrianglesNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->vertexData = (VkBuffer)memory->readq(address);address+=8;
        s->vertexOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->vertexCount = (uint32_t)memory->readd(address);address+=4;
        s->vertexStride = (VkDeviceSize)memory->readq(address);address+=8;
        s->vertexFormat = (VkFormat)memory->readd(address);address+=4;
        s->indexData = (VkBuffer)memory->readq(address);address+=8;
        s->indexOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->indexCount = (uint32_t)memory->readd(address);address+=4;
        s->indexType = (VkIndexType)memory->readd(address);address+=4;
        s->transformData = (VkBuffer)memory->readq(address);address+=8;
        s->transformOffset = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkGeometryAABBNV {
public:
    MarshalVkGeometryAABBNV() {}
    VkGeometryAABBNV s;
    MarshalVkGeometryAABBNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeometryAABBNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->aabbData = (VkBuffer)memory->readq(address);address+=8;
        s->numAABBs = (uint32_t)memory->readd(address);address+=4;
        s->stride = (uint32_t)memory->readd(address);address+=4;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkGeometryDataNV {
public:
    MarshalVkGeometryDataNV() {}
    VkGeometryDataNV s;
    MarshalVkGeometryDataNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeometryDataNV* s) {
        MarshalVkGeometryTrianglesNV::read(memory, address, &s->triangles); address+=80;
        MarshalVkGeometryAABBNV::read(memory, address, &s->aabbs); address+=32;
    }
};

class MarshalVkGeometryNV {
public:
    MarshalVkGeometryNV() {}
    VkGeometryNV s;
    MarshalVkGeometryNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkGeometryNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->geometryType = (VkGeometryTypeKHR)memory->readd(address);address+=4;
        MarshalVkGeometryDataNV::read(memory, address, &s->geometry); address+=112;
        s->flags = (VkGeometryFlagsKHR)memory->readd(address);address+=4;
    }
};

class MarshalVkAccelerationStructureInfoNV {
public:
    MarshalVkAccelerationStructureInfoNV() {}
    VkAccelerationStructureInfoNV s;
    MarshalVkAccelerationStructureInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAccelerationStructureInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
        s->flags = (VkBuildAccelerationStructureFlagsKHR)memory->readd(address);address+=4;
        s->instanceCount = (uint32_t)memory->readd(address);address+=4;
        s->geometryCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pGeometries = NULL;
        } else {
            VkGeometryNV* pGeometries = new VkGeometryNV[s->geometryCount];
            for (U32 i = 0; i < s->geometryCount; i++) {
                MarshalVkGeometryNV::read(memory, paramAddress, &pGeometries[i]);
            }
            s->pGeometries = pGeometries;
        }
    }
};

class MarshalVkAccelerationStructureCreateInfoNV {
public:
    MarshalVkAccelerationStructureCreateInfoNV() {}
    VkAccelerationStructureCreateInfoNV s;
    MarshalVkAccelerationStructureCreateInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAccelerationStructureCreateInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->compactedSize = (VkDeviceSize)memory->readq(address);address+=8;
        MarshalVkAccelerationStructureInfoNV::read(memory, address, &s->info); address+=28;
    }
};

class MarshalVkBindAccelerationStructureMemoryInfoNV {
public:
    MarshalVkBindAccelerationStructureMemoryInfoNV() {}
    VkBindAccelerationStructureMemoryInfoNV s;
    MarshalVkBindAccelerationStructureMemoryInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBindAccelerationStructureMemoryInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
        s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
        s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pDeviceIndices = NULL;
        } else {
            s->pDeviceIndices = new uint32_t[s->deviceIndexCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, s->deviceIndexCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkAccelerationStructureMemoryRequirementsInfoNV {
public:
    MarshalVkAccelerationStructureMemoryRequirementsInfoNV() {}
    VkAccelerationStructureMemoryRequirementsInfoNV s;
    MarshalVkAccelerationStructureMemoryRequirementsInfoNV(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAccelerationStructureMemoryRequirementsInfoNV* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->type = (VkAccelerationStructureMemoryRequirementsTypeNV)memory->readd(address);address+=4;
        s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
    }
};

class MarshalVkBufferDeviceAddressInfo {
public:
    MarshalVkBufferDeviceAddressInfo() {}
    VkBufferDeviceAddressInfo s;
    MarshalVkBufferDeviceAddressInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferDeviceAddressInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
    }
};

class MarshalVkCooperativeMatrixPropertiesNV {
public:
    MarshalVkCooperativeMatrixPropertiesNV() {}
    VkCooperativeMatrixPropertiesNV s;
    static void write(KMemory* memory, U32 address, VkCooperativeMatrixPropertiesNV* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->MSize);address+=4;
        memory->writed(address, s->NSize);address+=4;
        memory->writed(address, s->KSize);address+=4;
        memory->writed(address, s->AType);address+=4;
        memory->writed(address, s->BType);address+=4;
        memory->writed(address, s->CType);address+=4;
        memory->writed(address, s->DType);address+=4;
        memory->writed(address, s->scope);address+=4;
    }
};

class MarshalVkPerformanceCounterKHR {
public:
    MarshalVkPerformanceCounterKHR() {}
    VkPerformanceCounterKHR s;
    static void write(KMemory* memory, U32 address, VkPerformanceCounterKHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->unit);address+=4;
        memory->writed(address, s->scope);address+=4;
        memory->writed(address, s->storage);address+=4;
        memory->memcpy(address, s->uuid, 16); address+=16;
    }
};

class MarshalVkPerformanceCounterDescriptionKHR {
public:
    MarshalVkPerformanceCounterDescriptionKHR() {}
    VkPerformanceCounterDescriptionKHR s;
    static void write(KMemory* memory, U32 address, VkPerformanceCounterDescriptionKHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->flags);address+=4;
        memory->memcpy(address, s->name, 256); address+=256;
        memory->memcpy(address, s->category, 256); address+=256;
        memory->memcpy(address, s->description, 256); address+=256;
    }
};

class MarshalVkQueryPoolPerformanceCreateInfoKHR {
public:
    MarshalVkQueryPoolPerformanceCreateInfoKHR() {}
    VkQueryPoolPerformanceCreateInfoKHR s;
    MarshalVkQueryPoolPerformanceCreateInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkQueryPoolPerformanceCreateInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->counterIndexCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pCounterIndices = NULL;
        } else {
            s->pCounterIndices = new uint32_t[s->counterIndexCount * sizeof(uint32_t)];
            memory->memcpy((uint32_t*)s->pCounterIndices, paramAddress, s->counterIndexCount * sizeof(uint32_t));
        }
    }
};

class MarshalVkAcquireProfilingLockInfoKHR {
public:
    MarshalVkAcquireProfilingLockInfoKHR() {}
    VkAcquireProfilingLockInfoKHR s;
    MarshalVkAcquireProfilingLockInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkAcquireProfilingLockInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkAcquireProfilingLockFlagsKHR)memory->readd(address);address+=4;
        s->timeout = (uint64_t)memory->readq(address);address+=8;
    }
};

class MarshalVkHeadlessSurfaceCreateInfoEXT {
public:
    MarshalVkHeadlessSurfaceCreateInfoEXT() {}
    VkHeadlessSurfaceCreateInfoEXT s;
    MarshalVkHeadlessSurfaceCreateInfoEXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkHeadlessSurfaceCreateInfoEXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkHeadlessSurfaceCreateFlagsEXT)memory->readd(address);address+=4;
    }
};

class MarshalVkFramebufferMixedSamplesCombinationNV {
public:
    MarshalVkFramebufferMixedSamplesCombinationNV() {}
    VkFramebufferMixedSamplesCombinationNV s;
    static void write(KMemory* memory, U32 address, VkFramebufferMixedSamplesCombinationNV* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->coverageReductionMode);address+=4;
        memory->writed(address, s->rasterizationSamples);address+=4;
        memory->writed(address, s->depthStencilSamples);address+=4;
        memory->writed(address, s->colorSamples);address+=4;
    }
};

class MarshalVkDeviceMemoryOpaqueCaptureAddressInfo {
public:
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo() {}
    VkDeviceMemoryOpaqueCaptureAddressInfo s;
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDeviceMemoryOpaqueCaptureAddressInfo* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    }
};

class MarshalVkPhysicalDeviceToolPropertiesEXT {
public:
    MarshalVkPhysicalDeviceToolPropertiesEXT() {}
    VkPhysicalDeviceToolPropertiesEXT s;
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceToolPropertiesEXT* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->memcpy(address, s->name, 256); address+=256;
        memory->memcpy(address, s->version, 256); address+=256;
        memory->writed(address, s->purposes);address+=4;
        memory->memcpy(address, s->description, 256); address+=256;
        memory->memcpy(address, s->layer, 256); address+=256;
    }
};

class MarshalVkBufferCopy2KHR {
public:
    MarshalVkBufferCopy2KHR() {}
    VkBufferCopy2KHR s;
    MarshalVkBufferCopy2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferCopy2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->dstOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->size = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkImageCopy2KHR {
public:
    MarshalVkImageCopy2KHR() {}
    VkImageCopy2KHR s;
    MarshalVkImageCopy2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageCopy2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->srcSubresource, address, 16);address+=16;
        memory->memcpy(&s->srcOffset, address, 12);address+=12;
        memory->memcpy(&s->dstSubresource, address, 16);address+=16;
        memory->memcpy(&s->dstOffset, address, 12);address+=12;
        memory->memcpy(&s->extent, address, 12);address+=12;
    }
};

class MarshalVkImageBlit2KHR {
public:
    MarshalVkImageBlit2KHR() {}
    VkImageBlit2KHR s;
    MarshalVkImageBlit2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageBlit2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->srcSubresource, address, 16);address+=16;
        memory->memcpy(&s->srcOffsets, address, 2);address+=2;
        memory->memcpy(&s->dstSubresource, address, 16);address+=16;
        memory->memcpy(&s->dstOffsets, address, 2);address+=2;
    }
};

class MarshalVkBufferImageCopy2KHR {
public:
    MarshalVkBufferImageCopy2KHR() {}
    VkBufferImageCopy2KHR s;
    MarshalVkBufferImageCopy2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferImageCopy2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->bufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
        s->bufferRowLength = (uint32_t)memory->readd(address);address+=4;
        s->bufferImageHeight = (uint32_t)memory->readd(address);address+=4;
        memory->memcpy(&s->imageSubresource, address, 16);address+=16;
        memory->memcpy(&s->imageOffset, address, 12);address+=12;
        memory->memcpy(&s->imageExtent, address, 12);address+=12;
    }
};

class MarshalVkImageResolve2KHR {
public:
    MarshalVkImageResolve2KHR() {}
    VkImageResolve2KHR s;
    MarshalVkImageResolve2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageResolve2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        memory->memcpy(&s->srcSubresource, address, 16);address+=16;
        memory->memcpy(&s->srcOffset, address, 12);address+=12;
        memory->memcpy(&s->dstSubresource, address, 16);address+=16;
        memory->memcpy(&s->dstOffset, address, 12);address+=12;
        memory->memcpy(&s->extent, address, 12);address+=12;
    }
};

class MarshalVkCopyBufferInfo2KHR {
public:
    MarshalVkCopyBufferInfo2KHR() {}
    VkCopyBufferInfo2KHR s;
    MarshalVkCopyBufferInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCopyBufferInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkBufferCopy2KHR* pRegions = new VkBufferCopy2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkBufferCopy2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
    }
};

class MarshalVkCopyImageInfo2KHR {
public:
    MarshalVkCopyImageInfo2KHR() {}
    VkCopyImageInfo2KHR s;
    MarshalVkCopyImageInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCopyImageInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcImage = (VkImage)memory->readq(address);address+=8;
        s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->dstImage = (VkImage)memory->readq(address);address+=8;
        s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkImageCopy2KHR* pRegions = new VkImageCopy2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkImageCopy2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
    }
};

class MarshalVkBlitImageInfo2KHR {
public:
    MarshalVkBlitImageInfo2KHR() {}
    VkBlitImageInfo2KHR s;
    MarshalVkBlitImageInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBlitImageInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcImage = (VkImage)memory->readq(address);address+=8;
        s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->dstImage = (VkImage)memory->readq(address);address+=8;
        s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkImageBlit2KHR* pRegions = new VkImageBlit2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkImageBlit2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
        s->filter = (VkFilter)memory->readd(address);address+=4;
    }
};

class MarshalVkCopyBufferToImageInfo2KHR {
public:
    MarshalVkCopyBufferToImageInfo2KHR() {}
    VkCopyBufferToImageInfo2KHR s;
    MarshalVkCopyBufferToImageInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCopyBufferToImageInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->dstImage = (VkImage)memory->readq(address);address+=8;
        s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkBufferImageCopy2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
    }
};

class MarshalVkCopyImageToBufferInfo2KHR {
public:
    MarshalVkCopyImageToBufferInfo2KHR() {}
    VkCopyImageToBufferInfo2KHR s;
    MarshalVkCopyImageToBufferInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCopyImageToBufferInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcImage = (VkImage)memory->readq(address);address+=8;
        s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkBufferImageCopy2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
    }
};

class MarshalVkResolveImageInfo2KHR {
public:
    MarshalVkResolveImageInfo2KHR() {}
    VkResolveImageInfo2KHR s;
    MarshalVkResolveImageInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkResolveImageInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcImage = (VkImage)memory->readq(address);address+=8;
        s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->dstImage = (VkImage)memory->readq(address);address+=8;
        s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->regionCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pRegions = NULL;
        } else {
            VkImageResolve2KHR* pRegions = new VkImageResolve2KHR[s->regionCount];
            for (U32 i = 0; i < s->regionCount; i++) {
                MarshalVkImageResolve2KHR::read(memory, paramAddress, &pRegions[i]);
            }
            s->pRegions = pRegions;
        }
    }
};

class MarshalVkPhysicalDeviceFragmentShadingRateKHR {
public:
    MarshalVkPhysicalDeviceFragmentShadingRateKHR() {}
    VkPhysicalDeviceFragmentShadingRateKHR s;
    static void write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateKHR* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writed(address, s->sampleCounts);address+=4;
        memory->memcpy(address, &s->fragmentSize, 8); address+=8;
    }
};

class MarshalVkVertexInputBindingDescription2EXT {
public:
    MarshalVkVertexInputBindingDescription2EXT() {}
    VkVertexInputBindingDescription2EXT s;
    MarshalVkVertexInputBindingDescription2EXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkVertexInputBindingDescription2EXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->binding = (uint32_t)memory->readd(address);address+=4;
        s->stride = (uint32_t)memory->readd(address);address+=4;
        s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
        s->divisor = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkVertexInputAttributeDescription2EXT {
public:
    MarshalVkVertexInputAttributeDescription2EXT() {}
    VkVertexInputAttributeDescription2EXT s;
    MarshalVkVertexInputAttributeDescription2EXT(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkVertexInputAttributeDescription2EXT* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->location = (uint32_t)memory->readd(address);address+=4;
        s->binding = (uint32_t)memory->readd(address);address+=4;
        s->format = (VkFormat)memory->readd(address);address+=4;
        s->offset = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkMemoryBarrier2KHR {
public:
    MarshalVkMemoryBarrier2KHR() {}
    VkMemoryBarrier2KHR s;
    MarshalVkMemoryBarrier2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkMemoryBarrier2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
        s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    }
};

class MarshalVkImageMemoryBarrier2KHR {
public:
    MarshalVkImageMemoryBarrier2KHR() {}
    VkImageMemoryBarrier2KHR s;
    MarshalVkImageMemoryBarrier2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkImageMemoryBarrier2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
        s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
        s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
        s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->image = (VkImage)memory->readq(address);address+=8;
        memory->memcpy(&s->subresourceRange, address, 20);address+=20;
    }
};

class MarshalVkBufferMemoryBarrier2KHR {
public:
    MarshalVkBufferMemoryBarrier2KHR() {}
    VkBufferMemoryBarrier2KHR s;
    MarshalVkBufferMemoryBarrier2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkBufferMemoryBarrier2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
        s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
        s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
        s->buffer = (VkBuffer)memory->readq(address);address+=8;
        s->offset = (VkDeviceSize)memory->readq(address);address+=8;
        s->size = (VkDeviceSize)memory->readq(address);address+=8;
    }
};

class MarshalVkDependencyInfoKHR {
public:
    MarshalVkDependencyInfoKHR() {}
    VkDependencyInfoKHR s;
    MarshalVkDependencyInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkDependencyInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
        s->memoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pMemoryBarriers = NULL;
        } else {
            VkMemoryBarrier2KHR* pMemoryBarriers = new VkMemoryBarrier2KHR[s->memoryBarrierCount];
            for (U32 i = 0; i < s->memoryBarrierCount; i++) {
                MarshalVkMemoryBarrier2KHR::read(memory, paramAddress, &pMemoryBarriers[i]);
            }
            s->pMemoryBarriers = pMemoryBarriers;
        }
        s->bufferMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pBufferMemoryBarriers = NULL;
        } else {
            VkBufferMemoryBarrier2KHR* pBufferMemoryBarriers = new VkBufferMemoryBarrier2KHR[s->bufferMemoryBarrierCount];
            for (U32 i = 0; i < s->bufferMemoryBarrierCount; i++) {
                MarshalVkBufferMemoryBarrier2KHR::read(memory, paramAddress, &pBufferMemoryBarriers[i]);
            }
            s->pBufferMemoryBarriers = pBufferMemoryBarriers;
        }
        s->imageMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pImageMemoryBarriers = NULL;
        } else {
            VkImageMemoryBarrier2KHR* pImageMemoryBarriers = new VkImageMemoryBarrier2KHR[s->imageMemoryBarrierCount];
            for (U32 i = 0; i < s->imageMemoryBarrierCount; i++) {
                MarshalVkImageMemoryBarrier2KHR::read(memory, paramAddress, &pImageMemoryBarriers[i]);
            }
            s->pImageMemoryBarriers = pImageMemoryBarriers;
        }
    }
};

class MarshalVkSemaphoreSubmitInfoKHR {
public:
    MarshalVkSemaphoreSubmitInfoKHR() {}
    VkSemaphoreSubmitInfoKHR s;
    MarshalVkSemaphoreSubmitInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSemaphoreSubmitInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
        s->value = (uint64_t)memory->readq(address);address+=8;
        s->stageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
        s->deviceIndex = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkCommandBufferSubmitInfoKHR {
public:
    MarshalVkCommandBufferSubmitInfoKHR() {}
    VkCommandBufferSubmitInfoKHR s;
    MarshalVkCommandBufferSubmitInfoKHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkCommandBufferSubmitInfoKHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->commandBuffer = (VkCommandBuffer)getVulkanPtr(memory, memory->readd(address));address+=4;
        s->deviceMask = (uint32_t)memory->readd(address);address+=4;
    }
};

class MarshalVkSubmitInfo2KHR {
public:
    MarshalVkSubmitInfo2KHR() {}
    VkSubmitInfo2KHR s;
    MarshalVkSubmitInfo2KHR(KMemory* memory, U32 address) {read(memory, address, &this->s);}
    static void read(KMemory* memory, U32 address, VkSubmitInfo2KHR* s) {
        s->sType = (VkStructureType)memory->readd(address);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pNext = NULL;
        } else {
            s->pNext = vulkanGetNextPtr(memory, paramAddress);
        }
        s->flags = (VkSubmitFlagsKHR)memory->readd(address);address+=4;
        s->waitSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pWaitSemaphoreInfos = NULL;
        } else {
            VkSemaphoreSubmitInfoKHR* pWaitSemaphoreInfos = new VkSemaphoreSubmitInfoKHR[s->waitSemaphoreInfoCount];
            for (U32 i = 0; i < s->waitSemaphoreInfoCount; i++) {
                MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress, &pWaitSemaphoreInfos[i]);
            }
            s->pWaitSemaphoreInfos = pWaitSemaphoreInfos;
        }
        s->commandBufferInfoCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pCommandBufferInfos = NULL;
        } else {
            VkCommandBufferSubmitInfoKHR* pCommandBufferInfos = new VkCommandBufferSubmitInfoKHR[s->commandBufferInfoCount];
            for (U32 i = 0; i < s->commandBufferInfoCount; i++) {
                MarshalVkCommandBufferSubmitInfoKHR::read(memory, paramAddress, &pCommandBufferInfos[i]);
            }
            s->pCommandBufferInfos = pCommandBufferInfos;
        }
        s->signalSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress == 0) {
            s->pSignalSemaphoreInfos = NULL;
        } else {
            VkSemaphoreSubmitInfoKHR* pSignalSemaphoreInfos = new VkSemaphoreSubmitInfoKHR[s->signalSemaphoreInfoCount];
            for (U32 i = 0; i < s->signalSemaphoreInfoCount; i++) {
                MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress, &pSignalSemaphoreInfos[i]);
            }
            s->pSignalSemaphoreInfos = pSignalSemaphoreInfos;
        }
    }
};

class MarshalVkCheckpointData2NV {
public:
    MarshalVkCheckpointData2NV() {}
    VkCheckpointData2NV s;
    static void write(KMemory* memory, U32 address, VkCheckpointData2NV* s) {
        memory->writed(address, s->sType);address+=4;
        U32 paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
            vulkanWriteNextPtr(memory, paramAddress, s->pNext);
            delete s->pNext;
        }
        memory->writeq(address, s->stage);address+=8;
        paramAddress = memory->readd(address);address+=4;
        if (paramAddress != 0) {
kpanic("        Can't marshal void*");
        }
    }
};

// return type: VkResult(4 bytes)
void vk_CreateInstance(CPU* cpu) {
    initVulkan();
    MarshalVkInstanceCreateInfo local_pCreateInfo(cpu->memory, ARG1);
    VkInstanceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG2) { klog("vkCreateInstance:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkInstance pInstance;
    EAX = pvkCreateInstance(pCreateInfo, pAllocator, &pInstance);
    cpu->memory->writed(ARG3, createVulkanPtr(cpu->memory, (U64)pInstance, NULL));
}
void vk_DestroyInstance(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyInstance:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyInstance(instance, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDevices(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceCount = &tmp_pPhysicalDeviceCount;
    VkPhysicalDevice* pPhysicalDevices = NULL;
    if (ARG3) {
        pPhysicalDevices = new VkPhysicalDevice[*pPhysicalDeviceCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, (U64)pPhysicalDevices[i], pBoxedInfo));
        }
        delete[] pPhysicalDevices;
    }
}
void vk_GetPhysicalDeviceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties* pQueueFamilyProperties = new VkQueueFamilyProperties[*pQueueFamilyPropertyCount];
    cpu->memory->memcpy(pQueueFamilyProperties, ARG3, *pQueueFamilyPropertyCount * sizeof(VkQueueFamilyProperties));
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    cpu->memory->memcpy(ARG3, pQueueFamilyProperties, *pQueueFamilyPropertyCount * sizeof(VkQueueFamilyProperties));
    delete[] pQueueFamilyProperties;
}
void vk_GetPhysicalDeviceMemoryProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPhysicalDeviceMemoryProperties tmp_pMemoryProperties;
    cpu->memory->memcpy(&tmp_pMemoryProperties, ARG2, 456);
    VkPhysicalDeviceMemoryProperties* pMemoryProperties = &tmp_pMemoryProperties;
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
    cpu->memory->memcpy(ARG2, &tmp_pMemoryProperties, 456);
}
void vk_GetPhysicalDeviceFeatures(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPhysicalDeviceFeatures tmp_pFeatures;
    cpu->memory->memcpy(&tmp_pFeatures, ARG2, 220);
    VkPhysicalDeviceFeatures* pFeatures = &tmp_pFeatures;
    pBoxedInfo->pvkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
    cpu->memory->memcpy(ARG2, &tmp_pFeatures, 220);
}
void vk_GetPhysicalDeviceFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkFormatProperties tmp_pFormatProperties;
    cpu->memory->memcpy(&tmp_pFormatProperties, ARG3, 12);
    VkFormatProperties* pFormatProperties = &tmp_pFormatProperties;
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
    cpu->memory->memcpy(ARG3, &tmp_pFormatProperties, 12);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkImageTiling tiling = (VkImageTiling)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageCreateFlags flags = (VkImageCreateFlags)ARG6;
    VkImageFormatProperties tmp_pImageFormatProperties;
    cpu->memory->memcpy(&tmp_pImageFormatProperties, ARG7, 32);
    VkImageFormatProperties* pImageFormatProperties = &tmp_pImageFormatProperties;
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    cpu->memory->memcpy(ARG7, &tmp_pImageFormatProperties, 32);
}
// return type: VkResult(4 bytes)
void vk_CreateDevice(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDeviceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDevice pDevice;
    EAX = pBoxedInfo->pvkCreateDevice(physicalDevice, pCreateInfo, pAllocator, &pDevice);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, (U64)pDevice, pBoxedInfo));
}
void vk_DestroyDevice(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDevice(device, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceVersion(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pApiVersion = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pApiVersion = &tmp_pApiVersion;
    EAX = pvkEnumerateInstanceVersion(pApiVersion);
    cpu->memory->writed(ARG1, (U32)tmp_pApiVersion);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceLayerProperties(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = new VkLayerProperties[*pPropertyCount];
    cpu->memory->memcpy(pProperties, ARG2, *pPropertyCount * sizeof(VkLayerProperties));
    EAX = pvkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
    cpu->memory->writed(ARG1, (U32)tmp_pPropertyCount);
    cpu->memory->memcpy(ARG2, pProperties, *pPropertyCount * sizeof(VkLayerProperties));
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceExtensionProperties(CPU* cpu) {
    initVulkan();
U32 len = cpu->memory->strlen(ARG1);
    char* pLayerName = new char[len];
    cpu->memory->memcpy(pLayerName, ARG1, len * sizeof(char));
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkExtensionProperties* pProperties = new VkExtensionProperties[*pPropertyCount];
    cpu->memory->memcpy(pProperties, ARG3, *pPropertyCount * sizeof(VkExtensionProperties));
    EAX = pvkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
    delete[] pLayerName;
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    cpu->memory->memcpy(ARG3, pProperties, *pPropertyCount * sizeof(VkExtensionProperties));
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceLayerProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = new VkLayerProperties[*pPropertyCount];
    cpu->memory->memcpy(pProperties, ARG3, *pPropertyCount * sizeof(VkLayerProperties));
    EAX = pBoxedInfo->pvkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    cpu->memory->memcpy(ARG3, pProperties, *pPropertyCount * sizeof(VkLayerProperties));
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceExtensionProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
U32 len = cpu->memory->strlen(ARG2);
    char* pLayerName = new char[len];
    cpu->memory->memcpy(pLayerName, ARG2, len * sizeof(char));
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkExtensionProperties* pProperties = new VkExtensionProperties[*pPropertyCount];
    cpu->memory->memcpy(pProperties, ARG4, *pPropertyCount * sizeof(VkExtensionProperties));
    EAX = pBoxedInfo->pvkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
    delete[] pLayerName;
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    cpu->memory->memcpy(ARG4, pProperties, *pPropertyCount * sizeof(VkExtensionProperties));
    delete[] pProperties;
}
void vk_GetDeviceQueue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t queueIndex = (uint32_t)ARG3;
    VkQueue pQueue;
    pBoxedInfo->pvkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &pQueue);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, (U64)pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo::read(cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)ARG64(ARG4, ARG5);
    EAX = pBoxedInfo->pvkQueueSubmit(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
// return type: VkResult(4 bytes)
void vk_QueueWaitIdle(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkQueueWaitIdle(queue);
}
// return type: VkResult(4 bytes)
void vk_DeviceWaitIdle(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkDeviceWaitIdle(device);
}
// return type: VkResult(4 bytes)
void vk_AllocateMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkMemoryAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkAllocateMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeviceMemory tmp_pMemory = (VkDeviceMemory) cpu->memory->readq(ARG4);
    VkDeviceMemory* pMemory = &tmp_pMemory;
    EAX = pBoxedInfo->pvkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
    if (EAX == 0 && pMemory) {
        registerVkMemoryAllocation(*pMemory, pAllocateInfo->allocationSize);
    }
    cpu->memory->writeq(ARG4, (U64)tmp_pMemory);
}
void vk_FreeMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkFreeMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkFreeMemory(device, memory, pAllocator);
    unregisterVkMemoryAllocation(memory);
}
// return type: VkResult(4 bytes)
void vk_MapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkDeviceSize size = (VkDeviceSize)ARG64(ARG6, ARG7);
    VkMemoryMapFlags flags = (VkMemoryMapFlags)ARG8;
    void *pData = NULL;
    EAX = pBoxedInfo->pvkMapMemory(device, memory, offset, size, flags, &pData);
    if (EAX == 0) {
        cpu->memory->writed(ARG6, mapVkMemory(memory, pData, size));
    }
}
void vk_UnmapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG2, ARG3);
    pBoxedInfo->pvkUnmapMemory(device, memory);
    unmapVkMemory(memory);
}
// return type: VkResult(4 bytes)
void vk_FlushMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = pBoxedInfo->pvkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
// return type: VkResult(4 bytes)
void vk_InvalidateMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = pBoxedInfo->pvkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
void vk_GetDeviceMemoryCommitment(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG2, ARG3);
    VkDeviceSize tmp_pCommittedMemoryInBytes = (VkDeviceSize) cpu->memory->readq(ARG4);
    VkDeviceSize* pCommittedMemoryInBytes = &tmp_pCommittedMemoryInBytes;
    pBoxedInfo->pvkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    cpu->memory->writeq(ARG4, (U64)tmp_pCommittedMemoryInBytes);
}
void vk_GetBufferMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkMemoryRequirements tmp_pMemoryRequirements;
    cpu->memory->memcpy(&tmp_pMemoryRequirements, ARG4, 20);
    VkMemoryRequirements* pMemoryRequirements = &tmp_pMemoryRequirements;
    pBoxedInfo->pvkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
    cpu->memory->memcpy(ARG4, &tmp_pMemoryRequirements, 20);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG4, ARG5);
    VkDeviceSize memoryOffset = (VkDeviceSize)ARG64(ARG6, ARG7);
    EAX = pBoxedInfo->pvkBindBufferMemory(device, buffer, memory, memoryOffset);
}
void vk_GetImageMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    VkMemoryRequirements tmp_pMemoryRequirements;
    cpu->memory->memcpy(&tmp_pMemoryRequirements, ARG4, 20);
    VkMemoryRequirements* pMemoryRequirements = &tmp_pMemoryRequirements;
    pBoxedInfo->pvkGetImageMemoryRequirements(device, image, pMemoryRequirements);
    cpu->memory->memcpy(ARG4, &tmp_pMemoryRequirements, 20);
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    VkDeviceMemory memory = (VkDeviceMemory)ARG64(ARG4, ARG5);
    VkDeviceSize memoryOffset = (VkDeviceSize)ARG64(ARG6, ARG7);
    EAX = pBoxedInfo->pvkBindImageMemory(device, image, memory, memoryOffset);
}
void vk_GetImageSparseMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG4);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements = new VkSparseImageMemoryRequirements[*pSparseMemoryRequirementCount];
    cpu->memory->memcpy(pSparseMemoryRequirements, ARG5, *pSparseMemoryRequirementCount * sizeof(VkSparseImageMemoryRequirements));
    pBoxedInfo->pvkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG4, (U32)tmp_pSparseMemoryRequirementCount);
    cpu->memory->memcpy(ARG5, pSparseMemoryRequirements, *pSparseMemoryRequirementCount * sizeof(VkSparseImageMemoryRequirements));
    delete[] pSparseMemoryRequirements;
}
void vk_GetPhysicalDeviceSparseImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageTiling tiling = (VkImageTiling)ARG6;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG7);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties* pProperties = new VkSparseImageFormatProperties[*pPropertyCount];
    cpu->memory->memcpy(pProperties, ARG8, *pPropertyCount * sizeof(VkSparseImageFormatProperties));
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    cpu->memory->writed(ARG7, (U32)tmp_pPropertyCount);
    cpu->memory->memcpy(ARG8, pProperties, *pPropertyCount * sizeof(VkSparseImageFormatProperties));
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_QueueBindSparse(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindSparseInfo* pBindInfo = NULL;
    if (ARG3) {
        pBindInfo = new VkBindSparseInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindSparseInfo::read(cpu->memory, ARG3 + i * 48, &pBindInfo[i]);
        }
    }
    VkFence fence = (VkFence)ARG64(ARG4, ARG5);
    EAX = pBoxedInfo->pvkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
    if (pBindInfo) {
        delete[] pBindInfo;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFenceCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkFenceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFence tmp_pFence = (VkFence) cpu->memory->readq(ARG4);
    VkFence* pFence = &tmp_pFence;
    EAX = pBoxedInfo->pvkCreateFence(device, pCreateInfo, pAllocator, pFence);
    cpu->memory->writeq(ARG4, (U64)tmp_pFence);
}
void vk_DestroyFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFence(device, fence, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = new VkFence[fenceCount];
    cpu->memory->memcpy(pFences, ARG3, fenceCount * sizeof(VkFence));
    EAX = pBoxedInfo->pvkResetFences(device, fenceCount, pFences);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_GetFenceStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkGetFenceStatus(device, fence);
}
// return type: VkResult(4 bytes)
void vk_WaitForFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = new VkFence[fenceCount];
    cpu->memory->memcpy(pFences, ARG3, fenceCount * sizeof(VkFence));
    VkBool32 waitAll = (VkBool32)ARG4;
    uint64_t timeout = (uint64_t)ARG64(ARG5, ARG6);
    EAX = pBoxedInfo->pvkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_CreateSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSemaphoreCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSemaphore tmp_pSemaphore = (VkSemaphore) cpu->memory->readq(ARG4);
    VkSemaphore* pSemaphore = &tmp_pSemaphore;
    EAX = pBoxedInfo->pvkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
    cpu->memory->writeq(ARG4, (U64)tmp_pSemaphore);
}
void vk_DestroySemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySemaphore(device, semaphore, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkEventCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkEventCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkEvent tmp_pEvent = (VkEvent) cpu->memory->readq(ARG4);
    VkEvent* pEvent = &tmp_pEvent;
    EAX = pBoxedInfo->pvkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
    cpu->memory->writeq(ARG4, (U64)tmp_pEvent);
}
void vk_DestroyEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyEvent(device, event, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetEventStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkGetEventStatus(device, event);
}
// return type: VkResult(4 bytes)
void vk_SetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkSetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_ResetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkResetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_CreateQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkQueryPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkQueryPool tmp_pQueryPool = (VkQueryPool) cpu->memory->readq(ARG4);
    VkQueryPool* pQueryPool = &tmp_pQueryPool;
    EAX = pBoxedInfo->pvkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pQueryPool);
}
void vk_DestroyQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyQueryPool(device, queryPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetQueryPoolResults(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t firstQuery = (uint32_t)ARG4;
    uint32_t queryCount = (uint32_t)ARG5;
    size_t dataSize = (size_t)ARG6;
    void* pData = new char[dataSize];
    cpu->memory->memcpy(pData, ARG7, dataSize * sizeof(char));
    VkDeviceSize stride = (VkDeviceSize)ARG64(ARG8, ARG9);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG10;
    EAX = pBoxedInfo->pvkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    cpu->memory->memcpy(ARG7, pData, dataSize * sizeof(char));
    delete[] pData;
}
void vk_ResetQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t firstQuery = (uint32_t)ARG4;
    uint32_t queryCount = (uint32_t)ARG5;
    pBoxedInfo->pvkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
void vk_ResetQueryPoolEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t firstQuery = (uint32_t)ARG4;
    uint32_t queryCount = (uint32_t)ARG5;
    pBoxedInfo->pvkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
}
// return type: VkResult(4 bytes)
void vk_CreateBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkBufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBuffer tmp_pBuffer = (VkBuffer) cpu->memory->readq(ARG4);
    VkBuffer* pBuffer = &tmp_pBuffer;
    EAX = pBoxedInfo->pvkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pBuffer);
}
void vk_DestroyBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBuffer(device, buffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferViewCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkBufferViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBufferView tmp_pView = (VkBufferView) cpu->memory->readq(ARG4);
    VkBufferView* pView = &tmp_pView;
    EAX = pBoxedInfo->pvkCreateBufferView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBufferView bufferView = (VkBufferView)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBufferView(device, bufferView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkImageCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImage tmp_pImage = (VkImage) cpu->memory->readq(ARG4);
    VkImage* pImage = &tmp_pImage;
    EAX = pBoxedInfo->pvkCreateImage(device, pCreateInfo, pAllocator, pImage);
    cpu->memory->writeq(ARG4, (U64)tmp_pImage);
}
void vk_DestroyImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImage(device, image, pAllocator);
}
void vk_GetImageSubresourceLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    VkImageSubresource tmp_pSubresource;
    cpu->memory->memcpy(&tmp_pSubresource, ARG4, 12);
    VkImageSubresource* pSubresource = &tmp_pSubresource;
    VkSubresourceLayout tmp_pLayout;
    cpu->memory->memcpy(&tmp_pLayout, ARG5, 40);
    VkSubresourceLayout* pLayout = &tmp_pLayout;
    pBoxedInfo->pvkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
    cpu->memory->memcpy(ARG5, &tmp_pLayout, 40);
}
// return type: VkResult(4 bytes)
void vk_CreateImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkImageViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImageView tmp_pView = (VkImageView) cpu->memory->readq(ARG4);
    VkImageView* pView = &tmp_pView;
    EAX = pBoxedInfo->pvkCreateImageView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImageView(device, imageView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkShaderModuleCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkShaderModuleCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkShaderModule tmp_pShaderModule = (VkShaderModule) cpu->memory->readq(ARG4);
    VkShaderModule* pShaderModule = &tmp_pShaderModule;
    EAX = pBoxedInfo->pvkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
    cpu->memory->writeq(ARG4, (U64)tmp_pShaderModule);
}
void vk_DestroyShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderModule shaderModule = (VkShaderModule)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyShaderModule(device, shaderModule, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineCacheCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkPipelineCacheCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineCache tmp_pPipelineCache = (VkPipelineCache) cpu->memory->readq(ARG4);
    VkPipelineCache* pPipelineCache = &tmp_pPipelineCache;
    EAX = pBoxedInfo->pvkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineCache);
}
void vk_DestroyPipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyPipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineCache(device, pipelineCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineCacheData(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG4);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = new char[*pDataSize];
    cpu->memory->memcpy(pData, ARG5, *pDataSize * sizeof(char));
    EAX = pBoxedInfo->pvkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
    cpu->memory->writed(ARG4, (U32)tmp_pDataSize);
    cpu->memory->memcpy(ARG5, pData, *pDataSize * sizeof(char));
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergePipelineCaches(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache dstCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    uint32_t srcCacheCount = (uint32_t)ARG4;
    VkPipelineCache* pSrcCaches = new VkPipelineCache[srcCacheCount];
    cpu->memory->memcpy(pSrcCaches, ARG5, srcCacheCount * sizeof(VkPipelineCache));
    EAX = pBoxedInfo->pvkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
// return type: VkResult(4 bytes)
void vk_CreateGraphicsPipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    uint32_t createInfoCount = (uint32_t)ARG4;
    VkGraphicsPipelineCreateInfo* pCreateInfos = NULL;
    if (ARG5) {
        pCreateInfos = new VkGraphicsPipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkGraphicsPipelineCreateInfo::read(cpu->memory, ARG5 + i * 88, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG6) { klog("vkCreateGraphicsPipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = new VkPipeline[createInfoCount];
    cpu->memory->memcpy(pPipelines, ARG7, createInfoCount * sizeof(VkPipeline));
    EAX = pBoxedInfo->pvkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    cpu->memory->memcpy(ARG7, pPipelines, createInfoCount * sizeof(VkPipeline));
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_CreateComputePipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    uint32_t createInfoCount = (uint32_t)ARG4;
    VkComputePipelineCreateInfo* pCreateInfos = NULL;
    if (ARG5) {
        pCreateInfos = new VkComputePipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkComputePipelineCreateInfo::read(cpu->memory, ARG5 + i * 64, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG6) { klog("vkCreateComputePipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = new VkPipeline[createInfoCount];
    cpu->memory->memcpy(pPipelines, ARG7, createInfoCount * sizeof(VkPipeline));
    EAX = pBoxedInfo->pvkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    cpu->memory->memcpy(ARG7, pPipelines, createInfoCount * sizeof(VkPipeline));
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetSubpassShadingMaxWorkgroupSizeHUAWEI(CPU* cpu) {
    initVulkan();
    VkRenderPass renderpass = (VkRenderPass)ARG64(ARG1, ARG2);
    VkExtent2D tmp_pMaxWorkgroupSize;
    cpu->memory->memcpy(&tmp_pMaxWorkgroupSize, ARG3, 8);
    VkExtent2D* pMaxWorkgroupSize = &tmp_pMaxWorkgroupSize;
    EAX = pvkGetSubpassShadingMaxWorkgroupSizeHUAWEI(renderpass, pMaxWorkgroupSize);
    cpu->memory->memcpy(ARG3, &tmp_pMaxWorkgroupSize, 8);
}
void vk_DestroyPipeline(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyPipeline:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipeline(device, pipeline, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkPipelineLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineLayout tmp_pPipelineLayout = (VkPipelineLayout) cpu->memory->readq(ARG4);
    VkPipelineLayout* pPipelineLayout = &tmp_pPipelineLayout;
    EAX = pBoxedInfo->pvkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineLayout);
}
void vk_DestroyPipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout pipelineLayout = (VkPipelineLayout)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyPipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateSampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSampler tmp_pSampler = (VkSampler) cpu->memory->readq(ARG4);
    VkSampler* pSampler = &tmp_pSampler;
    EAX = pBoxedInfo->pvkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
    cpu->memory->writeq(ARG4, (U64)tmp_pSampler);
}
void vk_DestroySampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampler sampler = (VkSampler)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySampler(device, sampler, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorSetLayout tmp_pSetLayout = (VkDescriptorSetLayout) cpu->memory->readq(ARG4);
    VkDescriptorSetLayout* pSetLayout = &tmp_pSetLayout;
    EAX = pBoxedInfo->pvkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pSetLayout);
}
void vk_DestroyDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSetLayout descriptorSetLayout = (VkDescriptorSetLayout)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorPool tmp_pDescriptorPool = (VkDescriptorPool) cpu->memory->readq(ARG4);
    VkDescriptorPool* pDescriptorPool = &tmp_pDescriptorPool;
    EAX = pBoxedInfo->pvkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorPool);
}
void vk_DestroyDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorPool(device, descriptorPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)ARG64(ARG2, ARG3);
    VkDescriptorPoolResetFlags flags = (VkDescriptorPoolResetFlags)ARG4;
    EAX = pBoxedInfo->pvkResetDescriptorPool(device, descriptorPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkDescriptorSetAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkDescriptorSet* pDescriptorSets = new VkDescriptorSet[pAllocateInfo->descriptorSetCount];
    cpu->memory->memcpy(pDescriptorSets, ARG3, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    EAX = pBoxedInfo->pvkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
    cpu->memory->memcpy(ARG3, pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    delete[] pDescriptorSets;
}
// return type: VkResult(4 bytes)
void vk_FreeDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)ARG64(ARG2, ARG3);
    uint32_t descriptorSetCount = (uint32_t)ARG4;
    VkDescriptorSet* pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
    cpu->memory->memcpy(pDescriptorSets, ARG5, descriptorSetCount * sizeof(VkDescriptorSet));
    EAX = pBoxedInfo->pvkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    delete[] pDescriptorSets;
}
void vk_UpdateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t descriptorWriteCount = (uint32_t)ARG2;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG3) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(cpu->memory, ARG3 + i * 64, &pDescriptorWrites[i]);
        }
    }
    uint32_t descriptorCopyCount = (uint32_t)ARG4;
    VkCopyDescriptorSet* pDescriptorCopies = NULL;
    if (ARG5) {
        pDescriptorCopies = new VkCopyDescriptorSet[descriptorCopyCount];
        for (U32 i=0;i<descriptorCopyCount;i++) {
            MarshalVkCopyDescriptorSet::read(cpu->memory, ARG5 + i * 44, &pDescriptorCopies[i]);
        }
    }
    pBoxedInfo->pvkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
    if (pDescriptorCopies) {
        delete[] pDescriptorCopies;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFramebufferCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkFramebufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFramebuffer tmp_pFramebuffer = (VkFramebuffer) cpu->memory->readq(ARG4);
    VkFramebuffer* pFramebuffer = &tmp_pFramebuffer;
    EAX = pBoxedInfo->pvkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pFramebuffer);
}
void vk_DestroyFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFramebuffer framebuffer = (VkFramebuffer)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFramebuffer(device, framebuffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_DestroyRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyRenderPass(device, renderPass, pAllocator);
}
void vk_GetRenderAreaGranularity(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)ARG64(ARG2, ARG3);
    VkExtent2D tmp_pGranularity;
    cpu->memory->memcpy(&tmp_pGranularity, ARG4, 8);
    VkExtent2D* pGranularity = &tmp_pGranularity;
    pBoxedInfo->pvkGetRenderAreaGranularity(device, renderPass, pGranularity);
    cpu->memory->memcpy(ARG4, &tmp_pGranularity, 8);
}
// return type: VkResult(4 bytes)
void vk_CreateCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkCommandPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCommandPool tmp_pCommandPool = (VkCommandPool) cpu->memory->readq(ARG4);
    VkCommandPool* pCommandPool = &tmp_pCommandPool;
    EAX = pBoxedInfo->pvkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pCommandPool);
}
void vk_DestroyCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCommandPool(device, commandPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)ARG64(ARG2, ARG3);
    VkCommandPoolResetFlags flags = (VkCommandPoolResetFlags)ARG4;
    EAX = pBoxedInfo->pvkResetCommandPool(device, commandPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkCommandBufferAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkCommandBuffer* pCommandBuffers = NULL;
    if (ARG3) {
        pCommandBuffers = new VkCommandBuffer[pAllocateInfo->commandBufferCount];
    }
    EAX = pBoxedInfo->pvkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
    if (ARG3) {
        for (U32 i=0;i<pAllocateInfo->commandBufferCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, (U64)pCommandBuffers[i], pBoxedInfo));
        }
        delete[] pCommandBuffers;
    }
}
void vk_FreeCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)ARG64(ARG2, ARG3);
    uint32_t commandBufferCount = (uint32_t)ARG4;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG5 + i*4));
    }
    pBoxedInfo->pvkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
// return type: VkResult(4 bytes)
void vk_BeginCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferBeginInfo local_pBeginInfo(cpu->memory, ARG2);
    VkCommandBufferBeginInfo* pBeginInfo = &local_pBeginInfo.s;
    EAX = pBoxedInfo->pvkBeginCommandBuffer(commandBuffer, pBeginInfo);
}
// return type: VkResult(4 bytes)
void vk_EndCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkEndCommandBuffer(commandBuffer);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandBufferResetFlags flags = (VkCommandBufferResetFlags)ARG2;
    EAX = pBoxedInfo->pvkResetCommandBuffer(commandBuffer, flags);
}
void vk_CmdBindPipeline(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)ARG64(ARG3, ARG4);
    pBoxedInfo->pvkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
}
void vk_CmdSetViewport(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewport* pViewports = new VkViewport[viewportCount];
    cpu->memory->memcpy(pViewports, ARG4, viewportCount * sizeof(VkViewport));
    pBoxedInfo->pvkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    delete[] pViewports;
}
void vk_CmdSetScissor(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstScissor = (uint32_t)ARG2;
    uint32_t scissorCount = (uint32_t)ARG3;
    VkRect2D* pScissors = new VkRect2D[scissorCount];
    cpu->memory->memcpy(pScissors, ARG4, scissorCount * sizeof(VkRect2D));
    pBoxedInfo->pvkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    delete[] pScissors;
}
void vk_CmdSetLineWidth(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float lineWidth = (float)ARG2;
    pBoxedInfo->pvkCmdSetLineWidth(commandBuffer, lineWidth);
}
void vk_CmdSetDepthBias(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float depthBiasConstantFactor = (float)ARG2;
    float depthBiasClamp = (float)ARG3;
    float depthBiasSlopeFactor = (float)ARG4;
    pBoxedInfo->pvkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
void vk_CmdSetBlendConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float* blendConstants = new float[4];
    cpu->memory->memcpy(blendConstants, ARG2, 4 * sizeof(float));
    pBoxedInfo->pvkCmdSetBlendConstants(commandBuffer, blendConstants);
    delete[] blendConstants;
}
void vk_CmdSetDepthBounds(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float minDepthBounds = (float)ARG2;
    float maxDepthBounds = (float)ARG3;
    pBoxedInfo->pvkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
}
void vk_CmdSetStencilCompareMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t compareMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
}
void vk_CmdSetStencilWriteMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t writeMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
}
void vk_CmdSetStencilReference(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t reference = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilReference(commandBuffer, faceMask, reference);
}
void vk_CmdBindDescriptorSets(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)ARG64(ARG3, ARG4);
    uint32_t firstSet = (uint32_t)ARG5;
    uint32_t descriptorSetCount = (uint32_t)ARG6;
    VkDescriptorSet* pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
    cpu->memory->memcpy(pDescriptorSets, ARG7, descriptorSetCount * sizeof(VkDescriptorSet));
    uint32_t dynamicOffsetCount = (uint32_t)ARG8;
    uint32_t* pDynamicOffsets = new uint32_t[dynamicOffsetCount];
    cpu->memory->memcpy(pDynamicOffsets, ARG9, dynamicOffsetCount * sizeof(uint32_t));
    pBoxedInfo->pvkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    delete[] pDescriptorSets;
    delete[] pDynamicOffsets;
}
void vk_CmdBindIndexBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkIndexType indexType = (VkIndexType)ARG6;
    pBoxedInfo->pvkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
}
void vk_CmdBindVertexBuffers(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = new VkBuffer[bindingCount];
    cpu->memory->memcpy(pBuffers, ARG4, bindingCount * sizeof(VkBuffer));
    VkDeviceSize* pOffsets = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pOffsets, ARG5, bindingCount * sizeof(VkDeviceSize));
    pBoxedInfo->pvkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    delete[] pBuffers;
    delete[] pOffsets;
}
void vk_CmdDraw(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstVertex = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
void vk_CmdDrawIndexed(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t indexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstIndex = (uint32_t)ARG4;
    int32_t vertexOffset = (int32_t)ARG5;
    uint32_t firstInstance = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
void vk_CmdDrawMultiEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawInfoEXT* pVertexInfo = new VkMultiDrawInfoEXT[drawCount];
    cpu->memory->memcpy(pVertexInfo, ARG3, drawCount * sizeof(VkMultiDrawInfoEXT));
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    uint32_t stride = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
    delete[] pVertexInfo;
}
void vk_CmdDrawMultiIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawIndexedInfoEXT* pIndexInfo = new VkMultiDrawIndexedInfoEXT[drawCount];
    cpu->memory->memcpy(pIndexInfo, ARG3, drawCount * sizeof(VkMultiDrawIndexedInfoEXT));
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    uint32_t stride = (uint32_t)ARG6;
    int32_t tmp_pVertexOffset = (int32_t) cpu->memory->readd(ARG7);
    int32_t* pVertexOffset = &tmp_pVertexOffset;
    pBoxedInfo->pvkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
    delete[] pIndexInfo;
}
void vk_CmdDrawIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    uint32_t drawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawIndexedIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    uint32_t drawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDispatch(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t groupCountX = (uint32_t)ARG2;
    uint32_t groupCountY = (uint32_t)ARG3;
    uint32_t groupCountZ = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    pBoxedInfo->pvkCmdDispatchIndirect(commandBuffer, buffer, offset);
}
void vk_CmdSubpassShadingHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdSubpassShadingHUAWEI(commandBuffer);
}
void vk_CmdCopyBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG4, ARG5);
    uint32_t regionCount = (uint32_t)ARG6;
    VkBufferCopy* pRegions = new VkBufferCopy[regionCount];
    cpu->memory->memcpy(pRegions, ARG7, regionCount * sizeof(VkBufferCopy));
    pBoxedInfo->pvkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdCopyImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG4;
    VkImage dstImage = (VkImage)ARG64(ARG5, ARG6);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG7;
    uint32_t regionCount = (uint32_t)ARG8;
    VkImageCopy* pRegions = new VkImageCopy[regionCount];
    cpu->memory->memcpy(pRegions, ARG9, regionCount * sizeof(VkImageCopy));
    pBoxedInfo->pvkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdBlitImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG4;
    VkImage dstImage = (VkImage)ARG64(ARG5, ARG6);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG7;
    uint32_t regionCount = (uint32_t)ARG8;
    VkImageBlit* pRegions = new VkImageBlit[regionCount];
    cpu->memory->memcpy(pRegions, ARG9, regionCount * sizeof(VkImageBlit));
    VkFilter filter = (VkFilter)ARG10;
    pBoxedInfo->pvkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    delete[] pRegions;
}
void vk_CmdCopyBufferToImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkImage dstImage = (VkImage)ARG64(ARG4, ARG5);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG6;
    uint32_t regionCount = (uint32_t)ARG7;
    VkBufferImageCopy* pRegions = new VkBufferImageCopy[regionCount];
    cpu->memory->memcpy(pRegions, ARG8, regionCount * sizeof(VkBufferImageCopy));
    pBoxedInfo->pvkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdCopyImageToBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG4;
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG5, ARG6);
    uint32_t regionCount = (uint32_t)ARG7;
    VkBufferImageCopy* pRegions = new VkBufferImageCopy[regionCount];
    cpu->memory->memcpy(pRegions, ARG8, regionCount * sizeof(VkBufferImageCopy));
    pBoxedInfo->pvkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdUpdateBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkDeviceSize dataSize = (VkDeviceSize)ARG64(ARG6, ARG7);
    void* pData = new char[dataSize];
    cpu->memory->memcpy(pData, ARG8, dataSize * sizeof(char));
    pBoxedInfo->pvkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    delete[] pData;
}
void vk_CmdFillBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkDeviceSize size = (VkDeviceSize)ARG64(ARG6, ARG7);
    uint32_t data = (uint32_t)ARG8;
    pBoxedInfo->pvkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
}
void vk_CmdClearColorImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout imageLayout = (VkImageLayout)ARG4;
    VkClearColorValue tmp_pColor;
    cpu->memory->memcpy(&tmp_pColor, ARG5, 16);
    VkClearColorValue* pColor = &tmp_pColor;
    uint32_t rangeCount = (uint32_t)ARG6;
    VkImageSubresourceRange* pRanges = new VkImageSubresourceRange[rangeCount];
    cpu->memory->memcpy(pRanges, ARG7, rangeCount * sizeof(VkImageSubresourceRange));
    pBoxedInfo->pvkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    delete[] pRanges;
}
void vk_CmdClearDepthStencilImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout imageLayout = (VkImageLayout)ARG4;
    VkClearDepthStencilValue tmp_pDepthStencil;
    cpu->memory->memcpy(&tmp_pDepthStencil, ARG5, 8);
    VkClearDepthStencilValue* pDepthStencil = &tmp_pDepthStencil;
    uint32_t rangeCount = (uint32_t)ARG6;
    VkImageSubresourceRange* pRanges = new VkImageSubresourceRange[rangeCount];
    cpu->memory->memcpy(pRanges, ARG7, rangeCount * sizeof(VkImageSubresourceRange));
    pBoxedInfo->pvkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    delete[] pRanges;
}
void vk_CmdClearAttachments(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkClearAttachment* pAttachments = new VkClearAttachment[attachmentCount];
    cpu->memory->memcpy(pAttachments, ARG3, attachmentCount * sizeof(VkClearAttachment));
    uint32_t rectCount = (uint32_t)ARG4;
    VkClearRect* pRects = new VkClearRect[rectCount];
    cpu->memory->memcpy(pRects, ARG5, rectCount * sizeof(VkClearRect));
    pBoxedInfo->pvkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    delete[] pAttachments;
    delete[] pRects;
}
void vk_CmdResolveImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)ARG64(ARG2, ARG3);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG4;
    VkImage dstImage = (VkImage)ARG64(ARG5, ARG6);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG7;
    uint32_t regionCount = (uint32_t)ARG8;
    VkImageResolve* pRegions = new VkImageResolve[regionCount];
    cpu->memory->memcpy(pRegions, ARG9, regionCount * sizeof(VkImageResolve));
    pBoxedInfo->pvkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdSetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG4;
    pBoxedInfo->pvkCmdSetEvent(commandBuffer, event, stageMask);
}
void vk_CmdResetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG4;
    pBoxedInfo->pvkCmdResetEvent(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = new VkEvent[eventCount];
    cpu->memory->memcpy(pEvents, ARG3, eventCount * sizeof(VkEvent));
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG4;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG5;
    uint32_t memoryBarrierCount = (uint32_t)ARG6;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG7) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(cpu->memory, ARG7 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG8;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG9) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(cpu->memory, ARG9 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG10;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG11) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(cpu->memory, ARG11 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    delete[] pEvents;
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdPipelineBarrier(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG2;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG3;
    VkDependencyFlags dependencyFlags = (VkDependencyFlags)ARG4;
    uint32_t memoryBarrierCount = (uint32_t)ARG5;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG6) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(cpu->memory, ARG6 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG7;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG8) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(cpu->memory, ARG8 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG9;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG10) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(cpu->memory, ARG10 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdBeginQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t query = (uint32_t)ARG4;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG5;
    pBoxedInfo->pvkCmdBeginQuery(commandBuffer, queryPool, query, flags);
}
void vk_CmdEndQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdEndQuery(commandBuffer, queryPool, query);
}
void vk_CmdBeginConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkConditionalRenderingBeginInfoEXT local_pConditionalRenderingBegin(cpu->memory, ARG2);
    VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin = &local_pConditionalRenderingBegin.s;
    pBoxedInfo->pvkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
}
void vk_CmdEndConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndConditionalRenderingEXT(commandBuffer);
}
void vk_CmdResetQueryPool(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t firstQuery = (uint32_t)ARG4;
    uint32_t queryCount = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
}
void vk_CmdWriteTimestamp(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG3, ARG4);
    uint32_t query = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
}
void vk_CmdCopyQueryPoolResults(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t firstQuery = (uint32_t)ARG4;
    uint32_t queryCount = (uint32_t)ARG5;
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize dstOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    VkDeviceSize stride = (VkDeviceSize)ARG64(ARG10, ARG11);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG12;
    pBoxedInfo->pvkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
void vk_CmdPushConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout layout = (VkPipelineLayout)ARG64(ARG2, ARG3);
    VkShaderStageFlags stageFlags = (VkShaderStageFlags)ARG4;
    uint32_t offset = (uint32_t)ARG5;
    uint32_t size = (uint32_t)ARG6;
    void* pValues = new char[size];
    cpu->memory->memcpy(pValues, ARG7, size * sizeof(char));
    pBoxedInfo->pvkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    delete[] pValues;
}
void vk_CmdBeginRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    VkSubpassContents contents = (VkSubpassContents)ARG3;
    pBoxedInfo->pvkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
}
void vk_CmdNextSubpass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSubpassContents contents = (VkSubpassContents)ARG2;
    pBoxedInfo->pvkCmdNextSubpass(commandBuffer, contents);
}
void vk_CmdEndRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndRenderPass(commandBuffer);
}
void vk_CmdExecuteCommands(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t commandBufferCount = (uint32_t)ARG2;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG3 + i*4));
    }
    pBoxedInfo->pvkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
void vk_DestroySurfaceKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySurfaceKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySurfaceKHR(instance, surface, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceSupportKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG3, ARG4);
    VkBool32 tmp_pSupported = (VkBool32) cpu->memory->readd(ARG5);
    VkBool32* pSupported = &tmp_pSupported;
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
    cpu->memory->writed(ARG5, (U32)tmp_pSupported);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilitiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    MarshalVkSurfaceCapabilitiesKHR pSurfaceCapabilities(cpu->memory, ARG4);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilitiesKHR::write(cpu->memory, ARG4, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormatsKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG4);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormatKHR* pSurfaceFormats = NULL;
    if (ARG5) {
        pSurfaceFormats = new VkSurfaceFormatKHR[*pSurfaceFormatCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG4, (U32)tmp_pSurfaceFormatCount);
    if (ARG5) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormatKHR::write(cpu->memory, ARG5 + i * 8, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfacePresentModesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    uint32_t tmp_pPresentModeCount = (uint32_t) cpu->memory->readd(ARG4);
    uint32_t* pPresentModeCount = &tmp_pPresentModeCount;
    static_assert (sizeof(VkPresentModeKHR) == 4, "unhandled enum size");
    VkPresentModeKHR* pPresentModes = new VkPresentModeKHR[*pPresentModeCount];
    cpu->memory->memcpy(pPresentModes, ARG5, *pPresentModeCount * sizeof(VkPresentModeKHR));
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
    cpu->memory->writed(ARG4, (U32)tmp_pPresentModeCount);
}
// return type: VkResult(4 bytes)
void vk_CreateSwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSwapchainCreateInfoKHR local_pCreateInfo(cpu->memory, ARG2);
    VkSwapchainCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSwapchainKHR tmp_pSwapchain = (VkSwapchainKHR) cpu->memory->readq(ARG4);
    VkSwapchainKHR* pSwapchain = &tmp_pSwapchain;
    EAX = pBoxedInfo->pvkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
    cpu->memory->writeq(ARG4, (U64)tmp_pSwapchain);
}
void vk_DestroySwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySwapchainKHR(device, swapchain, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetSwapchainImagesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)ARG64(ARG2, ARG3);
    uint32_t tmp_pSwapchainImageCount = (uint32_t) cpu->memory->readd(ARG4);
    uint32_t* pSwapchainImageCount = &tmp_pSwapchainImageCount;
    VkImage* pSwapchainImages = new VkImage[*pSwapchainImageCount];
    cpu->memory->memcpy(pSwapchainImages, ARG5, *pSwapchainImageCount * sizeof(VkImage));
    EAX = pBoxedInfo->pvkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    cpu->memory->writed(ARG4, (U32)tmp_pSwapchainImageCount);
    cpu->memory->memcpy(ARG5, pSwapchainImages, *pSwapchainImageCount * sizeof(VkImage));
    delete[] pSwapchainImages;
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImageKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)ARG64(ARG2, ARG3);
    uint64_t timeout = (uint64_t)ARG64(ARG4, ARG5);
    VkSemaphore semaphore = (VkSemaphore)ARG64(ARG6, ARG7);
    VkFence fence = (VkFence)ARG64(ARG8, ARG9);
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG10);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = pBoxedInfo->pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
    cpu->memory->writed(ARG10, (U32)tmp_pImageIndex);
}
// return type: VkResult(4 bytes)
void vk_QueuePresentKHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPresentInfoKHR local_pPresentInfo(cpu->memory, ARG2);
    VkPresentInfoKHR* pPresentInfo = &local_pPresentInfo.s;
    EAX = pBoxedInfo->pvkQueuePresentKHR(queue, pPresentInfo);
}
void vk_CmdExecuteGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 isPreprocessed = (VkBool32)ARG2;
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(cpu->memory, ARG3);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
void vk_CmdPreprocessGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(cpu->memory, ARG2);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
}
void vk_CmdBindPipelineShaderGroupNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)ARG64(ARG3, ARG4);
    uint32_t groupIndex = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
void vk_GetGeneratedCommandsMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsMemoryRequirementsInfoNV local_pInfo(cpu->memory, ARG2);
    VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_CreateIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkIndirectCommandsLayoutCreateInfoNV local_pCreateInfo(cpu->memory, ARG2);
    VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkIndirectCommandsLayoutNV tmp_pIndirectCommandsLayout = (VkIndirectCommandsLayoutNV) cpu->memory->readq(ARG4);
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout = &tmp_pIndirectCommandsLayout;
    EAX = pBoxedInfo->pvkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pIndirectCommandsLayout);
}
void vk_DestroyIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectCommandsLayoutNV indirectCommandsLayout = (VkIndirectCommandsLayoutNV)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
}
void vk_GetPhysicalDeviceFeatures2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceFeatures2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2KHR(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2KHR(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(cpu->memory, ARG3, &pFormatProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(cpu->memory, ARG3, &pFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(cpu->memory, ARG3, &pImageFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(cpu->memory, ARG3, &pImageFormatProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceQueueFamilyProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceMemoryProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceMemoryProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_CmdPushDescriptorSetKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)ARG64(ARG3, ARG4);
    uint32_t set = (uint32_t)ARG5;
    uint32_t descriptorWriteCount = (uint32_t)ARG6;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG7) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(cpu->memory, ARG7 + i * 64, &pDescriptorWrites[i]);
        }
    }
    pBoxedInfo->pvkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
}
void vk_TrimCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)ARG64(ARG2, ARG3);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG4;
    pBoxedInfo->pvkTrimCommandPool(device, commandPool, flags);
}
void vk_TrimCommandPoolKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)ARG64(ARG2, ARG3);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG4;
    pBoxedInfo->pvkTrimCommandPoolKHR(device, commandPool, flags);
}
void vk_GetPhysicalDeviceExternalBufferProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalBufferPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphoreProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphorePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalFenceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(cpu->memory, ARG3, &pExternalFenceProperties.s);
}
void vk_GetPhysicalDeviceExternalFencePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(cpu->memory, ARG3, &pExternalFenceProperties.s);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroups(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroupsKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
void vk_GetDeviceGroupPeerMemoryFeatures(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
void vk_GetDeviceGroupPeerMemoryFeaturesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindBufferMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindImageMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdSetDeviceMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMask(commandBuffer, deviceMask);
}
void vk_CmdSetDeviceMaskKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupPresentCapabilitiesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities(cpu->memory, ARG2);
    EAX = pBoxedInfo->pvkGetDeviceGroupPresentCapabilitiesKHR(device, &pDeviceGroupPresentCapabilities.s);
    MarshalVkDeviceGroupPresentCapabilitiesKHR::write(cpu->memory, ARG2, &pDeviceGroupPresentCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupSurfacePresentModesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    VkDeviceGroupPresentModeFlagsKHR tmp_pModes = (VkDeviceGroupPresentModeFlagsKHR) cpu->memory->readd(ARG4);
    VkDeviceGroupPresentModeFlagsKHR* pModes = &tmp_pModes;
    EAX = pBoxedInfo->pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
    cpu->memory->writed(ARG4, (U32)tmp_pModes);
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImage2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireNextImageInfoKHR local_pAcquireInfo(cpu->memory, ARG2);
    VkAcquireNextImageInfoKHR* pAcquireInfo = &local_pAcquireInfo.s;
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = pBoxedInfo->pvkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
    cpu->memory->writed(ARG3, (U32)tmp_pImageIndex);
}
void vk_CmdDispatchBase(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchBaseKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDevicePresentRectanglesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)ARG64(ARG2, ARG3);
    uint32_t tmp_pRectCount = (uint32_t) cpu->memory->readd(ARG4);
    uint32_t* pRectCount = &tmp_pRectCount;
    VkRect2D* pRects = new VkRect2D[*pRectCount];
    cpu->memory->memcpy(pRects, ARG5, *pRectCount * sizeof(VkRect2D));
    EAX = pBoxedInfo->pvkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
    cpu->memory->writed(ARG4, (U32)tmp_pRectCount);
    cpu->memory->memcpy(ARG5, pRects, *pRectCount * sizeof(VkRect2D));
    delete[] pRects;
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = pBoxedInfo->pvkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = pBoxedInfo->pvkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
void vk_DestroyDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
void vk_DestroyDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
}
void vk_UpdateDescriptorSetWithTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)ARG64(ARG2, ARG3);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)ARG64(ARG4, ARG5);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_UpdateDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)ARG64(ARG2, ARG3);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)ARG64(ARG4, ARG5);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_CmdPushDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)ARG64(ARG2, ARG3);
    VkPipelineLayout layout = (VkPipelineLayout)ARG64(ARG4, ARG5);
    uint32_t set = (uint32_t)ARG6;
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
void vk_CmdSetViewportWScalingNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewportWScalingNV* pViewportWScalings = new VkViewportWScalingNV[viewportCount];
    cpu->memory->memcpy(pViewportWScalings, ARG4, viewportCount * sizeof(VkViewportWScalingNV));
    pBoxedInfo->pvkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    delete[] pViewportWScalings;
}
void vk_CmdSetDiscardRectangleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstDiscardRectangle = (uint32_t)ARG2;
    uint32_t discardRectangleCount = (uint32_t)ARG3;
    VkRect2D* pDiscardRectangles = new VkRect2D[discardRectangleCount];
    cpu->memory->memcpy(pDiscardRectangles, ARG4, discardRectangleCount * sizeof(VkRect2D));
    pBoxedInfo->pvkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    delete[] pDiscardRectangles;
}
void vk_CmdSetSampleLocationsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSampleLocationsInfoEXT local_pSampleLocationsInfo(cpu->memory, ARG2);
    VkSampleLocationsInfoEXT* pSampleLocationsInfo = &local_pSampleLocationsInfo.s;
    pBoxedInfo->pvkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
}
void vk_GetPhysicalDeviceMultisamplePropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG2;
    MarshalVkMultisamplePropertiesEXT pMultisampleProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, &pMultisampleProperties.s);
    MarshalVkMultisamplePropertiesEXT::write(cpu->memory, ARG3, &pMultisampleProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilities2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    MarshalVkSurfaceCapabilities2KHR pSurfaceCapabilities(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilities2KHR::write(cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormats2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormat2KHR* pSurfaceFormats = NULL;
    if (ARG4) {
        pSurfaceFormats = new VkSurfaceFormat2KHR[*pSurfaceFormatCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG3, (U32)tmp_pSurfaceFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormat2KHR::write(cpu->memory, ARG4 + i * 16, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
void vk_GetBufferMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetBufferMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageSparseMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetImageSparseMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = pBoxedInfo->pvkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = pBoxedInfo->pvkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
void vk_DestroySamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
void vk_DestroySamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroySamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
}
void vk_GetDeviceQueue2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceQueueInfo2 local_pQueueInfo(cpu->memory, ARG2);
    VkDeviceQueueInfo2* pQueueInfo = &local_pQueueInfo.s;
    VkQueue pQueue;
    pBoxedInfo->pvkGetDeviceQueue2(device, pQueueInfo, &pQueue);
    cpu->memory->writed(ARG3, createVulkanPtr(cpu->memory, (U64)pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_CreateValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkValidationCacheCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkValidationCacheCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkValidationCacheEXT tmp_pValidationCache = (VkValidationCacheEXT) cpu->memory->readq(ARG4);
    VkValidationCacheEXT* pValidationCache = &tmp_pValidationCache;
    EAX = pBoxedInfo->pvkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pValidationCache);
}
void vk_DestroyValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyValidationCacheEXT(device, validationCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetValidationCacheDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)ARG64(ARG2, ARG3);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG4);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = new char[*pDataSize];
    cpu->memory->memcpy(pData, ARG5, *pDataSize * sizeof(char));
    EAX = pBoxedInfo->pvkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
    cpu->memory->writed(ARG4, (U32)tmp_pDataSize);
    cpu->memory->memcpy(ARG5, pData, *pDataSize * sizeof(char));
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergeValidationCachesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT dstCache = (VkValidationCacheEXT)ARG64(ARG2, ARG3);
    uint32_t srcCacheCount = (uint32_t)ARG4;
    VkValidationCacheEXT* pSrcCaches = new VkValidationCacheEXT[srcCacheCount];
    cpu->memory->memcpy(pSrcCaches, ARG5, srcCacheCount * sizeof(VkValidationCacheEXT));
    EAX = pBoxedInfo->pvkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
void vk_GetDescriptorSetLayoutSupport(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupport(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(cpu->memory, ARG3, &pSupport.s);
}
void vk_GetDescriptorSetLayoutSupportKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(cpu->memory, ARG3, &pSupport.s);
}
// return type: VkResult(4 bytes)
void vk_GetShaderInfoAMD(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)ARG64(ARG2, ARG3);
    VkShaderStageFlagBits shaderStage = (VkShaderStageFlagBits)ARG4;
    VkShaderInfoTypeAMD infoType = (VkShaderInfoTypeAMD)ARG5;
    size_t tmp_pInfoSize = (size_t) cpu->memory->readd(ARG6);
    size_t* pInfoSize = &tmp_pInfoSize;
    void* pInfo = new char[*pInfoSize];
    cpu->memory->memcpy(pInfo, ARG7, *pInfoSize * sizeof(char));
    EAX = pBoxedInfo->pvkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    cpu->memory->writed(ARG6, (U32)tmp_pInfoSize);
    cpu->memory->memcpy(ARG7, pInfo, *pInfoSize * sizeof(char));
    delete[] pInfo;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCalibrateableTimeDomainsEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pTimeDomainCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pTimeDomainCount = &tmp_pTimeDomainCount;
    static_assert (sizeof(VkTimeDomainEXT) == 4, "unhandled enum size");
    VkTimeDomainEXT* pTimeDomains = new VkTimeDomainEXT[*pTimeDomainCount];
    cpu->memory->memcpy(pTimeDomains, ARG3, *pTimeDomainCount * sizeof(VkTimeDomainEXT));
    EAX = pBoxedInfo->pvkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
    cpu->memory->writed(ARG2, (U32)tmp_pTimeDomainCount);
}
// return type: VkResult(4 bytes)
void vk_GetCalibratedTimestampsEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t timestampCount = (uint32_t)ARG2;
    VkCalibratedTimestampInfoEXT* pTimestampInfos = NULL;
    if (ARG3) {
        pTimestampInfos = new VkCalibratedTimestampInfoEXT[timestampCount];
        for (U32 i=0;i<timestampCount;i++) {
            MarshalVkCalibratedTimestampInfoEXT::read(cpu->memory, ARG3 + i * 12, &pTimestampInfos[i]);
        }
    }
    uint64_t* pTimestamps = new uint64_t[timestampCount];
    cpu->memory->memcpy(pTimestamps, ARG4, timestampCount * sizeof(uint64_t));
    uint64_t tmp_pMaxDeviation = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pMaxDeviation = &tmp_pMaxDeviation;
    EAX = pBoxedInfo->pvkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (pTimestampInfos) {
        delete[] pTimestampInfos;
    }
    cpu->memory->memcpy(ARG4, pTimestamps, timestampCount * sizeof(uint64_t));
    delete[] pTimestamps;
    cpu->memory->writeq(ARG5, (U64)tmp_pMaxDeviation);
}
// return type: VkResult(4 bytes)
void vk_GetMemoryHostPointerPropertiesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkExternalMemoryHandleTypeFlagBits handleType = (VkExternalMemoryHandleTypeFlagBits)ARG2;
    void* pHostPointer;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    MarshalVkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties(cpu->memory, ARG4);
    EAX = pBoxedInfo->pvkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, &pMemoryHostPointerProperties.s);
    MarshalVkMemoryHostPointerPropertiesEXT::write(cpu->memory, ARG4, &pMemoryHostPointerProperties.s);
}
void vk_CmdWriteBufferMarkerAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG3, ARG4);
    VkDeviceSize dstOffset = (VkDeviceSize)ARG64(ARG5, ARG6);
    uint32_t marker = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2KHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_CmdBeginRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdBeginRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdNextSubpass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdNextSubpass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)ARG64(ARG2, ARG3);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG4);
    uint64_t* pValue = &tmp_pValue;
    EAX = pBoxedInfo->pvkGetSemaphoreCounterValue(device, semaphore, pValue);
    cpu->memory->writeq(ARG4, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValueKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)ARG64(ARG2, ARG3);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG4);
    uint64_t* pValue = &tmp_pValue;
    EAX = pBoxedInfo->pvkGetSemaphoreCounterValueKHR(device, semaphore, pValue);
    cpu->memory->writeq(ARG4, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphores(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)ARG64(ARG3, ARG4);
    EAX = pBoxedInfo->pvkWaitSemaphores(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphoresKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)ARG64(ARG3, ARG4);
    EAX = pBoxedInfo->pvkWaitSemaphoresKHR(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = pBoxedInfo->pvkSignalSemaphore(device, pSignalInfo);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphoreKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = pBoxedInfo->pvkSignalSemaphoreKHR(device, pSignalInfo);
}
void vk_CmdDrawIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdBindTransformFeedbackBuffersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = new VkBuffer[bindingCount];
    cpu->memory->memcpy(pBuffers, ARG4, bindingCount * sizeof(VkBuffer));
    VkDeviceSize* pOffsets = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pOffsets, ARG5, bindingCount * sizeof(VkDeviceSize));
    VkDeviceSize* pSizes = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pSizes, ARG6, bindingCount * sizeof(VkDeviceSize));
    pBoxedInfo->pvkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
}
void vk_CmdBeginTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = new VkBuffer[counterBufferCount];
    cpu->memory->memcpy(pCounterBuffers, ARG4, counterBufferCount * sizeof(VkBuffer));
    VkDeviceSize* pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
    cpu->memory->memcpy(pCounterBufferOffsets, ARG5, counterBufferCount * sizeof(VkDeviceSize));
    pBoxedInfo->pvkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdEndTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = new VkBuffer[counterBufferCount];
    cpu->memory->memcpy(pCounterBuffers, ARG4, counterBufferCount * sizeof(VkBuffer));
    VkDeviceSize* pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
    cpu->memory->memcpy(pCounterBufferOffsets, ARG5, counterBufferCount * sizeof(VkDeviceSize));
    pBoxedInfo->pvkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdBeginQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t query = (uint32_t)ARG4;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG5;
    uint32_t index = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
}
void vk_CmdEndQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG2, ARG3);
    uint32_t query = (uint32_t)ARG4;
    uint32_t index = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
}
void vk_CmdDrawIndirectByteCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t instanceCount = (uint32_t)ARG2;
    uint32_t firstInstance = (uint32_t)ARG3;
    VkBuffer counterBuffer = (VkBuffer)ARG64(ARG4, ARG5);
    VkDeviceSize counterBufferOffset = (VkDeviceSize)ARG64(ARG6, ARG7);
    uint32_t counterOffset = (uint32_t)ARG8;
    uint32_t vertexStride = (uint32_t)ARG9;
    pBoxedInfo->pvkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
void vk_CmdSetExclusiveScissorNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstExclusiveScissor = (uint32_t)ARG2;
    uint32_t exclusiveScissorCount = (uint32_t)ARG3;
    VkRect2D* pExclusiveScissors = new VkRect2D[exclusiveScissorCount];
    cpu->memory->memcpy(pExclusiveScissors, ARG4, exclusiveScissorCount * sizeof(VkRect2D));
    pBoxedInfo->pvkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
    delete[] pExclusiveScissors;
}
void vk_CmdBindShadingRateImageNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)ARG64(ARG2, ARG3);
    VkImageLayout imageLayout = (VkImageLayout)ARG4;
    pBoxedInfo->pvkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
}
void vk_CmdSetViewportShadingRatePaletteNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkShadingRatePaletteNV* pShadingRatePalettes = NULL;
    if (ARG4) {
        pShadingRatePalettes = new VkShadingRatePaletteNV[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkShadingRatePaletteNV::read(cpu->memory, ARG4 + i * 8, &pShadingRatePalettes[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
    if (pShadingRatePalettes) {
        delete[] pShadingRatePalettes;
    }
}
void vk_CmdSetCoarseSampleOrderNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCoarseSampleOrderTypeNV sampleOrderType = (VkCoarseSampleOrderTypeNV)ARG2;
    uint32_t customSampleOrderCount = (uint32_t)ARG3;
    VkCoarseSampleOrderCustomNV* pCustomSampleOrders = NULL;
    if (ARG4) {
        pCustomSampleOrders = new VkCoarseSampleOrderCustomNV[customSampleOrderCount];
        for (U32 i=0;i<customSampleOrderCount;i++) {
            MarshalVkCoarseSampleOrderCustomNV::read(cpu->memory, ARG4 + i * 16, &pCustomSampleOrders[i]);
        }
    }
    pBoxedInfo->pvkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
    if (pCustomSampleOrders) {
        delete[] pCustomSampleOrders;
    }
}
void vk_CmdDrawMeshTasksNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t taskCount = (uint32_t)ARG2;
    uint32_t firstTask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
}
void vk_CmdDrawMeshTasksIndirectNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    uint32_t drawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawMeshTasksIndirectCountNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize offset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer countBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize countBufferOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    uint32_t maxDrawCount = (uint32_t)ARG10;
    uint32_t stride = (uint32_t)ARG11;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
// return type: VkResult(4 bytes)
void vk_CompileDeferredNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)ARG64(ARG2, ARG3);
    uint32_t shader = (uint32_t)ARG4;
    EAX = pBoxedInfo->pvkCompileDeferredNV(device, pipeline, shader);
}
// return type: VkResult(4 bytes)
void vk_CreateAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureCreateInfoNV local_pCreateInfo(cpu->memory, ARG2);
    VkAccelerationStructureCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkAccelerationStructureNV tmp_pAccelerationStructure = (VkAccelerationStructureNV) cpu->memory->readq(ARG4);
    VkAccelerationStructureNV* pAccelerationStructure = &tmp_pAccelerationStructure;
    EAX = pBoxedInfo->pvkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
    cpu->memory->writeq(ARG4, (U64)tmp_pAccelerationStructure);
}
void vk_DestroyAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
}
void vk_GetAccelerationStructureMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureMemoryRequirementsInfoNV local_pInfo(cpu->memory, ARG2);
    VkAccelerationStructureMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_BindAccelerationStructureMemoryNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindAccelerationStructureMemoryInfoNV* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindAccelerationStructureMemoryInfoNV[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindAccelerationStructureMemoryInfoNV::read(cpu->memory, ARG3 + i * 40, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdCopyAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)ARG64(ARG2, ARG3);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)ARG64(ARG4, ARG5);
    VkCopyAccelerationStructureModeKHR mode = (VkCopyAccelerationStructureModeKHR)ARG6;
    pBoxedInfo->pvkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
}
void vk_CmdWriteAccelerationStructuresPropertiesNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t accelerationStructureCount = (uint32_t)ARG2;
    VkAccelerationStructureNV* pAccelerationStructures = new VkAccelerationStructureNV[accelerationStructureCount];
    cpu->memory->memcpy(pAccelerationStructures, ARG3, accelerationStructureCount * sizeof(VkAccelerationStructureNV));
    VkQueryType queryType = (VkQueryType)ARG4;
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG5, ARG6);
    uint32_t firstQuery = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    delete[] pAccelerationStructures;
}
void vk_CmdBuildAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureInfoNV local_pInfo(cpu->memory, ARG2);
    VkAccelerationStructureInfoNV* pInfo = &local_pInfo.s;
    VkBuffer instanceData = (VkBuffer)ARG64(ARG3, ARG4);
    VkDeviceSize instanceOffset = (VkDeviceSize)ARG64(ARG5, ARG6);
    VkBool32 update = (VkBool32)ARG7;
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)ARG64(ARG8, ARG9);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)ARG64(ARG10, ARG11);
    VkBuffer scratch = (VkBuffer)ARG64(ARG12, ARG13);
    VkDeviceSize scratchOffset = (VkDeviceSize)ARG64(ARG14, ARG15);
    pBoxedInfo->pvkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
void vk_CmdTraceRaysNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer raygenShaderBindingTableBuffer = (VkBuffer)ARG64(ARG2, ARG3);
    VkDeviceSize raygenShaderBindingOffset = (VkDeviceSize)ARG64(ARG4, ARG5);
    VkBuffer missShaderBindingTableBuffer = (VkBuffer)ARG64(ARG6, ARG7);
    VkDeviceSize missShaderBindingOffset = (VkDeviceSize)ARG64(ARG8, ARG9);
    VkDeviceSize missShaderBindingStride = (VkDeviceSize)ARG64(ARG10, ARG11);
    VkBuffer hitShaderBindingTableBuffer = (VkBuffer)ARG64(ARG12, ARG13);
    VkDeviceSize hitShaderBindingOffset = (VkDeviceSize)ARG64(ARG14, ARG15);
    VkDeviceSize hitShaderBindingStride = (VkDeviceSize)ARG64(ARG16, ARG17);
    VkBuffer callableShaderBindingTableBuffer = (VkBuffer)ARG64(ARG18, ARG19);
    VkDeviceSize callableShaderBindingOffset = (VkDeviceSize)ARG64(ARG20, ARG21);
    VkDeviceSize callableShaderBindingStride = (VkDeviceSize)ARG64(ARG22, ARG23);
    uint32_t width = (uint32_t)ARG24;
    uint32_t height = (uint32_t)ARG25;
    uint32_t depth = (uint32_t)ARG26;
    pBoxedInfo->pvkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
// return type: VkResult(4 bytes)
void vk_GetRayTracingShaderGroupHandlesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)ARG64(ARG2, ARG3);
    uint32_t firstGroup = (uint32_t)ARG4;
    uint32_t groupCount = (uint32_t)ARG5;
    size_t dataSize = (size_t)ARG6;
    void* pData = new char[dataSize];
    cpu->memory->memcpy(pData, ARG7, dataSize * sizeof(char));
    EAX = pBoxedInfo->pvkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
    cpu->memory->memcpy(ARG7, pData, dataSize * sizeof(char));
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_GetAccelerationStructureHandleNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)ARG64(ARG2, ARG3);
    size_t dataSize = (size_t)ARG4;
    void* pData = new char[dataSize];
    cpu->memory->memcpy(pData, ARG5, dataSize * sizeof(char));
    EAX = pBoxedInfo->pvkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
    cpu->memory->memcpy(ARG5, pData, dataSize * sizeof(char));
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_CreateRayTracingPipelinesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)ARG64(ARG2, ARG3);
    uint32_t createInfoCount = (uint32_t)ARG4;
    VkRayTracingPipelineCreateInfoNV* pCreateInfos = NULL;
    if (ARG5) {
        pCreateInfos = new VkRayTracingPipelineCreateInfoNV[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkRayTracingPipelineCreateInfoNV::read(cpu->memory, ARG5 + i * 52, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG6) { klog("vkCreateRayTracingPipelinesNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = new VkPipeline[createInfoCount];
    cpu->memory->memcpy(pPipelines, ARG7, createInfoCount * sizeof(VkPipeline));
    EAX = pBoxedInfo->pvkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    cpu->memory->memcpy(ARG7, pPipelines, createInfoCount * sizeof(VkPipeline));
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCooperativeMatrixPropertiesNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkCooperativeMatrixPropertiesNV* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkCooperativeMatrixPropertiesNV[*pPropertyCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkCooperativeMatrixPropertiesNV::write(cpu->memory, ARG3 + i * 40, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t tmp_pCounterCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pCounterCount = &tmp_pCounterCount;
    VkPerformanceCounterKHR* pCounters = NULL;
    if (ARG4) {
        pCounters = new VkPerformanceCounterKHR[*pCounterCount];
    }
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions = NULL;
    if (ARG5) {
        pCounterDescriptions = new VkPerformanceCounterDescriptionKHR[*pCounterCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    cpu->memory->writed(ARG3, (U32)tmp_pCounterCount);
    if (ARG4) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterKHR::write(cpu->memory, ARG4 + i * 36, &pCounters[i]);
        }
        delete[] pCounters;
    }
    if (ARG5) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterDescriptionKHR::write(cpu->memory, ARG5 + i * 780, &pCounterDescriptions[i]);
        }
        delete[] pCounterDescriptions;
    }
}
void vk_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolPerformanceCreateInfoKHR local_pPerformanceQueryCreateInfo(cpu->memory, ARG2);
    VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo = &local_pPerformanceQueryCreateInfo.s;
    uint32_t tmp_pNumPasses = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pNumPasses = &tmp_pNumPasses;
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
    cpu->memory->writed(ARG3, (U32)tmp_pNumPasses);
}
// return type: VkResult(4 bytes)
void vk_AcquireProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireProfilingLockInfoKHR local_pInfo(cpu->memory, ARG2);
    VkAcquireProfilingLockInfoKHR* pInfo = &local_pInfo.s;
    EAX = pBoxedInfo->pvkAcquireProfilingLockKHR(device, pInfo);
}
void vk_ReleaseProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkReleaseProfilingLockKHR(device);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressEXT(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_CreateHeadlessSurfaceEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkHeadlessSurfaceCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkHeadlessSurfaceCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateHeadlessSurfaceEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSurfaceKHR tmp_pSurface = (VkSurfaceKHR) cpu->memory->readq(ARG4);
    VkSurfaceKHR* pSurface = &tmp_pSurface;
    EAX = pBoxedInfo->pvkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
    cpu->memory->writeq(ARG4, (U64)tmp_pSurface);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCombinationCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCombinationCount = &tmp_pCombinationCount;
    VkFramebufferMixedSamplesCombinationNV* pCombinations = NULL;
    if (ARG3) {
        pCombinations = new VkFramebufferMixedSamplesCombinationNV[*pCombinationCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
    cpu->memory->writed(ARG2, (U32)tmp_pCombinationCount);
    if (ARG3) {
        for (U32 i=0;i<*pCombinationCount;i++) {
            MarshalVkFramebufferMixedSamplesCombinationNV::write(cpu->memory, ARG3 + i * 24, &pCombinations[i]);
        }
        delete[] pCombinations;
    }
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
void vk_CmdSetLineStippleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t lineStippleFactor = (uint32_t)ARG2;
    uint16_t lineStipplePattern = (uint16_t)ARG3;
    pBoxedInfo->pvkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceToolPropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pToolCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pToolCount = &tmp_pToolCount;
    VkPhysicalDeviceToolPropertiesEXT* pToolProperties = NULL;
    if (ARG3) {
        pToolProperties = new VkPhysicalDeviceToolPropertiesEXT[*pToolCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pToolCount);
    if (ARG3) {
        for (U32 i=0;i<*pToolCount;i++) {
            MarshalVkPhysicalDeviceToolPropertiesEXT::write(cpu->memory, ARG3 + i * 1036, &pToolProperties[i]);
        }
        delete[] pToolProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkCreateDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeferredOperationKHR tmp_pDeferredOperation = (VkDeferredOperationKHR) cpu->memory->readq(ARG3);
    VkDeferredOperationKHR* pDeferredOperation = &tmp_pDeferredOperation;
    EAX = pBoxedInfo->pvkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
    cpu->memory->writeq(ARG3, (U64)tmp_pDeferredOperation);
}
void vk_DestroyDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDeferredOperationKHR(device, operation, pAllocator);
}
// return type: uint32_t(4 bytes)
void vk_GetDeferredOperationMaxConcurrencyKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkGetDeferredOperationMaxConcurrencyKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_GetDeferredOperationResultKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkGetDeferredOperationResultKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_DeferredOperationJoinKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)ARG64(ARG2, ARG3);
    EAX = pBoxedInfo->pvkDeferredOperationJoinKHR(device, operation);
}
void vk_CmdSetCullModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCullModeFlags cullMode = (VkCullModeFlags)ARG2;
    pBoxedInfo->pvkCmdSetCullModeEXT(commandBuffer, cullMode);
}
void vk_CmdSetFrontFaceEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFrontFace frontFace = (VkFrontFace)ARG2;
    pBoxedInfo->pvkCmdSetFrontFaceEXT(commandBuffer, frontFace);
}
void vk_CmdSetPrimitiveTopologyEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrimitiveTopology primitiveTopology = (VkPrimitiveTopology)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
}
void vk_CmdSetViewportWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t viewportCount = (uint32_t)ARG2;
    VkViewport* pViewports = new VkViewport[viewportCount];
    cpu->memory->memcpy(pViewports, ARG3, viewportCount * sizeof(VkViewport));
    pBoxedInfo->pvkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
    delete[] pViewports;
}
void vk_CmdSetScissorWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t scissorCount = (uint32_t)ARG2;
    VkRect2D* pScissors = new VkRect2D[scissorCount];
    cpu->memory->memcpy(pScissors, ARG3, scissorCount * sizeof(VkRect2D));
    pBoxedInfo->pvkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
    delete[] pScissors;
}
void vk_CmdBindVertexBuffers2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = new VkBuffer[bindingCount];
    cpu->memory->memcpy(pBuffers, ARG4, bindingCount * sizeof(VkBuffer));
    VkDeviceSize* pOffsets = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pOffsets, ARG5, bindingCount * sizeof(VkDeviceSize));
    VkDeviceSize* pSizes = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pSizes, ARG6, bindingCount * sizeof(VkDeviceSize));
    VkDeviceSize* pStrides = new VkDeviceSize[bindingCount];
    cpu->memory->memcpy(pStrides, ARG7, bindingCount * sizeof(VkDeviceSize));
    pBoxedInfo->pvkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
    delete[] pStrides;
}
void vk_CmdSetDepthTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
}
void vk_CmdSetDepthWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthWriteEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
}
void vk_CmdSetDepthCompareOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCompareOp depthCompareOp = (VkCompareOp)ARG2;
    pBoxedInfo->pvkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
}
void vk_CmdSetDepthBoundsTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBoundsTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
}
void vk_CmdSetStencilTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 stencilTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
}
void vk_CmdSetStencilOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    VkStencilOp failOp = (VkStencilOp)ARG3;
    VkStencilOp passOp = (VkStencilOp)ARG4;
    VkStencilOp depthFailOp = (VkStencilOp)ARG5;
    VkCompareOp compareOp = (VkCompareOp)ARG6;
    pBoxedInfo->pvkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
void vk_CmdSetPatchControlPointsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t patchControlPoints = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
}
void vk_CmdSetRasterizerDiscardEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 rasterizerDiscardEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
}
void vk_CmdSetDepthBiasEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBiasEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
}
void vk_CmdSetLogicOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkLogicOp logicOp = (VkLogicOp)ARG2;
    pBoxedInfo->pvkCmdSetLogicOpEXT(commandBuffer, logicOp);
}
void vk_CmdSetPrimitiveRestartEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 primitiveRestartEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
}
// return type: VkResult(4 bytes)
void vk_CreatePrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPrivateDataSlotCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkPrivateDataSlotCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPrivateDataSlotEXT tmp_pPrivateDataSlot = (VkPrivateDataSlotEXT) cpu->memory->readq(ARG4);
    VkPrivateDataSlotEXT* pPrivateDataSlot = &tmp_pPrivateDataSlot;
    EAX = pBoxedInfo->pvkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    cpu->memory->writeq(ARG4, (U64)tmp_pPrivateDataSlot);
}
void vk_DestroyPrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)ARG64(ARG2, ARG3);
    static bool shown; if (!shown && ARG4) { klog("vkDestroyPrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_SetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)ARG64(ARG3, ARG4);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)ARG64(ARG5, ARG6);
    uint64_t data = (uint64_t)ARG64(ARG7, ARG8);
    EAX = pBoxedInfo->pvkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
}
void vk_GetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)ARG64(ARG3, ARG4);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)ARG64(ARG5, ARG6);
    uint64_t tmp_pData = (uint64_t) cpu->memory->readq(ARG7);
    uint64_t* pData = &tmp_pData;
    pBoxedInfo->pvkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
    cpu->memory->writeq(ARG7, (U64)tmp_pData);
}
void vk_CmdCopyBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferInfo2KHR local_pCopyBufferInfo(cpu->memory, ARG2);
    VkCopyBufferInfo2KHR* pCopyBufferInfo = &local_pCopyBufferInfo.s;
    pBoxedInfo->pvkCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
}
void vk_CmdCopyImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageInfo2KHR local_pCopyImageInfo(cpu->memory, ARG2);
    VkCopyImageInfo2KHR* pCopyImageInfo = &local_pCopyImageInfo.s;
    pBoxedInfo->pvkCmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
}
void vk_CmdBlitImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBlitImageInfo2KHR local_pBlitImageInfo(cpu->memory, ARG2);
    VkBlitImageInfo2KHR* pBlitImageInfo = &local_pBlitImageInfo.s;
    pBoxedInfo->pvkCmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
}
void vk_CmdCopyBufferToImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferToImageInfo2KHR local_pCopyBufferToImageInfo(cpu->memory, ARG2);
    VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo = &local_pCopyBufferToImageInfo.s;
    pBoxedInfo->pvkCmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
}
void vk_CmdCopyImageToBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToBufferInfo2KHR local_pCopyImageToBufferInfo(cpu->memory, ARG2);
    VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo = &local_pCopyImageToBufferInfo.s;
    pBoxedInfo->pvkCmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
}
void vk_CmdResolveImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkResolveImageInfo2KHR local_pResolveImageInfo(cpu->memory, ARG2);
    VkResolveImageInfo2KHR* pResolveImageInfo = &local_pResolveImageInfo.s;
    pBoxedInfo->pvkCmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
}
void vk_CmdSetFragmentShadingRateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkExtent2D tmp_pFragmentSize;
    cpu->memory->memcpy(&tmp_pFragmentSize, ARG2, 8);
    VkExtent2D* pFragmentSize = &tmp_pFragmentSize;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
    cpu->memory->memcpy(combinerOps, ARG3, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    pBoxedInfo->pvkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceFragmentShadingRatesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pFragmentShadingRateCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pFragmentShadingRateCount = &tmp_pFragmentShadingRateCount;
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates = NULL;
    if (ARG3) {
        pFragmentShadingRates = new VkPhysicalDeviceFragmentShadingRateKHR[*pFragmentShadingRateCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    cpu->memory->writed(ARG2, (U32)tmp_pFragmentShadingRateCount);
    if (ARG3) {
        for (U32 i=0;i<*pFragmentShadingRateCount;i++) {
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(cpu->memory, ARG3 + i * 20, &pFragmentShadingRates[i]);
        }
        delete[] pFragmentShadingRates;
    }
}
void vk_CmdSetFragmentShadingRateEnumNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFragmentShadingRateNV shadingRate = (VkFragmentShadingRateNV)ARG2;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
    cpu->memory->memcpy(combinerOps, ARG3, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    pBoxedInfo->pvkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
}
void vk_CmdSetVertexInputEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexBindingDescriptionCount = (uint32_t)ARG2;
    VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions = NULL;
    if (ARG3) {
        pVertexBindingDescriptions = new VkVertexInputBindingDescription2EXT[vertexBindingDescriptionCount];
        for (U32 i=0;i<vertexBindingDescriptionCount;i++) {
            MarshalVkVertexInputBindingDescription2EXT::read(cpu->memory, ARG3 + i * 24, &pVertexBindingDescriptions[i]);
        }
    }
    uint32_t vertexAttributeDescriptionCount = (uint32_t)ARG4;
    VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions = NULL;
    if (ARG5) {
        pVertexAttributeDescriptions = new VkVertexInputAttributeDescription2EXT[vertexAttributeDescriptionCount];
        for (U32 i=0;i<vertexAttributeDescriptionCount;i++) {
            MarshalVkVertexInputAttributeDescription2EXT::read(cpu->memory, ARG5 + i * 24, &pVertexAttributeDescriptions[i]);
        }
    }
    pBoxedInfo->pvkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
    if (pVertexBindingDescriptions) {
        delete[] pVertexBindingDescriptions;
    }
    if (pVertexAttributeDescriptions) {
        delete[] pVertexAttributeDescriptions;
    }
}
void vk_CmdSetColorWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkBool32* pColorWriteEnables = new VkBool32[attachmentCount];
    cpu->memory->memcpy(pColorWriteEnables, ARG3, attachmentCount * sizeof(VkBool32));
    pBoxedInfo->pvkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
    delete[] pColorWriteEnables;
}
void vk_CmdSetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    MarshalVkDependencyInfoKHR local_pDependencyInfo(cpu->memory, ARG4);
    VkDependencyInfoKHR* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
}
void vk_CmdResetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)ARG64(ARG2, ARG3);
    VkPipelineStageFlags2KHR stageMask = (VkPipelineStageFlags2KHR)ARG64(ARG4, ARG5);
    pBoxedInfo->pvkCmdResetEvent2KHR(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = new VkEvent[eventCount];
    cpu->memory->memcpy(pEvents, ARG3, eventCount * sizeof(VkEvent));
    VkDependencyInfoKHR* pDependencyInfos = NULL;
    if (ARG4) {
        pDependencyInfos = new VkDependencyInfoKHR[eventCount];
        for (U32 i=0;i<eventCount;i++) {
            MarshalVkDependencyInfoKHR::read(cpu->memory, ARG4 + i * 36, &pDependencyInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
    delete[] pEvents;
    if (pDependencyInfos) {
        delete[] pDependencyInfos;
    }
}
void vk_CmdPipelineBarrier2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDependencyInfoKHR local_pDependencyInfo(cpu->memory, ARG2);
    VkDependencyInfoKHR* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit2KHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo2KHR* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo2KHR[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo2KHR::read(cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)ARG64(ARG4, ARG5);
    EAX = pBoxedInfo->pvkQueueSubmit2KHR(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
void vk_CmdWriteTimestamp2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2KHR stage = (VkPipelineStageFlags2KHR)ARG64(ARG2, ARG3);
    VkQueryPool queryPool = (VkQueryPool)ARG64(ARG4, ARG5);
    uint32_t query = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
}
void vk_CmdWriteBufferMarker2AMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2KHR stage = (VkPipelineStageFlags2KHR)ARG64(ARG2, ARG3);
    VkBuffer dstBuffer = (VkBuffer)ARG64(ARG4, ARG5);
    VkDeviceSize dstOffset = (VkDeviceSize)ARG64(ARG6, ARG7);
    uint32_t marker = (uint32_t)ARG8;
    pBoxedInfo->pvkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
void vk_GetQueueCheckpointData2NV(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCheckpointDataCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCheckpointDataCount = &tmp_pCheckpointDataCount;
    VkCheckpointData2NV* pCheckpointData = NULL;
    if (ARG3) {
        pCheckpointData = new VkCheckpointData2NV[*pCheckpointDataCount];
    }
    pBoxedInfo->pvkGetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
    cpu->memory->writed(ARG2, (U32)tmp_pCheckpointDataCount);
    if (ARG3) {
        for (U32 i=0;i<*pCheckpointDataCount;i++) {
            MarshalVkCheckpointData2NV::write(cpu->memory, ARG3 + i * 20, &pCheckpointData[i]);
        }
        delete[] pCheckpointData;
    }
}
void* vulkanGetNextPtr(KMemory* memory, U32 address) {
    if (address == 0) {
        return NULL;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT* p = new VkPhysicalDeviceTransformFeedbackFeaturesEXT();
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* p = new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            VkPhysicalDeviceIDProperties* p = new VkPhysicalDeviceIDProperties();
            MarshalVkPhysicalDeviceIDProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            VkPhysicalDeviceHostQueryResetFeatures* p = new VkPhysicalDeviceHostQueryResetFeatures();
            MarshalVkPhysicalDeviceHostQueryResetFeatures::read(memory, address, p);
            return p;
        }
       default:
            kpanic("vulkanGetNextPtr not implemented for %d", type);
    }
}
void vulkanWriteNextPtr(KMemory* memory, U32 address, const void* p) {
    if (address == 0) {
        return;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::write(memory, address, (VkPhysicalDeviceTransformFeedbackFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::write(memory, address, (VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            MarshalVkPhysicalDeviceIDProperties::write(memory, address, (VkPhysicalDeviceIDProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            MarshalVkPhysicalDeviceHostQueryResetFeatures::write(memory, address, (VkPhysicalDeviceHostQueryResetFeatures*)p);
            break;
        }
       default:
            kpanic("vulkanWriteNextPtr not implemented for %d", type);
    }
}
#endif

