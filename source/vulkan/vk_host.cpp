// DON'T MODIFY, this is autogenerated
#include "boxedwine.h"
#ifdef BOXEDWINE_VULKAN
#include <SDL.h>
#include <SDL_vulkan.h>
#define VK_NO_PROTOTYPES
#include "vk/vulkan.h"
#include "vk/vulkan_core.h"
#define BOXED_VK_EXTERN
#include "vk_host.h"
#include "vk_host_marshal.h"

void initVulkan();
U32 createVulkanPtr(KMemory* memory, U64 value, BoxedVulkanInfo* info);
BoxedVulkanInfo* getInfoFromHandle(KMemory* memory, U32 address);
void freeVulkanPtr(KMemory* memory, U32 p);
void registerVkMemoryAllocation(VkDeviceMemory memory, VkDeviceSize size);
void unregisterVkMemoryAllocation(VkDeviceMemory memory);
U32 mapVkMemory(VkDeviceMemory memory, void* pData, VkDeviceSize len);
void unmapVkMemory(VkDeviceMemory memory);

#define ARG1 cpu->peek32(1)
#define ARG2 cpu->peek32(2)
#define ARG3 cpu->peek32(3)
#define ARG4 cpu->peek32(4)
#define ARG5 cpu->peek32(5)
#define ARG6 cpu->peek32(6)
#define ARG7 cpu->peek32(7)
#define ARG8 cpu->peek32(8)
#define ARG9 cpu->peek32(9)
#define ARG10 cpu->peek32(10)
#define ARG11 cpu->peek32(11)
#define ARG12 cpu->peek32(12)
#define ARG13 cpu->peek32(13)
#define ARG14 cpu->peek32(14)
#define ARG15 cpu->peek32(15)
#define ARG16 cpu->peek32(16)
#define ARG17 cpu->peek32(17)
#define ARG18 cpu->peek32(18)
#define ARG19 cpu->peek32(19)
#define ARG20 cpu->peek32(20)
#define ARG21 cpu->peek32(21)
#define ARG22 cpu->peek32(22)
#define ARG23 cpu->peek32(23)
#define ARG24 cpu->peek32(24)
#define ARG25 cpu->peek32(25)
#define ARG26 cpu->peek32(26)
// return type: VkResult(4 bytes)
void vk_CreateInstance(CPU* cpu) {
    initVulkan();
    MarshalVkInstanceCreateInfo local_pCreateInfo(cpu->memory, ARG1);
    VkInstanceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG2) { klog("vkCreateInstance:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkInstance pInstance;
    EAX = pvkCreateInstance(pCreateInfo, pAllocator, &pInstance);
    cpu->memory->writed(ARG3, createVulkanPtr(cpu->memory, (U64)pInstance, NULL));
}
void vk_DestroyInstance(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyInstance:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyInstance(instance, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDevices(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceCount = &tmp_pPhysicalDeviceCount;
    VkPhysicalDevice* pPhysicalDevices = NULL;
    if (ARG3) {
        pPhysicalDevices = new VkPhysicalDevice[*pPhysicalDeviceCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, (U64)pPhysicalDevices[i], pBoxedInfo));
        }
        delete[] pPhysicalDevices;
    }
}
void vk_GetPhysicalDeviceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties* pQueueFamilyProperties = nullptr;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties[*pQueueFamilyPropertyCount];
        cpu->memory->memcpy(pQueueFamilyProperties, ARG3, (U32)*pQueueFamilyPropertyCount * sizeof(VkQueueFamilyProperties));
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (pQueueFamilyProperties) {
        cpu->memory->memcpy(ARG3, pQueueFamilyProperties, (U32)*pQueueFamilyPropertyCount * sizeof(VkQueueFamilyProperties));
    }
    delete[] pQueueFamilyProperties;
}
void vk_GetPhysicalDeviceMemoryProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPhysicalDeviceMemoryProperties tmp_pMemoryProperties;
    cpu->memory->memcpy(&tmp_pMemoryProperties, ARG2, 456);
    VkPhysicalDeviceMemoryProperties* pMemoryProperties = &tmp_pMemoryProperties;
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
    cpu->memory->memcpy(ARG2, &tmp_pMemoryProperties, 456);
}
void vk_GetPhysicalDeviceFeatures(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPhysicalDeviceFeatures tmp_pFeatures;
    cpu->memory->memcpy(&tmp_pFeatures, ARG2, 220);
    VkPhysicalDeviceFeatures* pFeatures = &tmp_pFeatures;
    pBoxedInfo->pvkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
    cpu->memory->memcpy(ARG2, &tmp_pFeatures, 220);
}
void vk_GetPhysicalDeviceFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkFormatProperties tmp_pFormatProperties;
    cpu->memory->memcpy(&tmp_pFormatProperties, ARG3, 12);
    VkFormatProperties* pFormatProperties = &tmp_pFormatProperties;
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
    cpu->memory->memcpy(ARG3, &tmp_pFormatProperties, 12);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkImageTiling tiling = (VkImageTiling)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageCreateFlags flags = (VkImageCreateFlags)ARG6;
    VkImageFormatProperties tmp_pImageFormatProperties;
    cpu->memory->memcpy(&tmp_pImageFormatProperties, ARG7, 32);
    VkImageFormatProperties* pImageFormatProperties = &tmp_pImageFormatProperties;
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    cpu->memory->memcpy(ARG7, &tmp_pImageFormatProperties, 32);
}
// return type: VkResult(4 bytes)
void vk_CreateDevice(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDeviceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDevice pDevice;
    EAX = pBoxedInfo->pvkCreateDevice(physicalDevice, pCreateInfo, pAllocator, &pDevice);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, (U64)pDevice, pBoxedInfo));
}
void vk_DestroyDevice(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkDestroyDevice:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDevice(device, pAllocator);
    freeVulkanPtr(cpu->memory, ARG1);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceVersion(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pApiVersion = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pApiVersion = &tmp_pApiVersion;
    EAX = pvkEnumerateInstanceVersion(pApiVersion);
    cpu->memory->writed(ARG1, (U32)tmp_pApiVersion);
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceLayerProperties(CPU* cpu) {
    initVulkan();
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG1);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = nullptr;
    if (ARG2) {
        pProperties = new VkLayerProperties[*pPropertyCount];
        cpu->memory->memcpy(pProperties, ARG2, (U32)*pPropertyCount * sizeof(VkLayerProperties));
    }
    EAX = pvkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
    cpu->memory->writed(ARG1, (U32)tmp_pPropertyCount);
    if (pProperties) {
        cpu->memory->memcpy(ARG2, pProperties, (U32)*pPropertyCount * sizeof(VkLayerProperties));
    }
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateInstanceExtensionProperties(CPU* cpu) {
    initVulkan();
    U32 len = 0;
    char* pLayerName = nullptr;
    if (ARG1) {
        len = cpu->memory->strlen(ARG1);
        pLayerName = new char[len];
        cpu->memory->memcpy(pLayerName, ARG1, (U32)len * sizeof(char));
    }
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkExtensionProperties* pProperties = nullptr;
    if (ARG3) {
        pProperties = new VkExtensionProperties[*pPropertyCount];
        cpu->memory->memcpy(pProperties, ARG3, (U32)*pPropertyCount * sizeof(VkExtensionProperties));
    }
    EAX = pvkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
    delete[] pLayerName;
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (pProperties) {
        cpu->memory->memcpy(ARG3, pProperties, (U32)*pPropertyCount * sizeof(VkExtensionProperties));
    }
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceLayerProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkLayerProperties* pProperties = nullptr;
    if (ARG3) {
        pProperties = new VkLayerProperties[*pPropertyCount];
        cpu->memory->memcpy(pProperties, ARG3, (U32)*pPropertyCount * sizeof(VkLayerProperties));
    }
    EAX = pBoxedInfo->pvkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (pProperties) {
        cpu->memory->memcpy(ARG3, pProperties, (U32)*pPropertyCount * sizeof(VkLayerProperties));
    }
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_EnumerateDeviceExtensionProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    U32 len = 0;
    char* pLayerName = nullptr;
    if (ARG2) {
        len = cpu->memory->strlen(ARG2);
        pLayerName = new char[len];
        cpu->memory->memcpy(pLayerName, ARG2, (U32)len * sizeof(char));
    }
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkExtensionProperties* pProperties = nullptr;
    if (ARG4) {
        pProperties = new VkExtensionProperties[*pPropertyCount];
        cpu->memory->memcpy(pProperties, ARG4, (U32)*pPropertyCount * sizeof(VkExtensionProperties));
    }
    EAX = pBoxedInfo->pvkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
    delete[] pLayerName;
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (pProperties) {
        cpu->memory->memcpy(ARG4, pProperties, (U32)*pPropertyCount * sizeof(VkExtensionProperties));
    }
    delete[] pProperties;
}
void vk_GetDeviceQueue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t queueIndex = (uint32_t)ARG3;
    VkQueue pQueue;
    pBoxedInfo->pvkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &pQueue);
    cpu->memory->writed(ARG4, createVulkanPtr(cpu->memory, (U64)pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo::read(cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = pBoxedInfo->pvkQueueSubmit(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
// return type: VkResult(4 bytes)
void vk_QueueWaitIdle(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkQueueWaitIdle(queue);
}
// return type: VkResult(4 bytes)
void vk_DeviceWaitIdle(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkDeviceWaitIdle(device);
}
// return type: VkResult(4 bytes)
void vk_AllocateMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkMemoryAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkMemoryAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkAllocateMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeviceMemory tmp_pMemory = (VkDeviceMemory) cpu->memory->readq(ARG4);
    VkDeviceMemory* pMemory = &tmp_pMemory;
    EAX = pBoxedInfo->pvkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
    if (EAX == 0 && pMemory) {
        registerVkMemoryAllocation(*pMemory, pAllocateInfo->allocationSize);
    }
    cpu->memory->writeq(ARG4, (U64)tmp_pMemory);
}
void vk_FreeMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkFreeMemory:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkFreeMemory(device, memory, pAllocator);
    unregisterVkMemoryAllocation(memory);
}
// return type: VkResult(4 bytes)
void vk_MapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkMemoryMapFlags flags = (VkMemoryMapFlags)ARG5;
    void *pData = NULL;
    EAX = pBoxedInfo->pvkMapMemory(device, memory, offset, size, flags, &pData);
    if (EAX == 0) {
        cpu->memory->writed(ARG6, mapVkMemory(memory, pData, size));
    }
}
void vk_UnmapMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    pBoxedInfo->pvkUnmapMemory(device, memory);
    unmapVkMemory(memory);
}
// return type: VkResult(4 bytes)
void vk_FlushMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = pBoxedInfo->pvkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
// return type: VkResult(4 bytes)
void vk_InvalidateMappedMemoryRanges(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t memoryRangeCount = (uint32_t)ARG2;
    VkMappedMemoryRange* pMemoryRanges = NULL;
    if (ARG3) {
        pMemoryRanges = new VkMappedMemoryRange[memoryRangeCount];
        for (U32 i=0;i<memoryRangeCount;i++) {
            MarshalVkMappedMemoryRange::read(cpu->memory, ARG3 + i * 32, &pMemoryRanges[i]);
        }
    }
    EAX = pBoxedInfo->pvkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (pMemoryRanges) {
        delete[] pMemoryRanges;
    }
}
void vk_GetDeviceMemoryCommitment(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG2);
    VkDeviceSize tmp_pCommittedMemoryInBytes = (VkDeviceSize) cpu->memory->readq(ARG3);
    VkDeviceSize* pCommittedMemoryInBytes = &tmp_pCommittedMemoryInBytes;
    pBoxedInfo->pvkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    cpu->memory->writeq(ARG3, (U64)tmp_pCommittedMemoryInBytes);
}
void vk_GetBufferMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkMemoryRequirements tmp_pMemoryRequirements;
    cpu->memory->memcpy(&tmp_pMemoryRequirements, ARG3, 20);
    VkMemoryRequirements* pMemoryRequirements = &tmp_pMemoryRequirements;
    pBoxedInfo->pvkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
    cpu->memory->memcpy(ARG3, &tmp_pMemoryRequirements, 20);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG3);
    VkDeviceSize memoryOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    EAX = pBoxedInfo->pvkBindBufferMemory(device, buffer, memory, memoryOffset);
}
void vk_GetImageMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkMemoryRequirements tmp_pMemoryRequirements;
    cpu->memory->memcpy(&tmp_pMemoryRequirements, ARG3, 20);
    VkMemoryRequirements* pMemoryRequirements = &tmp_pMemoryRequirements;
    pBoxedInfo->pvkGetImageMemoryRequirements(device, image, pMemoryRequirements);
    cpu->memory->memcpy(ARG3, &tmp_pMemoryRequirements, 20);
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkDeviceMemory memory = (VkDeviceMemory)cpu->memory->readq(ARG3);
    VkDeviceSize memoryOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    EAX = pBoxedInfo->pvkBindImageMemory(device, image, memory, memoryOffset);
}
void vk_GetImageSparseMemoryRequirements(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements = nullptr;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements[*pSparseMemoryRequirementCount];
        cpu->memory->memcpy(pSparseMemoryRequirements, ARG4, (U32)*pSparseMemoryRequirementCount * sizeof(VkSparseImageMemoryRequirements));
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (pSparseMemoryRequirements) {
        cpu->memory->memcpy(ARG4, pSparseMemoryRequirements, (U32)*pSparseMemoryRequirementCount * sizeof(VkSparseImageMemoryRequirements));
    }
    delete[] pSparseMemoryRequirements;
}
void vk_GetPhysicalDeviceSparseImageFormatProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    VkImageType type = (VkImageType)ARG3;
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG4;
    VkImageUsageFlags usage = (VkImageUsageFlags)ARG5;
    VkImageTiling tiling = (VkImageTiling)ARG6;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG7);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties* pProperties = nullptr;
    if (ARG8) {
        pProperties = new VkSparseImageFormatProperties[*pPropertyCount];
        cpu->memory->memcpy(pProperties, ARG8, (U32)*pPropertyCount * sizeof(VkSparseImageFormatProperties));
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    cpu->memory->writed(ARG7, (U32)tmp_pPropertyCount);
    if (pProperties) {
        cpu->memory->memcpy(ARG8, pProperties, (U32)*pPropertyCount * sizeof(VkSparseImageFormatProperties));
    }
    delete[] pProperties;
}
// return type: VkResult(4 bytes)
void vk_QueueBindSparse(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindSparseInfo* pBindInfo = NULL;
    if (ARG3) {
        pBindInfo = new VkBindSparseInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindSparseInfo::read(cpu->memory, ARG3 + i * 48, &pBindInfo[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = pBoxedInfo->pvkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
    if (pBindInfo) {
        delete[] pBindInfo;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFenceCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkFenceCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFence tmp_pFence = (VkFence) cpu->memory->readq(ARG4);
    VkFence* pFence = &tmp_pFence;
    EAX = pBoxedInfo->pvkCreateFence(device, pCreateInfo, pAllocator, pFence);
    cpu->memory->writeq(ARG4, (U64)tmp_pFence);
}
void vk_DestroyFence(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyFence:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFence(device, fence, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = nullptr;
    if (ARG3) {
        pFences = new VkFence[fenceCount];
        cpu->memory->memcpy(pFences, ARG3, (U32)fenceCount * sizeof(VkFence));
    }
    EAX = pBoxedInfo->pvkResetFences(device, fenceCount, pFences);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_GetFenceStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFence fence = (VkFence)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkGetFenceStatus(device, fence);
}
// return type: VkResult(4 bytes)
void vk_WaitForFences(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t fenceCount = (uint32_t)ARG2;
    VkFence* pFences = nullptr;
    if (ARG3) {
        pFences = new VkFence[fenceCount];
        cpu->memory->memcpy(pFences, ARG3, (U32)fenceCount * sizeof(VkFence));
    }
    VkBool32 waitAll = (VkBool32)ARG4;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG5);
    EAX = pBoxedInfo->pvkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
    delete[] pFences;
}
// return type: VkResult(4 bytes)
void vk_CreateSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSemaphoreCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSemaphore tmp_pSemaphore = (VkSemaphore) cpu->memory->readq(ARG4);
    VkSemaphore* pSemaphore = &tmp_pSemaphore;
    EAX = pBoxedInfo->pvkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
    cpu->memory->writeq(ARG4, (U64)tmp_pSemaphore);
}
void vk_DestroySemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySemaphore:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySemaphore(device, semaphore, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkEventCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkEventCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkEvent tmp_pEvent = (VkEvent) cpu->memory->readq(ARG4);
    VkEvent* pEvent = &tmp_pEvent;
    EAX = pBoxedInfo->pvkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
    cpu->memory->writeq(ARG4, (U64)tmp_pEvent);
}
void vk_DestroyEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyEvent:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyEvent(device, event, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetEventStatus(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkGetEventStatus(device, event);
}
// return type: VkResult(4 bytes)
void vk_SetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkSetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_ResetEvent(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkResetEvent(device, event);
}
// return type: VkResult(4 bytes)
void vk_CreateQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkQueryPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkQueryPool tmp_pQueryPool = (VkQueryPool) cpu->memory->readq(ARG4);
    VkQueryPool* pQueryPool = &tmp_pQueryPool;
    EAX = pBoxedInfo->pvkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pQueryPool);
}
void vk_DestroyQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyQueryPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyQueryPool(device, queryPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetQueryPoolResults(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    VkDeviceSize stride = (VkDeviceSize)cpu->memory->readq(ARG7);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG8;
    EAX = pBoxedInfo->pvkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
void vk_ResetQueryPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
void vk_ResetQueryPoolEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
}
// return type: VkResult(4 bytes)
void vk_CreateBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkBufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBuffer tmp_pBuffer = (VkBuffer) cpu->memory->readq(ARG4);
    VkBuffer* pBuffer = &tmp_pBuffer;
    EAX = pBoxedInfo->pvkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pBuffer);
}
void vk_DestroyBuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyBuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBuffer(device, buffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferViewCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkBufferViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkBufferView tmp_pView = (VkBufferView) cpu->memory->readq(ARG4);
    VkBufferView* pView = &tmp_pView;
    EAX = pBoxedInfo->pvkCreateBufferView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyBufferView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBufferView bufferView = (VkBufferView)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyBufferView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyBufferView(device, bufferView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkImageCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImage tmp_pImage = (VkImage) cpu->memory->readq(ARG4);
    VkImage* pImage = &tmp_pImage;
    EAX = pBoxedInfo->pvkCreateImage(device, pCreateInfo, pAllocator, pImage);
    cpu->memory->writeq(ARG4, (U64)tmp_pImage);
}
void vk_DestroyImage(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyImage:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImage(device, image, pAllocator);
}
void vk_GetImageSubresourceLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkImageSubresource tmp_pSubresource;
    cpu->memory->memcpy(&tmp_pSubresource, ARG3, 12);
    VkImageSubresource* pSubresource = &tmp_pSubresource;
    VkSubresourceLayout tmp_pLayout;
    cpu->memory->memcpy(&tmp_pLayout, ARG4, 40);
    VkSubresourceLayout* pLayout = &tmp_pLayout;
    pBoxedInfo->pvkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
    cpu->memory->memcpy(ARG4, &tmp_pLayout, 40);
}
// return type: VkResult(4 bytes)
void vk_CreateImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageViewCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkImageViewCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkImageView tmp_pView = (VkImageView) cpu->memory->readq(ARG4);
    VkImageView* pView = &tmp_pView;
    EAX = pBoxedInfo->pvkCreateImageView(device, pCreateInfo, pAllocator, pView);
    cpu->memory->writeq(ARG4, (U64)tmp_pView);
}
void vk_DestroyImageView(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyImageView:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyImageView(device, imageView, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkShaderModuleCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkShaderModuleCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkShaderModule tmp_pShaderModule = (VkShaderModule) cpu->memory->readq(ARG4);
    VkShaderModule* pShaderModule = &tmp_pShaderModule;
    EAX = pBoxedInfo->pvkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
    cpu->memory->writeq(ARG4, (U64)tmp_pShaderModule);
}
void vk_DestroyShaderModule(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkShaderModule shaderModule = (VkShaderModule)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyShaderModule:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyShaderModule(device, shaderModule, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineCacheCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkPipelineCacheCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineCache tmp_pPipelineCache = (VkPipelineCache) cpu->memory->readq(ARG4);
    VkPipelineCache* pPipelineCache = &tmp_pPipelineCache;
    EAX = pBoxedInfo->pvkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineCache);
}
void vk_DestroyPipelineCache(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipelineCache:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineCache(device, pipelineCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPipelineCacheData(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)*pDataSize * sizeof(char));
    }
    EAX = pBoxedInfo->pvkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
    cpu->memory->writed(ARG3, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergePipelineCaches(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache dstCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t srcCacheCount = (uint32_t)ARG3;
    VkPipelineCache* pSrcCaches = nullptr;
    if (ARG4) {
        pSrcCaches = new VkPipelineCache[srcCacheCount];
        cpu->memory->memcpy(pSrcCaches, ARG4, (U32)srcCacheCount * sizeof(VkPipelineCache));
    }
    EAX = pBoxedInfo->pvkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
// return type: VkResult(4 bytes)
void vk_CreateGraphicsPipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkGraphicsPipelineCreateInfo* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkGraphicsPipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkGraphicsPipelineCreateInfo::read(cpu->memory, ARG4 + i * 88, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateGraphicsPipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = pBoxedInfo->pvkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_CreateComputePipelines(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkComputePipelineCreateInfo* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkComputePipelineCreateInfo[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkComputePipelineCreateInfo::read(cpu->memory, ARG4 + i * 64, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateComputePipelines:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = pBoxedInfo->pvkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetSubpassShadingMaxWorkgroupSizeHUAWEI(CPU* cpu) {
    initVulkan();
    VkRenderPass renderpass = (VkRenderPass)cpu->memory->readq(ARG1);
    VkExtent2D tmp_pMaxWorkgroupSize;
    cpu->memory->memcpy(&tmp_pMaxWorkgroupSize, ARG2, 8);
    VkExtent2D* pMaxWorkgroupSize = &tmp_pMaxWorkgroupSize;
    EAX = pvkGetSubpassShadingMaxWorkgroupSizeHUAWEI(renderpass, pMaxWorkgroupSize);
    cpu->memory->memcpy(ARG2, &tmp_pMaxWorkgroupSize, 8);
}
void vk_DestroyPipeline(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipeline:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipeline(device, pipeline, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreatePipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPipelineLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkPipelineLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipelineLayout tmp_pPipelineLayout = (VkPipelineLayout) cpu->memory->readq(ARG4);
    VkPipelineLayout* pPipelineLayout = &tmp_pPipelineLayout;
    EAX = pBoxedInfo->pvkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pPipelineLayout);
}
void vk_DestroyPipelineLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout pipelineLayout = (VkPipelineLayout)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPipelineLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateSampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSampler tmp_pSampler = (VkSampler) cpu->memory->readq(ARG4);
    VkSampler* pSampler = &tmp_pSampler;
    EAX = pBoxedInfo->pvkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
    cpu->memory->writeq(ARG4, (U64)tmp_pSampler);
}
void vk_DestroySampler(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampler sampler = (VkSampler)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySampler:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySampler(device, sampler, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorSetLayout tmp_pSetLayout = (VkDescriptorSetLayout) cpu->memory->readq(ARG4);
    VkDescriptorSetLayout* pSetLayout = &tmp_pSetLayout;
    EAX = pBoxedInfo->pvkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pSetLayout);
}
void vk_DestroyDescriptorSetLayout(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSetLayout descriptorSetLayout = (VkDescriptorSetLayout)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorSetLayout:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorPool tmp_pDescriptorPool = (VkDescriptorPool) cpu->memory->readq(ARG4);
    VkDescriptorPool* pDescriptorPool = &tmp_pDescriptorPool;
    EAX = pBoxedInfo->pvkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorPool);
}
void vk_DestroyDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorPool(device, descriptorPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetDescriptorPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    VkDescriptorPoolResetFlags flags = (VkDescriptorPoolResetFlags)ARG3;
    EAX = pBoxedInfo->pvkResetDescriptorPool(device, descriptorPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkDescriptorSetAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG3) {
        pDescriptorSets = new VkDescriptorSet[pAllocateInfo->descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG3, (U32)pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    }
    EAX = pBoxedInfo->pvkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
    if (pDescriptorSets) {
        cpu->memory->memcpy(ARG3, pDescriptorSets, (U32)pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    }
    delete[] pDescriptorSets;
}
// return type: VkResult(4 bytes)
void vk_FreeDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorPool descriptorPool = (VkDescriptorPool)cpu->memory->readq(ARG2);
    uint32_t descriptorSetCount = (uint32_t)ARG3;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG4) {
        pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG4, (U32)descriptorSetCount * sizeof(VkDescriptorSet));
    }
    EAX = pBoxedInfo->pvkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    delete[] pDescriptorSets;
}
void vk_UpdateDescriptorSets(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t descriptorWriteCount = (uint32_t)ARG2;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG3) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(cpu->memory, ARG3 + i * 44, &pDescriptorWrites[i]);
        }
    }
    uint32_t descriptorCopyCount = (uint32_t)ARG4;
    VkCopyDescriptorSet* pDescriptorCopies = NULL;
    if (ARG5) {
        pDescriptorCopies = new VkCopyDescriptorSet[descriptorCopyCount];
        for (U32 i=0;i<descriptorCopyCount;i++) {
            MarshalVkCopyDescriptorSet::read(cpu->memory, ARG5 + i * 44, &pDescriptorCopies[i]);
        }
    }
    pBoxedInfo->pvkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
    if (pDescriptorCopies) {
        delete[] pDescriptorCopies;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkFramebufferCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkFramebufferCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkFramebuffer tmp_pFramebuffer = (VkFramebuffer) cpu->memory->readq(ARG4);
    VkFramebuffer* pFramebuffer = &tmp_pFramebuffer;
    EAX = pBoxedInfo->pvkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
    cpu->memory->writeq(ARG4, (U64)tmp_pFramebuffer);
}
void vk_DestroyFramebuffer(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFramebuffer framebuffer = (VkFramebuffer)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyFramebuffer:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyFramebuffer(device, framebuffer, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_DestroyRenderPass(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyRenderPass:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyRenderPass(device, renderPass, pAllocator);
}
void vk_GetRenderAreaGranularity(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkRenderPass renderPass = (VkRenderPass)cpu->memory->readq(ARG2);
    VkExtent2D tmp_pGranularity;
    cpu->memory->memcpy(&tmp_pGranularity, ARG3, 8);
    VkExtent2D* pGranularity = &tmp_pGranularity;
    pBoxedInfo->pvkGetRenderAreaGranularity(device, renderPass, pGranularity);
    cpu->memory->memcpy(ARG3, &tmp_pGranularity, 8);
}
// return type: VkResult(4 bytes)
void vk_CreateCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandPoolCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkCommandPoolCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkCommandPool tmp_pCommandPool = (VkCommandPool) cpu->memory->readq(ARG4);
    VkCommandPool* pCommandPool = &tmp_pCommandPool;
    EAX = pBoxedInfo->pvkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
    cpu->memory->writeq(ARG4, (U64)tmp_pCommandPool);
}
void vk_DestroyCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyCommandPool:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyCommandPool(device, commandPool, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolResetFlags flags = (VkCommandPoolResetFlags)ARG3;
    EAX = pBoxedInfo->pvkResetCommandPool(device, commandPool, flags);
}
// return type: VkResult(4 bytes)
void vk_AllocateCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferAllocateInfo local_pAllocateInfo(cpu->memory, ARG2);
    VkCommandBufferAllocateInfo* pAllocateInfo = &local_pAllocateInfo.s;
    VkCommandBuffer* pCommandBuffers = NULL;
    if (ARG3) {
        pCommandBuffers = new VkCommandBuffer[pAllocateInfo->commandBufferCount];
    }
    EAX = pBoxedInfo->pvkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
    if (ARG3) {
        for (U32 i=0;i<pAllocateInfo->commandBufferCount;i++) {
            cpu->memory->writed(ARG3 + i*4, createVulkanPtr(cpu->memory, (U64)pCommandBuffers[i], pBoxedInfo));
        }
        delete[] pCommandBuffers;
    }
}
void vk_FreeCommandBuffers(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    uint32_t commandBufferCount = (uint32_t)ARG3;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG4 + i*4));
    }
    pBoxedInfo->pvkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
// return type: VkResult(4 bytes)
void vk_BeginCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCommandBufferBeginInfo local_pBeginInfo(cpu->memory, ARG2);
    VkCommandBufferBeginInfo* pBeginInfo = &local_pBeginInfo.s;
    EAX = pBoxedInfo->pvkBeginCommandBuffer(commandBuffer, pBeginInfo);
}
// return type: VkResult(4 bytes)
void vk_EndCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    EAX = pBoxedInfo->pvkEndCommandBuffer(commandBuffer);
}
// return type: VkResult(4 bytes)
void vk_ResetCommandBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandBufferResetFlags flags = (VkCommandBufferResetFlags)ARG2;
    EAX = pBoxedInfo->pvkResetCommandBuffer(commandBuffer, flags);
}
void vk_CmdBindPipeline(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
}
void vk_CmdSetViewport(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewport* pViewports = nullptr;
    if (ARG4) {
        pViewports = new VkViewport[viewportCount];
        cpu->memory->memcpy(pViewports, ARG4, (U32)viewportCount * sizeof(VkViewport));
    }
    pBoxedInfo->pvkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    delete[] pViewports;
}
void vk_CmdSetScissor(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstScissor = (uint32_t)ARG2;
    uint32_t scissorCount = (uint32_t)ARG3;
    VkRect2D* pScissors = nullptr;
    if (ARG4) {
        pScissors = new VkRect2D[scissorCount];
        cpu->memory->memcpy(pScissors, ARG4, (U32)scissorCount * sizeof(VkRect2D));
    }
    pBoxedInfo->pvkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    delete[] pScissors;
}
void vk_CmdSetLineWidth(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float lineWidth = (float)ARG2;
    pBoxedInfo->pvkCmdSetLineWidth(commandBuffer, lineWidth);
}
void vk_CmdSetDepthBias(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float depthBiasConstantFactor = (float)ARG2;
    float depthBiasClamp = (float)ARG3;
    float depthBiasSlopeFactor = (float)ARG4;
    pBoxedInfo->pvkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
void vk_CmdSetBlendConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float* blendConstants = nullptr;
    if (ARG2) {
        blendConstants = new float[4];
        cpu->memory->memcpy(blendConstants, ARG2, (U32)4 * sizeof(float));
    }
    pBoxedInfo->pvkCmdSetBlendConstants(commandBuffer, blendConstants);
    delete[] blendConstants;
}
void vk_CmdSetDepthBounds(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    float minDepthBounds = (float)ARG2;
    float maxDepthBounds = (float)ARG3;
    pBoxedInfo->pvkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
}
void vk_CmdSetStencilCompareMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t compareMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
}
void vk_CmdSetStencilWriteMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t writeMask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
}
void vk_CmdSetStencilReference(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    uint32_t reference = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdSetStencilReference(commandBuffer, faceMask, reference);
}
void vk_CmdBindDescriptorSets(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t firstSet = (uint32_t)ARG4;
    uint32_t descriptorSetCount = (uint32_t)ARG5;
    VkDescriptorSet* pDescriptorSets = nullptr;
    if (ARG6) {
        pDescriptorSets = new VkDescriptorSet[descriptorSetCount];
        cpu->memory->memcpy(pDescriptorSets, ARG6, (U32)descriptorSetCount * sizeof(VkDescriptorSet));
    }
    uint32_t dynamicOffsetCount = (uint32_t)ARG7;
    uint32_t* pDynamicOffsets = nullptr;
    if (ARG8) {
        pDynamicOffsets = new uint32_t[dynamicOffsetCount];
        cpu->memory->memcpy(pDynamicOffsets, ARG8, (U32)dynamicOffsetCount * sizeof(uint32_t));
    }
    pBoxedInfo->pvkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    delete[] pDescriptorSets;
    delete[] pDynamicOffsets;
}
void vk_CmdBindIndexBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkIndexType indexType = (VkIndexType)ARG4;
    pBoxedInfo->pvkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
}
void vk_CmdBindVertexBuffers(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    delete[] pBuffers;
    delete[] pOffsets;
}
void vk_CmdDraw(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstVertex = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
void vk_CmdDrawIndexed(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t indexCount = (uint32_t)ARG2;
    uint32_t instanceCount = (uint32_t)ARG3;
    uint32_t firstIndex = (uint32_t)ARG4;
    int32_t vertexOffset = (int32_t)ARG5;
    uint32_t firstInstance = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
void vk_CmdDrawMultiEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawInfoEXT* pVertexInfo = nullptr;
    if (ARG3) {
        pVertexInfo = new VkMultiDrawInfoEXT[drawCount];
        cpu->memory->memcpy(pVertexInfo, ARG3, (U32)drawCount * sizeof(VkMultiDrawInfoEXT));
    }
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    uint32_t stride = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
    delete[] pVertexInfo;
}
void vk_CmdDrawMultiIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t drawCount = (uint32_t)ARG2;
    VkMultiDrawIndexedInfoEXT* pIndexInfo = nullptr;
    if (ARG3) {
        pIndexInfo = new VkMultiDrawIndexedInfoEXT[drawCount];
        cpu->memory->memcpy(pIndexInfo, ARG3, (U32)drawCount * sizeof(VkMultiDrawIndexedInfoEXT));
    }
    uint32_t instanceCount = (uint32_t)ARG4;
    uint32_t firstInstance = (uint32_t)ARG5;
    uint32_t stride = (uint32_t)ARG6;
    int32_t tmp_pVertexOffset = (int32_t) cpu->memory->readd(ARG7);
    int32_t* pVertexOffset = &tmp_pVertexOffset;
    pBoxedInfo->pvkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
    delete[] pIndexInfo;
}
void vk_CmdDrawIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawIndexedIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDispatch(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t groupCountX = (uint32_t)ARG2;
    uint32_t groupCountY = (uint32_t)ARG3;
    uint32_t groupCountZ = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchIndirect(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdDispatchIndirect(commandBuffer, buffer, offset);
}
void vk_CmdSubpassShadingHUAWEI(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdSubpassShadingHUAWEI(commandBuffer);
}
void vk_CmdCopyBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    uint32_t regionCount = (uint32_t)ARG4;
    VkBufferCopy* pRegions = nullptr;
    if (ARG5) {
        pRegions = new VkBufferCopy[regionCount];
        cpu->memory->memcpy(pRegions, ARG5, (U32)regionCount * sizeof(VkBufferCopy));
    }
    pBoxedInfo->pvkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdCopyImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageCopy* pRegions = nullptr;
    if (ARG7) {
        pRegions = new VkImageCopy[regionCount];
        cpu->memory->memcpy(pRegions, ARG7, (U32)regionCount * sizeof(VkImageCopy));
    }
    pBoxedInfo->pvkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdBlitImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageBlit* pRegions = nullptr;
    if (ARG7) {
        pRegions = new VkImageBlit[regionCount];
        cpu->memory->memcpy(pRegions, ARG7, (U32)regionCount * sizeof(VkImageBlit));
    }
    VkFilter filter = (VkFilter)ARG8;
    pBoxedInfo->pvkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    delete[] pRegions;
}
void vk_CmdCopyBufferToImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer srcBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG3);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG4;
    uint32_t regionCount = (uint32_t)ARG5;
    VkBufferImageCopy* pRegions = nullptr;
    if (ARG6) {
        pRegions = new VkBufferImageCopy[regionCount];
        cpu->memory->memcpy(pRegions, ARG6, (U32)regionCount * sizeof(VkBufferImageCopy));
    }
    pBoxedInfo->pvkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdCopyImageToBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    uint32_t regionCount = (uint32_t)ARG5;
    VkBufferImageCopy* pRegions = nullptr;
    if (ARG6) {
        pRegions = new VkBufferImageCopy[regionCount];
        cpu->memory->memcpy(pRegions, ARG6, (U32)regionCount * sizeof(VkBufferImageCopy));
    }
    pBoxedInfo->pvkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdUpdateBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize dataSize = (VkDeviceSize)cpu->memory->readq(ARG4);
    void* pData = nullptr;
    if (ARG5) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG5, (U32)dataSize * sizeof(char));
    }
    pBoxedInfo->pvkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    delete[] pData;
}
void vk_CmdFillBuffer(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkDeviceSize size = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t data = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
}
void vk_CmdClearColorImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    VkClearColorValue tmp_pColor;
    cpu->memory->memcpy(&tmp_pColor, ARG4, 16);
    VkClearColorValue* pColor = &tmp_pColor;
    uint32_t rangeCount = (uint32_t)ARG5;
    VkImageSubresourceRange* pRanges = nullptr;
    if (ARG6) {
        pRanges = new VkImageSubresourceRange[rangeCount];
        cpu->memory->memcpy(pRanges, ARG6, (U32)rangeCount * sizeof(VkImageSubresourceRange));
    }
    pBoxedInfo->pvkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    delete[] pRanges;
}
void vk_CmdClearDepthStencilImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage image = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    VkClearDepthStencilValue tmp_pDepthStencil;
    cpu->memory->memcpy(&tmp_pDepthStencil, ARG4, 8);
    VkClearDepthStencilValue* pDepthStencil = &tmp_pDepthStencil;
    uint32_t rangeCount = (uint32_t)ARG5;
    VkImageSubresourceRange* pRanges = nullptr;
    if (ARG6) {
        pRanges = new VkImageSubresourceRange[rangeCount];
        cpu->memory->memcpy(pRanges, ARG6, (U32)rangeCount * sizeof(VkImageSubresourceRange));
    }
    pBoxedInfo->pvkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    delete[] pRanges;
}
void vk_CmdClearAttachments(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkClearAttachment* pAttachments = nullptr;
    if (ARG3) {
        pAttachments = new VkClearAttachment[attachmentCount];
        cpu->memory->memcpy(pAttachments, ARG3, (U32)attachmentCount * sizeof(VkClearAttachment));
    }
    uint32_t rectCount = (uint32_t)ARG4;
    VkClearRect* pRects = nullptr;
    if (ARG5) {
        pRects = new VkClearRect[rectCount];
        cpu->memory->memcpy(pRects, ARG5, (U32)rectCount * sizeof(VkClearRect));
    }
    pBoxedInfo->pvkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    delete[] pAttachments;
    delete[] pRects;
}
void vk_CmdResolveImage(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImage srcImage = (VkImage)cpu->memory->readq(ARG2);
    VkImageLayout srcImageLayout = (VkImageLayout)ARG3;
    VkImage dstImage = (VkImage)cpu->memory->readq(ARG4);
    VkImageLayout dstImageLayout = (VkImageLayout)ARG5;
    uint32_t regionCount = (uint32_t)ARG6;
    VkImageResolve* pRegions = nullptr;
    if (ARG7) {
        pRegions = new VkImageResolve[regionCount];
        cpu->memory->memcpy(pRegions, ARG7, (U32)regionCount * sizeof(VkImageResolve));
    }
    pBoxedInfo->pvkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    delete[] pRegions;
}
void vk_CmdSetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG3;
    pBoxedInfo->pvkCmdSetEvent(commandBuffer, event, stageMask);
}
void vk_CmdResetEvent(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags stageMask = (VkPipelineStageFlags)ARG3;
    pBoxedInfo->pvkCmdResetEvent(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = nullptr;
    if (ARG3) {
        pEvents = new VkEvent[eventCount];
        cpu->memory->memcpy(pEvents, ARG3, (U32)eventCount * sizeof(VkEvent));
    }
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG4;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG5;
    uint32_t memoryBarrierCount = (uint32_t)ARG6;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG7) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(cpu->memory, ARG7 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG8;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG9) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(cpu->memory, ARG9 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG10;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG11) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(cpu->memory, ARG11 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    delete[] pEvents;
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdPipelineBarrier(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags srcStageMask = (VkPipelineStageFlags)ARG2;
    VkPipelineStageFlags dstStageMask = (VkPipelineStageFlags)ARG3;
    VkDependencyFlags dependencyFlags = (VkDependencyFlags)ARG4;
    uint32_t memoryBarrierCount = (uint32_t)ARG5;
    VkMemoryBarrier* pMemoryBarriers = NULL;
    if (ARG6) {
        pMemoryBarriers = new VkMemoryBarrier[memoryBarrierCount];
        for (U32 i=0;i<memoryBarrierCount;i++) {
            MarshalVkMemoryBarrier::read(cpu->memory, ARG6 + i * 16, &pMemoryBarriers[i]);
        }
    }
    uint32_t bufferMemoryBarrierCount = (uint32_t)ARG7;
    VkBufferMemoryBarrier* pBufferMemoryBarriers = NULL;
    if (ARG8) {
        pBufferMemoryBarriers = new VkBufferMemoryBarrier[bufferMemoryBarrierCount];
        for (U32 i=0;i<bufferMemoryBarrierCount;i++) {
            MarshalVkBufferMemoryBarrier::read(cpu->memory, ARG8 + i * 48, &pBufferMemoryBarriers[i]);
        }
    }
    uint32_t imageMemoryBarrierCount = (uint32_t)ARG9;
    VkImageMemoryBarrier* pImageMemoryBarriers = NULL;
    if (ARG10) {
        pImageMemoryBarriers = new VkImageMemoryBarrier[imageMemoryBarrierCount];
        for (U32 i=0;i<imageMemoryBarrierCount;i++) {
            MarshalVkImageMemoryBarrier::read(cpu->memory, ARG10 + i * 60, &pImageMemoryBarriers[i]);
        }
    }
    pBoxedInfo->pvkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    if (pMemoryBarriers) {
        delete[] pMemoryBarriers;
    }
    if (pBufferMemoryBarriers) {
        delete[] pBufferMemoryBarriers;
    }
    if (pImageMemoryBarriers) {
        delete[] pImageMemoryBarriers;
    }
}
void vk_CmdBeginQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG4;
    pBoxedInfo->pvkCmdBeginQuery(commandBuffer, queryPool, query, flags);
}
void vk_CmdEndQuery(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdEndQuery(commandBuffer, queryPool, query);
}
void vk_CmdBeginConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkConditionalRenderingBeginInfoEXT local_pConditionalRenderingBegin(cpu->memory, ARG2);
    VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin = &local_pConditionalRenderingBegin.s;
    pBoxedInfo->pvkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
}
void vk_CmdEndConditionalRenderingEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndConditionalRenderingEXT(commandBuffer);
}
void vk_CmdResetQueryPool(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
}
void vk_CmdWriteTimestamp(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
}
void vk_CmdCopyQueryPoolResults(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t firstQuery = (uint32_t)ARG3;
    uint32_t queryCount = (uint32_t)ARG4;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG5);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG6);
    VkDeviceSize stride = (VkDeviceSize)cpu->memory->readq(ARG7);
    VkQueryResultFlags flags = (VkQueryResultFlags)ARG8;
    pBoxedInfo->pvkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
void vk_CmdPushConstants(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG2);
    VkShaderStageFlags stageFlags = (VkShaderStageFlags)ARG3;
    uint32_t offset = (uint32_t)ARG4;
    uint32_t size = (uint32_t)ARG5;
    void* pValues = nullptr;
    if (ARG6) {
        pValues = new char[size];
        cpu->memory->memcpy(pValues, ARG6, (U32)size * sizeof(char));
    }
    pBoxedInfo->pvkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    delete[] pValues;
}
void vk_CmdBeginRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    VkSubpassContents contents = (VkSubpassContents)ARG3;
    pBoxedInfo->pvkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
}
void vk_CmdNextSubpass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSubpassContents contents = (VkSubpassContents)ARG2;
    pBoxedInfo->pvkCmdNextSubpass(commandBuffer, contents);
}
void vk_CmdEndRenderPass(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkCmdEndRenderPass(commandBuffer);
}
void vk_CmdExecuteCommands(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t commandBufferCount = (uint32_t)ARG2;
    VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[commandBufferCount];
    for (U32 i=0;i<commandBufferCount;i++) {
        pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(cpu->memory, cpu->memory->readd(ARG3 + i*4));
    }
    pBoxedInfo->pvkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    delete[] pCommandBuffers;
}
void vk_DestroySurfaceKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySurfaceKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySurfaceKHR(instance, surface, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceSupportKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG3);
    VkBool32 tmp_pSupported = (VkBool32) cpu->memory->readd(ARG4);
    VkBool32* pSupported = &tmp_pSupported;
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
    cpu->memory->writed(ARG4, (U32)tmp_pSupported);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilitiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    MarshalVkSurfaceCapabilitiesKHR pSurfaceCapabilities(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilitiesKHR::write(cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormatsKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormatKHR* pSurfaceFormats = NULL;
    if (ARG4) {
        pSurfaceFormats = new VkSurfaceFormatKHR[*pSurfaceFormatCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG3, (U32)tmp_pSurfaceFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormatKHR::write(cpu->memory, ARG4 + i * 8, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfacePresentModesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pPresentModeCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPresentModeCount = &tmp_pPresentModeCount;
    static_assert (sizeof(VkPresentModeKHR) == 4, "unhandled enum size");
    VkPresentModeKHR* pPresentModes = nullptr;
    if (ARG4) {
        pPresentModes = new VkPresentModeKHR[*pPresentModeCount];
        cpu->memory->memcpy(pPresentModes, ARG4, (U32)*pPresentModeCount * sizeof(VkPresentModeKHR));
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
    cpu->memory->writed(ARG3, (U32)tmp_pPresentModeCount);
}
// return type: VkResult(4 bytes)
void vk_CreateSwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSwapchainCreateInfoKHR local_pCreateInfo(cpu->memory, ARG2);
    VkSwapchainCreateInfoKHR* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSwapchainKHR tmp_pSwapchain = (VkSwapchainKHR) cpu->memory->readq(ARG4);
    VkSwapchainKHR* pSwapchain = &tmp_pSwapchain;
    EAX = pBoxedInfo->pvkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
    cpu->memory->writeq(ARG4, (U64)tmp_pSwapchain);
}
void vk_DestroySwapchainKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySwapchainKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySwapchainKHR(device, swapchain, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetSwapchainImagesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pSwapchainImageCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSwapchainImageCount = &tmp_pSwapchainImageCount;
    VkImage* pSwapchainImages = nullptr;
    if (ARG4) {
        pSwapchainImages = new VkImage[*pSwapchainImageCount];
        cpu->memory->memcpy(pSwapchainImages, ARG4, (U32)*pSwapchainImageCount * sizeof(VkImage));
    }
    EAX = pBoxedInfo->pvkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    cpu->memory->writed(ARG3, (U32)tmp_pSwapchainImageCount);
    if (pSwapchainImages) {
        cpu->memory->memcpy(ARG4, pSwapchainImages, (U32)*pSwapchainImageCount * sizeof(VkImage));
    }
    delete[] pSwapchainImages;
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImageKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSwapchainKHR swapchain = (VkSwapchainKHR)cpu->memory->readq(ARG2);
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG4);
    VkFence fence = (VkFence)cpu->memory->readq(ARG5);
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG6);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = pBoxedInfo->pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
    cpu->memory->writed(ARG6, (U32)tmp_pImageIndex);
}
// return type: VkResult(4 bytes)
void vk_QueuePresentKHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPresentInfoKHR local_pPresentInfo(cpu->memory, ARG2);
    VkPresentInfoKHR* pPresentInfo = &local_pPresentInfo.s;
    EAX = pBoxedInfo->pvkQueuePresentKHR(queue, pPresentInfo);
}
void vk_CmdExecuteGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 isPreprocessed = (VkBool32)ARG2;
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(cpu->memory, ARG3);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
void vk_CmdPreprocessGeneratedCommandsNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsInfoNV local_pGeneratedCommandsInfo(cpu->memory, ARG2);
    VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo = &local_pGeneratedCommandsInfo.s;
    pBoxedInfo->pvkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
}
void vk_CmdBindPipelineShaderGroupNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG3);
    uint32_t groupIndex = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
void vk_GetGeneratedCommandsMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkGeneratedCommandsMemoryRequirementsInfoNV local_pInfo(cpu->memory, ARG2);
    VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_CreateIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkIndirectCommandsLayoutCreateInfoNV local_pCreateInfo(cpu->memory, ARG2);
    VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkIndirectCommandsLayoutNV tmp_pIndirectCommandsLayout = (VkIndirectCommandsLayoutNV) cpu->memory->readq(ARG4);
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout = &tmp_pIndirectCommandsLayout;
    EAX = pBoxedInfo->pvkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    cpu->memory->writeq(ARG4, (U64)tmp_pIndirectCommandsLayout);
}
void vk_DestroyIndirectCommandsLayoutNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkIndirectCommandsLayoutNV indirectCommandsLayout = (VkIndirectCommandsLayoutNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyIndirectCommandsLayoutNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
}
void vk_GetPhysicalDeviceFeatures2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceFeatures2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceFeatures2 pFeatures(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceFeatures2KHR(physicalDevice, &pFeatures.s);
    MarshalVkPhysicalDeviceFeatures2::write(cpu->memory, ARG2, &pFeatures.s);
}
void vk_GetPhysicalDeviceProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceProperties2 pProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceProperties2KHR(physicalDevice, &pProperties.s);
    MarshalVkPhysicalDeviceProperties2::write(cpu->memory, ARG2, &pProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(cpu->memory, ARG3, &pFormatProperties.s);
}
void vk_GetPhysicalDeviceFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFormat format = (VkFormat)ARG2;
    MarshalVkFormatProperties2 pFormatProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, &pFormatProperties.s);
    MarshalVkFormatProperties2::write(cpu->memory, ARG3, &pFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(cpu->memory, ARG3, &pImageFormatProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceImageFormatInfo2 local_pImageFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = &local_pImageFormatInfo.s;
    MarshalVkImageFormatProperties2 pImageFormatProperties(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, &pImageFormatProperties.s);
    MarshalVkImageFormatProperties2::write(cpu->memory, ARG3, &pImageFormatProperties.s);
}
void vk_GetPhysicalDeviceQueueFamilyProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceQueueFamilyProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pQueueFamilyPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pQueueFamilyPropertyCount = &tmp_pQueueFamilyPropertyCount;
    VkQueueFamilyProperties2* pQueueFamilyProperties = NULL;
    if (ARG3) {
        pQueueFamilyProperties = new VkQueueFamilyProperties2[*pQueueFamilyPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pQueueFamilyPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pQueueFamilyPropertyCount;i++) {
            MarshalVkQueueFamilyProperties2::write(cpu->memory, ARG3 + i * 32, &pQueueFamilyProperties[i]);
        }
        delete[] pQueueFamilyProperties;
    }
}
void vk_GetPhysicalDeviceMemoryProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceMemoryProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceMemoryProperties2 pMemoryProperties(cpu->memory, ARG2);
    pBoxedInfo->pvkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, &pMemoryProperties.s);
    MarshalVkPhysicalDeviceMemoryProperties2::write(cpu->memory, ARG2, &pMemoryProperties.s);
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_GetPhysicalDeviceSparseImageFormatProperties2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSparseImageFormatInfo2 local_pFormatInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = &local_pFormatInfo.s;
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkSparseImageFormatProperties2* pProperties = NULL;
    if (ARG4) {
        pProperties = new VkSparseImageFormatProperties2[*pPropertyCount];
    }
    pBoxedInfo->pvkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    cpu->memory->writed(ARG3, (U32)tmp_pPropertyCount);
    if (ARG4) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkSparseImageFormatProperties2::write(cpu->memory, ARG4 + i * 28, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
void vk_CmdPushDescriptorSetKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineBindPoint pipelineBindPoint = (VkPipelineBindPoint)ARG2;
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    uint32_t descriptorWriteCount = (uint32_t)ARG5;
    VkWriteDescriptorSet* pDescriptorWrites = NULL;
    if (ARG6) {
        pDescriptorWrites = new VkWriteDescriptorSet[descriptorWriteCount];
        for (U32 i=0;i<descriptorWriteCount;i++) {
            MarshalVkWriteDescriptorSet::read(cpu->memory, ARG6 + i * 44, &pDescriptorWrites[i]);
        }
    }
    pBoxedInfo->pvkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (pDescriptorWrites) {
        delete[] pDescriptorWrites;
    }
}
void vk_TrimCommandPool(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG3;
    pBoxedInfo->pvkTrimCommandPool(device, commandPool, flags);
}
void vk_TrimCommandPoolKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCommandPool commandPool = (VkCommandPool)cpu->memory->readq(ARG2);
    VkCommandPoolTrimFlags flags = (VkCommandPoolTrimFlags)ARG3;
    pBoxedInfo->pvkTrimCommandPoolKHR(device, commandPool, flags);
}
void vk_GetPhysicalDeviceExternalBufferProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalBufferPropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalBufferInfo local_pExternalBufferInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = &local_pExternalBufferInfo.s;
    MarshalVkExternalBufferProperties pExternalBufferProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, &pExternalBufferProperties.s);
    MarshalVkExternalBufferProperties::write(cpu->memory, ARG3, &pExternalBufferProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphoreProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalSemaphorePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalSemaphoreInfo local_pExternalSemaphoreInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = &local_pExternalSemaphoreInfo.s;
    MarshalVkExternalSemaphoreProperties pExternalSemaphoreProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, &pExternalSemaphoreProperties.s);
    MarshalVkExternalSemaphoreProperties::write(cpu->memory, ARG3, &pExternalSemaphoreProperties.s);
}
void vk_GetPhysicalDeviceExternalFenceProperties(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(cpu->memory, ARG3, &pExternalFenceProperties.s);
}
void vk_GetPhysicalDeviceExternalFencePropertiesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceExternalFenceInfo local_pExternalFenceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = &local_pExternalFenceInfo.s;
    MarshalVkExternalFenceProperties pExternalFenceProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, &pExternalFenceProperties.s);
    MarshalVkExternalFenceProperties::write(cpu->memory, ARG3, &pExternalFenceProperties.s);
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroups(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceGroupsKHR(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPhysicalDeviceGroupCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPhysicalDeviceGroupCount = &tmp_pPhysicalDeviceGroupCount;
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = NULL;
    if (ARG3) {
        pPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties[*pPhysicalDeviceGroupCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPhysicalDeviceGroupCount);
    if (ARG3) {
        for (U32 i=0;i<*pPhysicalDeviceGroupCount;i++) {
            MarshalVkPhysicalDeviceGroupProperties::write(cpu->memory, ARG3 + i * 144, &pPhysicalDeviceGroupProperties[i]);
        }
        delete[] pPhysicalDeviceGroupProperties;
    }
}
void vk_GetDeviceGroupPeerMemoryFeatures(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
void vk_GetDeviceGroupPeerMemoryFeaturesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t heapIndex = (uint32_t)ARG2;
    uint32_t localDeviceIndex = (uint32_t)ARG3;
    uint32_t remoteDeviceIndex = (uint32_t)ARG4;
    VkPeerMemoryFeatureFlags tmp_pPeerMemoryFeatures = (VkPeerMemoryFeatureFlags) cpu->memory->readd(ARG5);
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = &tmp_pPeerMemoryFeatures;
    pBoxedInfo->pvkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    cpu->memory->writed(ARG5, (U32)tmp_pPeerMemoryFeatures);
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindBufferMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindBufferMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindBufferMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindBufferMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindBufferMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindImageMemory2(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
// return type: VkResult(4 bytes)
void vk_BindImageMemory2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindImageMemoryInfo* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindImageMemoryInfo[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindImageMemoryInfo::read(cpu->memory, ARG3 + i * 32, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdSetDeviceMask(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMask(commandBuffer, deviceMask);
}
void vk_CmdSetDeviceMaskKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t deviceMask = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupPresentCapabilitiesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities(cpu->memory, ARG2);
    EAX = pBoxedInfo->pvkGetDeviceGroupPresentCapabilitiesKHR(device, &pDeviceGroupPresentCapabilities.s);
    MarshalVkDeviceGroupPresentCapabilitiesKHR::write(cpu->memory, ARG2, &pDeviceGroupPresentCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetDeviceGroupSurfacePresentModesKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    VkDeviceGroupPresentModeFlagsKHR tmp_pModes = (VkDeviceGroupPresentModeFlagsKHR) cpu->memory->readd(ARG3);
    VkDeviceGroupPresentModeFlagsKHR* pModes = &tmp_pModes;
    EAX = pBoxedInfo->pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
    cpu->memory->writed(ARG3, (U32)tmp_pModes);
}
// return type: VkResult(4 bytes)
void vk_AcquireNextImage2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireNextImageInfoKHR local_pAcquireInfo(cpu->memory, ARG2);
    VkAcquireNextImageInfoKHR* pAcquireInfo = &local_pAcquireInfo.s;
    uint32_t tmp_pImageIndex = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pImageIndex = &tmp_pImageIndex;
    EAX = pBoxedInfo->pvkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
    cpu->memory->writed(ARG3, (U32)tmp_pImageIndex);
}
void vk_CmdDispatchBase(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
void vk_CmdDispatchBaseKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t baseGroupX = (uint32_t)ARG2;
    uint32_t baseGroupY = (uint32_t)ARG3;
    uint32_t baseGroupZ = (uint32_t)ARG4;
    uint32_t groupCountX = (uint32_t)ARG5;
    uint32_t groupCountY = (uint32_t)ARG6;
    uint32_t groupCountZ = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDevicePresentRectanglesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSurfaceKHR surface = (VkSurfaceKHR)cpu->memory->readq(ARG2);
    uint32_t tmp_pRectCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pRectCount = &tmp_pRectCount;
    VkRect2D* pRects = nullptr;
    if (ARG4) {
        pRects = new VkRect2D[*pRectCount];
        cpu->memory->memcpy(pRects, ARG4, (U32)*pRectCount * sizeof(VkRect2D));
    }
    EAX = pBoxedInfo->pvkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
    cpu->memory->writed(ARG3, (U32)tmp_pRectCount);
    if (pRects) {
        cpu->memory->memcpy(ARG4, pRects, (U32)*pRectCount * sizeof(VkRect2D));
    }
    delete[] pRects;
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = pBoxedInfo->pvkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
// return type: VkResult(4 bytes)
void vk_CreateDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorUpdateTemplateCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDescriptorUpdateTemplate tmp_pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate) cpu->memory->readq(ARG4);
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = &tmp_pDescriptorUpdateTemplate;
    EAX = pBoxedInfo->pvkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    cpu->memory->writeq(ARG4, (U64)tmp_pDescriptorUpdateTemplate);
}
void vk_DestroyDescriptorUpdateTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorUpdateTemplate:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
void vk_DestroyDescriptorUpdateTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDescriptorUpdateTemplateKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
}
void vk_UpdateDescriptorSetWithTemplate(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)cpu->memory->readq(ARG2);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG3);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_UpdateDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorSet descriptorSet = (VkDescriptorSet)cpu->memory->readq(ARG2);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG3);
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
}
void vk_CmdPushDescriptorSetWithTemplateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDescriptorUpdateTemplate descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)cpu->memory->readq(ARG2);
    VkPipelineLayout layout = (VkPipelineLayout)cpu->memory->readq(ARG3);
    uint32_t set = (uint32_t)ARG4;
    void* pData;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    pBoxedInfo->pvkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
void vk_CmdSetViewportWScalingNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkViewportWScalingNV* pViewportWScalings = nullptr;
    if (ARG4) {
        pViewportWScalings = new VkViewportWScalingNV[viewportCount];
        cpu->memory->memcpy(pViewportWScalings, ARG4, (U32)viewportCount * sizeof(VkViewportWScalingNV));
    }
    pBoxedInfo->pvkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    delete[] pViewportWScalings;
}
void vk_CmdSetDiscardRectangleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstDiscardRectangle = (uint32_t)ARG2;
    uint32_t discardRectangleCount = (uint32_t)ARG3;
    VkRect2D* pDiscardRectangles = nullptr;
    if (ARG4) {
        pDiscardRectangles = new VkRect2D[discardRectangleCount];
        cpu->memory->memcpy(pDiscardRectangles, ARG4, (U32)discardRectangleCount * sizeof(VkRect2D));
    }
    pBoxedInfo->pvkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    delete[] pDiscardRectangles;
}
void vk_CmdSetSampleLocationsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSampleLocationsInfoEXT local_pSampleLocationsInfo(cpu->memory, ARG2);
    VkSampleLocationsInfoEXT* pSampleLocationsInfo = &local_pSampleLocationsInfo.s;
    pBoxedInfo->pvkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
}
void vk_GetPhysicalDeviceMultisamplePropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSampleCountFlagBits samples = (VkSampleCountFlagBits)ARG2;
    MarshalVkMultisamplePropertiesEXT pMultisampleProperties(cpu->memory, ARG3);
    pBoxedInfo->pvkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, &pMultisampleProperties.s);
    MarshalVkMultisamplePropertiesEXT::write(cpu->memory, ARG3, &pMultisampleProperties.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceCapabilities2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    MarshalVkSurfaceCapabilities2KHR pSurfaceCapabilities(cpu->memory, ARG3);
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, &pSurfaceCapabilities.s);
    MarshalVkSurfaceCapabilities2KHR::write(cpu->memory, ARG3, &pSurfaceCapabilities.s);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSurfaceFormats2KHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPhysicalDeviceSurfaceInfo2KHR local_pSurfaceInfo(cpu->memory, ARG2);
    VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo = &local_pSurfaceInfo.s;
    uint32_t tmp_pSurfaceFormatCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSurfaceFormatCount = &tmp_pSurfaceFormatCount;
    VkSurfaceFormat2KHR* pSurfaceFormats = NULL;
    if (ARG4) {
        pSurfaceFormats = new VkSurfaceFormat2KHR[*pSurfaceFormatCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    cpu->memory->writed(ARG3, (U32)tmp_pSurfaceFormatCount);
    if (ARG4) {
        for (U32 i=0;i<*pSurfaceFormatCount;i++) {
            MarshalVkSurfaceFormat2KHR::write(cpu->memory, ARG4 + i * 16, &pSurfaceFormats[i]);
        }
        delete[] pSurfaceFormats;
    }
}
void vk_GetBufferMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetBufferMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkBufferMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetBufferMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetImageMemoryRequirements2KHR(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
void vk_GetImageSparseMemoryRequirements2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
void vk_GetImageSparseMemoryRequirements2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkImageSparseMemoryRequirementsInfo2 local_pInfo(cpu->memory, ARG2);
    VkImageSparseMemoryRequirementsInfo2* pInfo = &local_pInfo.s;
    uint32_t tmp_pSparseMemoryRequirementCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pSparseMemoryRequirementCount = &tmp_pSparseMemoryRequirementCount;
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = NULL;
    if (ARG4) {
        pSparseMemoryRequirements = new VkSparseImageMemoryRequirements2[*pSparseMemoryRequirementCount];
    }
    pBoxedInfo->pvkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    cpu->memory->writed(ARG3, (U32)tmp_pSparseMemoryRequirementCount);
    if (ARG4) {
        for (U32 i=0;i<*pSparseMemoryRequirementCount;i++) {
            MarshalVkSparseImageMemoryRequirements2::write(cpu->memory, ARG4 + i * 56, &pSparseMemoryRequirements[i]);
        }
        delete[] pSparseMemoryRequirements;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = pBoxedInfo->pvkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
// return type: VkResult(4 bytes)
void vk_CreateSamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSamplerYcbcrConversionCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkSamplerYcbcrConversionCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateSamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSamplerYcbcrConversion tmp_pYcbcrConversion = (VkSamplerYcbcrConversion) cpu->memory->readq(ARG4);
    VkSamplerYcbcrConversion* pYcbcrConversion = &tmp_pYcbcrConversion;
    EAX = pBoxedInfo->pvkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
    cpu->memory->writeq(ARG4, (U64)tmp_pYcbcrConversion);
}
void vk_DestroySamplerYcbcrConversion(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySamplerYcbcrConversion:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
void vk_DestroySamplerYcbcrConversionKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSamplerYcbcrConversion ycbcrConversion = (VkSamplerYcbcrConversion)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroySamplerYcbcrConversionKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
}
void vk_GetDeviceQueue2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceQueueInfo2 local_pQueueInfo(cpu->memory, ARG2);
    VkDeviceQueueInfo2* pQueueInfo = &local_pQueueInfo.s;
    VkQueue pQueue;
    pBoxedInfo->pvkGetDeviceQueue2(device, pQueueInfo, &pQueue);
    cpu->memory->writed(ARG3, createVulkanPtr(cpu->memory, (U64)pQueue, pBoxedInfo));
}
// return type: VkResult(4 bytes)
void vk_CreateValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkValidationCacheCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkValidationCacheCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkValidationCacheEXT tmp_pValidationCache = (VkValidationCacheEXT) cpu->memory->readq(ARG4);
    VkValidationCacheEXT* pValidationCache = &tmp_pValidationCache;
    EAX = pBoxedInfo->pvkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
    cpu->memory->writeq(ARG4, (U64)tmp_pValidationCache);
}
void vk_DestroyValidationCacheEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyValidationCacheEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyValidationCacheEXT(device, validationCache, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_GetValidationCacheDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT validationCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    size_t tmp_pDataSize = (size_t) cpu->memory->readd(ARG3);
    size_t* pDataSize = &tmp_pDataSize;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[*pDataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)*pDataSize * sizeof(char));
    }
    EAX = pBoxedInfo->pvkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
    cpu->memory->writed(ARG3, (U32)tmp_pDataSize);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)*pDataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_MergeValidationCachesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkValidationCacheEXT dstCache = (VkValidationCacheEXT)cpu->memory->readq(ARG2);
    uint32_t srcCacheCount = (uint32_t)ARG3;
    VkValidationCacheEXT* pSrcCaches = nullptr;
    if (ARG4) {
        pSrcCaches = new VkValidationCacheEXT[srcCacheCount];
        cpu->memory->memcpy(pSrcCaches, ARG4, (U32)srcCacheCount * sizeof(VkValidationCacheEXT));
    }
    EAX = pBoxedInfo->pvkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
    delete[] pSrcCaches;
}
void vk_GetDescriptorSetLayoutSupport(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupport(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(cpu->memory, ARG3, &pSupport.s);
}
void vk_GetDescriptorSetLayoutSupportKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDescriptorSetLayoutCreateInfo local_pCreateInfo(cpu->memory, ARG2);
    VkDescriptorSetLayoutCreateInfo* pCreateInfo = &local_pCreateInfo.s;
    MarshalVkDescriptorSetLayoutSupport pSupport(cpu->memory, ARG3);
    pBoxedInfo->pvkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, &pSupport.s);
    MarshalVkDescriptorSetLayoutSupport::write(cpu->memory, ARG3, &pSupport.s);
}
// return type: VkResult(4 bytes)
void vk_GetShaderInfoAMD(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    VkShaderStageFlagBits shaderStage = (VkShaderStageFlagBits)ARG3;
    VkShaderInfoTypeAMD infoType = (VkShaderInfoTypeAMD)ARG4;
    size_t tmp_pInfoSize = (size_t) cpu->memory->readd(ARG5);
    size_t* pInfoSize = &tmp_pInfoSize;
    void* pInfo = nullptr;
    if (ARG6) {
        pInfo = new char[*pInfoSize];
        cpu->memory->memcpy(pInfo, ARG6, (U32)*pInfoSize * sizeof(char));
    }
    EAX = pBoxedInfo->pvkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    cpu->memory->writed(ARG5, (U32)tmp_pInfoSize);
    if (pInfo) {
        cpu->memory->memcpy(ARG6, pInfo, (U32)*pInfoSize * sizeof(char));
    }
    delete[] pInfo;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCalibrateableTimeDomainsEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pTimeDomainCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pTimeDomainCount = &tmp_pTimeDomainCount;
    static_assert (sizeof(VkTimeDomainEXT) == 4, "unhandled enum size");
    VkTimeDomainEXT* pTimeDomains = nullptr;
    if (ARG3) {
        pTimeDomains = new VkTimeDomainEXT[*pTimeDomainCount];
        cpu->memory->memcpy(pTimeDomains, ARG3, (U32)*pTimeDomainCount * sizeof(VkTimeDomainEXT));
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
    cpu->memory->writed(ARG2, (U32)tmp_pTimeDomainCount);
}
// return type: VkResult(4 bytes)
void vk_GetCalibratedTimestampsEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t timestampCount = (uint32_t)ARG2;
    VkCalibratedTimestampInfoEXT* pTimestampInfos = NULL;
    if (ARG3) {
        pTimestampInfos = new VkCalibratedTimestampInfoEXT[timestampCount];
        for (U32 i=0;i<timestampCount;i++) {
            MarshalVkCalibratedTimestampInfoEXT::read(cpu->memory, ARG3 + i * 12, &pTimestampInfos[i]);
        }
    }
    uint64_t* pTimestamps = nullptr;
    if (ARG4) {
        pTimestamps = new uint64_t[timestampCount];
        cpu->memory->memcpy(pTimestamps, ARG4, (U32)timestampCount * sizeof(uint64_t));
    }
    uint64_t tmp_pMaxDeviation = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pMaxDeviation = &tmp_pMaxDeviation;
    EAX = pBoxedInfo->pvkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (pTimestampInfos) {
        delete[] pTimestampInfos;
    }
    if (pTimestamps) {
        cpu->memory->memcpy(ARG4, pTimestamps, (U32)timestampCount * sizeof(uint64_t));
    }
    delete[] pTimestamps;
    cpu->memory->writeq(ARG5, (U64)tmp_pMaxDeviation);
}
// return type: VkResult(4 bytes)
void vk_GetMemoryHostPointerPropertiesEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkExternalMemoryHandleTypeFlagBits handleType = (VkExternalMemoryHandleTypeFlagBits)ARG2;
    void* pHostPointer;
    kpanic("vkUpdateDescriptorSetWithTemplate not implemented");
    MarshalVkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties(cpu->memory, ARG4);
    EAX = pBoxedInfo->pvkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, &pMemoryHostPointerProperties.s);
    MarshalVkMemoryHostPointerPropertiesEXT::write(cpu->memory, ARG4, &pMemoryHostPointerProperties.s);
}
void vk_CmdWriteBufferMarkerAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlagBits pipelineStage = (VkPipelineStageFlagBits)ARG2;
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t marker = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
// return type: VkResult(4 bytes)
void vk_CreateRenderPass2KHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassCreateInfo2 local_pCreateInfo(cpu->memory, ARG2);
    VkRenderPassCreateInfo2* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateRenderPass2KHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkRenderPass tmp_pRenderPass = (VkRenderPass) cpu->memory->readq(ARG4);
    VkRenderPass* pRenderPass = &tmp_pRenderPass;
    EAX = pBoxedInfo->pvkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
    cpu->memory->writeq(ARG4, (U64)tmp_pRenderPass);
}
void vk_CmdBeginRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdBeginRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkRenderPassBeginInfo local_pRenderPassBegin(cpu->memory, ARG2);
    VkRenderPassBeginInfo* pRenderPassBegin = &local_pRenderPassBegin.s;
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG3);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    pBoxedInfo->pvkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
void vk_CmdNextSubpass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdNextSubpass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassBeginInfo local_pSubpassBeginInfo(cpu->memory, ARG2);
    VkSubpassBeginInfo* pSubpassBeginInfo = &local_pSubpassBeginInfo.s;
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG3);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
void vk_CmdEndRenderPass2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSubpassEndInfo local_pSubpassEndInfo(cpu->memory, ARG2);
    VkSubpassEndInfo* pSubpassEndInfo = &local_pSubpassEndInfo.s;
    pBoxedInfo->pvkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValue(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG3);
    uint64_t* pValue = &tmp_pValue;
    EAX = pBoxedInfo->pvkGetSemaphoreCounterValue(device, semaphore, pValue);
    cpu->memory->writeq(ARG3, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_GetSemaphoreCounterValueKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkSemaphore semaphore = (VkSemaphore)cpu->memory->readq(ARG2);
    uint64_t tmp_pValue = (uint64_t) cpu->memory->readq(ARG3);
    uint64_t* pValue = &tmp_pValue;
    EAX = pBoxedInfo->pvkGetSemaphoreCounterValueKHR(device, semaphore, pValue);
    cpu->memory->writeq(ARG3, (U64)tmp_pValue);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphores(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    EAX = pBoxedInfo->pvkWaitSemaphores(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_WaitSemaphoresKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreWaitInfo local_pWaitInfo(cpu->memory, ARG2);
    VkSemaphoreWaitInfo* pWaitInfo = &local_pWaitInfo.s;
    uint64_t timeout = (uint64_t)cpu->memory->readq(ARG3);
    EAX = pBoxedInfo->pvkWaitSemaphoresKHR(device, pWaitInfo, timeout);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphore(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = pBoxedInfo->pvkSignalSemaphore(device, pSignalInfo);
}
// return type: VkResult(4 bytes)
void vk_SignalSemaphoreKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkSemaphoreSignalInfo local_pSignalInfo(cpu->memory, ARG2);
    VkSemaphoreSignalInfo* pSignalInfo = &local_pSignalInfo.s;
    EAX = pBoxedInfo->pvkSignalSemaphoreKHR(device, pSignalInfo);
}
void vk_CmdDrawIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCount(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdDrawIndexedIndirectCountAMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
void vk_CmdBindTransformFeedbackBuffersEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pSizes = nullptr;
    if (ARG6) {
        pSizes = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pSizes, ARG6, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
}
void vk_CmdBeginTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = nullptr;
    if (ARG4) {
        pCounterBuffers = new VkBuffer[counterBufferCount];
        cpu->memory->memcpy(pCounterBuffers, ARG4, (U32)counterBufferCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pCounterBufferOffsets = nullptr;
    if (ARG5) {
        pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
        cpu->memory->memcpy(pCounterBufferOffsets, ARG5, (U32)counterBufferCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdEndTransformFeedbackEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstCounterBuffer = (uint32_t)ARG2;
    uint32_t counterBufferCount = (uint32_t)ARG3;
    VkBuffer* pCounterBuffers = nullptr;
    if (ARG4) {
        pCounterBuffers = new VkBuffer[counterBufferCount];
        cpu->memory->memcpy(pCounterBuffers, ARG4, (U32)counterBufferCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pCounterBufferOffsets = nullptr;
    if (ARG5) {
        pCounterBufferOffsets = new VkDeviceSize[counterBufferCount];
        cpu->memory->memcpy(pCounterBufferOffsets, ARG5, (U32)counterBufferCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    delete[] pCounterBuffers;
    delete[] pCounterBufferOffsets;
}
void vk_CmdBeginQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    VkQueryControlFlags flags = (VkQueryControlFlags)ARG4;
    uint32_t index = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
}
void vk_CmdEndQueryIndexedEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG2);
    uint32_t query = (uint32_t)ARG3;
    uint32_t index = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
}
void vk_CmdDrawIndirectByteCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t instanceCount = (uint32_t)ARG2;
    uint32_t firstInstance = (uint32_t)ARG3;
    VkBuffer counterBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize counterBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t counterOffset = (uint32_t)ARG6;
    uint32_t vertexStride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
void vk_CmdSetExclusiveScissorNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstExclusiveScissor = (uint32_t)ARG2;
    uint32_t exclusiveScissorCount = (uint32_t)ARG3;
    VkRect2D* pExclusiveScissors = nullptr;
    if (ARG4) {
        pExclusiveScissors = new VkRect2D[exclusiveScissorCount];
        cpu->memory->memcpy(pExclusiveScissors, ARG4, (U32)exclusiveScissorCount * sizeof(VkRect2D));
    }
    pBoxedInfo->pvkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
    delete[] pExclusiveScissors;
}
void vk_CmdBindShadingRateImageNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkImageView imageView = (VkImageView)cpu->memory->readq(ARG2);
    VkImageLayout imageLayout = (VkImageLayout)ARG3;
    pBoxedInfo->pvkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
}
void vk_CmdSetViewportShadingRatePaletteNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstViewport = (uint32_t)ARG2;
    uint32_t viewportCount = (uint32_t)ARG3;
    VkShadingRatePaletteNV* pShadingRatePalettes = NULL;
    if (ARG4) {
        pShadingRatePalettes = new VkShadingRatePaletteNV[viewportCount];
        for (U32 i=0;i<viewportCount;i++) {
            MarshalVkShadingRatePaletteNV::read(cpu->memory, ARG4 + i * 8, &pShadingRatePalettes[i]);
        }
    }
    pBoxedInfo->pvkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
    if (pShadingRatePalettes) {
        delete[] pShadingRatePalettes;
    }
}
void vk_CmdSetCoarseSampleOrderNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCoarseSampleOrderTypeNV sampleOrderType = (VkCoarseSampleOrderTypeNV)ARG2;
    uint32_t customSampleOrderCount = (uint32_t)ARG3;
    VkCoarseSampleOrderCustomNV* pCustomSampleOrders = NULL;
    if (ARG4) {
        pCustomSampleOrders = new VkCoarseSampleOrderCustomNV[customSampleOrderCount];
        for (U32 i=0;i<customSampleOrderCount;i++) {
            MarshalVkCoarseSampleOrderCustomNV::read(cpu->memory, ARG4 + i * 16, &pCustomSampleOrders[i]);
        }
    }
    pBoxedInfo->pvkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
    if (pCustomSampleOrders) {
        delete[] pCustomSampleOrders;
    }
}
void vk_CmdDrawMeshTasksNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t taskCount = (uint32_t)ARG2;
    uint32_t firstTask = (uint32_t)ARG3;
    pBoxedInfo->pvkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
}
void vk_CmdDrawMeshTasksIndirectNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    uint32_t drawCount = (uint32_t)ARG4;
    uint32_t stride = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
}
void vk_CmdDrawMeshTasksIndirectCountNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer buffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize offset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer countBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize countBufferOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    uint32_t maxDrawCount = (uint32_t)ARG6;
    uint32_t stride = (uint32_t)ARG7;
    pBoxedInfo->pvkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
// return type: VkResult(4 bytes)
void vk_CompileDeferredNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t shader = (uint32_t)ARG3;
    EAX = pBoxedInfo->pvkCompileDeferredNV(device, pipeline, shader);
}
// return type: VkResult(4 bytes)
void vk_CreateAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureCreateInfoNV local_pCreateInfo(cpu->memory, ARG2);
    VkAccelerationStructureCreateInfoNV* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkAccelerationStructureNV tmp_pAccelerationStructure = (VkAccelerationStructureNV) cpu->memory->readq(ARG4);
    VkAccelerationStructureNV* pAccelerationStructure = &tmp_pAccelerationStructure;
    EAX = pBoxedInfo->pvkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
    cpu->memory->writeq(ARG4, (U64)tmp_pAccelerationStructure);
}
void vk_DestroyAccelerationStructureNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyAccelerationStructureNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
}
void vk_GetAccelerationStructureMemoryRequirementsNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureMemoryRequirementsInfoNV local_pInfo(cpu->memory, ARG2);
    VkAccelerationStructureMemoryRequirementsInfoNV* pInfo = &local_pInfo.s;
    MarshalVkMemoryRequirements2 pMemoryRequirements(cpu->memory, ARG3);
    pBoxedInfo->pvkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, &pMemoryRequirements.s);
    MarshalVkMemoryRequirements2::write(cpu->memory, ARG3, &pMemoryRequirements.s);
}
// return type: VkResult(4 bytes)
void vk_BindAccelerationStructureMemoryNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t bindInfoCount = (uint32_t)ARG2;
    VkBindAccelerationStructureMemoryInfoNV* pBindInfos = NULL;
    if (ARG3) {
        pBindInfos = new VkBindAccelerationStructureMemoryInfoNV[bindInfoCount];
        for (U32 i=0;i<bindInfoCount;i++) {
            MarshalVkBindAccelerationStructureMemoryInfoNV::read(cpu->memory, ARG3 + i * 40, &pBindInfos[i]);
        }
    }
    EAX = pBoxedInfo->pvkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
    if (pBindInfos) {
        delete[] pBindInfos;
    }
}
void vk_CmdCopyAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)cpu->memory->readq(ARG3);
    VkCopyAccelerationStructureModeKHR mode = (VkCopyAccelerationStructureModeKHR)ARG4;
    pBoxedInfo->pvkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
}
void vk_CmdWriteAccelerationStructuresPropertiesNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t accelerationStructureCount = (uint32_t)ARG2;
    VkAccelerationStructureNV* pAccelerationStructures = nullptr;
    if (ARG3) {
        pAccelerationStructures = new VkAccelerationStructureNV[accelerationStructureCount];
        cpu->memory->memcpy(pAccelerationStructures, ARG3, (U32)accelerationStructureCount * sizeof(VkAccelerationStructureNV));
    }
    VkQueryType queryType = (VkQueryType)ARG4;
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG5);
    uint32_t firstQuery = (uint32_t)ARG6;
    pBoxedInfo->pvkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    delete[] pAccelerationStructures;
}
void vk_CmdBuildAccelerationStructureNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAccelerationStructureInfoNV local_pInfo(cpu->memory, ARG2);
    VkAccelerationStructureInfoNV* pInfo = &local_pInfo.s;
    VkBuffer instanceData = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize instanceOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    VkBool32 update = (VkBool32)ARG5;
    VkAccelerationStructureNV dst = (VkAccelerationStructureNV)cpu->memory->readq(ARG6);
    VkAccelerationStructureNV src = (VkAccelerationStructureNV)cpu->memory->readq(ARG7);
    VkBuffer scratch = (VkBuffer)cpu->memory->readq(ARG8);
    VkDeviceSize scratchOffset = (VkDeviceSize)cpu->memory->readq(ARG9);
    pBoxedInfo->pvkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
void vk_CmdTraceRaysNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBuffer raygenShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG2);
    VkDeviceSize raygenShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG3);
    VkBuffer missShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG4);
    VkDeviceSize missShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG5);
    VkDeviceSize missShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG6);
    VkBuffer hitShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG7);
    VkDeviceSize hitShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG8);
    VkDeviceSize hitShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG9);
    VkBuffer callableShaderBindingTableBuffer = (VkBuffer)cpu->memory->readq(ARG10);
    VkDeviceSize callableShaderBindingOffset = (VkDeviceSize)cpu->memory->readq(ARG11);
    VkDeviceSize callableShaderBindingStride = (VkDeviceSize)cpu->memory->readq(ARG12);
    uint32_t width = (uint32_t)ARG13;
    uint32_t height = (uint32_t)ARG14;
    uint32_t depth = (uint32_t)ARG15;
    pBoxedInfo->pvkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
// return type: VkResult(4 bytes)
void vk_GetRayTracingShaderGroupHandlesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipeline pipeline = (VkPipeline)cpu->memory->readq(ARG2);
    uint32_t firstGroup = (uint32_t)ARG3;
    uint32_t groupCount = (uint32_t)ARG4;
    size_t dataSize = (size_t)ARG5;
    void* pData = nullptr;
    if (ARG6) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG6, (U32)dataSize * sizeof(char));
    }
    EAX = pBoxedInfo->pvkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (pData) {
        cpu->memory->memcpy(ARG6, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_GetAccelerationStructureHandleNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkAccelerationStructureNV accelerationStructure = (VkAccelerationStructureNV)cpu->memory->readq(ARG2);
    size_t dataSize = (size_t)ARG3;
    void* pData = nullptr;
    if (ARG4) {
        pData = new char[dataSize];
        cpu->memory->memcpy(pData, ARG4, (U32)dataSize * sizeof(char));
    }
    EAX = pBoxedInfo->pvkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
    if (pData) {
        cpu->memory->memcpy(ARG4, pData, (U32)dataSize * sizeof(char));
    }
    delete[] pData;
}
// return type: VkResult(4 bytes)
void vk_CreateRayTracingPipelinesNV(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineCache pipelineCache = (VkPipelineCache)cpu->memory->readq(ARG2);
    uint32_t createInfoCount = (uint32_t)ARG3;
    VkRayTracingPipelineCreateInfoNV* pCreateInfos = NULL;
    if (ARG4) {
        pCreateInfos = new VkRayTracingPipelineCreateInfoNV[createInfoCount];
        for (U32 i=0;i<createInfoCount;i++) {
            MarshalVkRayTracingPipelineCreateInfoNV::read(cpu->memory, ARG4 + i * 52, &pCreateInfos[i]);
        }
    }
    static bool shown; if (!shown && ARG5) { klog("vkCreateRayTracingPipelinesNV:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPipeline* pPipelines = nullptr;
    if (ARG6) {
        pPipelines = new VkPipeline[createInfoCount];
        cpu->memory->memcpy(pPipelines, ARG6, (U32)createInfoCount * sizeof(VkPipeline));
    }
    EAX = pBoxedInfo->pvkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (pCreateInfos) {
        delete[] pCreateInfos;
    }
    if (pPipelines) {
        cpu->memory->memcpy(ARG6, pPipelines, (U32)createInfoCount * sizeof(VkPipeline));
    }
    delete[] pPipelines;
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceCooperativeMatrixPropertiesNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pPropertyCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pPropertyCount = &tmp_pPropertyCount;
    VkCooperativeMatrixPropertiesNV* pProperties = NULL;
    if (ARG3) {
        pProperties = new VkCooperativeMatrixPropertiesNV[*pPropertyCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pPropertyCount);
    if (ARG3) {
        for (U32 i=0;i<*pPropertyCount;i++) {
            MarshalVkCooperativeMatrixPropertiesNV::write(cpu->memory, ARG3 + i * 40, &pProperties[i]);
        }
        delete[] pProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t queueFamilyIndex = (uint32_t)ARG2;
    uint32_t tmp_pCounterCount = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pCounterCount = &tmp_pCounterCount;
    VkPerformanceCounterKHR* pCounters = NULL;
    if (ARG4) {
        pCounters = new VkPerformanceCounterKHR[*pCounterCount];
    }
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions = NULL;
    if (ARG5) {
        pCounterDescriptions = new VkPerformanceCounterDescriptionKHR[*pCounterCount];
    }
    EAX = pBoxedInfo->pvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    cpu->memory->writed(ARG3, (U32)tmp_pCounterCount);
    if (ARG4) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterKHR::write(cpu->memory, ARG4 + i * 36, &pCounters[i]);
        }
        delete[] pCounters;
    }
    if (ARG5) {
        for (U32 i=0;i<*pCounterCount;i++) {
            MarshalVkPerformanceCounterDescriptionKHR::write(cpu->memory, ARG5 + i * 780, &pCounterDescriptions[i]);
        }
        delete[] pCounterDescriptions;
    }
}
void vk_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkQueryPoolPerformanceCreateInfoKHR local_pPerformanceQueryCreateInfo(cpu->memory, ARG2);
    VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo = &local_pPerformanceQueryCreateInfo.s;
    uint32_t tmp_pNumPasses = (uint32_t) cpu->memory->readd(ARG3);
    uint32_t* pNumPasses = &tmp_pNumPasses;
    pBoxedInfo->pvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
    cpu->memory->writed(ARG3, (U32)tmp_pNumPasses);
}
// return type: VkResult(4 bytes)
void vk_AcquireProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkAcquireProfilingLockInfoKHR local_pInfo(cpu->memory, ARG2);
    VkAcquireProfilingLockInfoKHR* pInfo = &local_pInfo.s;
    EAX = pBoxedInfo->pvkAcquireProfilingLockKHR(device, pInfo);
}
void vk_ReleaseProfilingLockKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    pBoxedInfo->pvkReleaseProfilingLockKHR(device);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetBufferOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetBufferOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkDeviceAddress(8 bytes)
void vk_GetBufferDeviceAddressEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBufferDeviceAddressInfo local_pInfo(cpu->memory, ARG2);
    VkBufferDeviceAddressInfo* pInfo = &local_pInfo.s;
    VkDeviceAddress result = pBoxedInfo->pvkGetBufferDeviceAddressEXT(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: VkResult(4 bytes)
void vk_CreateHeadlessSurfaceEXT(CPU* cpu) {
    VkInstance instance = (VkInstance)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkHeadlessSurfaceCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkHeadlessSurfaceCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreateHeadlessSurfaceEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkSurfaceKHR tmp_pSurface = (VkSurfaceKHR) cpu->memory->readq(ARG4);
    VkSurfaceKHR* pSurface = &tmp_pSurface;
    EAX = pBoxedInfo->pvkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
    cpu->memory->writeq(ARG4, (U64)tmp_pSurface);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCombinationCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCombinationCount = &tmp_pCombinationCount;
    VkFramebufferMixedSamplesCombinationNV* pCombinations = NULL;
    if (ARG3) {
        pCombinations = new VkFramebufferMixedSamplesCombinationNV[*pCombinationCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
    cpu->memory->writed(ARG2, (U32)tmp_pCombinationCount);
    if (ARG3) {
        for (U32 i=0;i<*pCombinationCount;i++) {
            MarshalVkFramebufferMixedSamplesCombinationNV::write(cpu->memory, ARG3 + i * 24, &pCombinations[i]);
        }
        delete[] pCombinations;
    }
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddress(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
// return type: uint64_t(8 bytes)
void vk_GetDeviceMemoryOpaqueCaptureAddressKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDeviceMemoryOpaqueCaptureAddressInfo local_pInfo(cpu->memory, ARG2);
    VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = &local_pInfo.s;
    uint64_t result = pBoxedInfo->pvkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
    EAX = (U32)result;
    EDX = (U32)(result >> 32);
}
void vk_CmdSetLineStippleEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t lineStippleFactor = (uint32_t)ARG2;
    uint16_t lineStipplePattern = (uint16_t)ARG3;
    pBoxedInfo->pvkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceToolPropertiesEXT(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pToolCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pToolCount = &tmp_pToolCount;
    VkPhysicalDeviceToolPropertiesEXT* pToolProperties = NULL;
    if (ARG3) {
        pToolProperties = new VkPhysicalDeviceToolPropertiesEXT[*pToolCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
    cpu->memory->writed(ARG2, (U32)tmp_pToolCount);
    if (ARG3) {
        for (U32 i=0;i<*pToolCount;i++) {
            MarshalVkPhysicalDeviceToolPropertiesEXT::write(cpu->memory, ARG3 + i * 1036, &pToolProperties[i]);
        }
        delete[] pToolProperties;
    }
}
// return type: VkResult(4 bytes)
void vk_CreateDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    static bool shown; if (!shown && ARG2) { klog("vkCreateDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkDeferredOperationKHR tmp_pDeferredOperation = (VkDeferredOperationKHR) cpu->memory->readq(ARG3);
    VkDeferredOperationKHR* pDeferredOperation = &tmp_pDeferredOperation;
    EAX = pBoxedInfo->pvkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
    cpu->memory->writeq(ARG3, (U64)tmp_pDeferredOperation);
}
void vk_DestroyDeferredOperationKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyDeferredOperationKHR:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyDeferredOperationKHR(device, operation, pAllocator);
}
// return type: uint32_t(4 bytes)
void vk_GetDeferredOperationMaxConcurrencyKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkGetDeferredOperationMaxConcurrencyKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_GetDeferredOperationResultKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkGetDeferredOperationResultKHR(device, operation);
}
// return type: VkResult(4 bytes)
void vk_DeferredOperationJoinKHR(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkDeferredOperationKHR operation = (VkDeferredOperationKHR)cpu->memory->readq(ARG2);
    EAX = pBoxedInfo->pvkDeferredOperationJoinKHR(device, operation);
}
void vk_CmdSetCullModeEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCullModeFlags cullMode = (VkCullModeFlags)ARG2;
    pBoxedInfo->pvkCmdSetCullModeEXT(commandBuffer, cullMode);
}
void vk_CmdSetFrontFaceEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFrontFace frontFace = (VkFrontFace)ARG2;
    pBoxedInfo->pvkCmdSetFrontFaceEXT(commandBuffer, frontFace);
}
void vk_CmdSetPrimitiveTopologyEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrimitiveTopology primitiveTopology = (VkPrimitiveTopology)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
}
void vk_CmdSetViewportWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t viewportCount = (uint32_t)ARG2;
    VkViewport* pViewports = nullptr;
    if (ARG3) {
        pViewports = new VkViewport[viewportCount];
        cpu->memory->memcpy(pViewports, ARG3, (U32)viewportCount * sizeof(VkViewport));
    }
    pBoxedInfo->pvkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
    delete[] pViewports;
}
void vk_CmdSetScissorWithCountEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t scissorCount = (uint32_t)ARG2;
    VkRect2D* pScissors = nullptr;
    if (ARG3) {
        pScissors = new VkRect2D[scissorCount];
        cpu->memory->memcpy(pScissors, ARG3, (U32)scissorCount * sizeof(VkRect2D));
    }
    pBoxedInfo->pvkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
    delete[] pScissors;
}
void vk_CmdBindVertexBuffers2EXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t firstBinding = (uint32_t)ARG2;
    uint32_t bindingCount = (uint32_t)ARG3;
    VkBuffer* pBuffers = nullptr;
    if (ARG4) {
        pBuffers = new VkBuffer[bindingCount];
        cpu->memory->memcpy(pBuffers, ARG4, (U32)bindingCount * sizeof(VkBuffer));
    }
    VkDeviceSize* pOffsets = nullptr;
    if (ARG5) {
        pOffsets = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pOffsets, ARG5, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pSizes = nullptr;
    if (ARG6) {
        pSizes = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pSizes, ARG6, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    VkDeviceSize* pStrides = nullptr;
    if (ARG7) {
        pStrides = new VkDeviceSize[bindingCount];
        cpu->memory->memcpy(pStrides, ARG7, (U32)bindingCount * sizeof(VkDeviceSize));
    }
    pBoxedInfo->pvkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    delete[] pBuffers;
    delete[] pOffsets;
    delete[] pSizes;
    delete[] pStrides;
}
void vk_CmdSetDepthTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
}
void vk_CmdSetDepthWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthWriteEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
}
void vk_CmdSetDepthCompareOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkCompareOp depthCompareOp = (VkCompareOp)ARG2;
    pBoxedInfo->pvkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
}
void vk_CmdSetDepthBoundsTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBoundsTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
}
void vk_CmdSetStencilTestEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 stencilTestEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
}
void vk_CmdSetStencilOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkStencilFaceFlags faceMask = (VkStencilFaceFlags)ARG2;
    VkStencilOp failOp = (VkStencilOp)ARG3;
    VkStencilOp passOp = (VkStencilOp)ARG4;
    VkStencilOp depthFailOp = (VkStencilOp)ARG5;
    VkCompareOp compareOp = (VkCompareOp)ARG6;
    pBoxedInfo->pvkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
void vk_CmdSetPatchControlPointsEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t patchControlPoints = (uint32_t)ARG2;
    pBoxedInfo->pvkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
}
void vk_CmdSetRasterizerDiscardEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 rasterizerDiscardEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
}
void vk_CmdSetDepthBiasEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 depthBiasEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
}
void vk_CmdSetLogicOpEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkLogicOp logicOp = (VkLogicOp)ARG2;
    pBoxedInfo->pvkCmdSetLogicOpEXT(commandBuffer, logicOp);
}
void vk_CmdSetPrimitiveRestartEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkBool32 primitiveRestartEnable = (VkBool32)ARG2;
    pBoxedInfo->pvkCmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
}
// return type: VkResult(4 bytes)
void vk_CreatePrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkPrivateDataSlotCreateInfoEXT local_pCreateInfo(cpu->memory, ARG2);
    VkPrivateDataSlotCreateInfoEXT* pCreateInfo = &local_pCreateInfo.s;
    static bool shown; if (!shown && ARG3) { klog("vkCreatePrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    VkPrivateDataSlotEXT tmp_pPrivateDataSlot = (VkPrivateDataSlotEXT) cpu->memory->readq(ARG4);
    VkPrivateDataSlotEXT* pPrivateDataSlot = &tmp_pPrivateDataSlot;
    EAX = pBoxedInfo->pvkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    cpu->memory->writeq(ARG4, (U64)tmp_pPrivateDataSlot);
}
void vk_DestroyPrivateDataSlotEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)cpu->memory->readq(ARG2);
    static bool shown; if (!shown && ARG3) { klog("vkDestroyPrivateDataSlotEXT:VkAllocationCallbacks not implemented"); shown = true;}
    VkAllocationCallbacks* pAllocator = NULL;
    pBoxedInfo->pvkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
}
// return type: VkResult(4 bytes)
void vk_SetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)cpu->memory->readq(ARG4);
    uint64_t data = (uint64_t)cpu->memory->readq(ARG5);
    EAX = pBoxedInfo->pvkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
}
void vk_GetPrivateDataEXT(CPU* cpu) {
    VkDevice device = (VkDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkObjectType objectType = (VkObjectType)ARG2;
    uint64_t objectHandle = (uint64_t)cpu->memory->readq(ARG3);
    VkPrivateDataSlotEXT privateDataSlot = (VkPrivateDataSlotEXT)cpu->memory->readq(ARG4);
    uint64_t tmp_pData = (uint64_t) cpu->memory->readq(ARG5);
    uint64_t* pData = &tmp_pData;
    pBoxedInfo->pvkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
    cpu->memory->writeq(ARG5, (U64)tmp_pData);
}
void vk_CmdCopyBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferInfo2KHR local_pCopyBufferInfo(cpu->memory, ARG2);
    VkCopyBufferInfo2KHR* pCopyBufferInfo = &local_pCopyBufferInfo.s;
    pBoxedInfo->pvkCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
}
void vk_CmdCopyImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageInfo2KHR local_pCopyImageInfo(cpu->memory, ARG2);
    VkCopyImageInfo2KHR* pCopyImageInfo = &local_pCopyImageInfo.s;
    pBoxedInfo->pvkCmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
}
void vk_CmdBlitImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkBlitImageInfo2KHR local_pBlitImageInfo(cpu->memory, ARG2);
    VkBlitImageInfo2KHR* pBlitImageInfo = &local_pBlitImageInfo.s;
    pBoxedInfo->pvkCmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
}
void vk_CmdCopyBufferToImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyBufferToImageInfo2KHR local_pCopyBufferToImageInfo(cpu->memory, ARG2);
    VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo = &local_pCopyBufferToImageInfo.s;
    pBoxedInfo->pvkCmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
}
void vk_CmdCopyImageToBuffer2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkCopyImageToBufferInfo2KHR local_pCopyImageToBufferInfo(cpu->memory, ARG2);
    VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo = &local_pCopyImageToBufferInfo.s;
    pBoxedInfo->pvkCmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
}
void vk_CmdResolveImage2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkResolveImageInfo2KHR local_pResolveImageInfo(cpu->memory, ARG2);
    VkResolveImageInfo2KHR* pResolveImageInfo = &local_pResolveImageInfo.s;
    pBoxedInfo->pvkCmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
}
void vk_CmdSetFragmentShadingRateKHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkExtent2D tmp_pFragmentSize;
    cpu->memory->memcpy(&tmp_pFragmentSize, ARG2, 8);
    VkExtent2D* pFragmentSize = &tmp_pFragmentSize;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = nullptr;
    if (ARG3) {
        combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
        cpu->memory->memcpy(combinerOps, ARG3, (U32)2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    }
    pBoxedInfo->pvkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
}
// return type: VkResult(4 bytes)
void vk_GetPhysicalDeviceFragmentShadingRatesKHR(CPU* cpu) {
    VkPhysicalDevice physicalDevice = (VkPhysicalDevice)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pFragmentShadingRateCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pFragmentShadingRateCount = &tmp_pFragmentShadingRateCount;
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates = NULL;
    if (ARG3) {
        pFragmentShadingRates = new VkPhysicalDeviceFragmentShadingRateKHR[*pFragmentShadingRateCount];
    }
    EAX = pBoxedInfo->pvkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    cpu->memory->writed(ARG2, (U32)tmp_pFragmentShadingRateCount);
    if (ARG3) {
        for (U32 i=0;i<*pFragmentShadingRateCount;i++) {
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(cpu->memory, ARG3 + i * 20, &pFragmentShadingRates[i]);
        }
        delete[] pFragmentShadingRates;
    }
}
void vk_CmdSetFragmentShadingRateEnumNV(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkFragmentShadingRateNV shadingRate = (VkFragmentShadingRateNV)ARG2;
    static_assert (sizeof(VkFragmentShadingRateCombinerOpKHR) == 4, "unhandled enum size");
    VkFragmentShadingRateCombinerOpKHR* combinerOps = nullptr;
    if (ARG3) {
        combinerOps = new VkFragmentShadingRateCombinerOpKHR[2];
        cpu->memory->memcpy(combinerOps, ARG3, (U32)2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    }
    pBoxedInfo->pvkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
}
void vk_CmdSetVertexInputEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t vertexBindingDescriptionCount = (uint32_t)ARG2;
    VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions = NULL;
    if (ARG3) {
        pVertexBindingDescriptions = new VkVertexInputBindingDescription2EXT[vertexBindingDescriptionCount];
        for (U32 i=0;i<vertexBindingDescriptionCount;i++) {
            MarshalVkVertexInputBindingDescription2EXT::read(cpu->memory, ARG3 + i * 24, &pVertexBindingDescriptions[i]);
        }
    }
    uint32_t vertexAttributeDescriptionCount = (uint32_t)ARG4;
    VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions = NULL;
    if (ARG5) {
        pVertexAttributeDescriptions = new VkVertexInputAttributeDescription2EXT[vertexAttributeDescriptionCount];
        for (U32 i=0;i<vertexAttributeDescriptionCount;i++) {
            MarshalVkVertexInputAttributeDescription2EXT::read(cpu->memory, ARG5 + i * 24, &pVertexAttributeDescriptions[i]);
        }
    }
    pBoxedInfo->pvkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
    if (pVertexBindingDescriptions) {
        delete[] pVertexBindingDescriptions;
    }
    if (pVertexAttributeDescriptions) {
        delete[] pVertexAttributeDescriptions;
    }
}
void vk_CmdSetColorWriteEnableEXT(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t attachmentCount = (uint32_t)ARG2;
    VkBool32* pColorWriteEnables = nullptr;
    if (ARG3) {
        pColorWriteEnables = new VkBool32[attachmentCount];
        cpu->memory->memcpy(pColorWriteEnables, ARG3, (U32)attachmentCount * sizeof(VkBool32));
    }
    pBoxedInfo->pvkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
    delete[] pColorWriteEnables;
}
void vk_CmdSetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    MarshalVkDependencyInfoKHR local_pDependencyInfo(cpu->memory, ARG3);
    VkDependencyInfoKHR* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
}
void vk_CmdResetEvent2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkEvent event = (VkEvent)cpu->memory->readq(ARG2);
    VkPipelineStageFlags2KHR stageMask = (VkPipelineStageFlags2KHR)cpu->memory->readq(ARG3);
    pBoxedInfo->pvkCmdResetEvent2KHR(commandBuffer, event, stageMask);
}
void vk_CmdWaitEvents2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t eventCount = (uint32_t)ARG2;
    VkEvent* pEvents = nullptr;
    if (ARG3) {
        pEvents = new VkEvent[eventCount];
        cpu->memory->memcpy(pEvents, ARG3, (U32)eventCount * sizeof(VkEvent));
    }
    VkDependencyInfoKHR* pDependencyInfos = NULL;
    if (ARG4) {
        pDependencyInfos = new VkDependencyInfoKHR[eventCount];
        for (U32 i=0;i<eventCount;i++) {
            MarshalVkDependencyInfoKHR::read(cpu->memory, ARG4 + i * 36, &pDependencyInfos[i]);
        }
    }
    pBoxedInfo->pvkCmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
    delete[] pEvents;
    if (pDependencyInfos) {
        delete[] pDependencyInfos;
    }
}
void vk_CmdPipelineBarrier2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    MarshalVkDependencyInfoKHR local_pDependencyInfo(cpu->memory, ARG2);
    VkDependencyInfoKHR* pDependencyInfo = &local_pDependencyInfo.s;
    pBoxedInfo->pvkCmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
}
// return type: VkResult(4 bytes)
void vk_QueueSubmit2KHR(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t submitCount = (uint32_t)ARG2;
    VkSubmitInfo2KHR* pSubmits = NULL;
    if (ARG3) {
        pSubmits = new VkSubmitInfo2KHR[submitCount];
        for (U32 i=0;i<submitCount;i++) {
            MarshalVkSubmitInfo2KHR::read(cpu->memory, ARG3 + i * 36, &pSubmits[i]);
        }
    }
    VkFence fence = (VkFence)cpu->memory->readq(ARG4);
    EAX = pBoxedInfo->pvkQueueSubmit2KHR(queue, submitCount, pSubmits, fence);
    if (pSubmits) {
        delete[] pSubmits;
    }
}
void vk_CmdWriteTimestamp2KHR(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2KHR stage = (VkPipelineStageFlags2KHR)cpu->memory->readq(ARG2);
    VkQueryPool queryPool = (VkQueryPool)cpu->memory->readq(ARG3);
    uint32_t query = (uint32_t)ARG4;
    pBoxedInfo->pvkCmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
}
void vk_CmdWriteBufferMarker2AMD(CPU* cpu) {
    VkCommandBuffer commandBuffer = (VkCommandBuffer)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    VkPipelineStageFlags2KHR stage = (VkPipelineStageFlags2KHR)cpu->memory->readq(ARG2);
    VkBuffer dstBuffer = (VkBuffer)cpu->memory->readq(ARG3);
    VkDeviceSize dstOffset = (VkDeviceSize)cpu->memory->readq(ARG4);
    uint32_t marker = (uint32_t)ARG5;
    pBoxedInfo->pvkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
void vk_GetQueueCheckpointData2NV(CPU* cpu) {
    VkQueue queue = (VkQueue)getVulkanPtr(cpu->memory, ARG1);
    BoxedVulkanInfo* pBoxedInfo = getInfoFromHandle(cpu->memory, ARG1);
    uint32_t tmp_pCheckpointDataCount = (uint32_t) cpu->memory->readd(ARG2);
    uint32_t* pCheckpointDataCount = &tmp_pCheckpointDataCount;
    VkCheckpointData2NV* pCheckpointData = NULL;
    if (ARG3) {
        pCheckpointData = new VkCheckpointData2NV[*pCheckpointDataCount];
    }
    pBoxedInfo->pvkGetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
    cpu->memory->writed(ARG2, (U32)tmp_pCheckpointDataCount);
    if (ARG3) {
        for (U32 i=0;i<*pCheckpointDataCount;i++) {
            MarshalVkCheckpointData2NV::write(cpu->memory, ARG3 + i * 20, &pCheckpointData[i]);
        }
        delete[] pCheckpointData;
    }
}
void* vulkanGetNextPtr(KMemory* memory, U32 address) {
    if (address == 0) {
        return NULL;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV* p = new VkPhysicalDeviceCooperativeMatrixFeaturesNV();
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: {
            VkDisplayProperties2KHR* p = new VkDisplayProperties2KHR();
            MarshalVkDisplayProperties2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {
            VkImageViewASTCDecodeModeEXT* p = new VkImageViewASTCDecodeModeEXT();
            MarshalVkImageViewASTCDecodeModeEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            VkExternalMemoryImageCreateInfo* p = new VkExternalMemoryImageCreateInfo();
            MarshalVkExternalMemoryImageCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            VkSemaphoreTypeCreateInfo* p = new VkSemaphoreTypeCreateInfo();
            MarshalVkSemaphoreTypeCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASSS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {
            VkSubpassShadingPipelineCreateInfoHUAWEI* p = new VkSubpassShadingPipelineCreateInfoHUAWEI();
            MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: {
            VkCommandBufferBeginInfo* p = new VkCommandBufferBeginInfo();
            MarshalVkCommandBufferBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            VkPhysicalDeviceSamplerFilterMinmaxProperties* p = new VkPhysicalDeviceSamplerFilterMinmaxProperties();
            MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: {
            VkFenceGetFdInfoKHR* p = new VkFenceGetFdInfoKHR();
            MarshalVkFenceGetFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: {
            VkBlitImageInfo2KHR* p = new VkBlitImageInfo2KHR();
            MarshalVkBlitImageInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {
            VkPhysicalDeviceShadingRateImageFeaturesNV* p = new VkPhysicalDeviceShadingRateImageFeaturesNV();
            MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: {
            VkDescriptorPoolInlineUniformBlockCreateInfoEXT* p = new VkDescriptorPoolInlineUniformBlockCreateInfoEXT();
            MarshalVkDescriptorPoolInlineUniformBlockCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            VkImageStencilUsageCreateInfo* p = new VkImageStencilUsageCreateInfo();
            MarshalVkImageStencilUsageCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {
            VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* p = new VkPhysicalDeviceDeviceMemoryReportFeaturesEXT();
            MarshalVkPhysicalDeviceDeviceMemoryReportFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {
            VkExternalMemoryImageCreateInfoNV* p = new VkExternalMemoryImageCreateInfoNV();
            MarshalVkExternalMemoryImageCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            VkAttachmentDescriptionStencilLayout* p = new VkAttachmentDescriptionStencilLayout();
            MarshalVkAttachmentDescriptionStencilLayout::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: {
            VkRayTracingPipelineCreateInfoNV* p = new VkRayTracingPipelineCreateInfoNV();
            MarshalVkRayTracingPipelineCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: {
            VkImageCreateInfo* p = new VkImageCreateInfo();
            MarshalVkImageCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            VkMemoryDedicatedAllocateInfo* p = new VkMemoryDedicatedAllocateInfo();
            MarshalVkMemoryDedicatedAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            VkProtectedSubmitInfo* p = new VkProtectedSubmitInfo();
            MarshalVkProtectedSubmitInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: {
            VkPerformanceMarkerInfoINTEL* p = new VkPerformanceMarkerInfoINTEL();
            MarshalVkPerformanceMarkerInfoINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* p = new VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE();
            MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: {
            VkPhysicalDeviceShadingRateImagePropertiesNV* p = new VkPhysicalDeviceShadingRateImagePropertiesNV();
            MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: {
            VkDebugUtilsObjectTagInfoEXT* p = new VkDebugUtilsObjectTagInfoEXT();
            MarshalVkDebugUtilsObjectTagInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: {
            VkPhysicalDevicePushDescriptorPropertiesKHR* p = new VkPhysicalDevicePushDescriptorPropertiesKHR();
            MarshalVkPhysicalDevicePushDescriptorPropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: {
            VkSemaphoreSubmitInfoKHR* p = new VkSemaphoreSubmitInfoKHR();
            MarshalVkSemaphoreSubmitInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {
            VkWriteDescriptorSetAccelerationStructureKHR* p = new VkWriteDescriptorSetAccelerationStructureKHR();
            MarshalVkWriteDescriptorSetAccelerationStructureKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            VkPhysicalDeviceShaderFloat16Int8Features* p = new VkPhysicalDeviceShaderFloat16Int8Features();
            MarshalVkPhysicalDeviceShaderFloat16Int8Features::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: {
            VkSubpassDescription2* p = new VkSubpassDescription2();
            MarshalVkSubpassDescription2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* p = new VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();
            MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            VkPhysicalDeviceVulkan12Properties* p = new VkPhysicalDeviceVulkan12Properties();
            MarshalVkPhysicalDeviceVulkan12Properties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: {
            VkPhysicalDeviceSampleLocationsPropertiesEXT* p = new VkPhysicalDeviceSampleLocationsPropertiesEXT();
            MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            VkPhysicalDevicePCIBusInfoPropertiesEXT* p = new VkPhysicalDevicePCIBusInfoPropertiesEXT();
            MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            VkPipelineCreationFeedbackCreateInfoEXT* p = new VkPipelineCreationFeedbackCreateInfoEXT();
            MarshalVkPipelineCreationFeedbackCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* p = new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
            VkBufferMemoryBarrier* p = new VkBufferMemoryBarrier();
            MarshalVkBufferMemoryBarrier::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            VkDeviceGroupSubmitInfo* p = new VkDeviceGroupSubmitInfo();
            MarshalVkDeviceGroupSubmitInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: {
            VkPipelineMultisampleStateCreateInfo* p = new VkPipelineMultisampleStateCreateInfo();
            MarshalVkPipelineMultisampleStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: {
            VkDescriptorUpdateTemplateCreateInfo* p = new VkDescriptorUpdateTemplateCreateInfo();
            MarshalVkDescriptorUpdateTemplateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {
            VkTextureLODGatherFormatPropertiesAMD* p = new VkTextureLODGatherFormatPropertiesAMD();
            MarshalVkTextureLODGatherFormatPropertiesAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: {
            VkExternalBufferProperties* p = new VkExternalBufferProperties();
            MarshalVkExternalBufferProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO: {
            VkSubpassEndInfo* p = new VkSubpassEndInfo();
            MarshalVkSubpassEndInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: {
            VkPipelineShaderStageCreateInfo* p = new VkPipelineShaderStageCreateInfo();
            MarshalVkPipelineShaderStageCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: {
            VkImageViewAddressPropertiesNVX* p = new VkImageViewAddressPropertiesNVX();
            MarshalVkImageViewAddressPropertiesNVX::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            VkDeviceGroupDeviceCreateInfo* p = new VkDeviceGroupDeviceCreateInfo();
            MarshalVkDeviceGroupDeviceCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: {
            VkBufferCreateInfo* p = new VkBufferCreateInfo();
            MarshalVkBufferCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {
            VkBufferDeviceAddressCreateInfoEXT* p = new VkBufferDeviceAddressCreateInfoEXT();
            MarshalVkBufferDeviceAddressCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* p = new VkPhysicalDeviceSubpassShadingPropertiesHUAWEI();
            MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationLineStateCreateInfoEXT* p = new VkPipelineRasterizationLineStateCreateInfoEXT();
            MarshalVkPipelineRasterizationLineStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            VkPhysicalDeviceFeatures2* p = new VkPhysicalDeviceFeatures2();
            MarshalVkPhysicalDeviceFeatures2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: {
            VkImportSemaphoreFdInfoKHR* p = new VkImportSemaphoreFdInfoKHR();
            MarshalVkImportSemaphoreFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: {
            VkAccelerationStructureInfoNV* p = new VkAccelerationStructureInfoNV();
            MarshalVkAccelerationStructureInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: {
            VkPhysicalDeviceShaderCoreProperties2AMD* p = new VkPhysicalDeviceShaderCoreProperties2AMD();
            MarshalVkPhysicalDeviceShaderCoreProperties2AMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {
            VkSwapchainCounterCreateInfoEXT* p = new VkSwapchainCounterCreateInfoEXT();
            MarshalVkSwapchainCounterCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {
            VkRenderPassTransformBeginInfoQCOM* p = new VkRenderPassTransformBeginInfoQCOM();
            MarshalVkRenderPassTransformBeginInfoQCOM::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {
            VkValidationFlagsEXT* p = new VkValidationFlagsEXT();
            MarshalVkValidationFlagsEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* p = new VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
            MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: {
            VkPipelineInfoKHR* p = new VkPipelineInfoKHR();
            MarshalVkPipelineInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: {
            VkSwapchainCreateInfoKHR* p = new VkSwapchainCreateInfoKHR();
            MarshalVkSwapchainCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: {
            VkMemoryHostPointerPropertiesEXT* p = new VkMemoryHostPointerPropertiesEXT();
            MarshalVkMemoryHostPointerPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {
            VkPhysicalDeviceMultiDrawFeaturesEXT* p = new VkPhysicalDeviceMultiDrawFeaturesEXT();
            MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            VkPhysicalDeviceHostQueryResetFeatures* p = new VkPhysicalDeviceHostQueryResetFeatures();
            MarshalVkPhysicalDeviceHostQueryResetFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: {
            VkImageDrmFormatModifierExplicitCreateInfoEXT* p = new VkImageDrmFormatModifierExplicitCreateInfoEXT();
            MarshalVkImageDrmFormatModifierExplicitCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: {
            VkPhysicalDeviceInlineUniformBlockPropertiesEXT* p = new VkPhysicalDeviceInlineUniformBlockPropertiesEXT();
            MarshalVkPhysicalDeviceInlineUniformBlockPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: {
            VkImageMemoryRequirementsInfo2* p = new VkImageMemoryRequirementsInfo2();
            MarshalVkImageMemoryRequirementsInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            VkPhysicalDeviceProtectedMemoryFeatures* p = new VkPhysicalDeviceProtectedMemoryFeatures();
            MarshalVkPhysicalDeviceProtectedMemoryFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            VkPhysicalDeviceVariablePointersFeatures* p = new VkPhysicalDeviceVariablePointersFeatures();
            MarshalVkPhysicalDeviceVariablePointersFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            VkDescriptorSetLayoutBindingFlagsCreateInfo* p = new VkDescriptorSetLayoutBindingFlagsCreateInfo();
            MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
            VkImageMemoryBarrier* p = new VkImageMemoryBarrier();
            MarshalVkImageMemoryBarrier::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            VkPhysicalDeviceVulkan11Features* p = new VkPhysicalDeviceVulkan11Features();
            MarshalVkPhysicalDeviceVulkan11Features::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {
            VkWriteDescriptorSetAccelerationStructureNV* p = new VkWriteDescriptorSetAccelerationStructureNV();
            MarshalVkWriteDescriptorSetAccelerationStructureNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT* p = new VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: {
            VkResolveImageInfo2KHR* p = new VkResolveImageInfo2KHR();
            MarshalVkResolveImageInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: {
            VkMemoryAllocateInfo* p = new VkMemoryAllocateInfo();
            MarshalVkMemoryAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            VkPhysicalDeviceTimelineSemaphoreProperties* p = new VkPhysicalDeviceTimelineSemaphoreProperties();
            MarshalVkPhysicalDeviceTimelineSemaphoreProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: {
            VkCopyImageInfo2KHR* p = new VkCopyImageInfo2KHR();
            MarshalVkCopyImageInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            VkDeviceGroupCommandBufferBeginInfo* p = new VkDeviceGroupCommandBufferBeginInfo();
            MarshalVkDeviceGroupCommandBufferBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            VkBufferOpaqueCaptureAddressCreateInfo* p = new VkBufferOpaqueCaptureAddressCreateInfo();
            MarshalVkBufferOpaqueCaptureAddressCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: {
            VkBufferDeviceAddressInfo* p = new VkBufferDeviceAddressInfo();
            MarshalVkBufferDeviceAddressInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            VkPhysicalDeviceImagelessFramebufferFeatures* p = new VkPhysicalDeviceImagelessFramebufferFeatures();
            MarshalVkPhysicalDeviceImagelessFramebufferFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* p = new VkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
            VkDedicatedAllocationBufferCreateInfoNV* p = new VkDedicatedAllocationBufferCreateInfoNV();
            MarshalVkDedicatedAllocationBufferCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: {
            VkDependencyInfoKHR* p = new VkDependencyInfoKHR();
            MarshalVkDependencyInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: {
            VkCommandBufferInheritanceInfo* p = new VkCommandBufferInheritanceInfo();
            MarshalVkCommandBufferInheritanceInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* p = new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
            MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures* p = new VkPhysicalDeviceSamplerYcbcrConversionFeatures();
            MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: {
            VkAccelerationStructureGeometryTrianglesDataKHR* p = new VkAccelerationStructureGeometryTrianglesDataKHR();
            MarshalVkAccelerationStructureGeometryTrianglesDataKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            VkPhysicalDeviceMultiviewFeatures* p = new VkPhysicalDeviceMultiviewFeatures();
            MarshalVkPhysicalDeviceMultiviewFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: {
            VkPipelineInputAssemblyStateCreateInfo* p = new VkPipelineInputAssemblyStateCreateInfo();
            MarshalVkPipelineInputAssemblyStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            VkPhysicalDeviceShaderCorePropertiesAMD* p = new VkPhysicalDeviceShaderCorePropertiesAMD();
            MarshalVkPhysicalDeviceShaderCorePropertiesAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: {
            VkAttachmentReference2* p = new VkAttachmentReference2();
            MarshalVkAttachmentReference2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: {
            VkMemoryGetFdInfoKHR* p = new VkMemoryGetFdInfoKHR();
            MarshalVkMemoryGetFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
            VkBindSparseInfo* p = new VkBindSparseInfo();
            MarshalVkBindSparseInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* p = new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: {
            VkSurfaceFormat2KHR* p = new VkSurfaceFormat2KHR();
            MarshalVkSurfaceFormat2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            VkMemoryAllocateFlagsInfo* p = new VkMemoryAllocateFlagsInfo();
            MarshalVkMemoryAllocateFlagsInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: {
            VkDisplayModeCreateInfoKHR* p = new VkDisplayModeCreateInfoKHR();
            MarshalVkDisplayModeCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: {
            VkAccelerationStructureCreateInfoNV* p = new VkAccelerationStructureCreateInfoNV();
            MarshalVkAccelerationStructureCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: {
            VkDebugMarkerObjectNameInfoEXT* p = new VkDebugMarkerObjectNameInfoEXT();
            MarshalVkDebugMarkerObjectNameInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: {
            VkSemaphoreGetFdInfoKHR* p = new VkSemaphoreGetFdInfoKHR();
            MarshalVkSemaphoreGetFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: {
            VkAccelerationStructureVersionInfoKHR* p = new VkAccelerationStructureVersionInfoKHR();
            MarshalVkAccelerationStructureVersionInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: {
            VkPerformanceConfigurationAcquireInfoINTEL* p = new VkPerformanceConfigurationAcquireInfoINTEL();
            MarshalVkPerformanceConfigurationAcquireInfoINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT* p = new VkPhysicalDeviceTransformFeedbackFeaturesEXT();
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: {
            VkIndirectCommandsLayoutCreateInfoNV* p = new VkIndirectCommandsLayoutCreateInfoNV();
            MarshalVkIndirectCommandsLayoutCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR* p = new VkPhysicalDeviceFragmentShadingRatePropertiesKHR();
            MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: {
            VkImportFenceFdInfoKHR* p = new VkImportFenceFdInfoKHR();
            MarshalVkImportFenceFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageToColorStateCreateInfoNV* p = new VkPipelineCoverageToColorStateCreateInfoNV();
            MarshalVkPipelineCoverageToColorStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
            VkPipelineColorBlendAdvancedStateCreateInfoEXT* p = new VkPipelineColorBlendAdvancedStateCreateInfoEXT();
            MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* p = new VkPhysicalDeviceSubpassShadingFeaturesHUAWEI();
            MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* p = new VkPhysicalDeviceExtendedDynamicState2FeaturesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            VkPhysicalDevice8BitStorageFeatures* p = new VkPhysicalDevice8BitStorageFeatures();
            MarshalVkPhysicalDevice8BitStorageFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            VkPhysicalDeviceDriverProperties* p = new VkPhysicalDeviceDriverProperties();
            MarshalVkPhysicalDeviceDriverProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
            VkDedicatedAllocationImageCreateInfoNV* p = new VkDedicatedAllocationImageCreateInfoNV();
            MarshalVkDedicatedAllocationImageCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
            VkPipelineDiscardRectangleStateCreateInfoEXT* p = new VkPipelineDiscardRectangleStateCreateInfoEXT();
            MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: {
            VkGeometryAABBNV* p = new VkGeometryAABBNV();
            MarshalVkGeometryAABBNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: {
            VkDisplayEventInfoEXT* p = new VkDisplayEventInfoEXT();
            MarshalVkDisplayEventInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {
            VkQueueFamilyCheckpointPropertiesNV* p = new VkQueueFamilyCheckpointPropertiesNV();
            MarshalVkQueueFamilyCheckpointPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {
            VkQueryPoolPerformanceQueryCreateInfoINTEL* p = new VkQueryPoolPerformanceQueryCreateInfoINTEL();
            MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: {
            VkBindImageMemoryInfo* p = new VkBindImageMemoryInfo();
            MarshalVkBindImageMemoryInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            VkAttachmentReferenceStencilLayout* p = new VkAttachmentReferenceStencilLayout();
            MarshalVkAttachmentReferenceStencilLayout::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            VkShaderModuleValidationCacheCreateInfoEXT* p = new VkShaderModuleValidationCacheCreateInfoEXT();
            MarshalVkShaderModuleValidationCacheCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* p = new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
            MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: {
            VkImageViewHandleInfoNVX* p = new VkImageViewHandleInfoNVX();
            MarshalVkImageViewHandleInfoNVX::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: {
            VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* p = new VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR();
            MarshalVkPhysicalDeviceShaderTerminateInvocationFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR* p = new VkPhysicalDeviceRayTracingPipelineFeaturesKHR();
            MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT* p = new VkPhysicalDeviceDepthClipEnableFeaturesEXT();
            MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            VkSamplerCustomBorderColorCreateInfoEXT* p = new VkSamplerCustomBorderColorCreateInfoEXT();
            MarshalVkSamplerCustomBorderColorCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: {
            VkPipelineDynamicStateCreateInfo* p = new VkPipelineDynamicStateCreateInfo();
            MarshalVkPipelineDynamicStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            VkPhysicalDeviceTimelineSemaphoreFeatures* p = new VkPhysicalDeviceTimelineSemaphoreFeatures();
            MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: {
            VkCuFunctionCreateInfoNVX* p = new VkCuFunctionCreateInfoNVX();
            MarshalVkCuFunctionCreateInfoNVX::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            VkPhysicalDeviceDepthStencilResolveProperties* p = new VkPhysicalDeviceDepthStencilResolveProperties();
            MarshalVkPhysicalDeviceDepthStencilResolveProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {
            VkPipelineViewportSwizzleStateCreateInfoNV* p = new VkPipelineViewportSwizzleStateCreateInfoNV();
            MarshalVkPipelineViewportSwizzleStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: {
            VkPhysicalDeviceSparseImageFormatInfo2* p = new VkPhysicalDeviceSparseImageFormatInfo2();
            MarshalVkPhysicalDeviceSparseImageFormatInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: {
            VkFenceCreateInfo* p = new VkFenceCreateInfo();
            MarshalVkFenceCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* p = new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            VkDeviceGroupSwapchainCreateInfoKHR* p = new VkDeviceGroupSwapchainCreateInfoKHR();
            MarshalVkDeviceGroupSwapchainCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: {
            VkDebugUtilsLabelEXT* p = new VkDebugUtilsLabelEXT();
            MarshalVkDebugUtilsLabelEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: {
            VkPhysicalDeviceInlineUniformBlockFeaturesEXT* p = new VkPhysicalDeviceInlineUniformBlockFeaturesEXT();
            MarshalVkPhysicalDeviceInlineUniformBlockFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: {
            VkPhysicalDeviceImageDrmFormatModifierInfoEXT* p = new VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
            MarshalVkPhysicalDeviceImageDrmFormatModifierInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: {
            VkMultisamplePropertiesEXT* p = new VkMultisamplePropertiesEXT();
            MarshalVkMultisamplePropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            VkPhysicalDeviceShaderClockFeaturesKHR* p = new VkPhysicalDeviceShaderClockFeaturesKHR();
            MarshalVkPhysicalDeviceShaderClockFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: {
            VkImageDrmFormatModifierPropertiesEXT* p = new VkImageDrmFormatModifierPropertiesEXT();
            MarshalVkImageDrmFormatModifierPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            VkPhysicalDeviceVulkanMemoryModelFeatures* p = new VkPhysicalDeviceVulkanMemoryModelFeatures();
            MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: {
            VkEventCreateInfo* p = new VkEventCreateInfo();
            MarshalVkEventCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: {
            VkSubmitInfo2KHR* p = new VkSubmitInfo2KHR();
            MarshalVkSubmitInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* p = new VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR();
            MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD* p = new VkPhysicalDeviceCoherentMemoryFeaturesAMD();
            MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR* p = new VkPhysicalDeviceFragmentShadingRateFeaturesKHR();
            MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: {
            VkImageBlit2KHR* p = new VkImageBlit2KHR();
            MarshalVkImageBlit2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: {
            VkSamplerCreateInfo* p = new VkSamplerCreateInfo();
            MarshalVkSamplerCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* p = new VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT();
            MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            VkBindImageMemoryDeviceGroupInfo* p = new VkBindImageMemoryDeviceGroupInfo();
            MarshalVkBindImageMemoryDeviceGroupInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: {
            VkPhysicalDevicePrivateDataFeaturesEXT* p = new VkPhysicalDevicePrivateDataFeaturesEXT();
            MarshalVkPhysicalDevicePrivateDataFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* p = new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
            MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT* p = new VkPhysicalDeviceMemoryPriorityFeaturesEXT();
            MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: {
            VkSparseImageMemoryRequirements2* p = new VkSparseImageMemoryRequirements2();
            MarshalVkSparseImageMemoryRequirements2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: {
            VkBindBufferMemoryInfo* p = new VkBindBufferMemoryInfo();
            MarshalVkBindBufferMemoryInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {
            VkGraphicsPipelineShaderGroupsCreateInfoNV* p = new VkGraphicsPipelineShaderGroupsCreateInfoNV();
            MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: {
            VkPhysicalDeviceExternalFenceInfo* p = new VkPhysicalDeviceExternalFenceInfo();
            MarshalVkPhysicalDeviceExternalFenceInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: {
            VkConditionalRenderingBeginInfoEXT* p = new VkConditionalRenderingBeginInfoEXT();
            MarshalVkConditionalRenderingBeginInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: {
            VkCopyDescriptorSet* p = new VkCopyDescriptorSet();
            MarshalVkCopyDescriptorSet::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: {
            VkDeviceMemoryOpaqueCaptureAddressInfo* p = new VkDeviceMemoryOpaqueCaptureAddressInfo();
            MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {
            VkPhysicalDeviceCornerSampledImageFeaturesNV* p = new VkPhysicalDeviceCornerSampledImageFeaturesNV();
            MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: {
            VkDescriptorPoolCreateInfo* p = new VkDescriptorPoolCreateInfo();
            MarshalVkDescriptorPoolCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM* p = new VkCommandBufferInheritanceRenderPassTransformInfoQCOM();
            MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: {
            VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* p = new VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT();
            MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT* p = new VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: {
            VkImportMemoryFdInfoKHR* p = new VkImportMemoryFdInfoKHR();
            MarshalVkImportMemoryFdInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: {
            VkAccelerationStructureBuildSizesInfoKHR* p = new VkAccelerationStructureBuildSizesInfoKHR();
            MarshalVkAccelerationStructureBuildSizesInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: {
            VkPrivateDataSlotCreateInfoEXT* p = new VkPrivateDataSlotCreateInfoEXT();
            MarshalVkPrivateDataSlotCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: {
            VkMemoryRequirements2* p = new VkMemoryRequirements2();
            MarshalVkMemoryRequirements2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV* p = new VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
            MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {
            VkRenderPassSampleLocationsBeginInfoEXT* p = new VkRenderPassSampleLocationsBeginInfoEXT();
            MarshalVkRenderPassSampleLocationsBeginInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            VkPhysicalDeviceLineRasterizationFeaturesEXT* p = new VkPhysicalDeviceLineRasterizationFeaturesEXT();
            MarshalVkPhysicalDeviceLineRasterizationFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT* p = new VkPhysicalDeviceCustomBorderColorPropertiesEXT();
            MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            VkPhysicalDevicePointClippingProperties* p = new VkPhysicalDevicePointClippingProperties();
            MarshalVkPhysicalDevicePointClippingProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: {
            VkDeviceQueueCreateInfo* p = new VkDeviceQueueCreateInfo();
            MarshalVkDeviceQueueCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            VkPhysicalDeviceShaderAtomicInt64Features* p = new VkPhysicalDeviceShaderAtomicInt64Features();
            MarshalVkPhysicalDeviceShaderAtomicInt64Features::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: {
            VkPipelineCacheCreateInfo* p = new VkPipelineCacheCreateInfo();
            MarshalVkPipelineCacheCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            VkTimelineSemaphoreSubmitInfo* p = new VkTimelineSemaphoreSubmitInfo();
            MarshalVkTimelineSemaphoreSubmitInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT: {
            VkHdrMetadataEXT* p = new VkHdrMetadataEXT();
            MarshalVkHdrMetadataEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            VkPhysicalDeviceDescriptorIndexingProperties* p = new VkPhysicalDeviceDescriptorIndexingProperties();
            MarshalVkPhysicalDeviceDescriptorIndexingProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            VkRenderPassMultiviewCreateInfo* p = new VkRenderPassMultiviewCreateInfo();
            MarshalVkRenderPassMultiviewCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: {
            VkCopyAccelerationStructureInfoKHR* p = new VkCopyAccelerationStructureInfoKHR();
            MarshalVkCopyAccelerationStructureInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* p = new VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR();
            MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            VkPipelineRasterizationStateStreamCreateInfoEXT* p = new VkPipelineRasterizationStateStreamCreateInfoEXT();
            MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
            VkPipelineSampleLocationsStateCreateInfoEXT* p = new VkPipelineSampleLocationsStateCreateInfoEXT();
            MarshalVkPipelineSampleLocationsStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            VkPhysicalDeviceProtectedMemoryProperties* p = new VkPhysicalDeviceProtectedMemoryProperties();
            MarshalVkPhysicalDeviceProtectedMemoryProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: {
            VkPhysicalDeviceMeshShaderPropertiesNV* p = new VkPhysicalDeviceMeshShaderPropertiesNV();
            MarshalVkPhysicalDeviceMeshShaderPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            VkDescriptorSetVariableDescriptorCountAllocateInfo* p = new VkDescriptorSetVariableDescriptorCountAllocateInfo();
            MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationConservativeStateCreateInfoEXT* p = new VkPipelineRasterizationConservativeStateCreateInfoEXT();
            MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* p = new VkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
            MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: {
            VkCalibratedTimestampInfoEXT* p = new VkCalibratedTimestampInfoEXT();
            MarshalVkCalibratedTimestampInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
            VkDebugUtilsObjectNameInfoEXT* p = new VkDebugUtilsObjectNameInfoEXT();
            MarshalVkDebugUtilsObjectNameInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT* p = new VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
            MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: {
            VkAcquireProfilingLockInfoKHR* p = new VkAcquireProfilingLockInfoKHR();
            MarshalVkAcquireProfilingLockInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {
            VkFilterCubicImageViewImageFormatPropertiesEXT* p = new VkFilterCubicImageViewImageFormatPropertiesEXT();
            MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: {
            VkPhysicalDeviceToolPropertiesEXT* p = new VkPhysicalDeviceToolPropertiesEXT();
            MarshalVkPhysicalDeviceToolPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: {
            VkSwapchainDisplayNativeHdrCreateInfoAMD* p = new VkSwapchainDisplayNativeHdrCreateInfoAMD();
            MarshalVkSwapchainDisplayNativeHdrCreateInfoAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: {
            VkImageResolve2KHR* p = new VkImageResolve2KHR();
            MarshalVkImageResolve2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: {
            VkPerformanceOverrideInfoINTEL* p = new VkPerformanceOverrideInfoINTEL();
            MarshalVkPerformanceOverrideInfoINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR* p = new VkPhysicalDeviceAccelerationStructurePropertiesKHR();
            MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: {
            VkSparseImageFormatProperties2* p = new VkSparseImageFormatProperties2();
            MarshalVkSparseImageFormatProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: {
            VkSharedPresentSurfaceCapabilitiesKHR* p = new VkSharedPresentSurfaceCapabilitiesKHR();
            MarshalVkSharedPresentSurfaceCapabilitiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* p = new VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT();
            MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {
            VkPipelineViewportExclusiveScissorStateCreateInfoNV* p = new VkPipelineViewportExclusiveScissorStateCreateInfoNV();
            MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {
            VkDeviceDiagnosticsConfigCreateInfoNV* p = new VkDeviceDiagnosticsConfigCreateInfoNV();
            MarshalVkDeviceDiagnosticsConfigCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* p = new VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: {
            VkAccelerationStructureGeometryKHR* p = new VkAccelerationStructureGeometryKHR();
            MarshalVkAccelerationStructureGeometryKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT* p = new VkPhysicalDeviceCustomBorderColorFeaturesEXT();
            MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {
            VkPipelineRasterizationStateRasterizationOrderAMD* p = new VkPipelineRasterizationStateRasterizationOrderAMD();
            MarshalVkPipelineRasterizationStateRasterizationOrderAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV* p = new VkPhysicalDeviceInheritedViewportScissorFeaturesNV();
            MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_APPLICATION_INFO: {
            VkApplicationInfo* p = new VkApplicationInfo();
            MarshalVkApplicationInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: {
            VkSurfaceProtectedCapabilitiesKHR* p = new VkSurfaceProtectedCapabilitiesKHR();
            MarshalVkSurfaceProtectedCapabilitiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: {
            VkPipelineRasterizationStateCreateInfo* p = new VkPipelineRasterizationStateCreateInfo();
            MarshalVkPipelineRasterizationStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            VkPhysicalDeviceShaderDrawParametersFeatures* p = new VkPhysicalDeviceShaderDrawParametersFeatures();
            MarshalVkPhysicalDeviceShaderDrawParametersFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV* p = new VkPhysicalDeviceCoverageReductionModeFeaturesNV();
            MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            VkPhysicalDeviceProvokingVertexFeaturesEXT* p = new VkPhysicalDeviceProvokingVertexFeaturesEXT();
            MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            VkPhysicalDeviceSubgroupProperties* p = new VkPhysicalDeviceSubgroupProperties();
            MarshalVkPhysicalDeviceSubgroupProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* p = new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
            MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: {
            VkGeneratedCommandsMemoryRequirementsInfoNV* p = new VkGeneratedCommandsMemoryRequirementsInfoNV();
            MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* p = new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
            MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: {
            VkRenderPassCreateInfo2* p = new VkRenderPassCreateInfo2();
            MarshalVkRenderPassCreateInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: {
            VkPhysicalDeviceExternalSemaphoreInfo* p = new VkPhysicalDeviceExternalSemaphoreInfo();
            MarshalVkPhysicalDeviceExternalSemaphoreInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: {
            VkAccelerationStructureGeometryInstancesDataKHR* p = new VkAccelerationStructureGeometryInstancesDataKHR();
            MarshalVkAccelerationStructureGeometryInstancesDataKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* p = new VkPhysicalDeviceRayTracingMotionBlurFeaturesNV();
            MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: {
            VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* p = new VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT();
            MarshalVkPhysicalDeviceTexelBufferAlignmentPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            VkMemoryDedicatedRequirements* p = new VkMemoryDedicatedRequirements();
            MarshalVkMemoryDedicatedRequirements::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            VkPhysicalDeviceProvokingVertexPropertiesEXT* p = new VkPhysicalDeviceProvokingVertexPropertiesEXT();
            MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT* p = new VkPhysicalDeviceDiscardRectanglePropertiesEXT();
            MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageReductionStateCreateInfoNV* p = new VkPipelineCoverageReductionStateCreateInfoNV();
            MarshalVkPipelineCoverageReductionStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: {
            VkMemoryFdPropertiesKHR* p = new VkMemoryFdPropertiesKHR();
            MarshalVkMemoryFdPropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: {
            VkSamplerYcbcrConversionCreateInfo* p = new VkSamplerYcbcrConversionCreateInfo();
            MarshalVkSamplerYcbcrConversionCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* p = new VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT();
            MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: {
            VkBufferMemoryBarrier2KHR* p = new VkBufferMemoryBarrier2KHR();
            MarshalVkBufferMemoryBarrier2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: {
            VkDisplayPlaneCapabilities2KHR* p = new VkDisplayPlaneCapabilities2KHR();
            MarshalVkDisplayPlaneCapabilities2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {
            VkCommandBufferInheritanceViewportScissorInfoNV* p = new VkCommandBufferInheritanceViewportScissorInfoNV();
            MarshalVkCommandBufferInheritanceViewportScissorInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: {
            VkPhysicalDeviceRayTracingPropertiesNV* p = new VkPhysicalDeviceRayTracingPropertiesNV();
            MarshalVkPhysicalDeviceRayTracingPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: {
            VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* p = new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
            MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* p = new VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: {
            VkInstanceCreateInfo* p = new VkInstanceCreateInfo();
            MarshalVkInstanceCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
            VkPhysicalDeviceLineRasterizationPropertiesEXT* p = new VkPhysicalDeviceLineRasterizationPropertiesEXT();
            MarshalVkPhysicalDeviceLineRasterizationPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: {
            VkDisplayPlaneProperties2KHR* p = new VkDisplayPlaneProperties2KHR();
            MarshalVkDisplayPlaneProperties2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: {
            VkDescriptorSetLayoutSupport* p = new VkDescriptorSetLayoutSupport();
            MarshalVkDescriptorSetLayoutSupport::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT* p = new VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
            MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: {
            VkSemaphoreSignalInfo* p = new VkSemaphoreSignalInfo();
            MarshalVkSemaphoreSignalInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: {
            VkBufferViewCreateInfo* p = new VkBufferViewCreateInfo();
            MarshalVkBufferViewCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {
            VkPerformanceQuerySubmitInfoKHR* p = new VkPerformanceQuerySubmitInfoKHR();
            MarshalVkPerformanceQuerySubmitInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: {
            VkBufferMemoryRequirementsInfo2* p = new VkBufferMemoryRequirementsInfo2();
            MarshalVkBufferMemoryRequirementsInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {
            VkExportMemoryAllocateInfoNV* p = new VkExportMemoryAllocateInfoNV();
            MarshalVkExportMemoryAllocateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
            VkMemoryPriorityAllocateInfoEXT* p = new VkMemoryPriorityAllocateInfoEXT();
            MarshalVkMemoryPriorityAllocateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: {
            VkAttachmentDescription2* p = new VkAttachmentDescription2();
            MarshalVkAttachmentDescription2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            VkBindBufferMemoryDeviceGroupInfo* p = new VkBindBufferMemoryDeviceGroupInfo();
            MarshalVkBindBufferMemoryDeviceGroupInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: {
            VkPipelineVertexInputStateCreateInfo* p = new VkPipelineVertexInputStateCreateInfo();
            MarshalVkPipelineVertexInputStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            VkExportMemoryAllocateInfo* p = new VkExportMemoryAllocateInfo();
            MarshalVkExportMemoryAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: {
            VkAccelerationStructureMemoryRequirementsInfoNV* p = new VkAccelerationStructureMemoryRequirementsInfoNV();
            MarshalVkAccelerationStructureMemoryRequirementsInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: {
            VkAccelerationStructureDeviceAddressInfoKHR* p = new VkAccelerationStructureDeviceAddressInfoKHR();
            MarshalVkAccelerationStructureDeviceAddressInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
            VkMemoryBarrier* p = new VkMemoryBarrier();
            MarshalVkMemoryBarrier::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
            VkSemaphoreWaitInfo* p = new VkSemaphoreWaitInfo();
            MarshalVkSemaphoreWaitInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT* p = new VkPhysicalDeviceColorWriteEnableFeaturesEXT();
            MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT* p = new VkPhysicalDeviceMemoryBudgetPropertiesEXT();
            MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            VkPhysicalDevice4444FormatsFeaturesEXT* p = new VkPhysicalDevice4444FormatsFeaturesEXT();
            MarshalVkPhysicalDevice4444FormatsFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: {
            VkExternalFenceProperties* p = new VkExternalFenceProperties();
            MarshalVkExternalFenceProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* p = new VkPipelineRasterizationProvokingVertexStateCreateInfoEXT();
            MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT* p = new VkPhysicalDeviceTransformFeedbackPropertiesEXT();
            MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            VkPhysicalDeviceIDProperties* p = new VkPhysicalDeviceIDProperties();
            MarshalVkPhysicalDeviceIDProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: {
            VkPerformanceStreamMarkerInfoINTEL* p = new VkPerformanceStreamMarkerInfoINTEL();
            MarshalVkPerformanceStreamMarkerInfoINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV* p = new VkPhysicalDeviceCooperativeMatrixPropertiesNV();
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            VkSamplerReductionModeCreateInfo* p = new VkSamplerReductionModeCreateInfo();
            MarshalVkSamplerReductionModeCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: {
            VkGeneratedCommandsInfoNV* p = new VkGeneratedCommandsInfoNV();
            MarshalVkGeneratedCommandsInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
            VkPipelineFragmentShadingRateStateCreateInfoKHR* p = new VkPipelineFragmentShadingRateStateCreateInfoKHR();
            MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: {
            VkPipelineExecutableInternalRepresentationKHR* p = new VkPipelineExecutableInternalRepresentationKHR();
            MarshalVkPipelineExecutableInternalRepresentationKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: {
            VkBindAccelerationStructureMemoryInfoNV* p = new VkBindAccelerationStructureMemoryInfoNV();
            MarshalVkBindAccelerationStructureMemoryInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            VkExportSemaphoreCreateInfo* p = new VkExportSemaphoreCreateInfo();
            MarshalVkExportSemaphoreCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: {
            VkCopyAccelerationStructureToMemoryInfoKHR* p = new VkCopyAccelerationStructureToMemoryInfoKHR();
            MarshalVkCopyAccelerationStructureToMemoryInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            VkExternalImageFormatProperties* p = new VkExternalImageFormatProperties();
            MarshalVkExternalImageFormatProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: {
            VkFormatProperties2* p = new VkFormatProperties2();
            MarshalVkFormatProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures* p = new VkPhysicalDeviceUniformBufferStandardLayoutFeatures();
            MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: {
            VkPhysicalDevicePerformanceQueryPropertiesKHR* p = new VkPhysicalDevicePerformanceQueryPropertiesKHR();
            MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: {
            VkImageDrmFormatModifierListCreateInfoEXT* p = new VkImageDrmFormatModifierListCreateInfoEXT();
            MarshalVkImageDrmFormatModifierListCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: {
            VkVertexInputBindingDescription2EXT* p = new VkVertexInputBindingDescription2EXT();
            MarshalVkVertexInputBindingDescription2EXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: {
            VkSurfaceCapabilities2EXT* p = new VkSurfaceCapabilities2EXT();
            MarshalVkSurfaceCapabilities2EXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            VkPipelineTessellationDomainOriginStateCreateInfo* p = new VkPipelineTessellationDomainOriginStateCreateInfo();
            MarshalVkPipelineTessellationDomainOriginStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            VkSamplerYcbcrConversionInfo* p = new VkSamplerYcbcrConversionInfo();
            MarshalVkSamplerYcbcrConversionInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {
            VkAccelerationStructureMotionInfoNV* p = new VkAccelerationStructureMotionInfoNV();
            MarshalVkAccelerationStructureMotionInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {
            VkCopyCommandTransformInfoQCOM* p = new VkCopyCommandTransformInfoQCOM();
            MarshalVkCopyCommandTransformInfoQCOM::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            VkExternalMemoryBufferCreateInfo* p = new VkExternalMemoryBufferCreateInfo();
            MarshalVkExternalMemoryBufferCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: {
            VkPhysicalDeviceProperties2* p = new VkPhysicalDeviceProperties2();
            MarshalVkPhysicalDeviceProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: {
            VkGraphicsShaderGroupCreateInfoNV* p = new VkGraphicsShaderGroupCreateInfoNV();
            MarshalVkGraphicsShaderGroupCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            VkPhysicalDeviceVulkan11Properties* p = new VkPhysicalDeviceVulkan11Properties();
            MarshalVkPhysicalDeviceVulkan11Properties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            VkPhysicalDeviceBufferDeviceAddressFeatures* p = new VkPhysicalDeviceBufferDeviceAddressFeatures();
            MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR* p = new VkPhysicalDeviceRayTracingPipelinePropertiesKHR();
            MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: {
            VkPhysicalDeviceImageFormatInfo2* p = new VkPhysicalDeviceImageFormatInfo2();
            MarshalVkPhysicalDeviceImageFormatInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            VkPresentRegionsKHR* p = new VkPresentRegionsKHR();
            MarshalVkPresentRegionsKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: {
            VkPhysicalDeviceExternalBufferInfo* p = new VkPhysicalDeviceExternalBufferInfo();
            MarshalVkPhysicalDeviceExternalBufferInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: {
            VkPhysicalDeviceDrmPropertiesEXT* p = new VkPhysicalDeviceDrmPropertiesEXT();
            MarshalVkPhysicalDeviceDrmPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: {
            VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* p = new VkPhysicalDeviceSubgroupSizeControlPropertiesEXT();
            MarshalVkPhysicalDeviceSubgroupSizeControlPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {
            VkPhysicalDeviceMeshShaderFeaturesNV* p = new VkPhysicalDeviceMeshShaderFeaturesNV();
            MarshalVkPhysicalDeviceMeshShaderFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: {
            VkPhysicalDeviceMemoryProperties2* p = new VkPhysicalDeviceMemoryProperties2();
            MarshalVkPhysicalDeviceMemoryProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: {
            VkDeviceQueueInfo2* p = new VkDeviceQueueInfo2();
            MarshalVkDeviceQueueInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            VkPhysicalDeviceExternalImageFormatInfo* p = new VkPhysicalDeviceExternalImageFormatInfo();
            MarshalVkPhysicalDeviceExternalImageFormatInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            VkDeviceGroupRenderPassBeginInfo* p = new VkDeviceGroupRenderPassBeginInfo();
            MarshalVkDeviceGroupRenderPassBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: {
            VkExternalSemaphoreProperties* p = new VkExternalSemaphoreProperties();
            MarshalVkExternalSemaphoreProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* p = new VkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
            MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: {
            VkDeviceQueueGlobalPriorityCreateInfoEXT* p = new VkDeviceQueueGlobalPriorityCreateInfoEXT();
            MarshalVkDeviceQueueGlobalPriorityCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            VkCooperativeMatrixPropertiesNV* p = new VkCooperativeMatrixPropertiesNV();
            MarshalVkCooperativeMatrixPropertiesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: {
            VkCopyImageToBufferInfo2KHR* p = new VkCopyImageToBufferInfo2KHR();
            MarshalVkCopyImageToBufferInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: {
            VkIndirectCommandsLayoutTokenNV* p = new VkIndirectCommandsLayoutTokenNV();
            MarshalVkIndirectCommandsLayoutTokenNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: {
            VkRayTracingShaderGroupCreateInfoNV* p = new VkRayTracingShaderGroupCreateInfoNV();
            MarshalVkRayTracingShaderGroupCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: {
            VkDeviceGroupPresentCapabilitiesKHR* p = new VkDeviceGroupPresentCapabilitiesKHR();
            MarshalVkDeviceGroupPresentCapabilitiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: {
            VkPipelineColorBlendStateCreateInfo* p = new VkPipelineColorBlendStateCreateInfo();
            MarshalVkPipelineColorBlendStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {
            VkValidationFeaturesEXT* p = new VkValidationFeaturesEXT();
            MarshalVkValidationFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: {
            VkPerformanceCounterKHR* p = new VkPerformanceCounterKHR();
            MarshalVkPerformanceCounterKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: {
            VkRenderPassBeginInfo* p = new VkRenderPassBeginInfo();
            MarshalVkRenderPassBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            VkPhysicalDeviceMaintenance3Properties* p = new VkPhysicalDeviceMaintenance3Properties();
            MarshalVkPhysicalDeviceMaintenance3Properties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            VkImageSwapchainCreateInfoKHR* p = new VkImageSwapchainCreateInfoKHR();
            MarshalVkImageSwapchainCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {
            VkPhysicalDeviceRobustness2FeaturesEXT* p = new VkPhysicalDeviceRobustness2FeaturesEXT();
            MarshalVkPhysicalDeviceRobustness2FeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: {
            VkDisplayModeProperties2KHR* p = new VkDisplayModeProperties2KHR();
            MarshalVkDisplayModeProperties2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            VkPhysicalDeviceVulkan12Features* p = new VkPhysicalDeviceVulkan12Features();
            MarshalVkPhysicalDeviceVulkan12Features::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: {
            VkImageViewCreateInfo* p = new VkImageViewCreateInfo();
            MarshalVkImageViewCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: {
            VkDebugMarkerMarkerInfoEXT* p = new VkDebugMarkerMarkerInfoEXT();
            MarshalVkDebugMarkerMarkerInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_NV: {
            VkGeometryNV* p = new VkGeometryNV();
            MarshalVkGeometryNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: {
            VkDeviceEventInfoEXT* p = new VkDeviceEventInfoEXT();
            MarshalVkDeviceEventInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: {
            VkAcquireNextImageInfoKHR* p = new VkAcquireNextImageInfoKHR();
            MarshalVkAcquireNextImageInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* p = new VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
            MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: {
            VkPipelineExecutableInfoKHR* p = new VkPipelineExecutableInfoKHR();
            MarshalVkPipelineExecutableInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: {
            VkDisplaySurfaceCreateInfoKHR* p = new VkDisplaySurfaceCreateInfoKHR();
            MarshalVkDisplaySurfaceCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            VkQueueFamilyCheckpointProperties2NV* p = new VkQueueFamilyCheckpointProperties2NV();
            MarshalVkQueueFamilyCheckpointProperties2NV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: {
            VkPhysicalDeviceRobustness2PropertiesEXT* p = new VkPhysicalDeviceRobustness2PropertiesEXT();
            MarshalVkPhysicalDeviceRobustness2PropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: {
            VkSemaphoreCreateInfo* p = new VkSemaphoreCreateInfo();
            MarshalVkSemaphoreCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: {
            VkDebugMarkerObjectTagInfoEXT* p = new VkDebugMarkerObjectTagInfoEXT();
            MarshalVkDebugMarkerObjectTagInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* p = new VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
            MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
            VkPipelineColorWriteCreateInfoEXT* p = new VkPipelineColorWriteCreateInfoEXT();
            MarshalVkPipelineColorWriteCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
            VkPipelineLayoutCreateInfo* p = new VkPipelineLayoutCreateInfo();
            MarshalVkPipelineLayoutCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: {
            VkAccelerationStructureCreateInfoKHR* p = new VkAccelerationStructureCreateInfoKHR();
            MarshalVkAccelerationStructureCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: {
            VkMemoryBarrier2KHR* p = new VkMemoryBarrier2KHR();
            MarshalVkMemoryBarrier2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: {
            VkCommandPoolCreateInfo* p = new VkCommandPoolCreateInfo();
            MarshalVkCommandPoolCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            VkPhysicalDeviceScalarBlockLayoutFeatures* p = new VkPhysicalDeviceScalarBlockLayoutFeatures();
            MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
            VkDescriptorSetLayoutCreateInfo* p = new VkDescriptorSetLayoutCreateInfo();
            MarshalVkDescriptorSetLayoutCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {
            VkDeviceMemoryOverallocationCreateInfoAMD* p = new VkDeviceMemoryOverallocationCreateInfoAMD();
            MarshalVkDeviceMemoryOverallocationCreateInfoAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: {
            VkPresentTimesInfoGOOGLE* p = new VkPresentTimesInfoGOOGLE();
            MarshalVkPresentTimesInfoGOOGLE::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            VkDeviceGroupPresentInfoKHR* p = new VkDeviceGroupPresentInfoKHR();
            MarshalVkDeviceGroupPresentInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            VkFragmentShadingRateAttachmentInfoKHR* p = new VkFragmentShadingRateAttachmentInfoKHR();
            MarshalVkFragmentShadingRateAttachmentInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: {
            VkPipelineViewportStateCreateInfo* p = new VkPipelineViewportStateCreateInfo();
            MarshalVkPipelineViewportStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: {
            VkRenderPassCreateInfo* p = new VkRenderPassCreateInfo();
            MarshalVkRenderPassCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            VkPipelineRasterizationDepthClipStateCreateInfoEXT* p = new VkPipelineRasterizationDepthClipStateCreateInfoEXT();
            MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: {
            VkSurfaceCapabilities2KHR* p = new VkSurfaceCapabilities2KHR();
            MarshalVkSurfaceCapabilities2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: {
            VkCommandBufferAllocateInfo* p = new VkCommandBufferAllocateInfo();
            MarshalVkCommandBufferAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
            VkDebugUtilsMessengerCallbackDataEXT* p = new VkDebugUtilsMessengerCallbackDataEXT();
            MarshalVkDebugUtilsMessengerCallbackDataEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: {
            VkBufferImageCopy2KHR* p = new VkBufferImageCopy2KHR();
            MarshalVkBufferImageCopy2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            VkDeviceGroupBindSparseInfo* p = new VkDeviceGroupBindSparseInfo();
            MarshalVkDeviceGroupBindSparseInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            VkSamplerYcbcrConversionImageFormatProperties* p = new VkSamplerYcbcrConversionImageFormatProperties();
            MarshalVkSamplerYcbcrConversionImageFormatProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: {
            VkPhysicalDeviceImageRobustnessFeaturesEXT* p = new VkPhysicalDeviceImageRobustnessFeaturesEXT();
            MarshalVkPhysicalDeviceImageRobustnessFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            VkValidationCacheCreateInfoEXT* p = new VkValidationCacheCreateInfoEXT();
            MarshalVkValidationCacheCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            VkPhysicalDeviceFloatControlsProperties* p = new VkPhysicalDeviceFloatControlsProperties();
            MarshalVkPhysicalDeviceFloatControlsProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: {
            VkSubpassDependency2* p = new VkSubpassDependency2();
            MarshalVkSubpassDependency2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV* p = new VkPhysicalDeviceShaderImageFootprintFeaturesNV();
            MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR* p = new VkPhysicalDeviceAccelerationStructureFeaturesKHR();
            MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: {
            VkSubpassBeginInfo* p = new VkSubpassBeginInfo();
            MarshalVkSubpassBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
            VkGraphicsPipelineCreateInfo* p = new VkGraphicsPipelineCreateInfo();
            MarshalVkGraphicsPipelineCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: {
            VkDeviceCreateInfo* p = new VkDeviceCreateInfo();
            MarshalVkDeviceCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
            VkFramebufferCreateInfo* p = new VkFramebufferCreateInfo();
            MarshalVkFramebufferCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
            VkDedicatedAllocationMemoryAllocateInfoNV* p = new VkDedicatedAllocationMemoryAllocateInfoNV();
            MarshalVkDedicatedAllocationMemoryAllocateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {
            VkPipelineViewportWScalingStateCreateInfoNV* p = new VkPipelineViewportWScalingStateCreateInfoNV();
            MarshalVkPipelineViewportWScalingStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: {
            VkDisplayPowerInfoEXT* p = new VkDisplayPowerInfoEXT();
            MarshalVkDisplayPowerInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: {
            VkQueryPoolCreateInfo* p = new VkQueryPoolCreateInfo();
            MarshalVkQueryPoolCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: {
            VkImageFormatProperties2* p = new VkImageFormatProperties2();
            MarshalVkImageFormatProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            VkExportFenceCreateInfo* p = new VkExportFenceCreateInfo();
            MarshalVkExportFenceCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: {
            VkDrmFormatModifierPropertiesListEXT* p = new VkDrmFormatModifierPropertiesListEXT();
            MarshalVkDrmFormatModifierPropertiesListEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: {
            VkMappedMemoryRange* p = new VkMappedMemoryRange();
            MarshalVkMappedMemoryRange::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* p = new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
            MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {
            VkPhysicalDeviceRayQueryFeaturesKHR* p = new VkPhysicalDeviceRayQueryFeaturesKHR();
            MarshalVkPhysicalDeviceRayQueryFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: {
            VkCommandBufferSubmitInfoKHR* p = new VkCommandBufferSubmitInfoKHR();
            MarshalVkCommandBufferSubmitInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* p = new VkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
            MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: {
            VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* p = new VkPhysicalDeviceSubgroupSizeControlFeaturesEXT();
            MarshalVkPhysicalDeviceSubgroupSizeControlFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* p = new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
            MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: {
            VkCopyMemoryToAccelerationStructureInfoKHR* p = new VkCopyMemoryToAccelerationStructureInfoKHR();
            MarshalVkCopyMemoryToAccelerationStructureInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
            VkDescriptorSetAllocateInfo* p = new VkDescriptorSetAllocateInfo();
            MarshalVkDescriptorSetAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {
            VkQueryPoolPerformanceCreateInfoKHR* p = new VkQueryPoolPerformanceCreateInfoKHR();
            MarshalVkQueryPoolPerformanceCreateInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: {
            VkPhysicalDeviceMultiDrawPropertiesEXT* p = new VkPhysicalDeviceMultiDrawPropertiesEXT();
            MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {
            VkRenderPassFragmentDensityMapCreateInfoEXT* p = new VkRenderPassFragmentDensityMapCreateInfoEXT();
            MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
            VkPhysicalDevicePerformanceQueryFeaturesKHR* p = new VkPhysicalDevicePerformanceQueryFeaturesKHR();
            MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
            VkPhysicalDeviceASTCDecodeFeaturesEXT* p = new VkPhysicalDeviceASTCDecodeFeaturesEXT();
            MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {
            VkPipelineCompilerControlCreateInfoAMD* p = new VkPipelineCompilerControlCreateInfoAMD();
            MarshalVkPipelineCompilerControlCreateInfoAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: {
            VkWriteDescriptorSetInlineUniformBlockEXT* p = new VkWriteDescriptorSetInlineUniformBlockEXT();
            MarshalVkWriteDescriptorSetInlineUniformBlockEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            VkPhysicalDeviceMultiviewProperties* p = new VkPhysicalDeviceMultiviewProperties();
            MarshalVkPhysicalDeviceMultiviewProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {
            VkDisplayPresentInfoKHR* p = new VkDisplayPresentInfoKHR();
            MarshalVkDisplayPresentInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: {
            VkPhysicalDeviceSynchronization2FeaturesKHR* p = new VkPhysicalDeviceSynchronization2FeaturesKHR();
            MarshalVkPhysicalDeviceSynchronization2FeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {
            VkPipelineCoverageModulationStateCreateInfoNV* p = new VkPipelineCoverageModulationStateCreateInfoNV();
            MarshalVkPipelineCoverageModulationStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: {
            VkPipelineDepthStencilStateCreateInfo* p = new VkPipelineDepthStencilStateCreateInfo();
            MarshalVkPipelineDepthStencilStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: {
            VkDisplayPlaneInfo2KHR* p = new VkDisplayPlaneInfo2KHR();
            MarshalVkDisplayPlaneInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {
            VkSampleLocationsInfoEXT* p = new VkSampleLocationsInfoEXT();
            MarshalVkSampleLocationsInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {
            VkPipelineViewportShadingRateImageStateCreateInfoNV* p = new VkPipelineViewportShadingRateImageStateCreateInfoNV();
            MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            VkMemoryOpaqueCaptureAddressAllocateInfo* p = new VkMemoryOpaqueCaptureAddressAllocateInfo();
            MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: {
            VkPhysicalDeviceFragmentShadingRateKHR* p = new VkPhysicalDeviceFragmentShadingRateKHR();
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
            VkPresentInfoKHR* p = new VkPresentInfoKHR();
            MarshalVkPresentInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            VkImageFormatListCreateInfo* p = new VkImageFormatListCreateInfo();
            MarshalVkImageFormatListCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: {
            VkPhysicalDeviceGroupProperties* p = new VkPhysicalDeviceGroupProperties();
            MarshalVkPhysicalDeviceGroupProperties::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
            VkComputePipelineCreateInfo* p = new VkComputePipelineCreateInfo();
            MarshalVkComputePipelineCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
            VkWriteDescriptorSet* p = new VkWriteDescriptorSet();
            MarshalVkWriteDescriptorSet::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* p = new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
            MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {
            VkPhysicalDeviceExclusiveScissorFeaturesNV* p = new VkPhysicalDeviceExclusiveScissorFeaturesNV();
            MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: {
            VkImageMemoryBarrier2KHR* p = new VkImageMemoryBarrier2KHR();
            MarshalVkImageMemoryBarrier2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: {
            VkAccelerationStructureGeometryAabbsDataKHR* p = new VkAccelerationStructureGeometryAabbsDataKHR();
            MarshalVkAccelerationStructureGeometryAabbsDataKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* p = new VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT();
            MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            VkBindImagePlaneMemoryInfo* p = new VkBindImagePlaneMemoryInfo();
            MarshalVkBindImagePlaneMemoryInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {
            VkPhysicalDeviceImageViewImageFormatInfoEXT* p = new VkPhysicalDeviceImageViewImageFormatInfoEXT();
            MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: {
            VkQueueFamilyProperties2* p = new VkQueueFamilyProperties2();
            MarshalVkQueueFamilyProperties2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: {
            VkCopyBufferInfo2KHR* p = new VkCopyBufferInfo2KHR();
            MarshalVkCopyBufferInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: {
            VkPhysicalDeviceSurfaceInfo2KHR* p = new VkPhysicalDeviceSurfaceInfo2KHR();
            MarshalVkPhysicalDeviceSurfaceInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: {
            VkCopyBufferToImageInfo2KHR* p = new VkCopyBufferToImageInfo2KHR();
            MarshalVkCopyBufferToImageInfo2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            VkFramebufferAttachmentsCreateInfo* p = new VkFramebufferAttachmentsCreateInfo();
            MarshalVkFramebufferAttachmentsCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {
            VkAccelerationStructureGeometryMotionTrianglesDataNV* p = new VkAccelerationStructureGeometryMotionTrianglesDataNV();
            MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: {
            VkPipelineTessellationStateCreateInfo* p = new VkPipelineTessellationStateCreateInfo();
            MarshalVkPipelineTessellationStateCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* p = new VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
            MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* p = new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
            MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV* p = new VkPipelineFragmentShadingRateEnumStateCreateInfoNV();
            MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: {
            VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* p = new VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT();
            MarshalVkPhysicalDeviceGlobalPriorityQueryFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            VkImageViewUsageCreateInfo* p = new VkImageViewUsageCreateInfo();
            MarshalVkImageViewUsageCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: {
            VkDeviceMemoryReportCallbackDataEXT* p = new VkDeviceMemoryReportCallbackDataEXT();
            MarshalVkDeviceMemoryReportCallbackDataEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: {
            VkMutableDescriptorTypeCreateInfoVALVE* p = new VkMutableDescriptorTypeCreateInfoVALVE();
            MarshalVkMutableDescriptorTypeCreateInfoVALVE::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: {
            VkPipelineVertexInputDivisorStateCreateInfoEXT* p = new VkPipelineVertexInputDivisorStateCreateInfoEXT();
            MarshalVkPipelineVertexInputDivisorStateCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV* p = new VkPhysicalDeviceDiagnosticsConfigFeaturesNV();
            MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {
            VkCommandBufferInheritanceConditionalRenderingInfoEXT* p = new VkCommandBufferInheritanceConditionalRenderingInfoEXT();
            MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: {
            VkFramebufferMixedSamplesCombinationNV* p = new VkFramebufferMixedSamplesCombinationNV();
            MarshalVkFramebufferMixedSamplesCombinationNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: {
            VkBufferCopy2KHR* p = new VkBufferCopy2KHR();
            MarshalVkBufferCopy2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* p = new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
            MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT* p = new VkPhysicalDeviceIndexTypeUint8FeaturesEXT();
            MarshalVkPhysicalDeviceIndexTypeUint8FeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: {
            VkPipelineExecutablePropertiesKHR* p = new VkPipelineExecutablePropertiesKHR();
            MarshalVkPipelineExecutablePropertiesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            VkRenderPassAttachmentBeginInfo* p = new VkRenderPassAttachmentBeginInfo();
            MarshalVkRenderPassAttachmentBeginInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            VkShaderModuleCreateInfo* p = new VkShaderModuleCreateInfo();
            MarshalVkShaderModuleCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: {
            VkHeadlessSurfaceCreateInfoEXT* p = new VkHeadlessSurfaceCreateInfoEXT();
            MarshalVkHeadlessSurfaceCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: {
            VkImageSparseMemoryRequirementsInfo2* p = new VkImageSparseMemoryRequirementsInfo2();
            MarshalVkImageSparseMemoryRequirementsInfo2::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: {
            VkDisplayNativeHdrSurfaceCapabilitiesAMD* p = new VkDisplayNativeHdrSurfaceCapabilitiesAMD();
            MarshalVkDisplayNativeHdrSurfaceCapabilitiesAMD::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: {
            VkQueueFamilyGlobalPriorityPropertiesEXT* p = new VkQueueFamilyGlobalPriorityPropertiesEXT();
            MarshalVkQueueFamilyGlobalPriorityPropertiesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: {
            VkImageCopy2KHR* p = new VkImageCopy2KHR();
            MarshalVkImageCopy2KHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: {
            VkVertexInputAttributeDescription2EXT* p = new VkVertexInputAttributeDescription2EXT();
            MarshalVkVertexInputAttributeDescription2EXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: {
            VkDevicePrivateDataCreateInfoEXT* p = new VkDevicePrivateDataCreateInfoEXT();
            MarshalVkDevicePrivateDataCreateInfoEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            VkSubpassDescriptionDepthStencilResolve* p = new VkSubpassDescriptionDepthStencilResolve();
            MarshalVkSubpassDescriptionDepthStencilResolve::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: {
            VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* p = new VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT();
            MarshalVkPhysicalDevicePipelineCreationCacheControlFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* p = new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
            MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* p = new VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
            MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: {
            VkPipelineExecutableStatisticKHR* p = new VkPipelineExecutableStatisticKHR();
            MarshalVkPipelineExecutableStatisticKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: {
            VkPerformanceCounterDescriptionKHR* p = new VkPerformanceCounterDescriptionKHR();
            MarshalVkPerformanceCounterDescriptionKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
            VkSubmitInfo* p = new VkSubmitInfo();
            MarshalVkSubmitInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            VkDescriptorSetVariableDescriptorCountLayoutSupport* p = new VkDescriptorSetVariableDescriptorCountLayoutSupport();
            MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            VkBindImageMemorySwapchainInfoKHR* p = new VkBindImageMemorySwapchainInfoKHR();
            MarshalVkBindImageMemorySwapchainInfoKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            VkPhysicalDevice16BitStorageFeatures* p = new VkPhysicalDevice16BitStorageFeatures();
            MarshalVkPhysicalDevice16BitStorageFeatures::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* p = new VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
            MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            VkRenderPassInputAttachmentAspectCreateInfo* p = new VkRenderPassInputAttachmentAspectCreateInfo();
            MarshalVkRenderPassInputAttachmentAspectCreateInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: {
            VkGeometryTrianglesNV* p = new VkGeometryTrianglesNV();
            MarshalVkGeometryTrianglesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* p = new VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR();
            MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            VkImagePlaneMemoryRequirementsInfo* p = new VkImagePlaneMemoryRequirementsInfo();
            MarshalVkImagePlaneMemoryRequirementsInfo::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT* p = new VkPhysicalDeviceConditionalRenderingFeaturesEXT();
            MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* p = new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
            MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::read(memory, address, p);
            return p;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            VkPhysicalDeviceDescriptorIndexingFeatures* p = new VkPhysicalDeviceDescriptorIndexingFeatures();
            MarshalVkPhysicalDeviceDescriptorIndexingFeatures::read(memory, address, p);
            return p;
        }
       default:
            kpanic("vulkanGetNextPtr not implemented for %d", type);
    }
}
void vulkanWriteNextPtr(KMemory* memory, U32 address, const void* p) {
    if (address == 0) {
        return;
    }
    VkStructureType type = (VkStructureType)memory->readd(address);
    switch (type) {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::write(memory, address, (VkPhysicalDeviceCooperativeMatrixFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: {
            MarshalVkDisplayProperties2KHR::write(memory, address, (VkDisplayProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {
            MarshalVkImageViewASTCDecodeModeEXT::write(memory, address, (VkImageViewASTCDecodeModeEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            MarshalVkExternalMemoryImageCreateInfo::write(memory, address, (VkExternalMemoryImageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            MarshalVkSemaphoreTypeCreateInfo::write(memory, address, (VkSemaphoreTypeCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASSS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {
            MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::write(memory, address, (VkSubpassShadingPipelineCreateInfoHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: {
            MarshalVkCommandBufferBeginInfo::write(memory, address, (VkCommandBufferBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::write(memory, address, (VkPhysicalDeviceSamplerFilterMinmaxProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: {
            MarshalVkFenceGetFdInfoKHR::write(memory, address, (VkFenceGetFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: {
            MarshalVkBlitImageInfo2KHR::write(memory, address, (VkBlitImageInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {
            MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::write(memory, address, (VkPhysicalDeviceShadingRateImageFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: {
            MarshalVkDescriptorPoolInlineUniformBlockCreateInfoEXT::write(memory, address, (VkDescriptorPoolInlineUniformBlockCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            MarshalVkImageStencilUsageCreateInfo::write(memory, address, (VkImageStencilUsageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDeviceMemoryReportFeaturesEXT::write(memory, address, (VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {
            MarshalVkExternalMemoryImageCreateInfoNV::write(memory, address, (VkExternalMemoryImageCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            MarshalVkAttachmentDescriptionStencilLayout::write(memory, address, (VkAttachmentDescriptionStencilLayout*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: {
            MarshalVkRayTracingPipelineCreateInfoNV::write(memory, address, (VkRayTracingPipelineCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: {
            MarshalVkImageCreateInfo::write(memory, address, (VkImageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            MarshalVkMemoryDedicatedAllocateInfo::write(memory, address, (VkMemoryDedicatedAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            MarshalVkProtectedSubmitInfo::write(memory, address, (VkProtectedSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: {
            MarshalVkPerformanceMarkerInfoINTEL::write(memory, address, (VkPerformanceMarkerInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: {
            MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE::write(memory, address, (VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::write(memory, address, (VkPhysicalDeviceShadingRateImagePropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: {
            MarshalVkDebugUtilsObjectTagInfoEXT::write(memory, address, (VkDebugUtilsObjectTagInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: {
            MarshalVkPhysicalDevicePushDescriptorPropertiesKHR::write(memory, address, (VkPhysicalDevicePushDescriptorPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: {
            MarshalVkSemaphoreSubmitInfoKHR::write(memory, address, (VkSemaphoreSubmitInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {
            MarshalVkWriteDescriptorSetAccelerationStructureKHR::write(memory, address, (VkWriteDescriptorSetAccelerationStructureKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            MarshalVkPhysicalDeviceShaderFloat16Int8Features::write(memory, address, (VkPhysicalDeviceShaderFloat16Int8Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: {
            MarshalVkSubpassDescription2::write(memory, address, (VkSubpassDescription2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: {
            MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::write(memory, address, (VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan12Properties::write(memory, address, (VkPhysicalDeviceVulkan12Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::write(memory, address, (VkPhysicalDeviceSampleLocationsPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::write(memory, address, (VkPhysicalDevicePCIBusInfoPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            MarshalVkPipelineCreationFeedbackCreateInfoEXT::write(memory, address, (VkPipelineCreationFeedbackCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::write(memory, address, (VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
            MarshalVkBufferMemoryBarrier::write(memory, address, (VkBufferMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            MarshalVkDeviceGroupSubmitInfo::write(memory, address, (VkDeviceGroupSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: {
            MarshalVkPipelineMultisampleStateCreateInfo::write(memory, address, (VkPipelineMultisampleStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: {
            MarshalVkDescriptorUpdateTemplateCreateInfo::write(memory, address, (VkDescriptorUpdateTemplateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {
            MarshalVkTextureLODGatherFormatPropertiesAMD::write(memory, address, (VkTextureLODGatherFormatPropertiesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: {
            MarshalVkExternalBufferProperties::write(memory, address, (VkExternalBufferProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_END_INFO: {
            MarshalVkSubpassEndInfo::write(memory, address, (VkSubpassEndInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: {
            MarshalVkPipelineShaderStageCreateInfo::write(memory, address, (VkPipelineShaderStageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: {
            MarshalVkImageViewAddressPropertiesNVX::write(memory, address, (VkImageViewAddressPropertiesNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            MarshalVkDeviceGroupDeviceCreateInfo::write(memory, address, (VkDeviceGroupDeviceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: {
            MarshalVkBufferCreateInfo::write(memory, address, (VkBufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {
            MarshalVkBufferDeviceAddressCreateInfoEXT::write(memory, address, (VkBufferDeviceAddressCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: {
            MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::write(memory, address, (VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationLineStateCreateInfoEXT::write(memory, address, (VkPipelineRasterizationLineStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            MarshalVkPhysicalDeviceFeatures2::write(memory, address, (VkPhysicalDeviceFeatures2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: {
            MarshalVkImportSemaphoreFdInfoKHR::write(memory, address, (VkImportSemaphoreFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: {
            MarshalVkAccelerationStructureInfoNV::write(memory, address, (VkAccelerationStructureInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: {
            MarshalVkPhysicalDeviceShaderCoreProperties2AMD::write(memory, address, (VkPhysicalDeviceShaderCoreProperties2AMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {
            MarshalVkSwapchainCounterCreateInfoEXT::write(memory, address, (VkSwapchainCounterCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {
            MarshalVkRenderPassTransformBeginInfoQCOM::write(memory, address, (VkRenderPassTransformBeginInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {
            MarshalVkValidationFlagsEXT::write(memory, address, (VkValidationFlagsEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::write(memory, address, (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: {
            MarshalVkPipelineInfoKHR::write(memory, address, (VkPipelineInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkSwapchainCreateInfoKHR::write(memory, address, (VkSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: {
            MarshalVkMemoryHostPointerPropertiesEXT::write(memory, address, (VkMemoryHostPointerPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::write(memory, address, (VkPhysicalDeviceMultiDrawFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            MarshalVkPhysicalDeviceHostQueryResetFeatures::write(memory, address, (VkPhysicalDeviceHostQueryResetFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: {
            MarshalVkImageDrmFormatModifierExplicitCreateInfoEXT::write(memory, address, (VkImageDrmFormatModifierExplicitCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceInlineUniformBlockPropertiesEXT::write(memory, address, (VkPhysicalDeviceInlineUniformBlockPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkImageMemoryRequirementsInfo2::write(memory, address, (VkImageMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            MarshalVkPhysicalDeviceProtectedMemoryFeatures::write(memory, address, (VkPhysicalDeviceProtectedMemoryFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            MarshalVkPhysicalDeviceVariablePointersFeatures::write(memory, address, (VkPhysicalDeviceVariablePointersFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::write(memory, address, (VkDescriptorSetLayoutBindingFlagsCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
            MarshalVkImageMemoryBarrier::write(memory, address, (VkImageMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            MarshalVkPhysicalDeviceVulkan11Features::write(memory, address, (VkPhysicalDeviceVulkan11Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {
            MarshalVkWriteDescriptorSetAccelerationStructureNV::write(memory, address, (VkWriteDescriptorSetAccelerationStructureNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::write(memory, address, (VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: {
            MarshalVkResolveImageInfo2KHR::write(memory, address, (VkResolveImageInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: {
            MarshalVkMemoryAllocateInfo::write(memory, address, (VkMemoryAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            MarshalVkPhysicalDeviceTimelineSemaphoreProperties::write(memory, address, (VkPhysicalDeviceTimelineSemaphoreProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: {
            MarshalVkCopyImageInfo2KHR::write(memory, address, (VkCopyImageInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            MarshalVkDeviceGroupCommandBufferBeginInfo::write(memory, address, (VkDeviceGroupCommandBufferBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            MarshalVkBufferOpaqueCaptureAddressCreateInfo::write(memory, address, (VkBufferOpaqueCaptureAddressCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: {
            MarshalVkBufferDeviceAddressInfo::write(memory, address, (VkBufferDeviceAddressInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            MarshalVkPhysicalDeviceImagelessFramebufferFeatures::write(memory, address, (VkPhysicalDeviceImagelessFramebufferFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::write(memory, address, (VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
            MarshalVkDedicatedAllocationBufferCreateInfoNV::write(memory, address, (VkDedicatedAllocationBufferCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: {
            MarshalVkDependencyInfoKHR::write(memory, address, (VkDependencyInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: {
            MarshalVkCommandBufferInheritanceInfo::write(memory, address, (VkCommandBufferInheritanceInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::write(memory, address, (VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::write(memory, address, (VkPhysicalDeviceSamplerYcbcrConversionFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryTrianglesDataKHR::write(memory, address, (VkAccelerationStructureGeometryTrianglesDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            MarshalVkPhysicalDeviceMultiviewFeatures::write(memory, address, (VkPhysicalDeviceMultiviewFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: {
            MarshalVkPipelineInputAssemblyStateCreateInfo::write(memory, address, (VkPipelineInputAssemblyStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            MarshalVkPhysicalDeviceShaderCorePropertiesAMD::write(memory, address, (VkPhysicalDeviceShaderCorePropertiesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: {
            MarshalVkAttachmentReference2::write(memory, address, (VkAttachmentReference2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: {
            MarshalVkMemoryGetFdInfoKHR::write(memory, address, (VkMemoryGetFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
            MarshalVkBindSparseInfo::write(memory, address, (VkBindSparseInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::write(memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: {
            MarshalVkSurfaceFormat2KHR::write(memory, address, (VkSurfaceFormat2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            MarshalVkMemoryAllocateFlagsInfo::write(memory, address, (VkMemoryAllocateFlagsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: {
            MarshalVkDisplayModeCreateInfoKHR::write(memory, address, (VkDisplayModeCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: {
            MarshalVkAccelerationStructureCreateInfoNV::write(memory, address, (VkAccelerationStructureCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: {
            MarshalVkDebugMarkerObjectNameInfoEXT::write(memory, address, (VkDebugMarkerObjectNameInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: {
            MarshalVkSemaphoreGetFdInfoKHR::write(memory, address, (VkSemaphoreGetFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: {
            MarshalVkAccelerationStructureVersionInfoKHR::write(memory, address, (VkAccelerationStructureVersionInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: {
            MarshalVkPerformanceConfigurationAcquireInfoINTEL::write(memory, address, (VkPerformanceConfigurationAcquireInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::write(memory, address, (VkPhysicalDeviceTransformFeedbackFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: {
            MarshalVkIndirectCommandsLayoutCreateInfoNV::write(memory, address, (VkIndirectCommandsLayoutCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::write(memory, address, (VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: {
            MarshalVkImportFenceFdInfoKHR::write(memory, address, (VkImportFenceFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageToColorStateCreateInfoNV::write(memory, address, (VkPipelineCoverageToColorStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::write(memory, address, (VkPipelineColorBlendAdvancedStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {
            MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::write(memory, address, (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::write(memory, address, (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            MarshalVkPhysicalDevice8BitStorageFeatures::write(memory, address, (VkPhysicalDevice8BitStorageFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            MarshalVkPhysicalDeviceDriverProperties::write(memory, address, (VkPhysicalDeviceDriverProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
            MarshalVkDedicatedAllocationImageCreateInfoNV::write(memory, address, (VkDedicatedAllocationImageCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::write(memory, address, (VkPipelineDiscardRectangleStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: {
            MarshalVkGeometryAABBNV::write(memory, address, (VkGeometryAABBNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: {
            MarshalVkDisplayEventInfoEXT::write(memory, address, (VkDisplayEventInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {
            MarshalVkQueueFamilyCheckpointPropertiesNV::write(memory, address, (VkQueueFamilyCheckpointPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {
            MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::write(memory, address, (VkQueryPoolPerformanceQueryCreateInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: {
            MarshalVkBindImageMemoryInfo::write(memory, address, (VkBindImageMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            MarshalVkAttachmentReferenceStencilLayout::write(memory, address, (VkAttachmentReferenceStencilLayout*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            MarshalVkShaderModuleValidationCacheCreateInfoEXT::write(memory, address, (VkShaderModuleValidationCacheCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {
            MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::write(memory, address, (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: {
            MarshalVkImageViewHandleInfoNVX::write(memory, address, (VkImageViewHandleInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderTerminateInvocationFeaturesKHR::write(memory, address, (VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::write(memory, address, (VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::write(memory, address, (VkPhysicalDeviceDepthClipEnableFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            MarshalVkSamplerCustomBorderColorCreateInfoEXT::write(memory, address, (VkSamplerCustomBorderColorCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: {
            MarshalVkPipelineDynamicStateCreateInfo::write(memory, address, (VkPipelineDynamicStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::write(memory, address, (VkPhysicalDeviceTimelineSemaphoreFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: {
            MarshalVkCuFunctionCreateInfoNVX::write(memory, address, (VkCuFunctionCreateInfoNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            MarshalVkPhysicalDeviceDepthStencilResolveProperties::write(memory, address, (VkPhysicalDeviceDepthStencilResolveProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportSwizzleStateCreateInfoNV::write(memory, address, (VkPipelineViewportSwizzleStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: {
            MarshalVkPhysicalDeviceSparseImageFormatInfo2::write(memory, address, (VkPhysicalDeviceSparseImageFormatInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: {
            MarshalVkFenceCreateInfo::write(memory, address, (VkFenceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {
            MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::write(memory, address, (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkDeviceGroupSwapchainCreateInfoKHR::write(memory, address, (VkDeviceGroupSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: {
            MarshalVkDebugUtilsLabelEXT::write(memory, address, (VkDebugUtilsLabelEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceInlineUniformBlockFeaturesEXT::write(memory, address, (VkPhysicalDeviceInlineUniformBlockFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: {
            MarshalVkPhysicalDeviceImageDrmFormatModifierInfoEXT::write(memory, address, (VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: {
            MarshalVkMultisamplePropertiesEXT::write(memory, address, (VkMultisamplePropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderClockFeaturesKHR::write(memory, address, (VkPhysicalDeviceShaderClockFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: {
            MarshalVkImageDrmFormatModifierPropertiesEXT::write(memory, address, (VkImageDrmFormatModifierPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::write(memory, address, (VkPhysicalDeviceVulkanMemoryModelFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: {
            MarshalVkEventCreateInfo::write(memory, address, (VkEventCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: {
            MarshalVkSubmitInfo2KHR::write(memory, address, (VkSubmitInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {
            MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::write(memory, address, (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {
            MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::write(memory, address, (VkPhysicalDeviceCoherentMemoryFeaturesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::write(memory, address, (VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: {
            MarshalVkImageBlit2KHR::write(memory, address, (VkImageBlit2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: {
            MarshalVkSamplerCreateInfo::write(memory, address, (VkSamplerCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: {
            MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT::write(memory, address, (VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            MarshalVkBindImageMemoryDeviceGroupInfo::write(memory, address, (VkBindImageMemoryDeviceGroupInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: {
            MarshalVkPhysicalDevicePrivateDataFeaturesEXT::write(memory, address, (VkPhysicalDevicePrivateDataFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::write(memory, address, (VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {
            MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::write(memory, address, (VkPhysicalDeviceMemoryPriorityFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: {
            MarshalVkSparseImageMemoryRequirements2::write(memory, address, (VkSparseImageMemoryRequirements2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: {
            MarshalVkBindBufferMemoryInfo::write(memory, address, (VkBindBufferMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {
            MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::write(memory, address, (VkGraphicsPipelineShaderGroupsCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: {
            MarshalVkPhysicalDeviceExternalFenceInfo::write(memory, address, (VkPhysicalDeviceExternalFenceInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: {
            MarshalVkConditionalRenderingBeginInfoEXT::write(memory, address, (VkConditionalRenderingBeginInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: {
            MarshalVkCopyDescriptorSet::write(memory, address, (VkCopyDescriptorSet*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: {
            MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::write(memory, address, (VkDeviceMemoryOpaqueCaptureAddressInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {
            MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::write(memory, address, (VkPhysicalDeviceCornerSampledImageFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: {
            MarshalVkDescriptorPoolCreateInfo::write(memory, address, (VkDescriptorPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {
            MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::write(memory, address, (VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT::write(memory, address, (VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::write(memory, address, (VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: {
            MarshalVkImportMemoryFdInfoKHR::write(memory, address, (VkImportMemoryFdInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: {
            MarshalVkAccelerationStructureBuildSizesInfoKHR::write(memory, address, (VkAccelerationStructureBuildSizesInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: {
            MarshalVkPrivateDataSlotCreateInfoEXT::write(memory, address, (VkPrivateDataSlotCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: {
            MarshalVkMemoryRequirements2::write(memory, address, (VkMemoryRequirements2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::write(memory, address, (VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {
            MarshalVkRenderPassSampleLocationsBeginInfoEXT::write(memory, address, (VkRenderPassSampleLocationsBeginInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            MarshalVkPhysicalDeviceLineRasterizationFeaturesEXT::write(memory, address, (VkPhysicalDeviceLineRasterizationFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::write(memory, address, (VkPhysicalDeviceCustomBorderColorPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            MarshalVkPhysicalDevicePointClippingProperties::write(memory, address, (VkPhysicalDevicePointClippingProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: {
            MarshalVkDeviceQueueCreateInfo::write(memory, address, (VkDeviceQueueCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            MarshalVkPhysicalDeviceShaderAtomicInt64Features::write(memory, address, (VkPhysicalDeviceShaderAtomicInt64Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: {
            MarshalVkPipelineCacheCreateInfo::write(memory, address, (VkPipelineCacheCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            MarshalVkTimelineSemaphoreSubmitInfo::write(memory, address, (VkTimelineSemaphoreSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HDR_METADATA_EXT: {
            MarshalVkHdrMetadataEXT::write(memory, address, (VkHdrMetadataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            MarshalVkPhysicalDeviceDescriptorIndexingProperties::write(memory, address, (VkPhysicalDeviceDescriptorIndexingProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            MarshalVkRenderPassMultiviewCreateInfo::write(memory, address, (VkRenderPassMultiviewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: {
            MarshalVkCopyAccelerationStructureInfoKHR::write(memory, address, (VkCopyAccelerationStructureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {
            MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::write(memory, address, (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::write(memory, address, (VkPipelineRasterizationStateStreamCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineSampleLocationsStateCreateInfoEXT::write(memory, address, (VkPipelineSampleLocationsStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            MarshalVkPhysicalDeviceProtectedMemoryProperties::write(memory, address, (VkPhysicalDeviceProtectedMemoryProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceMeshShaderPropertiesNV::write(memory, address, (VkPhysicalDeviceMeshShaderPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::write(memory, address, (VkDescriptorSetVariableDescriptorCountAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::write(memory, address, (VkPipelineRasterizationConservativeStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::write(memory, address, (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: {
            MarshalVkCalibratedTimestampInfoEXT::write(memory, address, (VkCalibratedTimestampInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
            MarshalVkDebugUtilsObjectNameInfoEXT::write(memory, address, (VkDebugUtilsObjectNameInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::write(memory, address, (VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: {
            MarshalVkAcquireProfilingLockInfoKHR::write(memory, address, (VkAcquireProfilingLockInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {
            MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::write(memory, address, (VkFilterCubicImageViewImageFormatPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceToolPropertiesEXT::write(memory, address, (VkPhysicalDeviceToolPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: {
            MarshalVkSwapchainDisplayNativeHdrCreateInfoAMD::write(memory, address, (VkSwapchainDisplayNativeHdrCreateInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: {
            MarshalVkImageResolve2KHR::write(memory, address, (VkImageResolve2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: {
            MarshalVkPerformanceOverrideInfoINTEL::write(memory, address, (VkPerformanceOverrideInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::write(memory, address, (VkPhysicalDeviceAccelerationStructurePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: {
            MarshalVkSparseImageFormatProperties2::write(memory, address, (VkSparseImageFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: {
            MarshalVkSharedPresentSurfaceCapabilitiesKHR::write(memory, address, (VkSharedPresentSurfaceCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::write(memory, address, (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::write(memory, address, (VkPipelineViewportExclusiveScissorStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {
            MarshalVkDeviceDiagnosticsConfigCreateInfoNV::write(memory, address, (VkDeviceDiagnosticsConfigCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::write(memory, address, (VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: {
            MarshalVkAccelerationStructureGeometryKHR::write(memory, address, (VkAccelerationStructureGeometryKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::write(memory, address, (VkPhysicalDeviceCustomBorderColorFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {
            MarshalVkPipelineRasterizationStateRasterizationOrderAMD::write(memory, address, (VkPipelineRasterizationStateRasterizationOrderAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {
            MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::write(memory, address, (VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_APPLICATION_INFO: {
            MarshalVkApplicationInfo::write(memory, address, (VkApplicationInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: {
            MarshalVkSurfaceProtectedCapabilitiesKHR::write(memory, address, (VkSurfaceProtectedCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: {
            MarshalVkPipelineRasterizationStateCreateInfo::write(memory, address, (VkPipelineRasterizationStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            MarshalVkPhysicalDeviceShaderDrawParametersFeatures::write(memory, address, (VkPhysicalDeviceShaderDrawParametersFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {
            MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::write(memory, address, (VkPhysicalDeviceCoverageReductionModeFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::write(memory, address, (VkPhysicalDeviceProvokingVertexFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            MarshalVkPhysicalDeviceSubgroupProperties::write(memory, address, (VkPhysicalDeviceSubgroupProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::write(memory, address, (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: {
            MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::write(memory, address, (VkGeneratedCommandsMemoryRequirementsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::write(memory, address, (VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: {
            MarshalVkRenderPassCreateInfo2::write(memory, address, (VkRenderPassCreateInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: {
            MarshalVkPhysicalDeviceExternalSemaphoreInfo::write(memory, address, (VkPhysicalDeviceExternalSemaphoreInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryInstancesDataKHR::write(memory, address, (VkAccelerationStructureGeometryInstancesDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {
            MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::write(memory, address, (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceTexelBufferAlignmentPropertiesEXT::write(memory, address, (VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            MarshalVkMemoryDedicatedRequirements::write(memory, address, (VkMemoryDedicatedRequirements*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::write(memory, address, (VkPhysicalDeviceProvokingVertexPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::write(memory, address, (VkPhysicalDeviceDiscardRectanglePropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageReductionStateCreateInfoNV::write(memory, address, (VkPipelineCoverageReductionStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: {
            MarshalVkMemoryFdPropertiesKHR::write(memory, address, (VkMemoryFdPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: {
            MarshalVkSamplerYcbcrConversionCreateInfo::write(memory, address, (VkSamplerYcbcrConversionCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT::write(memory, address, (VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: {
            MarshalVkBufferMemoryBarrier2KHR::write(memory, address, (VkBufferMemoryBarrier2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: {
            MarshalVkDisplayPlaneCapabilities2KHR::write(memory, address, (VkDisplayPlaneCapabilities2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {
            MarshalVkCommandBufferInheritanceViewportScissorInfoNV::write(memory, address, (VkCommandBufferInheritanceViewportScissorInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceRayTracingPropertiesNV::write(memory, address, (VkPhysicalDeviceRayTracingPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: {
            MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::write(memory, address, (VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {
            MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::write(memory, address, (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: {
            MarshalVkInstanceCreateInfo::write(memory, address, (VkInstanceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceLineRasterizationPropertiesEXT::write(memory, address, (VkPhysicalDeviceLineRasterizationPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: {
            MarshalVkDisplayPlaneProperties2KHR::write(memory, address, (VkDisplayPlaneProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: {
            MarshalVkDescriptorSetLayoutSupport::write(memory, address, (VkDescriptorSetLayoutSupport*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::write(memory, address, (VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: {
            MarshalVkSemaphoreSignalInfo::write(memory, address, (VkSemaphoreSignalInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: {
            MarshalVkBufferViewCreateInfo::write(memory, address, (VkBufferViewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {
            MarshalVkPerformanceQuerySubmitInfoKHR::write(memory, address, (VkPerformanceQuerySubmitInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkBufferMemoryRequirementsInfo2::write(memory, address, (VkBufferMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {
            MarshalVkExportMemoryAllocateInfoNV::write(memory, address, (VkExportMemoryAllocateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
            MarshalVkMemoryPriorityAllocateInfoEXT::write(memory, address, (VkMemoryPriorityAllocateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: {
            MarshalVkAttachmentDescription2::write(memory, address, (VkAttachmentDescription2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            MarshalVkBindBufferMemoryDeviceGroupInfo::write(memory, address, (VkBindBufferMemoryDeviceGroupInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: {
            MarshalVkPipelineVertexInputStateCreateInfo::write(memory, address, (VkPipelineVertexInputStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            MarshalVkExportMemoryAllocateInfo::write(memory, address, (VkExportMemoryAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: {
            MarshalVkAccelerationStructureMemoryRequirementsInfoNV::write(memory, address, (VkAccelerationStructureMemoryRequirementsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: {
            MarshalVkAccelerationStructureDeviceAddressInfoKHR::write(memory, address, (VkAccelerationStructureDeviceAddressInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
            MarshalVkMemoryBarrier::write(memory, address, (VkMemoryBarrier*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
            MarshalVkSemaphoreWaitInfo::write(memory, address, (VkSemaphoreWaitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::write(memory, address, (VkPhysicalDeviceColorWriteEnableFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::write(memory, address, (VkPhysicalDeviceMemoryBudgetPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            MarshalVkPhysicalDevice4444FormatsFeaturesEXT::write(memory, address, (VkPhysicalDevice4444FormatsFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: {
            MarshalVkExternalFenceProperties::write(memory, address, (VkExternalFenceProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::write(memory, address, (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::write(memory, address, (VkPhysicalDeviceTransformFeedbackPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            MarshalVkPhysicalDeviceIDProperties::write(memory, address, (VkPhysicalDeviceIDProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: {
            MarshalVkPerformanceStreamMarkerInfoINTEL::write(memory, address, (VkPerformanceStreamMarkerInfoINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::write(memory, address, (VkPhysicalDeviceCooperativeMatrixPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            MarshalVkSamplerReductionModeCreateInfo::write(memory, address, (VkSamplerReductionModeCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: {
            MarshalVkGeneratedCommandsInfoNV::write(memory, address, (VkGeneratedCommandsInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
            MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::write(memory, address, (VkPipelineFragmentShadingRateStateCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: {
            MarshalVkPipelineExecutableInternalRepresentationKHR::write(memory, address, (VkPipelineExecutableInternalRepresentationKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: {
            MarshalVkBindAccelerationStructureMemoryInfoNV::write(memory, address, (VkBindAccelerationStructureMemoryInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            MarshalVkExportSemaphoreCreateInfo::write(memory, address, (VkExportSemaphoreCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: {
            MarshalVkCopyAccelerationStructureToMemoryInfoKHR::write(memory, address, (VkCopyAccelerationStructureToMemoryInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            MarshalVkExternalImageFormatProperties::write(memory, address, (VkExternalImageFormatProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: {
            MarshalVkFormatProperties2::write(memory, address, (VkFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::write(memory, address, (VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: {
            MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::write(memory, address, (VkPhysicalDevicePerformanceQueryPropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: {
            MarshalVkImageDrmFormatModifierListCreateInfoEXT::write(memory, address, (VkImageDrmFormatModifierListCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: {
            MarshalVkVertexInputBindingDescription2EXT::write(memory, address, (VkVertexInputBindingDescription2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: {
            MarshalVkSurfaceCapabilities2EXT::write(memory, address, (VkSurfaceCapabilities2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            MarshalVkPipelineTessellationDomainOriginStateCreateInfo::write(memory, address, (VkPipelineTessellationDomainOriginStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            MarshalVkSamplerYcbcrConversionInfo::write(memory, address, (VkSamplerYcbcrConversionInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {
            MarshalVkAccelerationStructureMotionInfoNV::write(memory, address, (VkAccelerationStructureMotionInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {
            MarshalVkCopyCommandTransformInfoQCOM::write(memory, address, (VkCopyCommandTransformInfoQCOM*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            MarshalVkExternalMemoryBufferCreateInfo::write(memory, address, (VkExternalMemoryBufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: {
            MarshalVkPhysicalDeviceProperties2::write(memory, address, (VkPhysicalDeviceProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: {
            MarshalVkGraphicsShaderGroupCreateInfoNV::write(memory, address, (VkGraphicsShaderGroupCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            MarshalVkPhysicalDeviceVulkan11Properties::write(memory, address, (VkPhysicalDeviceVulkan11Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::write(memory, address, (VkPhysicalDeviceBufferDeviceAddressFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: {
            MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::write(memory, address, (VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: {
            MarshalVkPhysicalDeviceImageFormatInfo2::write(memory, address, (VkPhysicalDeviceImageFormatInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            MarshalVkPresentRegionsKHR::write(memory, address, (VkPresentRegionsKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: {
            MarshalVkPhysicalDeviceExternalBufferInfo::write(memory, address, (VkPhysicalDeviceExternalBufferInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceDrmPropertiesEXT::write(memory, address, (VkPhysicalDeviceDrmPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceSubgroupSizeControlPropertiesEXT::write(memory, address, (VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {
            MarshalVkPhysicalDeviceMeshShaderFeaturesNV::write(memory, address, (VkPhysicalDeviceMeshShaderFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: {
            MarshalVkPhysicalDeviceMemoryProperties2::write(memory, address, (VkPhysicalDeviceMemoryProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: {
            MarshalVkDeviceQueueInfo2::write(memory, address, (VkDeviceQueueInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            MarshalVkPhysicalDeviceExternalImageFormatInfo::write(memory, address, (VkPhysicalDeviceExternalImageFormatInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            MarshalVkDeviceGroupRenderPassBeginInfo::write(memory, address, (VkDeviceGroupRenderPassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: {
            MarshalVkExternalSemaphoreProperties::write(memory, address, (VkExternalSemaphoreProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::write(memory, address, (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: {
            MarshalVkDeviceQueueGlobalPriorityCreateInfoEXT::write(memory, address, (VkDeviceQueueGlobalPriorityCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            MarshalVkCooperativeMatrixPropertiesNV::write(memory, address, (VkCooperativeMatrixPropertiesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: {
            MarshalVkCopyImageToBufferInfo2KHR::write(memory, address, (VkCopyImageToBufferInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: {
            MarshalVkIndirectCommandsLayoutTokenNV::write(memory, address, (VkIndirectCommandsLayoutTokenNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: {
            MarshalVkRayTracingShaderGroupCreateInfoNV::write(memory, address, (VkRayTracingShaderGroupCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: {
            MarshalVkDeviceGroupPresentCapabilitiesKHR::write(memory, address, (VkDeviceGroupPresentCapabilitiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: {
            MarshalVkPipelineColorBlendStateCreateInfo::write(memory, address, (VkPipelineColorBlendStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {
            MarshalVkValidationFeaturesEXT::write(memory, address, (VkValidationFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: {
            MarshalVkPerformanceCounterKHR::write(memory, address, (VkPerformanceCounterKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: {
            MarshalVkRenderPassBeginInfo::write(memory, address, (VkRenderPassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            MarshalVkPhysicalDeviceMaintenance3Properties::write(memory, address, (VkPhysicalDeviceMaintenance3Properties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            MarshalVkImageSwapchainCreateInfoKHR::write(memory, address, (VkImageSwapchainCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {
            MarshalVkPhysicalDeviceRobustness2FeaturesEXT::write(memory, address, (VkPhysicalDeviceRobustness2FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: {
            MarshalVkDisplayModeProperties2KHR::write(memory, address, (VkDisplayModeProperties2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            MarshalVkPhysicalDeviceVulkan12Features::write(memory, address, (VkPhysicalDeviceVulkan12Features*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: {
            MarshalVkImageViewCreateInfo::write(memory, address, (VkImageViewCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: {
            MarshalVkDebugMarkerMarkerInfoEXT::write(memory, address, (VkDebugMarkerMarkerInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_NV: {
            MarshalVkGeometryNV::write(memory, address, (VkGeometryNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: {
            MarshalVkDeviceEventInfoEXT::write(memory, address, (VkDeviceEventInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: {
            MarshalVkAcquireNextImageInfoKHR::write(memory, address, (VkAcquireNextImageInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {
            MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::write(memory, address, (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: {
            MarshalVkPipelineExecutableInfoKHR::write(memory, address, (VkPipelineExecutableInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: {
            MarshalVkDisplaySurfaceCreateInfoKHR::write(memory, address, (VkDisplaySurfaceCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            MarshalVkQueueFamilyCheckpointProperties2NV::write(memory, address, (VkQueueFamilyCheckpointProperties2NV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceRobustness2PropertiesEXT::write(memory, address, (VkPhysicalDeviceRobustness2PropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: {
            MarshalVkSemaphoreCreateInfo::write(memory, address, (VkSemaphoreCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: {
            MarshalVkDebugMarkerObjectTagInfoEXT::write(memory, address, (VkDebugMarkerObjectTagInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::write(memory, address, (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
            MarshalVkPipelineColorWriteCreateInfoEXT::write(memory, address, (VkPipelineColorWriteCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
            MarshalVkPipelineLayoutCreateInfo::write(memory, address, (VkPipelineLayoutCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: {
            MarshalVkAccelerationStructureCreateInfoKHR::write(memory, address, (VkAccelerationStructureCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: {
            MarshalVkMemoryBarrier2KHR::write(memory, address, (VkMemoryBarrier2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: {
            MarshalVkCommandPoolCreateInfo::write(memory, address, (VkCommandPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::write(memory, address, (VkPhysicalDeviceScalarBlockLayoutFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
            MarshalVkDescriptorSetLayoutCreateInfo::write(memory, address, (VkDescriptorSetLayoutCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {
            MarshalVkDeviceMemoryOverallocationCreateInfoAMD::write(memory, address, (VkDeviceMemoryOverallocationCreateInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: {
            MarshalVkPresentTimesInfoGOOGLE::write(memory, address, (VkPresentTimesInfoGOOGLE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            MarshalVkDeviceGroupPresentInfoKHR::write(memory, address, (VkDeviceGroupPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            MarshalVkFragmentShadingRateAttachmentInfoKHR::write(memory, address, (VkFragmentShadingRateAttachmentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: {
            MarshalVkPipelineViewportStateCreateInfo::write(memory, address, (VkPipelineViewportStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: {
            MarshalVkRenderPassCreateInfo::write(memory, address, (VkRenderPassCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::write(memory, address, (VkPipelineRasterizationDepthClipStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: {
            MarshalVkSurfaceCapabilities2KHR::write(memory, address, (VkSurfaceCapabilities2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: {
            MarshalVkCommandBufferAllocateInfo::write(memory, address, (VkCommandBufferAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
            MarshalVkDebugUtilsMessengerCallbackDataEXT::write(memory, address, (VkDebugUtilsMessengerCallbackDataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: {
            MarshalVkBufferImageCopy2KHR::write(memory, address, (VkBufferImageCopy2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            MarshalVkDeviceGroupBindSparseInfo::write(memory, address, (VkDeviceGroupBindSparseInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            MarshalVkSamplerYcbcrConversionImageFormatProperties::write(memory, address, (VkSamplerYcbcrConversionImageFormatProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceImageRobustnessFeaturesEXT::write(memory, address, (VkPhysicalDeviceImageRobustnessFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            MarshalVkValidationCacheCreateInfoEXT::write(memory, address, (VkValidationCacheCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            MarshalVkPhysicalDeviceFloatControlsProperties::write(memory, address, (VkPhysicalDeviceFloatControlsProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: {
            MarshalVkSubpassDependency2::write(memory, address, (VkSubpassDependency2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {
            MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::write(memory, address, (VkPhysicalDeviceShaderImageFootprintFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {
            MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::write(memory, address, (VkPhysicalDeviceAccelerationStructureFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: {
            MarshalVkSubpassBeginInfo::write(memory, address, (VkSubpassBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
            MarshalVkGraphicsPipelineCreateInfo::write(memory, address, (VkGraphicsPipelineCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: {
            MarshalVkDeviceCreateInfo::write(memory, address, (VkDeviceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
            MarshalVkFramebufferCreateInfo::write(memory, address, (VkFramebufferCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
            MarshalVkDedicatedAllocationMemoryAllocateInfoNV::write(memory, address, (VkDedicatedAllocationMemoryAllocateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportWScalingStateCreateInfoNV::write(memory, address, (VkPipelineViewportWScalingStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: {
            MarshalVkDisplayPowerInfoEXT::write(memory, address, (VkDisplayPowerInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: {
            MarshalVkQueryPoolCreateInfo::write(memory, address, (VkQueryPoolCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: {
            MarshalVkImageFormatProperties2::write(memory, address, (VkImageFormatProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            MarshalVkExportFenceCreateInfo::write(memory, address, (VkExportFenceCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: {
            MarshalVkDrmFormatModifierPropertiesListEXT::write(memory, address, (VkDrmFormatModifierPropertiesListEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: {
            MarshalVkMappedMemoryRange::write(memory, address, (VkMappedMemoryRange*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::write(memory, address, (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {
            MarshalVkPhysicalDeviceRayQueryFeaturesKHR::write(memory, address, (VkPhysicalDeviceRayQueryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: {
            MarshalVkCommandBufferSubmitInfoKHR::write(memory, address, (VkCommandBufferSubmitInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::write(memory, address, (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDeviceSubgroupSizeControlFeaturesEXT::write(memory, address, (VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {
            MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::write(memory, address, (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: {
            MarshalVkCopyMemoryToAccelerationStructureInfoKHR::write(memory, address, (VkCopyMemoryToAccelerationStructureInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
            MarshalVkDescriptorSetAllocateInfo::write(memory, address, (VkDescriptorSetAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {
            MarshalVkQueryPoolPerformanceCreateInfoKHR::write(memory, address, (VkQueryPoolPerformanceCreateInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: {
            MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::write(memory, address, (VkPhysicalDeviceMultiDrawPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {
            MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::write(memory, address, (VkRenderPassFragmentDensityMapCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
            MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::write(memory, address, (VkPhysicalDevicePerformanceQueryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::write(memory, address, (VkPhysicalDeviceASTCDecodeFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {
            MarshalVkPipelineCompilerControlCreateInfoAMD::write(memory, address, (VkPipelineCompilerControlCreateInfoAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: {
            MarshalVkWriteDescriptorSetInlineUniformBlockEXT::write(memory, address, (VkWriteDescriptorSetInlineUniformBlockEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            MarshalVkPhysicalDeviceMultiviewProperties::write(memory, address, (VkPhysicalDeviceMultiviewProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {
            MarshalVkDisplayPresentInfoKHR::write(memory, address, (VkDisplayPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: {
            MarshalVkPhysicalDeviceSynchronization2FeaturesKHR::write(memory, address, (VkPhysicalDeviceSynchronization2FeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineCoverageModulationStateCreateInfoNV::write(memory, address, (VkPipelineCoverageModulationStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: {
            MarshalVkPipelineDepthStencilStateCreateInfo::write(memory, address, (VkPipelineDepthStencilStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: {
            MarshalVkDisplayPlaneInfo2KHR::write(memory, address, (VkDisplayPlaneInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {
            MarshalVkSampleLocationsInfoEXT::write(memory, address, (VkSampleLocationsInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::write(memory, address, (VkPipelineViewportShadingRateImageStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::write(memory, address, (VkMemoryOpaqueCaptureAddressAllocateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: {
            MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(memory, address, (VkPhysicalDeviceFragmentShadingRateKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
            MarshalVkPresentInfoKHR::write(memory, address, (VkPresentInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            MarshalVkImageFormatListCreateInfo::write(memory, address, (VkImageFormatListCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: {
            MarshalVkPhysicalDeviceGroupProperties::write(memory, address, (VkPhysicalDeviceGroupProperties*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
            MarshalVkComputePipelineCreateInfo::write(memory, address, (VkComputePipelineCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
            MarshalVkWriteDescriptorSet::write(memory, address, (VkWriteDescriptorSet*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
            MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::write(memory, address, (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {
            MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::write(memory, address, (VkPhysicalDeviceExclusiveScissorFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: {
            MarshalVkImageMemoryBarrier2KHR::write(memory, address, (VkImageMemoryBarrier2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: {
            MarshalVkAccelerationStructureGeometryAabbsDataKHR::write(memory, address, (VkAccelerationStructureGeometryAabbsDataKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
            MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::write(memory, address, (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            MarshalVkBindImagePlaneMemoryInfo::write(memory, address, (VkBindImagePlaneMemoryInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {
            MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::write(memory, address, (VkPhysicalDeviceImageViewImageFormatInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: {
            MarshalVkQueueFamilyProperties2::write(memory, address, (VkQueueFamilyProperties2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: {
            MarshalVkCopyBufferInfo2KHR::write(memory, address, (VkCopyBufferInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: {
            MarshalVkPhysicalDeviceSurfaceInfo2KHR::write(memory, address, (VkPhysicalDeviceSurfaceInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: {
            MarshalVkCopyBufferToImageInfo2KHR::write(memory, address, (VkCopyBufferToImageInfo2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            MarshalVkFramebufferAttachmentsCreateInfo::write(memory, address, (VkFramebufferAttachmentsCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {
            MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::write(memory, address, (VkAccelerationStructureGeometryMotionTrianglesDataNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: {
            MarshalVkPipelineTessellationStateCreateInfo::write(memory, address, (VkPipelineTessellationStateCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
            MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::write(memory, address, (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::write(memory, address, (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {
            MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::write(memory, address, (VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: {
            MarshalVkPhysicalDeviceGlobalPriorityQueryFeaturesEXT::write(memory, address, (VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            MarshalVkImageViewUsageCreateInfo::write(memory, address, (VkImageViewUsageCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: {
            MarshalVkDeviceMemoryReportCallbackDataEXT::write(memory, address, (VkDeviceMemoryReportCallbackDataEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: {
            MarshalVkMutableDescriptorTypeCreateInfoVALVE::write(memory, address, (VkMutableDescriptorTypeCreateInfoVALVE*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: {
            MarshalVkPipelineVertexInputDivisorStateCreateInfoEXT::write(memory, address, (VkPipelineVertexInputDivisorStateCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {
            MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::write(memory, address, (VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {
            MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::write(memory, address, (VkCommandBufferInheritanceConditionalRenderingInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: {
            MarshalVkFramebufferMixedSamplesCombinationNV::write(memory, address, (VkFramebufferMixedSamplesCombinationNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: {
            MarshalVkBufferCopy2KHR::write(memory, address, (VkBufferCopy2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {
            MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::write(memory, address, (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            MarshalVkPhysicalDeviceIndexTypeUint8FeaturesEXT::write(memory, address, (VkPhysicalDeviceIndexTypeUint8FeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: {
            MarshalVkPipelineExecutablePropertiesKHR::write(memory, address, (VkPipelineExecutablePropertiesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            MarshalVkRenderPassAttachmentBeginInfo::write(memory, address, (VkRenderPassAttachmentBeginInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            MarshalVkShaderModuleCreateInfo::write(memory, address, (VkShaderModuleCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: {
            MarshalVkHeadlessSurfaceCreateInfoEXT::write(memory, address, (VkHeadlessSurfaceCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: {
            MarshalVkImageSparseMemoryRequirementsInfo2::write(memory, address, (VkImageSparseMemoryRequirementsInfo2*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: {
            MarshalVkDisplayNativeHdrSurfaceCapabilitiesAMD::write(memory, address, (VkDisplayNativeHdrSurfaceCapabilitiesAMD*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: {
            MarshalVkQueueFamilyGlobalPriorityPropertiesEXT::write(memory, address, (VkQueueFamilyGlobalPriorityPropertiesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: {
            MarshalVkImageCopy2KHR::write(memory, address, (VkImageCopy2KHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: {
            MarshalVkVertexInputAttributeDescription2EXT::write(memory, address, (VkVertexInputAttributeDescription2EXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: {
            MarshalVkDevicePrivateDataCreateInfoEXT::write(memory, address, (VkDevicePrivateDataCreateInfoEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            MarshalVkSubpassDescriptionDepthStencilResolve::write(memory, address, (VkSubpassDescriptionDepthStencilResolve*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: {
            MarshalVkPhysicalDevicePipelineCreationCacheControlFeaturesEXT::write(memory, address, (VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::write(memory, address, (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::write(memory, address, (VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: {
            MarshalVkPipelineExecutableStatisticKHR::write(memory, address, (VkPipelineExecutableStatisticKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: {
            MarshalVkPerformanceCounterDescriptionKHR::write(memory, address, (VkPerformanceCounterDescriptionKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
            MarshalVkSubmitInfo::write(memory, address, (VkSubmitInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::write(memory, address, (VkDescriptorSetVariableDescriptorCountLayoutSupport*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            MarshalVkBindImageMemorySwapchainInfoKHR::write(memory, address, (VkBindImageMemorySwapchainInfoKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            MarshalVkPhysicalDevice16BitStorageFeatures::write(memory, address, (VkPhysicalDevice16BitStorageFeatures*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: {
            MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesNV::write(memory, address, (VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            MarshalVkRenderPassInputAttachmentAspectCreateInfo::write(memory, address, (VkRenderPassInputAttachmentAspectCreateInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: {
            MarshalVkGeometryTrianglesNV::write(memory, address, (VkGeometryTrianglesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: {
            MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR::write(memory, address, (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            MarshalVkImagePlaneMemoryRequirementsInfo::write(memory, address, (VkImagePlaneMemoryRequirementsInfo*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {
            MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::write(memory, address, (VkPhysicalDeviceConditionalRenderingFeaturesEXT*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {
            MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::write(memory, address, (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)p);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            MarshalVkPhysicalDeviceDescriptorIndexingFeatures::write(memory, address, (VkPhysicalDeviceDescriptorIndexingFeatures*)p);
            break;
        }
       default:
            kpanic("vulkanWriteNextPtr not implemented for %d", type);
    }
}
#endif

