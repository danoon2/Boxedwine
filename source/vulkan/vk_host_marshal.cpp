// DON'T MODIFY, this is autogenerated
#include "boxedwine.h"
#ifdef BOXEDWINE_VULKAN
#include <SDL.h>
#include <SDL_vulkan.h>
#define VK_NO_PROTOTYPES
#include "vk/vulkan.h"
#include "vk/vulkan_core.h"
#include "vk_host.h"

#include "vk_host_marshal.h"

void MarshalVkViewport::read(KMemory* memory, U32 address, VkViewport* s) {
    MarshalFloat xFloat;
    xFloat.i = memory->readd(address);address+=4;
    s->x = xFloat.f;
    MarshalFloat yFloat;
    yFloat.i = memory->readd(address);address+=4;
    s->y = yFloat.f;
    MarshalFloat widthFloat;
    widthFloat.i = memory->readd(address);address+=4;
    s->width = widthFloat.f;
    MarshalFloat heightFloat;
    heightFloat.i = memory->readd(address);address+=4;
    s->height = heightFloat.f;
    MarshalFloat minDepthFloat;
    minDepthFloat.i = memory->readd(address);address+=4;
    s->minDepth = minDepthFloat.f;
    MarshalFloat maxDepthFloat;
    maxDepthFloat.i = memory->readd(address);address+=4;
    s->maxDepth = maxDepthFloat.f;
}
void MarshalVkRect2D::read(KMemory* memory, U32 address, VkRect2D* s) {
    memory->memcpy(&s->offset, address, 8);address+=8;
    memory->memcpy(&s->extent, address, 8);address+=8;
}
void MarshalVkComponentMapping::read(KMemory* memory, U32 address, VkComponentMapping* s) {
    s->r = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->g = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->b = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->a = (VkComponentSwizzle)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
    s->apiVersion = (uint32_t)memory->readd(address);address+=4;
    s->driverVersion = (uint32_t)memory->readd(address);address+=4;
    s->vendorID = (uint32_t)memory->readd(address);address+=4;
    s->deviceID = (uint32_t)memory->readd(address);address+=4;
    s->deviceType = (VkPhysicalDeviceType)memory->readd(address);address+=4;
    memory->memcpy(&s->deviceName, address, 256);address+=256;
    memory->memcpy(&s->pipelineCacheUUID, address, 16);address+=16;
    MarshalVkPhysicalDeviceLimits::read(memory, address, &s->limits); address+=488;
    memory->memcpy(&s->sparseProperties, address, 20);address+=20;
}
void MarshalVkPhysicalDeviceProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
    memory->writed(address, s->apiVersion);address+=4;
    memory->writed(address, s->driverVersion);address+=4;
    memory->writed(address, s->vendorID);address+=4;
    memory->writed(address, s->deviceID);address+=4;
    memory->writed(address, s->deviceType);address+=4;
    memory->memcpy(address, s->deviceName, 256); address+=256;
    memory->memcpy(address, s->pipelineCacheUUID, 16); address+=16;
    memory->memcpy(address, &s->limits, 488); address+=488;
    memory->memcpy(address, &s->sparseProperties, 20); address+=20;
}
void MarshalVkApplicationInfo::read(KMemory* memory, U32 address, VkApplicationInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pApplicationName = NULL;
    } else {
        U32 pApplicationNameLen = memory->strlen(paramAddress)+1;
        s->pApplicationName = new char[pApplicationNameLen * sizeof(char)];
        memory->memcpy((char*)s->pApplicationName, paramAddress, pApplicationNameLen * sizeof(char));
    }
    s->applicationVersion = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEngineName = NULL;
    } else {
        U32 pEngineNameLen = memory->strlen(paramAddress)+1;
        s->pEngineName = new char[pEngineNameLen * sizeof(char)];
        memory->memcpy((char*)s->pEngineName, paramAddress, pEngineNameLen * sizeof(char));
    }
    s->engineVersion = (uint32_t)memory->readd(address);address+=4;
    s->apiVersion = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkApplicationInfo::write(KMemory* memory, U32 address, VkApplicationInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->applicationVersion);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->engineVersion);address+=4;
    memory->writed(address, s->apiVersion);address+=4;
}
void MarshalVkDeviceQueueCreateInfo::read(KMemory* memory, U32 address, VkDeviceQueueCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->queueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueuePriorities = NULL;
    } else {
        s->pQueuePriorities = new float[(U32)s->queueCount * sizeof(float)];
        memory->memcpy((float*)s->pQueuePriorities, paramAddress, (U32)s->queueCount * sizeof(float));
    }
}
void MarshalVkDeviceQueueCreateInfo::write(KMemory* memory, U32 address, VkDeviceQueueCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->queueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDeviceCreateInfo::read(KMemory* memory, U32 address, VkDeviceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDeviceCreateFlags)memory->readd(address);address+=4;
    s->queueCreateInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueCreateInfos = NULL;
    } else {
        VkDeviceQueueCreateInfo* pQueueCreateInfos = new VkDeviceQueueCreateInfo[s->queueCreateInfoCount];
        for (U32 i = 0; i < s->queueCreateInfoCount; i++) {
            MarshalVkDeviceQueueCreateInfo::read(memory, paramAddress + i*24, &pQueueCreateInfos[i]);
        }
        s->pQueueCreateInfos = pQueueCreateInfos;
    }
    s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledLayerNames = NULL;
    } else {
        char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
        for (int i=0;i<(int)s->enabledLayerCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledLayerNames[i] = new char[size];
            memory->memcpy(ppEnabledLayerNames[i], itemAddress, size);
        }
        s->ppEnabledLayerNames = ppEnabledLayerNames;
    }
    s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledExtensionNames = NULL;
    } else {
        char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
        for (int i=0;i<(int)s->enabledExtensionCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledExtensionNames[i] = new char[size];
            memory->memcpy(ppEnabledExtensionNames[i], itemAddress, size);
        }
        s->ppEnabledExtensionNames = ppEnabledExtensionNames;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEnabledFeatures = NULL;
    } else {
        VkPhysicalDeviceFeatures* pEnabledFeatures = new VkPhysicalDeviceFeatures();
        MarshalVkPhysicalDeviceFeatures::read(memory, paramAddress, pEnabledFeatures);
        s->pEnabledFeatures = pEnabledFeatures;
    }
}
void MarshalVkDeviceCreateInfo::write(KMemory* memory, U32 address, VkDeviceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueCreateInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDeviceQueueCreateInfo* pQueueCreateInfos = new VkDeviceQueueCreateInfo();
        MarshalVkDeviceQueueCreateInfo::read(memory, paramAddress, pQueueCreateInfos);
        s->pQueueCreateInfos = pQueueCreateInfos;
    }
    memory->writed(address, s->enabledLayerCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->enabledExtensionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPhysicalDeviceFeatures* pEnabledFeatures = new VkPhysicalDeviceFeatures();
        MarshalVkPhysicalDeviceFeatures::read(memory, paramAddress, pEnabledFeatures);
        s->pEnabledFeatures = pEnabledFeatures;
    }
}
void MarshalVkInstanceCreateInfo::read(KMemory* memory, U32 address, VkInstanceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkInstanceCreateFlags)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pApplicationInfo = NULL;
    } else {
        VkApplicationInfo* pApplicationInfo = new VkApplicationInfo();
        MarshalVkApplicationInfo::read(memory, paramAddress, pApplicationInfo);
        s->pApplicationInfo = pApplicationInfo;
    }
    s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledLayerNames = NULL;
    } else {
        char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
        for (int i=0;i<(int)s->enabledLayerCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledLayerNames[i] = new char[size];
            memory->memcpy(ppEnabledLayerNames[i], itemAddress, size);
        }
        s->ppEnabledLayerNames = ppEnabledLayerNames;
    }
    s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledExtensionNames = NULL;
    } else {
        char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
        for (int i=0;i<(int)s->enabledExtensionCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledExtensionNames[i] = new char[size];
            memory->memcpy(ppEnabledExtensionNames[i], itemAddress, size);
        }
        s->ppEnabledExtensionNames = ppEnabledExtensionNames;
    }
}
void MarshalVkInstanceCreateInfo::write(KMemory* memory, U32 address, VkInstanceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkApplicationInfo* pApplicationInfo = new VkApplicationInfo();
        MarshalVkApplicationInfo::read(memory, paramAddress, pApplicationInfo);
        s->pApplicationInfo = pApplicationInfo;
    }
    memory->writed(address, s->enabledLayerCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->enabledExtensionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkMemoryAllocateInfo::read(KMemory* memory, U32 address, VkMemoryAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->allocationSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->memoryTypeIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryAllocateInfo::write(KMemory* memory, U32 address, VkMemoryAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->allocationSize);address+=8;
    memory->writed(address, s->memoryTypeIndex);address+=4;
}
void MarshalVkMappedMemoryRange::read(KMemory* memory, U32 address, VkMappedMemoryRange* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkMappedMemoryRange::write(KMemory* memory, U32 address, VkMappedMemoryRange* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
void MarshalVkDescriptorBufferInfo::read(KMemory* memory, U32 address, VkDescriptorBufferInfo* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->range = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkDescriptorImageInfo::read(KMemory* memory, U32 address, VkDescriptorImageInfo* s) {
    s->sampler = (VkSampler)memory->readq(address);address+=8;
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->imageLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkWriteDescriptorSet::read(KMemory* memory, U32 address, VkWriteDescriptorSet* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageInfo = NULL;
    } else {
        VkDescriptorImageInfo* pImageInfo = new VkDescriptorImageInfo[s->descriptorCount];
        for (U32 i = 0; i < s->descriptorCount; i++) {
            MarshalVkDescriptorImageInfo::read(memory, paramAddress + i*20, &pImageInfo[i]);
        }
        s->pImageInfo = pImageInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferInfo = NULL;
    } else {
        s->pBufferInfo = new VkDescriptorBufferInfo[(U32)s->descriptorCount * sizeof(VkDescriptorBufferInfo)];
        memory->memcpy((VkDescriptorBufferInfo*)s->pBufferInfo, paramAddress, (U32)s->descriptorCount * sizeof(VkDescriptorBufferInfo));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTexelBufferView = NULL;
    } else {
        s->pTexelBufferView = new VkBufferView[(U32)s->descriptorCount * sizeof(VkBufferView)];
        memory->memcpy((VkBufferView*)s->pTexelBufferView, paramAddress, (U32)s->descriptorCount * sizeof(VkBufferView));
    }
}
void MarshalVkWriteDescriptorSet::write(KMemory* memory, U32 address, VkWriteDescriptorSet* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->dstSet);address+=8;
    memory->writed(address, s->dstBinding);address+=4;
    memory->writed(address, s->dstArrayElement);address+=4;
    memory->writed(address, s->descriptorCount);address+=4;
    memory->writed(address, s->descriptorType);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorImageInfo* pImageInfo = new VkDescriptorImageInfo();
        MarshalVkDescriptorImageInfo::read(memory, paramAddress, pImageInfo);
        s->pImageInfo = pImageInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorBufferInfo* pBufferInfo = new VkDescriptorBufferInfo();
        MarshalVkDescriptorBufferInfo::read(memory, paramAddress, pBufferInfo);
        s->pBufferInfo = pBufferInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkCopyDescriptorSet::read(KMemory* memory, U32 address, VkCopyDescriptorSet* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->srcBinding = (uint32_t)memory->readd(address);address+=4;
    s->srcArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCopyDescriptorSet::write(KMemory* memory, U32 address, VkCopyDescriptorSet* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcSet);address+=8;
    memory->writed(address, s->srcBinding);address+=4;
    memory->writed(address, s->srcArrayElement);address+=4;
    memory->writeq(address, (U64)s->dstSet);address+=8;
    memory->writed(address, s->dstBinding);address+=4;
    memory->writed(address, s->dstArrayElement);address+=4;
    memory->writed(address, s->descriptorCount);address+=4;
}
void MarshalVkBufferCreateInfo::read(KMemory* memory, U32 address, VkBufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
    s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount * sizeof(uint32_t));
    }
}
void MarshalVkBufferCreateInfo::write(KMemory* memory, U32 address, VkBufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->sharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkBufferViewCreateInfo::read(KMemory* memory, U32 address, VkBufferViewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkBufferViewCreateFlags)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->range = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferViewCreateInfo::write(KMemory* memory, U32 address, VkBufferViewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writed(address, s->format);address+=4;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->range);address+=8;
}
void MarshalVkMemoryBarrier::read(KMemory* memory, U32 address, VkMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
}
void MarshalVkMemoryBarrier::write(KMemory* memory, U32 address, VkMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
}
void MarshalVkBufferMemoryBarrier::read(KMemory* memory, U32 address, VkBufferMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryBarrier::write(KMemory* memory, U32 address, VkBufferMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
void MarshalVkImageMemoryBarrier::read(KMemory* memory, U32 address, VkImageMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageMemoryBarrier::write(KMemory* memory, U32 address, VkImageMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->oldLayout);address+=4;
    memory->writed(address, s->newLayout);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
void MarshalVkImageCreateInfo::read(KMemory* memory, U32 address, VkImageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
    s->imageType = (VkImageType)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    memory->memcpy(&s->extent, address, 12);address+=12;
    s->mipLevels = (uint32_t)memory->readd(address);address+=4;
    s->arrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount * sizeof(uint32_t));
    }
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkImageCreateInfo::write(KMemory* memory, U32 address, VkImageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->imageType);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->memcpy(address, &s->extent, 12); address+=12;
    memory->writed(address, s->mipLevels);address+=4;
    memory->writed(address, s->arrayLayers);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->tiling);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->sharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->initialLayout);address+=4;
}
void MarshalVkSubresourceLayout::read(KMemory* memory, U32 address, VkSubresourceLayout* s) {
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->rowPitch = (VkDeviceSize)memory->readq(address);address+=8;
    s->arrayPitch = (VkDeviceSize)memory->readq(address);address+=8;
    s->depthPitch = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkImageViewCreateInfo::read(KMemory* memory, U32 address, VkImageViewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkImageViewCreateFlags)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    s->viewType = (VkImageViewType)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    MarshalVkComponentMapping::read(memory, address, &s->components); address+=16;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageViewCreateInfo::write(KMemory* memory, U32 address, VkImageViewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writed(address, s->viewType);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->memcpy(address, &s->components, 16); address+=16;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
void MarshalVkSparseBufferMemoryBindInfo::read(KMemory* memory, U32 address, VkSparseBufferMemoryBindInfo* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseMemoryBind[(U32)s->bindCount * sizeof(VkSparseMemoryBind)];
        memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseMemoryBind));
    }
}
void MarshalVkSparseImageOpaqueMemoryBindInfo::read(KMemory* memory, U32 address, VkSparseImageOpaqueMemoryBindInfo* s) {
    s->image = (VkImage)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseMemoryBind[(U32)s->bindCount * sizeof(VkSparseMemoryBind)];
        memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseMemoryBind));
    }
}
void MarshalVkSparseImageMemoryBindInfo::read(KMemory* memory, U32 address, VkSparseImageMemoryBindInfo* s) {
    s->image = (VkImage)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseImageMemoryBind[(U32)s->bindCount * sizeof(VkSparseImageMemoryBind)];
        memory->memcpy((VkSparseImageMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseImageMemoryBind));
    }
}
void MarshalVkBindSparseInfo::read(KMemory* memory, U32 address, VkBindSparseInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount * sizeof(VkSemaphore));
    }
    s->bufferBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferBinds = NULL;
    } else {
        VkSparseBufferMemoryBindInfo* pBufferBinds = new VkSparseBufferMemoryBindInfo[s->bufferBindCount];
        for (U32 i = 0; i < s->bufferBindCount; i++) {
            MarshalVkSparseBufferMemoryBindInfo::read(memory, paramAddress + i*16, &pBufferBinds[i]);
        }
        s->pBufferBinds = pBufferBinds;
    }
    s->imageOpaqueBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageOpaqueBinds = NULL;
    } else {
        VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = new VkSparseImageOpaqueMemoryBindInfo[s->imageOpaqueBindCount];
        for (U32 i = 0; i < s->imageOpaqueBindCount; i++) {
            MarshalVkSparseImageOpaqueMemoryBindInfo::read(memory, paramAddress + i*16, &pImageOpaqueBinds[i]);
        }
        s->pImageOpaqueBinds = pImageOpaqueBinds;
    }
    s->imageBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageBinds = NULL;
    } else {
        VkSparseImageMemoryBindInfo* pImageBinds = new VkSparseImageMemoryBindInfo[s->imageBindCount];
        for (U32 i = 0; i < s->imageBindCount; i++) {
            MarshalVkSparseImageMemoryBindInfo::read(memory, paramAddress + i*16, &pImageBinds[i]);
        }
        s->pImageBinds = pImageBinds;
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphores = NULL;
    } else {
        s->pSignalSemaphores = new VkSemaphore[(U32)s->signalSemaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, (U32)s->signalSemaphoreCount * sizeof(VkSemaphore));
    }
}
void MarshalVkBindSparseInfo::write(KMemory* memory, U32 address, VkBindSparseInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->bufferBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseBufferMemoryBindInfo* pBufferBinds = new VkSparseBufferMemoryBindInfo();
        MarshalVkSparseBufferMemoryBindInfo::read(memory, paramAddress, pBufferBinds);
        s->pBufferBinds = pBufferBinds;
    }
    memory->writed(address, s->imageOpaqueBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = new VkSparseImageOpaqueMemoryBindInfo();
        MarshalVkSparseImageOpaqueMemoryBindInfo::read(memory, paramAddress, pImageOpaqueBinds);
        s->pImageOpaqueBinds = pImageOpaqueBinds;
    }
    memory->writed(address, s->imageBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseImageMemoryBindInfo* pImageBinds = new VkSparseImageMemoryBindInfo();
        MarshalVkSparseImageMemoryBindInfo::read(memory, paramAddress, pImageBinds);
        s->pImageBinds = pImageBinds;
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkShaderModuleCreateInfo::read(KMemory* memory, U32 address, VkShaderModuleCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkShaderModuleCreateFlags)memory->readd(address);address+=4;
    s->codeSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCode = NULL;
    } else {
        s->pCode = new uint32_t[(U32)s->codeSize / 4 * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pCode, paramAddress, (U32)s->codeSize / 4 * sizeof(uint32_t));
    }
}
void MarshalVkShaderModuleCreateInfo::write(KMemory* memory, U32 address, VkShaderModuleCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->codeSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDescriptorSetLayoutBinding::read(KMemory* memory, U32 address, VkDescriptorSetLayoutBinding* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImmutableSamplers = NULL;
    } else {
        s->pImmutableSamplers = new VkSampler[(U32)s->descriptorCount * sizeof(VkSampler)];
        memory->memcpy((VkSampler*)s->pImmutableSamplers, paramAddress, (U32)s->descriptorCount * sizeof(VkSampler));
    }
}
void MarshalVkDescriptorSetLayoutCreateInfo::read(KMemory* memory, U32 address, VkDescriptorSetLayoutCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDescriptorSetLayoutCreateFlags)memory->readd(address);address+=4;
    s->bindingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBindings = NULL;
    } else {
        VkDescriptorSetLayoutBinding* pBindings = new VkDescriptorSetLayoutBinding[s->bindingCount];
        for (U32 i = 0; i < s->bindingCount; i++) {
            MarshalVkDescriptorSetLayoutBinding::read(memory, paramAddress + i*20, &pBindings[i]);
        }
        s->pBindings = pBindings;
    }
}
void MarshalVkDescriptorSetLayoutCreateInfo::write(KMemory* memory, U32 address, VkDescriptorSetLayoutCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->bindingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorSetLayoutBinding* pBindings = new VkDescriptorSetLayoutBinding();
        MarshalVkDescriptorSetLayoutBinding::read(memory, paramAddress, pBindings);
        s->pBindings = pBindings;
    }
}
void MarshalVkDescriptorPoolSize::read(KMemory* memory, U32 address, VkDescriptorPoolSize* s) {
    s->type = (VkDescriptorType)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorPoolCreateInfo::read(KMemory* memory, U32 address, VkDescriptorPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDescriptorPoolCreateFlags)memory->readd(address);address+=4;
    s->maxSets = (uint32_t)memory->readd(address);address+=4;
    s->poolSizeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPoolSizes = NULL;
    } else {
        VkDescriptorPoolSize* pPoolSizes = new VkDescriptorPoolSize[s->poolSizeCount];
        for (U32 i = 0; i < s->poolSizeCount; i++) {
            MarshalVkDescriptorPoolSize::read(memory, paramAddress + i*8, &pPoolSizes[i]);
        }
        s->pPoolSizes = pPoolSizes;
    }
}
void MarshalVkDescriptorPoolCreateInfo::write(KMemory* memory, U32 address, VkDescriptorPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->maxSets);address+=4;
    memory->writed(address, s->poolSizeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorPoolSize* pPoolSizes = new VkDescriptorPoolSize();
        MarshalVkDescriptorPoolSize::read(memory, paramAddress, pPoolSizes);
        s->pPoolSizes = pPoolSizes;
    }
}
void MarshalVkDescriptorSetAllocateInfo::read(KMemory* memory, U32 address, VkDescriptorSetAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->descriptorPool = (VkDescriptorPool)memory->readq(address);address+=8;
    s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->descriptorSetCount * sizeof(VkDescriptorSetLayout)];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->descriptorSetCount * sizeof(VkDescriptorSetLayout));
    }
}
void MarshalVkDescriptorSetAllocateInfo::write(KMemory* memory, U32 address, VkDescriptorSetAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->descriptorPool);address+=8;
    memory->writed(address, s->descriptorSetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSpecializationMapEntry::read(KMemory* memory, U32 address, VkSpecializationMapEntry* s) {
    s->constantID = (uint32_t)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->size = (size_t)memory->readd(address);address+=4;
}
void MarshalVkSpecializationInfo::read(KMemory* memory, U32 address, VkSpecializationInfo* s) {
    s->mapEntryCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMapEntries = NULL;
    } else {
        VkSpecializationMapEntry* pMapEntries = new VkSpecializationMapEntry[s->mapEntryCount];
        for (U32 i = 0; i < s->mapEntryCount; i++) {
            MarshalVkSpecializationMapEntry::read(memory, paramAddress + i*12, &pMapEntries[i]);
        }
        s->pMapEntries = pMapEntries;
    }
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkPipelineShaderStageCreateInfo::read(KMemory* memory, U32 address, VkPipelineShaderStageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineShaderStageCreateFlags)memory->readd(address);address+=4;
    s->stage = (VkShaderStageFlagBits)memory->readd(address);address+=4;
    s->module = (VkShaderModule)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen * sizeof(char)];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen * sizeof(char));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSpecializationInfo = NULL;
    } else {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
void MarshalVkPipelineShaderStageCreateInfo::write(KMemory* memory, U32 address, VkPipelineShaderStageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stage);address+=4;
    memory->writeq(address, (U64)s->module);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
void MarshalVkComputePipelineCreateInfo::read(KMemory* memory, U32 address, VkComputePipelineCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    MarshalVkPipelineShaderStageCreateInfo::read(memory, address, &s->stage); address+=32;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkComputePipelineCreateInfo::write(KMemory* memory, U32 address, VkComputePipelineCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, &s->stage, 32); address+=32;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
void MarshalVkVertexInputBindingDescription::read(KMemory* memory, U32 address, VkVertexInputBindingDescription* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
}
void MarshalVkVertexInputAttributeDescription::read(KMemory* memory, U32 address, VkVertexInputAttributeDescription* s) {
    s->location = (uint32_t)memory->readd(address);address+=4;
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineVertexInputStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineVertexInputStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineVertexInputStateCreateFlags)memory->readd(address);address+=4;
    s->vertexBindingDescriptionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexBindingDescriptions = NULL;
    } else {
        VkVertexInputBindingDescription* pVertexBindingDescriptions = new VkVertexInputBindingDescription[s->vertexBindingDescriptionCount];
        for (U32 i = 0; i < s->vertexBindingDescriptionCount; i++) {
            MarshalVkVertexInputBindingDescription::read(memory, paramAddress + i*12, &pVertexBindingDescriptions[i]);
        }
        s->pVertexBindingDescriptions = pVertexBindingDescriptions;
    }
    s->vertexAttributeDescriptionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexAttributeDescriptions = NULL;
    } else {
        VkVertexInputAttributeDescription* pVertexAttributeDescriptions = new VkVertexInputAttributeDescription[s->vertexAttributeDescriptionCount];
        for (U32 i = 0; i < s->vertexAttributeDescriptionCount; i++) {
            MarshalVkVertexInputAttributeDescription::read(memory, paramAddress + i*16, &pVertexAttributeDescriptions[i]);
        }
        s->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
    }
}
void MarshalVkPipelineVertexInputStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineVertexInputStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->vertexBindingDescriptionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputBindingDescription* pVertexBindingDescriptions = new VkVertexInputBindingDescription();
        MarshalVkVertexInputBindingDescription::read(memory, paramAddress, pVertexBindingDescriptions);
        s->pVertexBindingDescriptions = pVertexBindingDescriptions;
    }
    memory->writed(address, s->vertexAttributeDescriptionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputAttributeDescription* pVertexAttributeDescriptions = new VkVertexInputAttributeDescription();
        MarshalVkVertexInputAttributeDescription::read(memory, paramAddress, pVertexAttributeDescriptions);
        s->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
    }
}
void MarshalVkPipelineInputAssemblyStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineInputAssemblyStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineInputAssemblyStateCreateFlags)memory->readd(address);address+=4;
    s->topology = (VkPrimitiveTopology)memory->readd(address);address+=4;
    s->primitiveRestartEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineInputAssemblyStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineInputAssemblyStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->topology);address+=4;
    memory->writed(address, s->primitiveRestartEnable);address+=4;
}
void MarshalVkPipelineTessellationStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineTessellationStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineTessellationStateCreateFlags)memory->readd(address);address+=4;
    s->patchControlPoints = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineTessellationStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineTessellationStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->patchControlPoints);address+=4;
}
void MarshalVkPipelineViewportStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineViewportStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineViewportStateCreateFlags)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewports = NULL;
    } else {
        s->pViewports = new VkViewport[(U32)s->viewportCount * sizeof(VkViewport)];
        memory->memcpy((VkViewport*)s->pViewports, paramAddress, (U32)s->viewportCount * sizeof(VkViewport));
    }
    s->scissorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pScissors = NULL;
    } else {
        s->pScissors = new VkRect2D[(U32)s->scissorCount * sizeof(VkRect2D)];
        memory->memcpy((VkRect2D*)s->pScissors, paramAddress, (U32)s->scissorCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineViewportStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineViewportStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewport* pViewports = new VkViewport();
        MarshalVkViewport::read(memory, paramAddress, pViewports);
        s->pViewports = pViewports;
    }
    memory->writed(address, s->scissorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pScissors = new VkRect2D();
        MarshalVkRect2D::read(memory, paramAddress, pScissors);
        s->pScissors = pScissors;
    }
}
void MarshalVkPipelineRasterizationStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineRasterizationStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationStateCreateFlags)memory->readd(address);address+=4;
    s->depthClampEnable = (VkBool32)memory->readd(address);address+=4;
    s->rasterizerDiscardEnable = (VkBool32)memory->readd(address);address+=4;
    s->polygonMode = (VkPolygonMode)memory->readd(address);address+=4;
    s->cullMode = (VkCullModeFlags)memory->readd(address);address+=4;
    s->frontFace = (VkFrontFace)memory->readd(address);address+=4;
    s->depthBiasEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasConstantFactor = depthBiasConstantFactorFloat.f;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.i = memory->readd(address);address+=4;
    s->depthBiasClamp = depthBiasClampFloat.f;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasSlopeFactor = depthBiasSlopeFactorFloat.f;
    MarshalFloat lineWidthFloat;
    lineWidthFloat.i = memory->readd(address);address+=4;
    s->lineWidth = lineWidthFloat.f;
}
void MarshalVkPipelineRasterizationStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineRasterizationStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthClampEnable);address+=4;
    memory->writed(address, s->rasterizerDiscardEnable);address+=4;
    memory->writed(address, s->polygonMode);address+=4;
    memory->writed(address, s->cullMode);address+=4;
    memory->writed(address, s->frontFace);address+=4;
    memory->writed(address, s->depthBiasEnable);address+=4;
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.f = s->depthBiasConstantFactor;
    memory->writed(address, depthBiasConstantFactorFloat.i);address+=4;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.f = s->depthBiasClamp;
    memory->writed(address, depthBiasClampFloat.i);address+=4;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.f = s->depthBiasSlopeFactor;
    memory->writed(address, depthBiasSlopeFactorFloat.i);address+=4;
    MarshalFloat lineWidthFloat;
    lineWidthFloat.f = s->lineWidth;
    memory->writed(address, lineWidthFloat.i);address+=4;
}
void MarshalVkPipelineMultisampleStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineMultisampleStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineMultisampleStateCreateFlags)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->sampleShadingEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat minSampleShadingFloat;
    minSampleShadingFloat.i = memory->readd(address);address+=4;
    s->minSampleShading = minSampleShadingFloat.f;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleMask = NULL;
    } else {
        s->pSampleMask = new VkSampleMask[(s->rasterizationSamples + 31) / 32 * sizeof(VkSampleMask)];
        memory->memcpy((VkSampleMask*)s->pSampleMask, paramAddress, (s->rasterizationSamples + 31) / 32 * sizeof(VkSampleMask));
    }
    s->alphaToCoverageEnable = (VkBool32)memory->readd(address);address+=4;
    s->alphaToOneEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineMultisampleStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineMultisampleStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
    memory->writed(address, s->sampleShadingEnable);address+=4;
    MarshalFloat minSampleShadingFloat;
    minSampleShadingFloat.f = s->minSampleShading;
    memory->writed(address, minSampleShadingFloat.i);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->alphaToCoverageEnable);address+=4;
    memory->writed(address, s->alphaToOneEnable);address+=4;
}
void MarshalVkPipelineColorBlendAttachmentState::read(KMemory* memory, U32 address, VkPipelineColorBlendAttachmentState* s) {
    s->blendEnable = (VkBool32)memory->readd(address);address+=4;
    s->srcColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->colorBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->srcAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->alphaBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->colorWriteMask = (VkColorComponentFlags)memory->readd(address);address+=4;
}
void MarshalVkPipelineColorBlendStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineColorBlendStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineColorBlendStateCreateFlags)memory->readd(address);address+=4;
    s->logicOpEnable = (VkBool32)memory->readd(address);address+=4;
    s->logicOp = (VkLogicOp)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkPipelineColorBlendAttachmentState* pAttachments = new VkPipelineColorBlendAttachmentState[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkPipelineColorBlendAttachmentState::read(memory, paramAddress + i*32, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    memory->memcpy(&s->blendConstants, address, 4);address+=4;
}
void MarshalVkPipelineColorBlendStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineColorBlendStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->logicOpEnable);address+=4;
    memory->writed(address, s->logicOp);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineColorBlendAttachmentState* pAttachments = new VkPipelineColorBlendAttachmentState();
        MarshalVkPipelineColorBlendAttachmentState::read(memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->memcpy(address, s->blendConstants, 16); address+=16;
}
void MarshalVkPipelineDynamicStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineDynamicStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineDynamicStateCreateFlags)memory->readd(address);address+=4;
    s->dynamicStateCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicStates = NULL;
    } else {
        s->pDynamicStates = new VkDynamicState[(U32)s->dynamicStateCount * sizeof(VkDynamicState)];
        memory->memcpy((VkDynamicState*)s->pDynamicStates, paramAddress, (U32)s->dynamicStateCount * sizeof(VkDynamicState));
    }
}
void MarshalVkPipelineDynamicStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineDynamicStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->dynamicStateCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkStencilOpState::read(KMemory* memory, U32 address, VkStencilOpState* s) {
    s->failOp = (VkStencilOp)memory->readd(address);address+=4;
    s->passOp = (VkStencilOp)memory->readd(address);address+=4;
    s->depthFailOp = (VkStencilOp)memory->readd(address);address+=4;
    s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
    s->compareMask = (uint32_t)memory->readd(address);address+=4;
    s->writeMask = (uint32_t)memory->readd(address);address+=4;
    s->reference = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineDepthStencilStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineDepthStencilStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineDepthStencilStateCreateFlags)memory->readd(address);address+=4;
    s->depthTestEnable = (VkBool32)memory->readd(address);address+=4;
    s->depthWriteEnable = (VkBool32)memory->readd(address);address+=4;
    s->depthCompareOp = (VkCompareOp)memory->readd(address);address+=4;
    s->depthBoundsTestEnable = (VkBool32)memory->readd(address);address+=4;
    s->stencilTestEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalVkStencilOpState::read(memory, address, &s->front); address+=28;
    MarshalVkStencilOpState::read(memory, address, &s->back); address+=28;
    MarshalFloat minDepthBoundsFloat;
    minDepthBoundsFloat.i = memory->readd(address);address+=4;
    s->minDepthBounds = minDepthBoundsFloat.f;
    MarshalFloat maxDepthBoundsFloat;
    maxDepthBoundsFloat.i = memory->readd(address);address+=4;
    s->maxDepthBounds = maxDepthBoundsFloat.f;
}
void MarshalVkPipelineDepthStencilStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineDepthStencilStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthTestEnable);address+=4;
    memory->writed(address, s->depthWriteEnable);address+=4;
    memory->writed(address, s->depthCompareOp);address+=4;
    memory->writed(address, s->depthBoundsTestEnable);address+=4;
    memory->writed(address, s->stencilTestEnable);address+=4;
    memory->memcpy(address, &s->front, 28); address+=28;
    memory->memcpy(address, &s->back, 28); address+=28;
    MarshalFloat minDepthBoundsFloat;
    minDepthBoundsFloat.f = s->minDepthBounds;
    memory->writed(address, minDepthBoundsFloat.i);address+=4;
    MarshalFloat maxDepthBoundsFloat;
    maxDepthBoundsFloat.f = s->maxDepthBounds;
    memory->writed(address, maxDepthBoundsFloat.i);address+=4;
}
void MarshalVkGraphicsPipelineCreateInfo::read(KMemory* memory, U32 address, VkGraphicsPipelineCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexInputState = NULL;
    } else {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAssemblyState = NULL;
    } else {
        VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo();
        MarshalVkPipelineInputAssemblyStateCreateInfo::read(memory, paramAddress, pInputAssemblyState);
        s->pInputAssemblyState = pInputAssemblyState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTessellationState = NULL;
    } else {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportState = NULL;
    } else {
        VkPipelineViewportStateCreateInfo* pViewportState = new VkPipelineViewportStateCreateInfo();
        MarshalVkPipelineViewportStateCreateInfo::read(memory, paramAddress, pViewportState);
        s->pViewportState = pViewportState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRasterizationState = NULL;
    } else {
        VkPipelineRasterizationStateCreateInfo* pRasterizationState = new VkPipelineRasterizationStateCreateInfo();
        MarshalVkPipelineRasterizationStateCreateInfo::read(memory, paramAddress, pRasterizationState);
        s->pRasterizationState = pRasterizationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMultisampleState = NULL;
    } else {
        VkPipelineMultisampleStateCreateInfo* pMultisampleState = new VkPipelineMultisampleStateCreateInfo();
        MarshalVkPipelineMultisampleStateCreateInfo::read(memory, paramAddress, pMultisampleState);
        s->pMultisampleState = pMultisampleState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilState = NULL;
    } else {
        VkPipelineDepthStencilStateCreateInfo* pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo();
        MarshalVkPipelineDepthStencilStateCreateInfo::read(memory, paramAddress, pDepthStencilState);
        s->pDepthStencilState = pDepthStencilState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorBlendState = NULL;
    } else {
        VkPipelineColorBlendStateCreateInfo* pColorBlendState = new VkPipelineColorBlendStateCreateInfo();
        MarshalVkPipelineColorBlendStateCreateInfo::read(memory, paramAddress, pColorBlendState);
        s->pColorBlendState = pColorBlendState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicState = NULL;
    } else {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkGraphicsPipelineCreateInfo::write(KMemory* memory, U32 address, VkGraphicsPipelineCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo();
        MarshalVkPipelineInputAssemblyStateCreateInfo::read(memory, paramAddress, pInputAssemblyState);
        s->pInputAssemblyState = pInputAssemblyState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineViewportStateCreateInfo* pViewportState = new VkPipelineViewportStateCreateInfo();
        MarshalVkPipelineViewportStateCreateInfo::read(memory, paramAddress, pViewportState);
        s->pViewportState = pViewportState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineRasterizationStateCreateInfo* pRasterizationState = new VkPipelineRasterizationStateCreateInfo();
        MarshalVkPipelineRasterizationStateCreateInfo::read(memory, paramAddress, pRasterizationState);
        s->pRasterizationState = pRasterizationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineMultisampleStateCreateInfo* pMultisampleState = new VkPipelineMultisampleStateCreateInfo();
        MarshalVkPipelineMultisampleStateCreateInfo::read(memory, paramAddress, pMultisampleState);
        s->pMultisampleState = pMultisampleState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineDepthStencilStateCreateInfo* pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo();
        MarshalVkPipelineDepthStencilStateCreateInfo::read(memory, paramAddress, pDepthStencilState);
        s->pDepthStencilState = pDepthStencilState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineColorBlendStateCreateInfo* pColorBlendState = new VkPipelineColorBlendStateCreateInfo();
        MarshalVkPipelineColorBlendStateCreateInfo::read(memory, paramAddress, pColorBlendState);
        s->pColorBlendState = pColorBlendState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
void MarshalVkPipelineCacheCreateInfo::read(KMemory* memory, U32 address, VkPipelineCacheCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCacheCreateFlags)memory->readd(address);address+=4;
    s->initialDataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInitialData = NULL;
    } else {
        s->pInitialData = new char[(U32)s->initialDataSize];
        memory->memcpy((void*)s->pInitialData, paramAddress, (U32)s->initialDataSize);
    }
}
void MarshalVkPipelineCacheCreateInfo::write(KMemory* memory, U32 address, VkPipelineCacheCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->initialDataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPushConstantRange::read(KMemory* memory, U32 address, VkPushConstantRange* s) {
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->size = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineLayoutCreateInfo::read(KMemory* memory, U32 address, VkPipelineLayoutCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineLayoutCreateFlags)memory->readd(address);address+=4;
    s->setLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->setLayoutCount * sizeof(VkDescriptorSetLayout)];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->setLayoutCount * sizeof(VkDescriptorSetLayout));
    }
    s->pushConstantRangeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPushConstantRanges = NULL;
    } else {
        s->pPushConstantRanges = new VkPushConstantRange[(U32)s->pushConstantRangeCount * sizeof(VkPushConstantRange)];
        memory->memcpy((VkPushConstantRange*)s->pPushConstantRanges, paramAddress, (U32)s->pushConstantRangeCount * sizeof(VkPushConstantRange));
    }
}
void MarshalVkPipelineLayoutCreateInfo::write(KMemory* memory, U32 address, VkPipelineLayoutCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->setLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->pushConstantRangeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPushConstantRange* pPushConstantRanges = new VkPushConstantRange();
        MarshalVkPushConstantRange::read(memory, paramAddress, pPushConstantRanges);
        s->pPushConstantRanges = pPushConstantRanges;
    }
}
void MarshalVkSamplerCreateInfo::read(KMemory* memory, U32 address, VkSamplerCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSamplerCreateFlags)memory->readd(address);address+=4;
    s->magFilter = (VkFilter)memory->readd(address);address+=4;
    s->minFilter = (VkFilter)memory->readd(address);address+=4;
    s->mipmapMode = (VkSamplerMipmapMode)memory->readd(address);address+=4;
    s->addressModeU = (VkSamplerAddressMode)memory->readd(address);address+=4;
    s->addressModeV = (VkSamplerAddressMode)memory->readd(address);address+=4;
    s->addressModeW = (VkSamplerAddressMode)memory->readd(address);address+=4;
    MarshalFloat mipLodBiasFloat;
    mipLodBiasFloat.i = memory->readd(address);address+=4;
    s->mipLodBias = mipLodBiasFloat.f;
    s->anisotropyEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat maxAnisotropyFloat;
    maxAnisotropyFloat.i = memory->readd(address);address+=4;
    s->maxAnisotropy = maxAnisotropyFloat.f;
    s->compareEnable = (VkBool32)memory->readd(address);address+=4;
    s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
    MarshalFloat minLodFloat;
    minLodFloat.i = memory->readd(address);address+=4;
    s->minLod = minLodFloat.f;
    MarshalFloat maxLodFloat;
    maxLodFloat.i = memory->readd(address);address+=4;
    s->maxLod = maxLodFloat.f;
    s->borderColor = (VkBorderColor)memory->readd(address);address+=4;
    s->unnormalizedCoordinates = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerCreateInfo::write(KMemory* memory, U32 address, VkSamplerCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->magFilter);address+=4;
    memory->writed(address, s->minFilter);address+=4;
    memory->writed(address, s->mipmapMode);address+=4;
    memory->writed(address, s->addressModeU);address+=4;
    memory->writed(address, s->addressModeV);address+=4;
    memory->writed(address, s->addressModeW);address+=4;
    MarshalFloat mipLodBiasFloat;
    mipLodBiasFloat.f = s->mipLodBias;
    memory->writed(address, mipLodBiasFloat.i);address+=4;
    memory->writed(address, s->anisotropyEnable);address+=4;
    MarshalFloat maxAnisotropyFloat;
    maxAnisotropyFloat.f = s->maxAnisotropy;
    memory->writed(address, maxAnisotropyFloat.i);address+=4;
    memory->writed(address, s->compareEnable);address+=4;
    memory->writed(address, s->compareOp);address+=4;
    MarshalFloat minLodFloat;
    minLodFloat.f = s->minLod;
    memory->writed(address, minLodFloat.i);address+=4;
    MarshalFloat maxLodFloat;
    maxLodFloat.f = s->maxLod;
    memory->writed(address, maxLodFloat.i);address+=4;
    memory->writed(address, s->borderColor);address+=4;
    memory->writed(address, s->unnormalizedCoordinates);address+=4;
}
void MarshalVkCommandPoolCreateInfo::read(KMemory* memory, U32 address, VkCommandPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkCommandPoolCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandPoolCreateInfo::write(KMemory* memory, U32 address, VkCommandPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
}
void MarshalVkCommandBufferAllocateInfo::read(KMemory* memory, U32 address, VkCommandBufferAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->commandPool = (VkCommandPool)memory->readq(address);address+=8;
    s->level = (VkCommandBufferLevel)memory->readd(address);address+=4;
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferAllocateInfo::write(KMemory* memory, U32 address, VkCommandBufferAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->commandPool);address+=8;
    memory->writed(address, s->level);address+=4;
    memory->writed(address, s->commandBufferCount);address+=4;
}
void MarshalVkCommandBufferInheritanceInfo::read(KMemory* memory, U32 address, VkCommandBufferInheritanceInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
    s->occlusionQueryEnable = (VkBool32)memory->readd(address);address+=4;
    s->queryFlags = (VkQueryControlFlags)memory->readd(address);address+=4;
    s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferInheritanceInfo::write(KMemory* memory, U32 address, VkCommandBufferInheritanceInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
    memory->writeq(address, (U64)s->framebuffer);address+=8;
    memory->writed(address, s->occlusionQueryEnable);address+=4;
    memory->writed(address, s->queryFlags);address+=4;
    memory->writed(address, s->pipelineStatistics);address+=4;
}
void MarshalVkCommandBufferBeginInfo::read(KMemory* memory, U32 address, VkCommandBufferBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkCommandBufferUsageFlags)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInheritanceInfo = NULL;
    } else {
        VkCommandBufferInheritanceInfo* pInheritanceInfo = new VkCommandBufferInheritanceInfo();
        MarshalVkCommandBufferInheritanceInfo::read(memory, paramAddress, pInheritanceInfo);
        s->pInheritanceInfo = pInheritanceInfo;
    }
}
void MarshalVkCommandBufferBeginInfo::write(KMemory* memory, U32 address, VkCommandBufferBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCommandBufferInheritanceInfo* pInheritanceInfo = new VkCommandBufferInheritanceInfo();
        MarshalVkCommandBufferInheritanceInfo::read(memory, paramAddress, pInheritanceInfo);
        s->pInheritanceInfo = pInheritanceInfo;
    }
}
void MarshalVkRenderPassBeginInfo::read(KMemory* memory, U32 address, VkRenderPassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
    memory->memcpy(&s->renderArea, address, 16);address+=16;
    s->clearValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pClearValues = NULL;
    } else {
        s->pClearValues = new VkClearValue[(U32)s->clearValueCount * sizeof(VkClearValue)];
        memory->memcpy((VkClearValue*)s->pClearValues, paramAddress, (U32)s->clearValueCount * sizeof(VkClearValue));
    }
}
void MarshalVkRenderPassBeginInfo::write(KMemory* memory, U32 address, VkRenderPassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writeq(address, (U64)s->framebuffer);address+=8;
    memory->memcpy(address, &s->renderArea, 16); address+=16;
    memory->writed(address, s->clearValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkAttachmentDescription::read(KMemory* memory, U32 address, VkAttachmentDescription* s) {
    s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReference::read(KMemory* memory, U32 address, VkAttachmentReference* s) {
    s->attachment = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkSubpassDescription::read(KMemory* memory, U32 address, VkSubpassDescription* s) {
    s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAttachments = NULL;
    } else {
        VkAttachmentReference* pInputAttachments = new VkAttachmentReference[s->inputAttachmentCount];
        for (U32 i = 0; i < s->inputAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(memory, paramAddress + i*8, &pInputAttachments[i]);
        }
        s->pInputAttachments = pInputAttachments;
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachments = NULL;
    } else {
        VkAttachmentReference* pColorAttachments = new VkAttachmentReference[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(memory, paramAddress + i*8, &pColorAttachments[i]);
        }
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResolveAttachments = NULL;
    } else {
        VkAttachmentReference* pResolveAttachments = new VkAttachmentReference[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(memory, paramAddress + i*8, &pResolveAttachments[i]);
        }
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilAttachment = NULL;
    } else {
        VkAttachmentReference* pDepthStencilAttachment = new VkAttachmentReference();
        MarshalVkAttachmentReference::read(memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPreserveAttachments = NULL;
    } else {
        s->pPreserveAttachments = new uint32_t[(U32)s->preserveAttachmentCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, (U32)s->preserveAttachmentCount * sizeof(uint32_t));
    }
}
void MarshalVkSubpassDependency::read(KMemory* memory, U32 address, VkSubpassDependency* s) {
    s->srcSubpass = (uint32_t)memory->readd(address);address+=4;
    s->dstSubpass = (uint32_t)memory->readd(address);address+=4;
    s->srcStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->dstStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
}
void MarshalVkRenderPassCreateInfo::read(KMemory* memory, U32 address, VkRenderPassCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkAttachmentDescription* pAttachments = new VkAttachmentDescription[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkAttachmentDescription::read(memory, paramAddress + i*36, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubpasses = NULL;
    } else {
        VkSubpassDescription* pSubpasses = new VkSubpassDescription[s->subpassCount];
        for (U32 i = 0; i < s->subpassCount; i++) {
            MarshalVkSubpassDescription::read(memory, paramAddress + i*40, &pSubpasses[i]);
        }
        s->pSubpasses = pSubpasses;
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDependencies = NULL;
    } else {
        s->pDependencies = new VkSubpassDependency[(U32)s->dependencyCount * sizeof(VkSubpassDependency)];
        memory->memcpy((VkSubpassDependency*)s->pDependencies, paramAddress, (U32)s->dependencyCount * sizeof(VkSubpassDependency));
    }
}
void MarshalVkRenderPassCreateInfo::write(KMemory* memory, U32 address, VkRenderPassCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentDescription* pAttachments = new VkAttachmentDescription();
        MarshalVkAttachmentDescription::read(memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDescription* pSubpasses = new VkSubpassDescription();
        MarshalVkSubpassDescription::read(memory, paramAddress, pSubpasses);
        s->pSubpasses = pSubpasses;
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDependency* pDependencies = new VkSubpassDependency();
        MarshalVkSubpassDependency::read(memory, paramAddress, pDependencies);
        s->pDependencies = pDependencies;
    }
}
void MarshalVkEventCreateInfo::read(KMemory* memory, U32 address, VkEventCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkEventCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkEventCreateInfo::write(KMemory* memory, U32 address, VkEventCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkFenceCreateInfo::read(KMemory* memory, U32 address, VkFenceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkFenceCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkFenceCreateInfo::write(KMemory* memory, U32 address, VkFenceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkSemaphoreCreateInfo::read(KMemory* memory, U32 address, VkSemaphoreCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSemaphoreCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkSemaphoreCreateInfo::write(KMemory* memory, U32 address, VkSemaphoreCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkQueryPoolCreateInfo::read(KMemory* memory, U32 address, VkQueryPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkQueryPoolCreateFlags)memory->readd(address);address+=4;
    s->queryType = (VkQueryType)memory->readd(address);address+=4;
    s->queryCount = (uint32_t)memory->readd(address);address+=4;
    s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
}
void MarshalVkQueryPoolCreateInfo::write(KMemory* memory, U32 address, VkQueryPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queryType);address+=4;
    memory->writed(address, s->queryCount);address+=4;
    memory->writed(address, s->pipelineStatistics);address+=4;
}
void MarshalVkFramebufferCreateInfo::read(KMemory* memory, U32 address, VkFramebufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkFramebufferCreateFlags)memory->readd(address);address+=4;
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        s->pAttachments = new VkImageView[(U32)s->attachmentCount * sizeof(VkImageView)];
        memory->memcpy((VkImageView*)s->pAttachments, paramAddress, (U32)s->attachmentCount * sizeof(VkImageView));
    }
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
    s->layers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkFramebufferCreateInfo::write(KMemory* memory, U32 address, VkFramebufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->width);address+=4;
    memory->writed(address, s->height);address+=4;
    memory->writed(address, s->layers);address+=4;
}
void MarshalVkSubmitInfo::read(KMemory* memory, U32 address, VkSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount * sizeof(VkSemaphore));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitDstStageMask = NULL;
    } else {
        s->pWaitDstStageMask = new VkPipelineStageFlags[(U32)s->waitSemaphoreCount * sizeof(VkPipelineStageFlags)];
        memory->memcpy((VkPipelineStageFlags*)s->pWaitDstStageMask, paramAddress, (U32)s->waitSemaphoreCount * sizeof(VkPipelineStageFlags));
    }
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBuffers = NULL;
    } else {
        VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[s->commandBufferCount];
        for (int i=0;i<(int)s->commandBufferCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(memory, itemAddress);
        }
        s->pCommandBuffers = pCommandBuffers;
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphores = NULL;
    } else {
        s->pSignalSemaphores = new VkSemaphore[(U32)s->signalSemaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, (U32)s->signalSemaphoreCount * sizeof(VkSemaphore));
    }
}
void MarshalVkSubmitInfo::write(KMemory* memory, U32 address, VkSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->commandBufferCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDisplayPropertiesKHR::read(KMemory* memory, U32 address, VkDisplayPropertiesKHR* s) {
    s->display = (VkDisplayKHR)memory->readq(address);address+=8;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->displayName = NULL;
    } else {
        U32 displayNameLen = memory->strlen(paramAddress)+1;
        s->displayName = new char[displayNameLen * sizeof(char)];
        memory->memcpy((char*)s->displayName, paramAddress, displayNameLen * sizeof(char));
    }
    memory->memcpy(&s->physicalDimensions, address, 8);address+=8;
    memory->memcpy(&s->physicalResolution, address, 8);address+=8;
    s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
    s->planeReorderPossible = (VkBool32)memory->readd(address);address+=4;
    s->persistentContent = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDisplayModeCreateInfoKHR::read(KMemory* memory, U32 address, VkDisplayModeCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDisplayModeCreateFlagsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->parameters, address, 12);address+=12;
}
void MarshalVkDisplayModeCreateInfoKHR::write(KMemory* memory, U32 address, VkDisplayModeCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, &s->parameters, 12); address+=12;
}
void MarshalVkDisplaySurfaceCreateInfoKHR::read(KMemory* memory, U32 address, VkDisplaySurfaceCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDisplaySurfaceCreateFlagsKHR)memory->readd(address);address+=4;
    s->displayMode = (VkDisplayModeKHR)memory->readq(address);address+=8;
    s->planeIndex = (uint32_t)memory->readd(address);address+=4;
    s->planeStackIndex = (uint32_t)memory->readd(address);address+=4;
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    MarshalFloat globalAlphaFloat;
    globalAlphaFloat.i = memory->readd(address);address+=4;
    s->globalAlpha = globalAlphaFloat.f;
    s->alphaMode = (VkDisplayPlaneAlphaFlagBitsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->imageExtent, address, 8);address+=8;
}
void MarshalVkDisplaySurfaceCreateInfoKHR::write(KMemory* memory, U32 address, VkDisplaySurfaceCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->displayMode);address+=8;
    memory->writed(address, s->planeIndex);address+=4;
    memory->writed(address, s->planeStackIndex);address+=4;
    memory->writed(address, s->transform);address+=4;
    MarshalFloat globalAlphaFloat;
    globalAlphaFloat.f = s->globalAlpha;
    memory->writed(address, globalAlphaFloat.i);address+=4;
    memory->writed(address, s->alphaMode);address+=4;
    memory->memcpy(address, &s->imageExtent, 8); address+=8;
}
void MarshalVkDisplayPresentInfoKHR::read(KMemory* memory, U32 address, VkDisplayPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->srcRect, address, 16);address+=16;
    memory->memcpy(&s->dstRect, address, 16);address+=16;
    s->persistent = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDisplayPresentInfoKHR::write(KMemory* memory, U32 address, VkDisplayPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->srcRect, 16); address+=16;
    memory->memcpy(address, &s->dstRect, 16); address+=16;
    memory->writed(address, s->persistent);address+=4;
}
void MarshalVkSurfaceCapabilitiesKHR::read(KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->maxImageCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->currentExtent, address, 8);address+=8;
    memory->memcpy(&s->minImageExtent, address, 8);address+=8;
    memory->memcpy(&s->maxImageExtent, address, 8);address+=8;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
    s->currentTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)memory->readd(address);address+=4;
    s->supportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkSurfaceCapabilitiesKHR::write(KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->maxImageCount);address+=4;
    memory->memcpy(address, &s->currentExtent, 8); address+=8;
    memory->memcpy(address, &s->minImageExtent, 8); address+=8;
    memory->memcpy(address, &s->maxImageExtent, 8); address+=8;
    memory->writed(address, s->maxImageArrayLayers);address+=4;
    memory->writed(address, s->supportedTransforms);address+=4;
    memory->writed(address, s->currentTransform);address+=4;
    memory->writed(address, s->supportedCompositeAlpha);address+=4;
    memory->writed(address, s->supportedUsageFlags);address+=4;
}
void MarshalVkSurfaceFormatKHR::read(KMemory* memory, U32 address, VkSurfaceFormatKHR* s) {
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->colorSpace = (VkColorSpaceKHR)memory->readd(address);address+=4;
}
void MarshalVkSurfaceFormatKHR::write(KMemory* memory, U32 address, VkSurfaceFormatKHR* s) {
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->colorSpace);address+=4;
}
void MarshalVkSwapchainCreateInfoKHR::read(KMemory* memory, U32 address, VkSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSwapchainCreateFlagsKHR)memory->readd(address);address+=4;
    s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->imageFormat = (VkFormat)memory->readd(address);address+=4;
    s->imageColorSpace = (VkColorSpaceKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->imageExtent, address, 8);address+=8;
    s->imageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->imageUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->imageSharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount * sizeof(uint32_t));
    }
    s->preTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->compositeAlpha = (VkCompositeAlphaFlagBitsKHR)memory->readd(address);address+=4;
    s->presentMode = (VkPresentModeKHR)memory->readd(address);address+=4;
    s->clipped = (VkBool32)memory->readd(address);address+=4;
    s->oldSwapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
}
void MarshalVkSwapchainCreateInfoKHR::write(KMemory* memory, U32 address, VkSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->surface);address+=8;
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->imageFormat);address+=4;
    memory->writed(address, s->imageColorSpace);address+=4;
    memory->memcpy(address, &s->imageExtent, 8); address+=8;
    memory->writed(address, s->imageArrayLayers);address+=4;
    memory->writed(address, s->imageUsage);address+=4;
    memory->writed(address, s->imageSharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->preTransform);address+=4;
    memory->writed(address, s->compositeAlpha);address+=4;
    memory->writed(address, s->presentMode);address+=4;
    memory->writed(address, s->clipped);address+=4;
    memory->writeq(address, (U64)s->oldSwapchain);address+=8;
}
void MarshalVkPresentInfoKHR::read(KMemory* memory, U32 address, VkPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount * sizeof(VkSemaphore));
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSwapchains = NULL;
    } else {
        s->pSwapchains = new VkSwapchainKHR[(U32)s->swapchainCount * sizeof(VkSwapchainKHR)];
        memory->memcpy((VkSwapchainKHR*)s->pSwapchains, paramAddress, (U32)s->swapchainCount * sizeof(VkSwapchainKHR));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageIndices = NULL;
    } else {
        s->pImageIndices = new uint32_t[(U32)s->swapchainCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pImageIndices, paramAddress, (U32)s->swapchainCount * sizeof(uint32_t));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResults = NULL;
    } else {
        s->pResults = new VkResult[(U32)s->swapchainCount * sizeof(VkResult)];
        memory->memcpy((VkResult*)s->pResults, paramAddress, (U32)s->swapchainCount * sizeof(VkResult));
    }
}
void MarshalVkPresentInfoKHR::write(KMemory* memory, U32 address, VkPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkValidationFlagsEXT::read(KMemory* memory, U32 address, VkValidationFlagsEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->disabledValidationCheckCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDisabledValidationChecks = NULL;
    } else {
        s->pDisabledValidationChecks = new VkValidationCheckEXT[(U32)s->disabledValidationCheckCount * sizeof(VkValidationCheckEXT)];
        memory->memcpy((VkValidationCheckEXT*)s->pDisabledValidationChecks, paramAddress, (U32)s->disabledValidationCheckCount * sizeof(VkValidationCheckEXT));
    }
}
void MarshalVkValidationFlagsEXT::write(KMemory* memory, U32 address, VkValidationFlagsEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->disabledValidationCheckCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkValidationFeaturesEXT::read(KMemory* memory, U32 address, VkValidationFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->enabledValidationFeatureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEnabledValidationFeatures = NULL;
    } else {
        s->pEnabledValidationFeatures = new VkValidationFeatureEnableEXT[(U32)s->enabledValidationFeatureCount * sizeof(VkValidationFeatureEnableEXT)];
        memory->memcpy((VkValidationFeatureEnableEXT*)s->pEnabledValidationFeatures, paramAddress, (U32)s->enabledValidationFeatureCount * sizeof(VkValidationFeatureEnableEXT));
    }
    s->disabledValidationFeatureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDisabledValidationFeatures = NULL;
    } else {
        s->pDisabledValidationFeatures = new VkValidationFeatureDisableEXT[(U32)s->disabledValidationFeatureCount * sizeof(VkValidationFeatureDisableEXT)];
        memory->memcpy((VkValidationFeatureDisableEXT*)s->pDisabledValidationFeatures, paramAddress, (U32)s->disabledValidationFeatureCount * sizeof(VkValidationFeatureDisableEXT));
    }
}
void MarshalVkValidationFeaturesEXT::write(KMemory* memory, U32 address, VkValidationFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->enabledValidationFeatureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->disabledValidationFeatureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPipelineRasterizationStateRasterizationOrderAMD::read(KMemory* memory, U32 address, VkPipelineRasterizationStateRasterizationOrderAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->rasterizationOrder = (VkRasterizationOrderAMD)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationStateRasterizationOrderAMD::write(KMemory* memory, U32 address, VkPipelineRasterizationStateRasterizationOrderAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->rasterizationOrder);address+=4;
}
void MarshalVkDebugMarkerObjectNameInfoEXT::read(KMemory* memory, U32 address, VkDebugMarkerObjectNameInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->objectType = (VkDebugReportObjectTypeEXT)memory->readd(address);address+=4;
    s->object = (uint64_t)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjectName = NULL;
    } else {
        U32 pObjectNameLen = memory->strlen(paramAddress)+1;
        s->pObjectName = new char[pObjectNameLen * sizeof(char)];
        memory->memcpy((char*)s->pObjectName, paramAddress, pObjectNameLen * sizeof(char));
    }
}
void MarshalVkDebugMarkerObjectNameInfoEXT::write(KMemory* memory, U32 address, VkDebugMarkerObjectNameInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->object);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDebugMarkerObjectTagInfoEXT::read(KMemory* memory, U32 address, VkDebugMarkerObjectTagInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->objectType = (VkDebugReportObjectTypeEXT)memory->readd(address);address+=4;
    s->object = (uint64_t)memory->readq(address);address+=8;
    s->tagName = (uint64_t)memory->readq(address);address+=8;
    s->tagSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTag = NULL;
    } else {
        s->pTag = new char[(U32)s->tagSize];
        memory->memcpy((void*)s->pTag, paramAddress, (U32)s->tagSize);
    }
}
void MarshalVkDebugMarkerObjectTagInfoEXT::write(KMemory* memory, U32 address, VkDebugMarkerObjectTagInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->object);address+=8;
    memory->writeq(address, s->tagName);address+=8;
    memory->writed(address, (U32)s->tagSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDebugMarkerMarkerInfoEXT::read(KMemory* memory, U32 address, VkDebugMarkerMarkerInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMarkerName = NULL;
    } else {
        U32 pMarkerNameLen = memory->strlen(paramAddress)+1;
        s->pMarkerName = new char[pMarkerNameLen * sizeof(char)];
        memory->memcpy((char*)s->pMarkerName, paramAddress, pMarkerNameLen * sizeof(char));
    }
    memory->memcpy(&s->color, address, 4);address+=4;
}
void MarshalVkDebugMarkerMarkerInfoEXT::write(KMemory* memory, U32 address, VkDebugMarkerMarkerInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->color, 16); address+=16;
}
void MarshalVkDedicatedAllocationImageCreateInfoNV::read(KMemory* memory, U32 address, VkDedicatedAllocationImageCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDedicatedAllocationImageCreateInfoNV::write(KMemory* memory, U32 address, VkDedicatedAllocationImageCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->dedicatedAllocation);address+=4;
}
void MarshalVkDedicatedAllocationBufferCreateInfoNV::read(KMemory* memory, U32 address, VkDedicatedAllocationBufferCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDedicatedAllocationBufferCreateInfoNV::write(KMemory* memory, U32 address, VkDedicatedAllocationBufferCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->dedicatedAllocation);address+=4;
}
void MarshalVkDedicatedAllocationMemoryAllocateInfoNV::read(KMemory* memory, U32 address, VkDedicatedAllocationMemoryAllocateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkDedicatedAllocationMemoryAllocateInfoNV::write(KMemory* memory, U32 address, VkDedicatedAllocationMemoryAllocateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->buffer);address+=8;
}
void MarshalVkExternalMemoryImageCreateInfoNV::read(KMemory* memory, U32 address, VkExternalMemoryImageCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryImageCreateInfoNV::write(KMemory* memory, U32 address, VkExternalMemoryImageCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkExportMemoryAllocateInfoNV::read(KMemory* memory, U32 address, VkExportMemoryAllocateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkExportMemoryAllocateInfoNV::write(KMemory* memory, U32 address, VkExportMemoryAllocateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceGeneratedCommands = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceGeneratedCommands);address+=4;
}
void MarshalVkDevicePrivateDataCreateInfoEXT::read(KMemory* memory, U32 address, VkDevicePrivateDataCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->privateDataSlotRequestCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDevicePrivateDataCreateInfoEXT::write(KMemory* memory, U32 address, VkDevicePrivateDataCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->privateDataSlotRequestCount);address+=4;
}
void MarshalVkPrivateDataSlotCreateInfoEXT::read(KMemory* memory, U32 address, VkPrivateDataSlotCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPrivateDataSlotCreateFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkPrivateDataSlotCreateInfoEXT::write(KMemory* memory, U32 address, VkPrivateDataSlotCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkPhysicalDevicePrivateDataFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDevicePrivateDataFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->privateData = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePrivateDataFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDevicePrivateDataFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->privateData);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxGraphicsShaderGroupCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectSequenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsStreamCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenOffset = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsStreamStride = (uint32_t)memory->readd(address);address+=4;
    s->minSequencesCountBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
    s->minSequencesIndexBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
    s->minIndirectCommandsBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxGraphicsShaderGroupCount);address+=4;
    memory->writed(address, s->maxIndirectSequenceCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsStreamCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenOffset);address+=4;
    memory->writed(address, s->maxIndirectCommandsStreamStride);address+=4;
    memory->writed(address, s->minSequencesCountBufferOffsetAlignment);address+=4;
    memory->writed(address, s->minSequencesIndexBufferOffsetAlignment);address+=4;
    memory->writed(address, s->minIndirectCommandsBufferOffsetAlignment);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxMultiDrawCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxMultiDrawCount);address+=4;
}
void MarshalVkGraphicsShaderGroupCreateInfoNV::read(KMemory* memory, U32 address, VkGraphicsShaderGroupCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexInputState = NULL;
    } else {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTessellationState = NULL;
    } else {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
}
void MarshalVkGraphicsShaderGroupCreateInfoNV::write(KMemory* memory, U32 address, VkGraphicsShaderGroupCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
}
void MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::read(KMemory* memory, U32 address, VkGraphicsPipelineShaderGroupsCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->groupCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGroups = NULL;
    } else {
        VkGraphicsShaderGroupCreateInfoNV* pGroups = new VkGraphicsShaderGroupCreateInfoNV[s->groupCount];
        for (U32 i = 0; i < s->groupCount; i++) {
            MarshalVkGraphicsShaderGroupCreateInfoNV::read(memory, paramAddress + i*24, &pGroups[i]);
        }
        s->pGroups = pGroups;
    }
    s->pipelineCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelines = NULL;
    } else {
        s->pPipelines = new VkPipeline[(U32)s->pipelineCount * sizeof(VkPipeline)];
        memory->memcpy((VkPipeline*)s->pPipelines, paramAddress, (U32)s->pipelineCount * sizeof(VkPipeline));
    }
}
void MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::write(KMemory* memory, U32 address, VkGraphicsPipelineShaderGroupsCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->groupCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkGraphicsShaderGroupCreateInfoNV* pGroups = new VkGraphicsShaderGroupCreateInfoNV();
        MarshalVkGraphicsShaderGroupCreateInfoNV::read(memory, paramAddress, pGroups);
        s->pGroups = pGroups;
    }
    memory->writed(address, s->pipelineCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkIndirectCommandsStreamNV::read(KMemory* memory, U32 address, VkIndirectCommandsStreamNV* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkIndirectCommandsLayoutTokenNV::read(KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->tokenType = (VkIndirectCommandsTokenTypeNV)memory->readd(address);address+=4;
    s->stream = (uint32_t)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->vertexBindingUnit = (uint32_t)memory->readd(address);address+=4;
    s->vertexDynamicStride = (VkBool32)memory->readd(address);address+=4;
    s->pushconstantPipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->pushconstantShaderStageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->pushconstantOffset = (uint32_t)memory->readd(address);address+=4;
    s->pushconstantSize = (uint32_t)memory->readd(address);address+=4;
    s->indirectStateFlags = (VkIndirectStateFlagsNV)memory->readd(address);address+=4;
    s->indexTypeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pIndexTypes = NULL;
    } else {
        s->pIndexTypes = new VkIndexType[(U32)s->indexTypeCount * sizeof(VkIndexType)];
        memory->memcpy((VkIndexType*)s->pIndexTypes, paramAddress, (U32)s->indexTypeCount * sizeof(VkIndexType));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pIndexTypeValues = NULL;
    } else {
        s->pIndexTypeValues = new uint32_t[(U32)s->indexTypeCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pIndexTypeValues, paramAddress, (U32)s->indexTypeCount * sizeof(uint32_t));
    }
}
void MarshalVkIndirectCommandsLayoutTokenNV::write(KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->tokenType);address+=4;
    memory->writed(address, s->stream);address+=4;
    memory->writed(address, s->offset);address+=4;
    memory->writed(address, s->vertexBindingUnit);address+=4;
    memory->writed(address, s->vertexDynamicStride);address+=4;
    memory->writeq(address, (U64)s->pushconstantPipelineLayout);address+=8;
    memory->writed(address, s->pushconstantShaderStageFlags);address+=4;
    memory->writed(address, s->pushconstantOffset);address+=4;
    memory->writed(address, s->pushconstantSize);address+=4;
    memory->writed(address, s->indirectStateFlags);address+=4;
    memory->writed(address, s->indexTypeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkIndirectCommandsLayoutCreateInfoNV::read(KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkIndirectCommandsLayoutUsageFlagsNV)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->tokenCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTokens = NULL;
    } else {
        VkIndirectCommandsLayoutTokenNV* pTokens = new VkIndirectCommandsLayoutTokenNV[s->tokenCount];
        for (U32 i = 0; i < s->tokenCount; i++) {
            MarshalVkIndirectCommandsLayoutTokenNV::read(memory, paramAddress + i*64, &pTokens[i]);
        }
        s->pTokens = pTokens;
    }
    s->streamCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStreamStrides = NULL;
    } else {
        s->pStreamStrides = new uint32_t[(U32)s->streamCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pStreamStrides, paramAddress, (U32)s->streamCount * sizeof(uint32_t));
    }
}
void MarshalVkIndirectCommandsLayoutCreateInfoNV::write(KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writed(address, s->tokenCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectCommandsLayoutTokenNV* pTokens = new VkIndirectCommandsLayoutTokenNV();
        MarshalVkIndirectCommandsLayoutTokenNV::read(memory, paramAddress, pTokens);
        s->pTokens = pTokens;
    }
    memory->writed(address, s->streamCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkGeneratedCommandsInfoNV::read(KMemory* memory, U32 address, VkGeneratedCommandsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
    s->streamCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStreams = NULL;
    } else {
        s->pStreams = new VkIndirectCommandsStreamNV[(U32)s->streamCount * sizeof(VkIndirectCommandsStreamNV)];
        memory->memcpy((VkIndirectCommandsStreamNV*)s->pStreams, paramAddress, (U32)s->streamCount * sizeof(VkIndirectCommandsStreamNV));
    }
    s->sequencesCount = (uint32_t)memory->readd(address);address+=4;
    s->preprocessBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->preprocessOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->preprocessSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->sequencesCountBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->sequencesCountOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->sequencesIndexBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->sequencesIndexOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeneratedCommandsInfoNV::write(KMemory* memory, U32 address, VkGeneratedCommandsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writed(address, s->streamCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectCommandsStreamNV* pStreams = new VkIndirectCommandsStreamNV();
        MarshalVkIndirectCommandsStreamNV::read(memory, paramAddress, pStreams);
        s->pStreams = pStreams;
    }
    memory->writed(address, s->sequencesCount);address+=4;
    memory->writeq(address, (U64)s->preprocessBuffer);address+=8;
    memory->writeq(address, s->preprocessOffset);address+=8;
    memory->writeq(address, s->preprocessSize);address+=8;
    memory->writeq(address, (U64)s->sequencesCountBuffer);address+=8;
    memory->writeq(address, s->sequencesCountOffset);address+=8;
    memory->writeq(address, (U64)s->sequencesIndexBuffer);address+=8;
    memory->writeq(address, s->sequencesIndexOffset);address+=8;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::read(KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
    s->maxSequencesCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::write(KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writed(address, s->maxSequencesCount);address+=4;
}
void MarshalVkPhysicalDeviceFeatures2::read(KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->features, address, 220);address+=220;
}
void MarshalVkPhysicalDeviceFeatures2::write(KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->features, 220); address+=220;
}
void MarshalVkPhysicalDeviceProperties2::read(KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalVkPhysicalDeviceProperties::read(memory, address, &s->properties); address+=800;
}
void MarshalVkPhysicalDeviceProperties2::write(KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->properties, 800); address+=800;
}
void MarshalVkFormatProperties2::read(KMemory* memory, U32 address, VkFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->formatProperties, address, 12);address+=12;
}
void MarshalVkFormatProperties2::write(KMemory* memory, U32 address, VkFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->formatProperties, 12); address+=12;
}
void MarshalVkImageFormatProperties2::read(KMemory* memory, U32 address, VkImageFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->imageFormatProperties, address, 32);address+=32;
}
void MarshalVkImageFormatProperties2::write(KMemory* memory, U32 address, VkImageFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->imageFormatProperties, 32); address+=32;
}
void MarshalVkPhysicalDeviceImageFormatInfo2::read(KMemory* memory, U32 address, VkPhysicalDeviceImageFormatInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->type = (VkImageType)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageFormatInfo2::write(KMemory* memory, U32 address, VkPhysicalDeviceImageFormatInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->tiling);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkQueueFamilyProperties2::read(KMemory* memory, U32 address, VkQueueFamilyProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->queueFamilyProperties, address, 24);address+=24;
}
void MarshalVkQueueFamilyProperties2::write(KMemory* memory, U32 address, VkQueueFamilyProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->queueFamilyProperties, 24); address+=24;
}
void MarshalVkPhysicalDeviceMemoryProperties2::read(KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->memoryProperties, address, 456);address+=456;
}
void MarshalVkPhysicalDeviceMemoryProperties2::write(KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->memoryProperties, 456); address+=456;
}
void MarshalVkSparseImageFormatProperties2::read(KMemory* memory, U32 address, VkSparseImageFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->properties, address, 20);address+=20;
}
void MarshalVkSparseImageFormatProperties2::write(KMemory* memory, U32 address, VkSparseImageFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->properties, 20); address+=20;
}
void MarshalVkPhysicalDeviceSparseImageFormatInfo2::read(KMemory* memory, U32 address, VkPhysicalDeviceSparseImageFormatInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->type = (VkImageType)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSparseImageFormatInfo2::write(KMemory* memory, U32 address, VkPhysicalDeviceSparseImageFormatInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->tiling);address+=4;
}
void MarshalVkPhysicalDevicePushDescriptorPropertiesKHR::read(KMemory* memory, U32 address, VkPhysicalDevicePushDescriptorPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxPushDescriptors = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePushDescriptorPropertiesKHR::write(KMemory* memory, U32 address, VkPhysicalDevicePushDescriptorPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxPushDescriptors);address+=4;
}
void MarshalVkPhysicalDeviceDriverProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceDriverProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->driverID = (VkDriverId)memory->readd(address);address+=4;
    memory->memcpy(&s->driverName, address, 256);address+=256;
    memory->memcpy(&s->driverInfo, address, 256);address+=256;
    memory->memcpy(&s->conformanceVersion, address, 4);address+=4;
}
void MarshalVkPhysicalDeviceDriverProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceDriverProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->driverID);address+=4;
    memory->memcpy(address, s->driverName, 256); address+=256;
    memory->memcpy(address, s->driverInfo, 256); address+=256;
    memory->memcpy(address, &s->conformanceVersion, 4); address+=4;
}
void MarshalVkPresentRegionsKHR::read(KMemory* memory, U32 address, VkPresentRegionsKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkPresentRegionKHR* pRegions = new VkPresentRegionKHR[s->swapchainCount];
        for (U32 i = 0; i < s->swapchainCount; i++) {
            MarshalVkPresentRegionKHR::read(memory, paramAddress + i*8, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkPresentRegionsKHR::write(KMemory* memory, U32 address, VkPresentRegionsKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPresentRegionKHR* pRegions = new VkPresentRegionKHR();
        MarshalVkPresentRegionKHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkPhysicalDeviceVariablePointersFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceVariablePointersFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->variablePointersStorageBuffer = (VkBool32)memory->readd(address);address+=4;
    s->variablePointers = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVariablePointersFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceVariablePointersFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->variablePointersStorageBuffer);address+=4;
    memory->writed(address, s->variablePointers);address+=4;
}
void MarshalVkPhysicalDeviceExternalImageFormatInfo::read(KMemory* memory, U32 address, VkPhysicalDeviceExternalImageFormatInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalImageFormatInfo::write(KMemory* memory, U32 address, VkPhysicalDeviceExternalImageFormatInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkExternalImageFormatProperties::read(KMemory* memory, U32 address, VkExternalImageFormatProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->externalMemoryProperties, address, 12);address+=12;
}
void MarshalVkExternalImageFormatProperties::write(KMemory* memory, U32 address, VkExternalImageFormatProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->externalMemoryProperties, 12); address+=12;
}
void MarshalVkPhysicalDeviceExternalBufferInfo::read(KMemory* memory, U32 address, VkPhysicalDeviceExternalBufferInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
    s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalBufferInfo::write(KMemory* memory, U32 address, VkPhysicalDeviceExternalBufferInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkExternalBufferProperties::read(KMemory* memory, U32 address, VkExternalBufferProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->externalMemoryProperties, address, 12);address+=12;
}
void MarshalVkExternalBufferProperties::write(KMemory* memory, U32 address, VkExternalBufferProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->externalMemoryProperties, 12); address+=12;
}
void MarshalVkPhysicalDeviceIDProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->deviceUUID, address, 16);address+=16;
    memory->memcpy(&s->driverUUID, address, 16);address+=16;
    memory->memcpy(&s->deviceLUID, address, 8);address+=8;
    s->deviceNodeMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceLUIDValid = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceIDProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->deviceUUID, 16); address+=16;
    memory->memcpy(address, s->driverUUID, 16); address+=16;
    memory->memcpy(address, s->deviceLUID, 8); address+=8;
    memory->writed(address, s->deviceNodeMask);address+=4;
    memory->writed(address, s->deviceLUIDValid);address+=4;
}
void MarshalVkExternalMemoryImageCreateInfo::read(KMemory* memory, U32 address, VkExternalMemoryImageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryImageCreateInfo::write(KMemory* memory, U32 address, VkExternalMemoryImageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkExternalMemoryBufferCreateInfo::read(KMemory* memory, U32 address, VkExternalMemoryBufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryBufferCreateInfo::write(KMemory* memory, U32 address, VkExternalMemoryBufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkExportMemoryAllocateInfo::read(KMemory* memory, U32 address, VkExportMemoryAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportMemoryAllocateInfo::write(KMemory* memory, U32 address, VkExportMemoryAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkImportMemoryFdInfoKHR::read(KMemory* memory, U32 address, VkImportMemoryFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
    s->fd = (int)memory->readd(address);address+=4;
}
void MarshalVkImportMemoryFdInfoKHR::write(KMemory* memory, U32 address, VkImportMemoryFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleType);address+=4;
    memory->writed(address, s->fd);address+=4;
}
void MarshalVkMemoryFdPropertiesKHR::read(KMemory* memory, U32 address, VkMemoryFdPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memoryTypeBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryFdPropertiesKHR::write(KMemory* memory, U32 address, VkMemoryFdPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->memoryTypeBits);address+=4;
}
void MarshalVkMemoryGetFdInfoKHR::read(KMemory* memory, U32 address, VkMemoryGetFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkMemoryGetFdInfoKHR::write(KMemory* memory, U32 address, VkMemoryGetFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkPhysicalDeviceExternalSemaphoreInfo::read(KMemory* memory, U32 address, VkPhysicalDeviceExternalSemaphoreInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleType = (VkExternalSemaphoreHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalSemaphoreInfo::write(KMemory* memory, U32 address, VkPhysicalDeviceExternalSemaphoreInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkExternalSemaphoreProperties::read(KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->exportFromImportedHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
    s->compatibleHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
    s->externalSemaphoreFeatures = (VkExternalSemaphoreFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalSemaphoreProperties::write(KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
    memory->writed(address, s->compatibleHandleTypes);address+=4;
    memory->writed(address, s->externalSemaphoreFeatures);address+=4;
}
void MarshalVkExportSemaphoreCreateInfo::read(KMemory* memory, U32 address, VkExportSemaphoreCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportSemaphoreCreateInfo::write(KMemory* memory, U32 address, VkExportSemaphoreCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkImportSemaphoreFdInfoKHR::read(KMemory* memory, U32 address, VkImportSemaphoreFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->flags = (VkSemaphoreImportFlags)memory->readd(address);address+=4;
    s->handleType = (VkExternalSemaphoreHandleTypeFlagBits)memory->readd(address);address+=4;
    s->fd = (int)memory->readd(address);address+=4;
}
void MarshalVkImportSemaphoreFdInfoKHR::write(KMemory* memory, U32 address, VkImportSemaphoreFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->handleType);address+=4;
    memory->writed(address, s->fd);address+=4;
}
void MarshalVkSemaphoreGetFdInfoKHR::read(KMemory* memory, U32 address, VkSemaphoreGetFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->handleType = (VkExternalSemaphoreHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkSemaphoreGetFdInfoKHR::write(KMemory* memory, U32 address, VkSemaphoreGetFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkPhysicalDeviceExternalFenceInfo::read(KMemory* memory, U32 address, VkPhysicalDeviceExternalFenceInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleType = (VkExternalFenceHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalFenceInfo::write(KMemory* memory, U32 address, VkPhysicalDeviceExternalFenceInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkExternalFenceProperties::read(KMemory* memory, U32 address, VkExternalFenceProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->exportFromImportedHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
    s->compatibleHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
    s->externalFenceFeatures = (VkExternalFenceFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalFenceProperties::write(KMemory* memory, U32 address, VkExternalFenceProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
    memory->writed(address, s->compatibleHandleTypes);address+=4;
    memory->writed(address, s->externalFenceFeatures);address+=4;
}
void MarshalVkExportFenceCreateInfo::read(KMemory* memory, U32 address, VkExportFenceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->handleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportFenceCreateInfo::write(KMemory* memory, U32 address, VkExportFenceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->handleTypes);address+=4;
}
void MarshalVkImportFenceFdInfoKHR::read(KMemory* memory, U32 address, VkImportFenceFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fence = (VkFence)memory->readq(address);address+=8;
    s->flags = (VkFenceImportFlags)memory->readd(address);address+=4;
    s->handleType = (VkExternalFenceHandleTypeFlagBits)memory->readd(address);address+=4;
    s->fd = (int)memory->readd(address);address+=4;
}
void MarshalVkImportFenceFdInfoKHR::write(KMemory* memory, U32 address, VkImportFenceFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->fence);address+=8;
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->handleType);address+=4;
    memory->writed(address, s->fd);address+=4;
}
void MarshalVkFenceGetFdInfoKHR::read(KMemory* memory, U32 address, VkFenceGetFdInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fence = (VkFence)memory->readq(address);address+=8;
    s->handleType = (VkExternalFenceHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkFenceGetFdInfoKHR::write(KMemory* memory, U32 address, VkFenceGetFdInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->fence);address+=8;
    memory->writed(address, s->handleType);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->multiview = (VkBool32)memory->readd(address);address+=4;
    s->multiviewGeometryShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewTessellationShader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->multiview);address+=4;
    memory->writed(address, s->multiviewGeometryShader);address+=4;
    memory->writed(address, s->multiviewTessellationShader);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMultiviewInstanceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxMultiviewViewCount);address+=4;
    memory->writed(address, s->maxMultiviewInstanceIndex);address+=4;
}
void MarshalVkRenderPassMultiviewCreateInfo::read(KMemory* memory, U32 address, VkRenderPassMultiviewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewMasks = NULL;
    } else {
        s->pViewMasks = new uint32_t[(U32)s->subpassCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pViewMasks, paramAddress, (U32)s->subpassCount * sizeof(uint32_t));
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewOffsets = NULL;
    } else {
        s->pViewOffsets = new int32_t[(U32)s->dependencyCount * sizeof(int32_t)];
        memory->memcpy((int32_t*)s->pViewOffsets, paramAddress, (U32)s->dependencyCount * sizeof(int32_t));
    }
    s->correlationMaskCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCorrelationMasks = NULL;
    } else {
        s->pCorrelationMasks = new uint32_t[(U32)s->correlationMaskCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pCorrelationMasks, paramAddress, (U32)s->correlationMaskCount * sizeof(uint32_t));
    }
}
void MarshalVkRenderPassMultiviewCreateInfo::write(KMemory* memory, U32 address, VkRenderPassMultiviewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->correlationMaskCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSurfaceCapabilities2EXT::read(KMemory* memory, U32 address, VkSurfaceCapabilities2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->maxImageCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->currentExtent, address, 8);address+=8;
    memory->memcpy(&s->minImageExtent, address, 8);address+=8;
    memory->memcpy(&s->maxImageExtent, address, 8);address+=8;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
    s->currentTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)memory->readd(address);address+=4;
    s->supportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->supportedSurfaceCounters = (VkSurfaceCounterFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkSurfaceCapabilities2EXT::write(KMemory* memory, U32 address, VkSurfaceCapabilities2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->maxImageCount);address+=4;
    memory->memcpy(address, &s->currentExtent, 8); address+=8;
    memory->memcpy(address, &s->minImageExtent, 8); address+=8;
    memory->memcpy(address, &s->maxImageExtent, 8); address+=8;
    memory->writed(address, s->maxImageArrayLayers);address+=4;
    memory->writed(address, s->supportedTransforms);address+=4;
    memory->writed(address, s->currentTransform);address+=4;
    memory->writed(address, s->supportedCompositeAlpha);address+=4;
    memory->writed(address, s->supportedUsageFlags);address+=4;
    memory->writed(address, s->supportedSurfaceCounters);address+=4;
}
void MarshalVkDisplayPowerInfoEXT::read(KMemory* memory, U32 address, VkDisplayPowerInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->powerState = (VkDisplayPowerStateEXT)memory->readd(address);address+=4;
}
void MarshalVkDisplayPowerInfoEXT::write(KMemory* memory, U32 address, VkDisplayPowerInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->powerState);address+=4;
}
void MarshalVkDeviceEventInfoEXT::read(KMemory* memory, U32 address, VkDeviceEventInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceEvent = (VkDeviceEventTypeEXT)memory->readd(address);address+=4;
}
void MarshalVkDeviceEventInfoEXT::write(KMemory* memory, U32 address, VkDeviceEventInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceEvent);address+=4;
}
void MarshalVkDisplayEventInfoEXT::read(KMemory* memory, U32 address, VkDisplayEventInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->displayEvent = (VkDisplayEventTypeEXT)memory->readd(address);address+=4;
}
void MarshalVkDisplayEventInfoEXT::write(KMemory* memory, U32 address, VkDisplayEventInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->displayEvent);address+=4;
}
void MarshalVkSwapchainCounterCreateInfoEXT::read(KMemory* memory, U32 address, VkSwapchainCounterCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->surfaceCounters = (VkSurfaceCounterFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkSwapchainCounterCreateInfoEXT::write(KMemory* memory, U32 address, VkSwapchainCounterCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->surfaceCounters);address+=4;
}
void MarshalVkPhysicalDeviceGroupProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceGroupProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->physicalDeviceCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->physicalDevices, address, 32);address+=32;
    s->subsetAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGroupProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceGroupProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->physicalDeviceCount);address+=4;
    memory->memcpy(address, s->physicalDevices, 128); address+=128;
    memory->writed(address, s->subsetAllocation);address+=4;
}
void MarshalVkMemoryAllocateFlagsInfo::read(KMemory* memory, U32 address, VkMemoryAllocateFlagsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkMemoryAllocateFlags)memory->readd(address);address+=4;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryAllocateFlagsInfo::write(KMemory* memory, U32 address, VkMemoryAllocateFlagsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->deviceMask);address+=4;
}
void MarshalVkBindBufferMemoryInfo::read(KMemory* memory, U32 address, VkBindBufferMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBindBufferMemoryInfo::write(KMemory* memory, U32 address, VkBindBufferMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
}
void MarshalVkBindBufferMemoryDeviceGroupInfo::read(KMemory* memory, U32 address, VkBindBufferMemoryDeviceGroupInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount * sizeof(uint32_t));
    }
}
void MarshalVkBindBufferMemoryDeviceGroupInfo::write(KMemory* memory, U32 address, VkBindBufferMemoryDeviceGroupInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkBindImageMemoryInfo::read(KMemory* memory, U32 address, VkBindImageMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBindImageMemoryInfo::write(KMemory* memory, U32 address, VkBindImageMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
}
void MarshalVkBindImageMemoryDeviceGroupInfo::read(KMemory* memory, U32 address, VkBindImageMemoryDeviceGroupInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount * sizeof(uint32_t));
    }
    s->splitInstanceBindRegionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSplitInstanceBindRegions = NULL;
    } else {
        s->pSplitInstanceBindRegions = new VkRect2D[(U32)s->splitInstanceBindRegionCount * sizeof(VkRect2D)];
        memory->memcpy((VkRect2D*)s->pSplitInstanceBindRegions, paramAddress, (U32)s->splitInstanceBindRegionCount * sizeof(VkRect2D));
    }
}
void MarshalVkBindImageMemoryDeviceGroupInfo::write(KMemory* memory, U32 address, VkBindImageMemoryDeviceGroupInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->splitInstanceBindRegionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pSplitInstanceBindRegions = new VkRect2D();
        MarshalVkRect2D::read(memory, paramAddress, pSplitInstanceBindRegions);
        s->pSplitInstanceBindRegions = pSplitInstanceBindRegions;
    }
}
void MarshalVkDeviceGroupRenderPassBeginInfo::read(KMemory* memory, U32 address, VkDeviceGroupRenderPassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceRenderAreaCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceRenderAreas = NULL;
    } else {
        s->pDeviceRenderAreas = new VkRect2D[(U32)s->deviceRenderAreaCount * sizeof(VkRect2D)];
        memory->memcpy((VkRect2D*)s->pDeviceRenderAreas, paramAddress, (U32)s->deviceRenderAreaCount * sizeof(VkRect2D));
    }
}
void MarshalVkDeviceGroupRenderPassBeginInfo::write(KMemory* memory, U32 address, VkDeviceGroupRenderPassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceMask);address+=4;
    memory->writed(address, s->deviceRenderAreaCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pDeviceRenderAreas = new VkRect2D();
        MarshalVkRect2D::read(memory, paramAddress, pDeviceRenderAreas);
        s->pDeviceRenderAreas = pDeviceRenderAreas;
    }
}
void MarshalVkDeviceGroupCommandBufferBeginInfo::read(KMemory* memory, U32 address, VkDeviceGroupCommandBufferBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupCommandBufferBeginInfo::write(KMemory* memory, U32 address, VkDeviceGroupCommandBufferBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceMask);address+=4;
}
void MarshalVkDeviceGroupSubmitInfo::read(KMemory* memory, U32 address, VkDeviceGroupSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreDeviceIndices = NULL;
    } else {
        s->pWaitSemaphoreDeviceIndices = new uint32_t[(U32)s->waitSemaphoreCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pWaitSemaphoreDeviceIndices, paramAddress, (U32)s->waitSemaphoreCount * sizeof(uint32_t));
    }
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBufferDeviceMasks = NULL;
    } else {
        s->pCommandBufferDeviceMasks = new uint32_t[(U32)s->commandBufferCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pCommandBufferDeviceMasks, paramAddress, (U32)s->commandBufferCount * sizeof(uint32_t));
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreDeviceIndices = NULL;
    } else {
        s->pSignalSemaphoreDeviceIndices = new uint32_t[(U32)s->signalSemaphoreCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pSignalSemaphoreDeviceIndices, paramAddress, (U32)s->signalSemaphoreCount * sizeof(uint32_t));
    }
}
void MarshalVkDeviceGroupSubmitInfo::write(KMemory* memory, U32 address, VkDeviceGroupSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->commandBufferCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDeviceGroupBindSparseInfo::read(KMemory* memory, U32 address, VkDeviceGroupBindSparseInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->resourceDeviceIndex = (uint32_t)memory->readd(address);address+=4;
    s->memoryDeviceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupBindSparseInfo::write(KMemory* memory, U32 address, VkDeviceGroupBindSparseInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->resourceDeviceIndex);address+=4;
    memory->writed(address, s->memoryDeviceIndex);address+=4;
}
void MarshalVkDeviceGroupPresentCapabilitiesKHR::read(KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->presentMask, address, 32);address+=32;
    s->modes = (VkDeviceGroupPresentModeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupPresentCapabilitiesKHR::write(KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->presentMask, 128); address+=128;
    memory->writed(address, s->modes);address+=4;
}
void MarshalVkImageSwapchainCreateInfoKHR::read(KMemory* memory, U32 address, VkImageSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
}
void MarshalVkImageSwapchainCreateInfoKHR::write(KMemory* memory, U32 address, VkImageSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
}
void MarshalVkBindImageMemorySwapchainInfoKHR::read(KMemory* memory, U32 address, VkBindImageMemorySwapchainInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    s->imageIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkBindImageMemorySwapchainInfoKHR::write(KMemory* memory, U32 address, VkBindImageMemorySwapchainInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
    memory->writed(address, s->imageIndex);address+=4;
}
void MarshalVkAcquireNextImageInfoKHR::read(KMemory* memory, U32 address, VkAcquireNextImageInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    s->timeout = (uint64_t)memory->readq(address);address+=8;
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->fence = (VkFence)memory->readq(address);address+=8;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkAcquireNextImageInfoKHR::write(KMemory* memory, U32 address, VkAcquireNextImageInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
    memory->writeq(address, s->timeout);address+=8;
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, (U64)s->fence);address+=8;
    memory->writed(address, s->deviceMask);address+=4;
}
void MarshalVkDeviceGroupPresentInfoKHR::read(KMemory* memory, U32 address, VkDeviceGroupPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceMasks = NULL;
    } else {
        s->pDeviceMasks = new uint32_t[(U32)s->swapchainCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pDeviceMasks, paramAddress, (U32)s->swapchainCount * sizeof(uint32_t));
    }
    s->mode = (VkDeviceGroupPresentModeFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupPresentInfoKHR::write(KMemory* memory, U32 address, VkDeviceGroupPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->mode);address+=4;
}
void MarshalVkDeviceGroupDeviceCreateInfo::read(KMemory* memory, U32 address, VkDeviceGroupDeviceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->physicalDeviceCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPhysicalDevices = NULL;
    } else {
        VkPhysicalDevice* pPhysicalDevices = new VkPhysicalDevice[s->physicalDeviceCount];
        for (int i=0;i<(int)s->physicalDeviceCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            pPhysicalDevices[i] = (VkPhysicalDevice)getVulkanPtr(memory, itemAddress);
        }
        s->pPhysicalDevices = pPhysicalDevices;
    }
}
void MarshalVkDeviceGroupDeviceCreateInfo::write(KMemory* memory, U32 address, VkDeviceGroupDeviceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->physicalDeviceCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDeviceGroupSwapchainCreateInfoKHR::read(KMemory* memory, U32 address, VkDeviceGroupSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->modes = (VkDeviceGroupPresentModeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupSwapchainCreateInfoKHR::write(KMemory* memory, U32 address, VkDeviceGroupSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->modes);address+=4;
}
void MarshalVkDescriptorUpdateTemplateEntry::read(KMemory* memory, U32 address, VkDescriptorUpdateTemplateEntry* s) {
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->offset = (size_t)memory->readd(address);address+=4;
    s->stride = (size_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorUpdateTemplateCreateInfo::read(KMemory* memory, U32 address, VkDescriptorUpdateTemplateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDescriptorUpdateTemplateCreateFlags)memory->readd(address);address+=4;
    s->descriptorUpdateEntryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorUpdateEntries = NULL;
    } else {
        VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = new VkDescriptorUpdateTemplateEntry[s->descriptorUpdateEntryCount];
        for (U32 i = 0; i < s->descriptorUpdateEntryCount; i++) {
            MarshalVkDescriptorUpdateTemplateEntry::read(memory, paramAddress + i*24, &pDescriptorUpdateEntries[i]);
        }
        s->pDescriptorUpdateEntries = pDescriptorUpdateEntries;
    }
    s->templateType = (VkDescriptorUpdateTemplateType)memory->readd(address);address+=4;
    s->descriptorSetLayout = (VkDescriptorSetLayout)memory->readq(address);address+=8;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->set = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorUpdateTemplateCreateInfo::write(KMemory* memory, U32 address, VkDescriptorUpdateTemplateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->descriptorUpdateEntryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = new VkDescriptorUpdateTemplateEntry();
        MarshalVkDescriptorUpdateTemplateEntry::read(memory, paramAddress, pDescriptorUpdateEntries);
        s->pDescriptorUpdateEntries = pDescriptorUpdateEntries;
    }
    memory->writed(address, s->templateType);address+=4;
    memory->writeq(address, (U64)s->descriptorSetLayout);address+=8;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipelineLayout);address+=8;
    memory->writed(address, s->set);address+=4;
}
void MarshalVkHdrMetadataEXT::read(KMemory* memory, U32 address, VkHdrMetadataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->displayPrimaryRed, address, 8);address+=8;
    memory->memcpy(&s->displayPrimaryGreen, address, 8);address+=8;
    memory->memcpy(&s->displayPrimaryBlue, address, 8);address+=8;
    memory->memcpy(&s->whitePoint, address, 8);address+=8;
    MarshalFloat maxLuminanceFloat;
    maxLuminanceFloat.i = memory->readd(address);address+=4;
    s->maxLuminance = maxLuminanceFloat.f;
    MarshalFloat minLuminanceFloat;
    minLuminanceFloat.i = memory->readd(address);address+=4;
    s->minLuminance = minLuminanceFloat.f;
    MarshalFloat maxContentLightLevelFloat;
    maxContentLightLevelFloat.i = memory->readd(address);address+=4;
    s->maxContentLightLevel = maxContentLightLevelFloat.f;
    MarshalFloat maxFrameAverageLightLevelFloat;
    maxFrameAverageLightLevelFloat.i = memory->readd(address);address+=4;
    s->maxFrameAverageLightLevel = maxFrameAverageLightLevelFloat.f;
}
void MarshalVkHdrMetadataEXT::write(KMemory* memory, U32 address, VkHdrMetadataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->displayPrimaryRed, 8); address+=8;
    memory->memcpy(address, &s->displayPrimaryGreen, 8); address+=8;
    memory->memcpy(address, &s->displayPrimaryBlue, 8); address+=8;
    memory->memcpy(address, &s->whitePoint, 8); address+=8;
    MarshalFloat maxLuminanceFloat;
    maxLuminanceFloat.f = s->maxLuminance;
    memory->writed(address, maxLuminanceFloat.i);address+=4;
    MarshalFloat minLuminanceFloat;
    minLuminanceFloat.f = s->minLuminance;
    memory->writed(address, minLuminanceFloat.i);address+=4;
    MarshalFloat maxContentLightLevelFloat;
    maxContentLightLevelFloat.f = s->maxContentLightLevel;
    memory->writed(address, maxContentLightLevelFloat.i);address+=4;
    MarshalFloat maxFrameAverageLightLevelFloat;
    maxFrameAverageLightLevelFloat.f = s->maxFrameAverageLightLevel;
    memory->writed(address, maxFrameAverageLightLevelFloat.i);address+=4;
}
void MarshalVkDisplayNativeHdrSurfaceCapabilitiesAMD::read(KMemory* memory, U32 address, VkDisplayNativeHdrSurfaceCapabilitiesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->localDimmingSupport = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDisplayNativeHdrSurfaceCapabilitiesAMD::write(KMemory* memory, U32 address, VkDisplayNativeHdrSurfaceCapabilitiesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->localDimmingSupport);address+=4;
}
void MarshalVkSwapchainDisplayNativeHdrCreateInfoAMD::read(KMemory* memory, U32 address, VkSwapchainDisplayNativeHdrCreateInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->localDimmingEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSwapchainDisplayNativeHdrCreateInfoAMD::write(KMemory* memory, U32 address, VkSwapchainDisplayNativeHdrCreateInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->localDimmingEnable);address+=4;
}
void MarshalVkPresentTimesInfoGOOGLE::read(KMemory* memory, U32 address, VkPresentTimesInfoGOOGLE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTimes = NULL;
    } else {
        s->pTimes = new VkPresentTimeGOOGLE[(U32)s->swapchainCount * sizeof(VkPresentTimeGOOGLE)];
        memory->memcpy((VkPresentTimeGOOGLE*)s->pTimes, paramAddress, (U32)s->swapchainCount * sizeof(VkPresentTimeGOOGLE));
    }
}
void MarshalVkPresentTimesInfoGOOGLE::write(KMemory* memory, U32 address, VkPresentTimesInfoGOOGLE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPresentTimeGOOGLE* pTimes = new VkPresentTimeGOOGLE();
        MarshalVkPresentTimeGOOGLE::read(memory, paramAddress, pTimes);
        s->pTimes = pTimes;
    }
}
void MarshalVkViewportWScalingNV::read(KMemory* memory, U32 address, VkViewportWScalingNV* s) {
    MarshalFloat xcoeffFloat;
    xcoeffFloat.i = memory->readd(address);address+=4;
    s->xcoeff = xcoeffFloat.f;
    MarshalFloat ycoeffFloat;
    ycoeffFloat.i = memory->readd(address);address+=4;
    s->ycoeff = ycoeffFloat.f;
}
void MarshalVkPipelineViewportWScalingStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineViewportWScalingStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->viewportWScalingEnable = (VkBool32)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportWScalings = NULL;
    } else {
        s->pViewportWScalings = new VkViewportWScalingNV[(U32)s->viewportCount * sizeof(VkViewportWScalingNV)];
        memory->memcpy((VkViewportWScalingNV*)s->pViewportWScalings, paramAddress, (U32)s->viewportCount * sizeof(VkViewportWScalingNV));
    }
}
void MarshalVkPipelineViewportWScalingStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineViewportWScalingStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->viewportWScalingEnable);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewportWScalingNV* pViewportWScalings = new VkViewportWScalingNV();
        MarshalVkViewportWScalingNV::read(memory, paramAddress, pViewportWScalings);
        s->pViewportWScalings = pViewportWScalings;
    }
}
void MarshalVkViewportSwizzleNV::read(KMemory* memory, U32 address, VkViewportSwizzleNV* s) {
    s->x = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->y = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->z = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->w = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
}
void MarshalVkPipelineViewportSwizzleStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineViewportSwizzleStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineViewportSwizzleStateCreateFlagsNV)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportSwizzles = NULL;
    } else {
        VkViewportSwizzleNV* pViewportSwizzles = new VkViewportSwizzleNV[s->viewportCount];
        for (U32 i = 0; i < s->viewportCount; i++) {
            MarshalVkViewportSwizzleNV::read(memory, paramAddress + i*16, &pViewportSwizzles[i]);
        }
        s->pViewportSwizzles = pViewportSwizzles;
    }
}
void MarshalVkPipelineViewportSwizzleStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineViewportSwizzleStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewportSwizzleNV* pViewportSwizzles = new VkViewportSwizzleNV();
        MarshalVkViewportSwizzleNV::read(memory, paramAddress, pViewportSwizzles);
        s->pViewportSwizzles = pViewportSwizzles;
    }
}
void MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceDiscardRectanglePropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxDiscardRectangles = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceDiscardRectanglePropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxDiscardRectangles);address+=4;
}
void MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineDiscardRectangleStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineDiscardRectangleStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->discardRectangleMode = (VkDiscardRectangleModeEXT)memory->readd(address);address+=4;
    s->discardRectangleCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDiscardRectangles = NULL;
    } else {
        s->pDiscardRectangles = new VkRect2D[(U32)s->discardRectangleCount * sizeof(VkRect2D)];
        memory->memcpy((VkRect2D*)s->pDiscardRectangles, paramAddress, (U32)s->discardRectangleCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineDiscardRectangleStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->discardRectangleMode);address+=4;
    memory->writed(address, s->discardRectangleCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pDiscardRectangles = new VkRect2D();
        MarshalVkRect2D::read(memory, paramAddress, pDiscardRectangles);
        s->pDiscardRectangles = pDiscardRectangles;
    }
}
void MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::read(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->perViewPositionAllComponents = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::write(KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->perViewPositionAllComponents);address+=4;
}
void MarshalVkInputAttachmentAspectReference::read(KMemory* memory, U32 address, VkInputAttachmentAspectReference* s) {
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->inputAttachmentIndex = (uint32_t)memory->readd(address);address+=4;
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
}
void MarshalVkRenderPassInputAttachmentAspectCreateInfo::read(KMemory* memory, U32 address, VkRenderPassInputAttachmentAspectCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->aspectReferenceCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAspectReferences = NULL;
    } else {
        s->pAspectReferences = new VkInputAttachmentAspectReference[(U32)s->aspectReferenceCount * sizeof(VkInputAttachmentAspectReference)];
        memory->memcpy((VkInputAttachmentAspectReference*)s->pAspectReferences, paramAddress, (U32)s->aspectReferenceCount * sizeof(VkInputAttachmentAspectReference));
    }
}
void MarshalVkRenderPassInputAttachmentAspectCreateInfo::write(KMemory* memory, U32 address, VkRenderPassInputAttachmentAspectCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->aspectReferenceCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkInputAttachmentAspectReference* pAspectReferences = new VkInputAttachmentAspectReference();
        MarshalVkInputAttachmentAspectReference::read(memory, paramAddress, pAspectReferences);
        s->pAspectReferences = pAspectReferences;
    }
}
void MarshalVkPhysicalDeviceSurfaceInfo2KHR::read(KMemory* memory, U32 address, VkPhysicalDeviceSurfaceInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceSurfaceInfo2KHR::write(KMemory* memory, U32 address, VkPhysicalDeviceSurfaceInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->surface);address+=8;
}
void MarshalVkSurfaceCapabilities2KHR::read(KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalVkSurfaceCapabilitiesKHR::read(memory, address, &s->surfaceCapabilities); address+=52;
}
void MarshalVkSurfaceCapabilities2KHR::write(KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->surfaceCapabilities, 52); address+=52;
}
void MarshalVkSurfaceFormat2KHR::read(KMemory* memory, U32 address, VkSurfaceFormat2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalVkSurfaceFormatKHR::read(memory, address, &s->surfaceFormat); address+=8;
}
void MarshalVkSurfaceFormat2KHR::write(KMemory* memory, U32 address, VkSurfaceFormat2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->surfaceFormat, 8); address+=8;
}
void MarshalVkDisplayProperties2KHR::read(KMemory* memory, U32 address, VkDisplayProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalVkDisplayPropertiesKHR::read(memory, address, &s->displayProperties); address+=40;
}
void MarshalVkDisplayProperties2KHR::write(KMemory* memory, U32 address, VkDisplayProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->displayProperties, 40); address+=40;
}
void MarshalVkDisplayPlaneProperties2KHR::read(KMemory* memory, U32 address, VkDisplayPlaneProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->displayPlaneProperties, address, 12);address+=12;
}
void MarshalVkDisplayPlaneProperties2KHR::write(KMemory* memory, U32 address, VkDisplayPlaneProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->displayPlaneProperties, 12); address+=12;
}
void MarshalVkDisplayModeProperties2KHR::read(KMemory* memory, U32 address, VkDisplayModeProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->displayModeProperties, address, 20);address+=20;
}
void MarshalVkDisplayModeProperties2KHR::write(KMemory* memory, U32 address, VkDisplayModeProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->displayModeProperties, 20); address+=20;
}
void MarshalVkDisplayPlaneInfo2KHR::read(KMemory* memory, U32 address, VkDisplayPlaneInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->mode = (VkDisplayModeKHR)memory->readq(address);address+=8;
    s->planeIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDisplayPlaneInfo2KHR::write(KMemory* memory, U32 address, VkDisplayPlaneInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->mode);address+=8;
    memory->writed(address, s->planeIndex);address+=4;
}
void MarshalVkDisplayPlaneCapabilities2KHR::read(KMemory* memory, U32 address, VkDisplayPlaneCapabilities2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->capabilities, address, 68);address+=68;
}
void MarshalVkDisplayPlaneCapabilities2KHR::write(KMemory* memory, U32 address, VkDisplayPlaneCapabilities2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->capabilities, 68); address+=68;
}
void MarshalVkSharedPresentSurfaceCapabilitiesKHR::read(KMemory* memory, U32 address, VkSharedPresentSurfaceCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sharedPresentSupportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkSharedPresentSurfaceCapabilitiesKHR::write(KMemory* memory, U32 address, VkSharedPresentSurfaceCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sharedPresentSupportedUsageFlags);address+=4;
}
void MarshalVkPhysicalDevice16BitStorageFeatures::read(KMemory* memory, U32 address, VkPhysicalDevice16BitStorageFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->storageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant16 = (VkBool32)memory->readd(address);address+=4;
    s->storageInputOutput16 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice16BitStorageFeatures::write(KMemory* memory, U32 address, VkPhysicalDevice16BitStorageFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->storageBuffer16BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer16BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant16);address+=4;
    memory->writed(address, s->storageInputOutput16);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->supportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->supportedOperations = (VkSubgroupFeatureFlags)memory->readd(address);address+=4;
    s->quadOperationsInAllStages = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->subgroupSize);address+=4;
    memory->writed(address, s->supportedStages);address+=4;
    memory->writed(address, s->supportedOperations);address+=4;
    memory->writed(address, s->quadOperationsInAllStages);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderSubgroupExtendedTypes = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderSubgroupExtendedTypes);address+=4;
}
void MarshalVkBufferMemoryRequirementsInfo2::read(KMemory* memory, U32 address, VkBufferMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryRequirementsInfo2::write(KMemory* memory, U32 address, VkBufferMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
void MarshalVkImageMemoryRequirementsInfo2::read(KMemory* memory, U32 address, VkImageMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
}
void MarshalVkImageMemoryRequirementsInfo2::write(KMemory* memory, U32 address, VkImageMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->image);address+=8;
}
void MarshalVkImageSparseMemoryRequirementsInfo2::read(KMemory* memory, U32 address, VkImageSparseMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
}
void MarshalVkImageSparseMemoryRequirementsInfo2::write(KMemory* memory, U32 address, VkImageSparseMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->image);address+=8;
}
void MarshalVkMemoryRequirements2::read(KMemory* memory, U32 address, VkMemoryRequirements2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->memoryRequirements, address, 20);address+=20;
}
void MarshalVkMemoryRequirements2::write(KMemory* memory, U32 address, VkMemoryRequirements2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->memoryRequirements, 20); address+=20;
}
void MarshalVkSparseImageMemoryRequirements2::read(KMemory* memory, U32 address, VkSparseImageMemoryRequirements2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->memoryRequirements, address, 48);address+=48;
}
void MarshalVkSparseImageMemoryRequirements2::write(KMemory* memory, U32 address, VkSparseImageMemoryRequirements2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->memoryRequirements, 48); address+=48;
}
void MarshalVkPhysicalDevicePointClippingProperties::read(KMemory* memory, U32 address, VkPhysicalDevicePointClippingProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pointClippingBehavior = (VkPointClippingBehavior)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePointClippingProperties::write(KMemory* memory, U32 address, VkPhysicalDevicePointClippingProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pointClippingBehavior);address+=4;
}
void MarshalVkMemoryDedicatedRequirements::read(KMemory* memory, U32 address, VkMemoryDedicatedRequirements* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->prefersDedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
    s->requiresDedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkMemoryDedicatedRequirements::write(KMemory* memory, U32 address, VkMemoryDedicatedRequirements* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->prefersDedicatedAllocation);address+=4;
    memory->writed(address, s->requiresDedicatedAllocation);address+=4;
}
void MarshalVkMemoryDedicatedAllocateInfo::read(KMemory* memory, U32 address, VkMemoryDedicatedAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkMemoryDedicatedAllocateInfo::write(KMemory* memory, U32 address, VkMemoryDedicatedAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->buffer);address+=8;
}
void MarshalVkImageViewUsageCreateInfo::read(KMemory* memory, U32 address, VkImageViewUsageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkImageViewUsageCreateInfo::write(KMemory* memory, U32 address, VkImageViewUsageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->usage);address+=4;
}
void MarshalVkPipelineTessellationDomainOriginStateCreateInfo::read(KMemory* memory, U32 address, VkPipelineTessellationDomainOriginStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->domainOrigin = (VkTessellationDomainOrigin)memory->readd(address);address+=4;
}
void MarshalVkPipelineTessellationDomainOriginStateCreateInfo::write(KMemory* memory, U32 address, VkPipelineTessellationDomainOriginStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->domainOrigin);address+=4;
}
void MarshalVkSamplerYcbcrConversionInfo::read(KMemory* memory, U32 address, VkSamplerYcbcrConversionInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->conversion = (VkSamplerYcbcrConversion)memory->readq(address);address+=8;
}
void MarshalVkSamplerYcbcrConversionInfo::write(KMemory* memory, U32 address, VkSamplerYcbcrConversionInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->conversion);address+=8;
}
void MarshalVkSamplerYcbcrConversionCreateInfo::read(KMemory* memory, U32 address, VkSamplerYcbcrConversionCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->ycbcrModel = (VkSamplerYcbcrModelConversion)memory->readd(address);address+=4;
    s->ycbcrRange = (VkSamplerYcbcrRange)memory->readd(address);address+=4;
    MarshalVkComponentMapping::read(memory, address, &s->components); address+=16;
    s->xChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
    s->yChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
    s->chromaFilter = (VkFilter)memory->readd(address);address+=4;
    s->forceExplicitReconstruction = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerYcbcrConversionCreateInfo::write(KMemory* memory, U32 address, VkSamplerYcbcrConversionCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->ycbcrModel);address+=4;
    memory->writed(address, s->ycbcrRange);address+=4;
    memory->memcpy(address, &s->components, 16); address+=16;
    memory->writed(address, s->xChromaOffset);address+=4;
    memory->writed(address, s->yChromaOffset);address+=4;
    memory->writed(address, s->chromaFilter);address+=4;
    memory->writed(address, s->forceExplicitReconstruction);address+=4;
}
void MarshalVkBindImagePlaneMemoryInfo::read(KMemory* memory, U32 address, VkBindImagePlaneMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->planeAspect = (VkImageAspectFlagBits)memory->readd(address);address+=4;
}
void MarshalVkBindImagePlaneMemoryInfo::write(KMemory* memory, U32 address, VkBindImagePlaneMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->planeAspect);address+=4;
}
void MarshalVkImagePlaneMemoryRequirementsInfo::read(KMemory* memory, U32 address, VkImagePlaneMemoryRequirementsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->planeAspect = (VkImageAspectFlagBits)memory->readd(address);address+=4;
}
void MarshalVkImagePlaneMemoryRequirementsInfo::write(KMemory* memory, U32 address, VkImagePlaneMemoryRequirementsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->planeAspect);address+=4;
}
void MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceSamplerYcbcrConversionFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->samplerYcbcrConversion = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceSamplerYcbcrConversionFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->samplerYcbcrConversion);address+=4;
}
void MarshalVkSamplerYcbcrConversionImageFormatProperties::read(KMemory* memory, U32 address, VkSamplerYcbcrConversionImageFormatProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->combinedImageSamplerDescriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSamplerYcbcrConversionImageFormatProperties::write(KMemory* memory, U32 address, VkSamplerYcbcrConversionImageFormatProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->combinedImageSamplerDescriptorCount);address+=4;
}
void MarshalVkTextureLODGatherFormatPropertiesAMD::read(KMemory* memory, U32 address, VkTextureLODGatherFormatPropertiesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->supportsTextureGatherLODBiasAMD = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkTextureLODGatherFormatPropertiesAMD::write(KMemory* memory, U32 address, VkTextureLODGatherFormatPropertiesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->supportsTextureGatherLODBiasAMD);address+=4;
}
void MarshalVkConditionalRenderingBeginInfoEXT::read(KMemory* memory, U32 address, VkConditionalRenderingBeginInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->flags = (VkConditionalRenderingFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkConditionalRenderingBeginInfoEXT::write(KMemory* memory, U32 address, VkConditionalRenderingBeginInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkProtectedSubmitInfo::read(KMemory* memory, U32 address, VkProtectedSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->protectedSubmit = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkProtectedSubmitInfo::write(KMemory* memory, U32 address, VkProtectedSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->protectedSubmit);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->protectedMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->protectedMemory);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->protectedNoFault = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->protectedNoFault);address+=4;
}
void MarshalVkDeviceQueueInfo2::read(KMemory* memory, U32 address, VkDeviceQueueInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->queueIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceQueueInfo2::write(KMemory* memory, U32 address, VkDeviceQueueInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->queueIndex);address+=4;
}
void MarshalVkPipelineCoverageToColorStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineCoverageToColorStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageToColorStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageToColorEnable = (VkBool32)memory->readd(address);address+=4;
    s->coverageToColorLocation = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineCoverageToColorStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineCoverageToColorStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageToColorEnable);address+=4;
    memory->writed(address, s->coverageToColorLocation);address+=4;
}
void MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceSamplerFilterMinmaxProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->filterMinmaxSingleComponentFormats = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxImageComponentMapping = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceSamplerFilterMinmaxProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->filterMinmaxSingleComponentFormats);address+=4;
    memory->writed(address, s->filterMinmaxImageComponentMapping);address+=4;
}
void MarshalVkSampleLocationEXT::read(KMemory* memory, U32 address, VkSampleLocationEXT* s) {
    MarshalFloat xFloat;
    xFloat.i = memory->readd(address);address+=4;
    s->x = xFloat.f;
    MarshalFloat yFloat;
    yFloat.i = memory->readd(address);address+=4;
    s->y = yFloat.f;
}
void MarshalVkSampleLocationsInfoEXT::read(KMemory* memory, U32 address, VkSampleLocationsInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sampleLocationsPerPixel = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    memory->memcpy(&s->sampleLocationGridSize, address, 8);address+=8;
    s->sampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleLocations = NULL;
    } else {
        s->pSampleLocations = new VkSampleLocationEXT[(U32)s->sampleLocationsCount * sizeof(VkSampleLocationEXT)];
        memory->memcpy((VkSampleLocationEXT*)s->pSampleLocations, paramAddress, (U32)s->sampleLocationsCount * sizeof(VkSampleLocationEXT));
    }
}
void MarshalVkSampleLocationsInfoEXT::write(KMemory* memory, U32 address, VkSampleLocationsInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sampleLocationsPerPixel);address+=4;
    memory->memcpy(address, &s->sampleLocationGridSize, 8); address+=8;
    memory->writed(address, s->sampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSampleLocationEXT* pSampleLocations = new VkSampleLocationEXT();
        MarshalVkSampleLocationEXT::read(memory, paramAddress, pSampleLocations);
        s->pSampleLocations = pSampleLocations;
    }
}
void MarshalVkAttachmentSampleLocationsEXT::read(KMemory* memory, U32 address, VkAttachmentSampleLocationsEXT* s) {
    s->attachmentIndex = (uint32_t)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkSubpassSampleLocationsEXT::read(KMemory* memory, U32 address, VkSubpassSampleLocationsEXT* s) {
    s->subpassIndex = (uint32_t)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkRenderPassSampleLocationsBeginInfoEXT::read(KMemory* memory, U32 address, VkRenderPassSampleLocationsBeginInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->attachmentInitialSampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachmentInitialSampleLocations = NULL;
    } else {
        VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = new VkAttachmentSampleLocationsEXT[s->attachmentInitialSampleLocationsCount];
        for (U32 i = 0; i < s->attachmentInitialSampleLocationsCount; i++) {
            MarshalVkAttachmentSampleLocationsEXT::read(memory, paramAddress + i*32, &pAttachmentInitialSampleLocations[i]);
        }
        s->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations;
    }
    s->postSubpassSampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPostSubpassSampleLocations = NULL;
    } else {
        VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations = new VkSubpassSampleLocationsEXT[s->postSubpassSampleLocationsCount];
        for (U32 i = 0; i < s->postSubpassSampleLocationsCount; i++) {
            MarshalVkSubpassSampleLocationsEXT::read(memory, paramAddress + i*32, &pPostSubpassSampleLocations[i]);
        }
        s->pPostSubpassSampleLocations = pPostSubpassSampleLocations;
    }
}
void MarshalVkRenderPassSampleLocationsBeginInfoEXT::write(KMemory* memory, U32 address, VkRenderPassSampleLocationsBeginInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->attachmentInitialSampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = new VkAttachmentSampleLocationsEXT();
        MarshalVkAttachmentSampleLocationsEXT::read(memory, paramAddress, pAttachmentInitialSampleLocations);
        s->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations;
    }
    memory->writed(address, s->postSubpassSampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations = new VkSubpassSampleLocationsEXT();
        MarshalVkSubpassSampleLocationsEXT::read(memory, paramAddress, pPostSubpassSampleLocations);
        s->pPostSubpassSampleLocations = pPostSubpassSampleLocations;
    }
}
void MarshalVkPipelineSampleLocationsStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineSampleLocationsStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sampleLocationsEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkPipelineSampleLocationsStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineSampleLocationsStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sampleLocationsEnable);address+=4;
    memory->memcpy(address, &s->sampleLocationsInfo, 28); address+=28;
}
void MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceSampleLocationsPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sampleLocationSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->maxSampleLocationGridSize, address, 8);address+=8;
    memory->memcpy(&s->sampleLocationCoordinateRange, address, 2);address+=2;
    s->sampleLocationSubPixelBits = (uint32_t)memory->readd(address);address+=4;
    s->variableSampleLocations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceSampleLocationsPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sampleLocationSampleCounts);address+=4;
    memory->memcpy(address, &s->maxSampleLocationGridSize, 8); address+=8;
    memory->memcpy(address, s->sampleLocationCoordinateRange, 8); address+=8;
    memory->writed(address, s->sampleLocationSubPixelBits);address+=4;
    memory->writed(address, s->variableSampleLocations);address+=4;
}
void MarshalVkMultisamplePropertiesEXT::read(KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->maxSampleLocationGridSize, address, 8);address+=8;
}
void MarshalVkMultisamplePropertiesEXT::write(KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->maxSampleLocationGridSize, 8); address+=8;
}
void MarshalVkSamplerReductionModeCreateInfo::read(KMemory* memory, U32 address, VkSamplerReductionModeCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->reductionMode = (VkSamplerReductionMode)memory->readd(address);address+=4;
}
void MarshalVkSamplerReductionModeCreateInfo::write(KMemory* memory, U32 address, VkSamplerReductionModeCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->reductionMode);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->advancedBlendCoherentOperations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->advancedBlendCoherentOperations);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->multiDraw = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->multiDraw);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->advancedBlendMaxColorAttachments = (uint32_t)memory->readd(address);address+=4;
    s->advancedBlendIndependentBlend = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendNonPremultipliedSrcColor = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendNonPremultipliedDstColor = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendCorrelatedOverlap = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendAllOperations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->advancedBlendMaxColorAttachments);address+=4;
    memory->writed(address, s->advancedBlendIndependentBlend);address+=4;
    memory->writed(address, s->advancedBlendNonPremultipliedSrcColor);address+=4;
    memory->writed(address, s->advancedBlendNonPremultipliedDstColor);address+=4;
    memory->writed(address, s->advancedBlendCorrelatedOverlap);address+=4;
    memory->writed(address, s->advancedBlendAllOperations);address+=4;
}
void MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineColorBlendAdvancedStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->dstPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->blendOverlap = (VkBlendOverlapEXT)memory->readd(address);address+=4;
}
void MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineColorBlendAdvancedStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->srcPremultiplied);address+=4;
    memory->writed(address, s->dstPremultiplied);address+=4;
    memory->writed(address, s->blendOverlap);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->inlineUniformBlock = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingInlineUniformBlockUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->inlineUniformBlock);address+=4;
    memory->writed(address, s->descriptorBindingInlineUniformBlockUpdateAfterBind);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxInlineUniformBlockSize = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxInlineUniformBlockSize);address+=4;
    memory->writed(address, s->maxPerStageDescriptorInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks);address+=4;
}
void MarshalVkWriteDescriptorSetInlineUniformBlockEXT::read(KMemory* memory, U32 address, VkWriteDescriptorSetInlineUniformBlockEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dataSize = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkWriteDescriptorSetInlineUniformBlockEXT::write(KMemory* memory, U32 address, VkWriteDescriptorSetInlineUniformBlockEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDescriptorPoolInlineUniformBlockCreateInfoEXT::read(KMemory* memory, U32 address, VkDescriptorPoolInlineUniformBlockCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxInlineUniformBlockBindings = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorPoolInlineUniformBlockCreateInfoEXT::write(KMemory* memory, U32 address, VkDescriptorPoolInlineUniformBlockCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxInlineUniformBlockBindings);address+=4;
}
void MarshalVkPipelineCoverageModulationStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineCoverageModulationStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageModulationStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageModulationMode = (VkCoverageModulationModeNV)memory->readd(address);address+=4;
    s->coverageModulationTableEnable = (VkBool32)memory->readd(address);address+=4;
    s->coverageModulationTableCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCoverageModulationTable = NULL;
    } else {
        s->pCoverageModulationTable = new float[(U32)s->coverageModulationTableCount * sizeof(float)];
        memory->memcpy((float*)s->pCoverageModulationTable, paramAddress, (U32)s->coverageModulationTableCount * sizeof(float));
    }
}
void MarshalVkPipelineCoverageModulationStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineCoverageModulationStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageModulationMode);address+=4;
    memory->writed(address, s->coverageModulationTableEnable);address+=4;
    memory->writed(address, s->coverageModulationTableCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkImageFormatListCreateInfo::read(KMemory* memory, U32 address, VkImageFormatListCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->viewFormatCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewFormats = NULL;
    } else {
        s->pViewFormats = new VkFormat[(U32)s->viewFormatCount * sizeof(VkFormat)];
        memory->memcpy((VkFormat*)s->pViewFormats, paramAddress, (U32)s->viewFormatCount * sizeof(VkFormat));
    }
}
void MarshalVkImageFormatListCreateInfo::write(KMemory* memory, U32 address, VkImageFormatListCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->viewFormatCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkValidationCacheCreateInfoEXT::read(KMemory* memory, U32 address, VkValidationCacheCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkValidationCacheCreateFlagsEXT)memory->readd(address);address+=4;
    s->initialDataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInitialData = NULL;
    } else {
        s->pInitialData = new char[(U32)s->initialDataSize];
        memory->memcpy((void*)s->pInitialData, paramAddress, (U32)s->initialDataSize);
    }
}
void MarshalVkValidationCacheCreateInfoEXT::write(KMemory* memory, U32 address, VkValidationCacheCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->initialDataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkShaderModuleValidationCacheCreateInfoEXT::read(KMemory* memory, U32 address, VkShaderModuleValidationCacheCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->validationCache = (VkValidationCacheEXT)memory->readq(address);address+=8;
}
void MarshalVkShaderModuleValidationCacheCreateInfoEXT::write(KMemory* memory, U32 address, VkShaderModuleValidationCacheCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->validationCache);address+=8;
}
void MarshalVkPhysicalDeviceMaintenance3Properties::read(KMemory* memory, U32 address, VkPhysicalDeviceMaintenance3Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxPerSetDescriptors = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceMaintenance3Properties::write(KMemory* memory, U32 address, VkPhysicalDeviceMaintenance3Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxPerSetDescriptors);address+=4;
    memory->writeq(address, s->maxMemoryAllocationSize);address+=8;
}
void MarshalVkDescriptorSetLayoutSupport::read(KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->supported = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetLayoutSupport::write(KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->supported);address+=4;
}
void MarshalVkPhysicalDeviceShaderDrawParametersFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderDrawParametersFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderDrawParameters = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderDrawParametersFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderDrawParametersFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderDrawParameters);address+=4;
}
void MarshalVkPhysicalDeviceShaderFloat16Int8Features::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderFloat16Int8Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderFloat16Int8Features::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderFloat16Int8Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderFloat16);address+=4;
    memory->writed(address, s->shaderInt8);address+=4;
}
void MarshalVkPhysicalDeviceFloatControlsProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceFloatControlsProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->denormBehaviorIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->roundingModeIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat64 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFloatControlsProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceFloatControlsProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->denormBehaviorIndependence);address+=4;
    memory->writed(address, s->roundingModeIndependence);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat16);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat32);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat16);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat32);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat16);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat32);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat64);address+=4;
}
void MarshalVkPhysicalDeviceHostQueryResetFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->hostQueryReset = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceHostQueryResetFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->hostQueryReset);address+=4;
}
void MarshalVkDeviceQueueGlobalPriorityCreateInfoEXT::read(KMemory* memory, U32 address, VkDeviceQueueGlobalPriorityCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->globalPriority = (VkQueueGlobalPriorityEXT)memory->readd(address);address+=4;
}
void MarshalVkDeviceQueueGlobalPriorityCreateInfoEXT::write(KMemory* memory, U32 address, VkDeviceQueueGlobalPriorityCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->globalPriority);address+=4;
}
void MarshalVkPhysicalDeviceGlobalPriorityQueryFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->globalPriorityQuery = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGlobalPriorityQueryFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->globalPriorityQuery);address+=4;
}
void MarshalVkQueueFamilyGlobalPriorityPropertiesEXT::read(KMemory* memory, U32 address, VkQueueFamilyGlobalPriorityPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->priorityCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->priorities, address, 16);address+=16;
}
void MarshalVkQueueFamilyGlobalPriorityPropertiesEXT::write(KMemory* memory, U32 address, VkQueueFamilyGlobalPriorityPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->priorityCount);address+=4;
    memory->memcpy(address, s->priorities, 64); address+=64;
}
void MarshalVkDebugUtilsObjectNameInfoEXT::read(KMemory* memory, U32 address, VkDebugUtilsObjectNameInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->objectType = (VkObjectType)memory->readd(address);address+=4;
    s->objectHandle = (uint64_t)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjectName = NULL;
    } else {
        U32 pObjectNameLen = memory->strlen(paramAddress)+1;
        s->pObjectName = new char[pObjectNameLen * sizeof(char)];
        memory->memcpy((char*)s->pObjectName, paramAddress, pObjectNameLen * sizeof(char));
    }
}
void MarshalVkDebugUtilsObjectNameInfoEXT::write(KMemory* memory, U32 address, VkDebugUtilsObjectNameInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->objectHandle);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDebugUtilsObjectTagInfoEXT::read(KMemory* memory, U32 address, VkDebugUtilsObjectTagInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->objectType = (VkObjectType)memory->readd(address);address+=4;
    s->objectHandle = (uint64_t)memory->readq(address);address+=8;
    s->tagName = (uint64_t)memory->readq(address);address+=8;
    s->tagSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTag = NULL;
    } else {
        s->pTag = new char[(U32)s->tagSize];
        memory->memcpy((void*)s->pTag, paramAddress, (U32)s->tagSize);
    }
}
void MarshalVkDebugUtilsObjectTagInfoEXT::write(KMemory* memory, U32 address, VkDebugUtilsObjectTagInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->objectHandle);address+=8;
    memory->writeq(address, s->tagName);address+=8;
    memory->writed(address, (U32)s->tagSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDebugUtilsLabelEXT::read(KMemory* memory, U32 address, VkDebugUtilsLabelEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLabelName = NULL;
    } else {
        U32 pLabelNameLen = memory->strlen(paramAddress)+1;
        s->pLabelName = new char[pLabelNameLen * sizeof(char)];
        memory->memcpy((char*)s->pLabelName, paramAddress, pLabelNameLen * sizeof(char));
    }
    memory->memcpy(&s->color, address, 4);address+=4;
}
void MarshalVkDebugUtilsLabelEXT::write(KMemory* memory, U32 address, VkDebugUtilsLabelEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->color, 16); address+=16;
}
void MarshalVkDebugUtilsMessengerCallbackDataEXT::read(KMemory* memory, U32 address, VkDebugUtilsMessengerCallbackDataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDebugUtilsMessengerCallbackDataFlagsEXT)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMessageIdName = NULL;
    } else {
        U32 pMessageIdNameLen = memory->strlen(paramAddress)+1;
        s->pMessageIdName = new char[pMessageIdNameLen * sizeof(char)];
        memory->memcpy((char*)s->pMessageIdName, paramAddress, pMessageIdNameLen * sizeof(char));
    }
    s->messageIdNumber = (int32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMessage = NULL;
    } else {
        U32 pMessageLen = memory->strlen(paramAddress)+1;
        s->pMessage = new char[pMessageLen * sizeof(char)];
        memory->memcpy((char*)s->pMessage, paramAddress, pMessageLen * sizeof(char));
    }
    s->queueLabelCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueLabels = NULL;
    } else {
        VkDebugUtilsLabelEXT* pQueueLabels = new VkDebugUtilsLabelEXT[s->queueLabelCount];
        for (U32 i = 0; i < s->queueLabelCount; i++) {
            MarshalVkDebugUtilsLabelEXT::read(memory, paramAddress + i*28, &pQueueLabels[i]);
        }
        s->pQueueLabels = pQueueLabels;
    }
    s->cmdBufLabelCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCmdBufLabels = NULL;
    } else {
        VkDebugUtilsLabelEXT* pCmdBufLabels = new VkDebugUtilsLabelEXT[s->cmdBufLabelCount];
        for (U32 i = 0; i < s->cmdBufLabelCount; i++) {
            MarshalVkDebugUtilsLabelEXT::read(memory, paramAddress + i*28, &pCmdBufLabels[i]);
        }
        s->pCmdBufLabels = pCmdBufLabels;
    }
    s->objectCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjects = NULL;
    } else {
        VkDebugUtilsObjectNameInfoEXT* pObjects = new VkDebugUtilsObjectNameInfoEXT[s->objectCount];
        for (U32 i = 0; i < s->objectCount; i++) {
            MarshalVkDebugUtilsObjectNameInfoEXT::read(memory, paramAddress + i*24, &pObjects[i]);
        }
        s->pObjects = pObjects;
    }
}
void MarshalVkDebugUtilsMessengerCallbackDataEXT::write(KMemory* memory, U32 address, VkDebugUtilsMessengerCallbackDataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->messageIdNumber);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->queueLabelCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsLabelEXT* pQueueLabels = new VkDebugUtilsLabelEXT();
        MarshalVkDebugUtilsLabelEXT::read(memory, paramAddress, pQueueLabels);
        s->pQueueLabels = pQueueLabels;
    }
    memory->writed(address, s->cmdBufLabelCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsLabelEXT* pCmdBufLabels = new VkDebugUtilsLabelEXT();
        MarshalVkDebugUtilsLabelEXT::read(memory, paramAddress, pCmdBufLabels);
        s->pCmdBufLabels = pCmdBufLabels;
    }
    memory->writed(address, s->objectCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsObjectNameInfoEXT* pObjects = new VkDebugUtilsObjectNameInfoEXT();
        MarshalVkDebugUtilsObjectNameInfoEXT::read(memory, paramAddress, pObjects);
        s->pObjects = pObjects;
    }
}
void MarshalVkPhysicalDeviceDeviceMemoryReportFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceMemoryReport = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceMemoryReportFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceMemoryReport);address+=4;
}
void MarshalVkDeviceMemoryReportCallbackDataEXT::read(KMemory* memory, U32 address, VkDeviceMemoryReportCallbackDataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDeviceMemoryReportFlagsEXT)memory->readd(address);address+=4;
    s->type = (VkDeviceMemoryReportEventTypeEXT)memory->readd(address);address+=4;
    s->memoryObjectId = (uint64_t)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->objectType = (VkObjectType)memory->readd(address);address+=4;
    s->objectHandle = (uint64_t)memory->readq(address);address+=8;
    s->heapIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceMemoryReportCallbackDataEXT::write(KMemory* memory, U32 address, VkDeviceMemoryReportCallbackDataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, s->memoryObjectId);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->objectHandle);address+=8;
    memory->writed(address, s->heapIndex);address+=4;
}
void MarshalVkMemoryHostPointerPropertiesEXT::read(KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memoryTypeBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryHostPointerPropertiesEXT::write(KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->memoryTypeBits);address+=4;
}
void MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceExternalMemoryHostPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->minImportedHostPointerAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceExternalMemoryHostPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->minImportedHostPointerAlignment);address+=8;
}
void MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceConservativeRasterizationPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalFloat primitiveOverestimationSizeFloat;
    primitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->primitiveOverestimationSize = primitiveOverestimationSizeFloat.f;
    MarshalFloat maxExtraPrimitiveOverestimationSizeFloat;
    maxExtraPrimitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->maxExtraPrimitiveOverestimationSize = maxExtraPrimitiveOverestimationSizeFloat.f;
    MarshalFloat extraPrimitiveOverestimationSizeGranularityFloat;
    extraPrimitiveOverestimationSizeGranularityFloat.i = memory->readd(address);address+=4;
    s->extraPrimitiveOverestimationSizeGranularity = extraPrimitiveOverestimationSizeGranularityFloat.f;
    s->primitiveUnderestimation = (VkBool32)memory->readd(address);address+=4;
    s->conservativePointAndLineRasterization = (VkBool32)memory->readd(address);address+=4;
    s->degenerateTrianglesRasterized = (VkBool32)memory->readd(address);address+=4;
    s->degenerateLinesRasterized = (VkBool32)memory->readd(address);address+=4;
    s->fullyCoveredFragmentShaderInputVariable = (VkBool32)memory->readd(address);address+=4;
    s->conservativeRasterizationPostDepthCoverage = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceConservativeRasterizationPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    MarshalFloat primitiveOverestimationSizeFloat;
    primitiveOverestimationSizeFloat.f = s->primitiveOverestimationSize;
    memory->writed(address, primitiveOverestimationSizeFloat.i);address+=4;
    MarshalFloat maxExtraPrimitiveOverestimationSizeFloat;
    maxExtraPrimitiveOverestimationSizeFloat.f = s->maxExtraPrimitiveOverestimationSize;
    memory->writed(address, maxExtraPrimitiveOverestimationSizeFloat.i);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeGranularityFloat;
    extraPrimitiveOverestimationSizeGranularityFloat.f = s->extraPrimitiveOverestimationSizeGranularity;
    memory->writed(address, extraPrimitiveOverestimationSizeGranularityFloat.i);address+=4;
    memory->writed(address, s->primitiveUnderestimation);address+=4;
    memory->writed(address, s->conservativePointAndLineRasterization);address+=4;
    memory->writed(address, s->degenerateTrianglesRasterized);address+=4;
    memory->writed(address, s->degenerateLinesRasterized);address+=4;
    memory->writed(address, s->fullyCoveredFragmentShaderInputVariable);address+=4;
    memory->writed(address, s->conservativeRasterizationPostDepthCoverage);address+=4;
}
void MarshalVkCalibratedTimestampInfoEXT::read(KMemory* memory, U32 address, VkCalibratedTimestampInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->timeDomain = (VkTimeDomainEXT)memory->readd(address);address+=4;
}
void MarshalVkCalibratedTimestampInfoEXT::write(KMemory* memory, U32 address, VkCalibratedTimestampInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->timeDomain);address+=4;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesAMD::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderEngineCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderArraysPerEngineCount = (uint32_t)memory->readd(address);address+=4;
    s->computeUnitsPerShaderArray = (uint32_t)memory->readd(address);address+=4;
    s->simdPerComputeUnit = (uint32_t)memory->readd(address);address+=4;
    s->wavefrontsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->wavefrontSize = (uint32_t)memory->readd(address);address+=4;
    s->sgprsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->minSgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->maxSgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->sgprAllocationGranularity = (uint32_t)memory->readd(address);address+=4;
    s->vgprsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->minVgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->maxVgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->vgprAllocationGranularity = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesAMD::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderEngineCount);address+=4;
    memory->writed(address, s->shaderArraysPerEngineCount);address+=4;
    memory->writed(address, s->computeUnitsPerShaderArray);address+=4;
    memory->writed(address, s->simdPerComputeUnit);address+=4;
    memory->writed(address, s->wavefrontsPerSimd);address+=4;
    memory->writed(address, s->wavefrontSize);address+=4;
    memory->writed(address, s->sgprsPerSimd);address+=4;
    memory->writed(address, s->minSgprAllocation);address+=4;
    memory->writed(address, s->maxSgprAllocation);address+=4;
    memory->writed(address, s->sgprAllocationGranularity);address+=4;
    memory->writed(address, s->vgprsPerSimd);address+=4;
    memory->writed(address, s->minVgprAllocation);address+=4;
    memory->writed(address, s->maxVgprAllocation);address+=4;
    memory->writed(address, s->vgprAllocationGranularity);address+=4;
}
void MarshalVkPhysicalDeviceShaderCoreProperties2AMD::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreProperties2AMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderCoreFeatures = (VkShaderCorePropertiesFlagsAMD)memory->readd(address);address+=4;
    s->activeComputeUnitCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCoreProperties2AMD::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreProperties2AMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderCoreFeatures);address+=4;
    memory->writed(address, s->activeComputeUnitCount);address+=4;
}
void MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineRasterizationConservativeStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationConservativeStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->conservativeRasterizationMode = (VkConservativeRasterizationModeEXT)memory->readd(address);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeFloat;
    extraPrimitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSizeFloat.f;
}
void MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineRasterizationConservativeStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->conservativeRasterizationMode);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeFloat;
    extraPrimitiveOverestimationSizeFloat.f = s->extraPrimitiveOverestimationSize;
    memory->writed(address, extraPrimitiveOverestimationSizeFloat.i);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderInputAttachmentArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingSampledImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUpdateUnusedWhilePending = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingPartiallyBound = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingVariableDescriptorCount = (VkBool32)memory->readd(address);address+=4;
    s->runtimeDescriptorArray = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderInputAttachmentArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->descriptorBindingUniformBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingSampledImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUniformTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUpdateUnusedWhilePending);address+=4;
    memory->writed(address, s->descriptorBindingPartiallyBound);address+=4;
    memory->writed(address, s->descriptorBindingVariableDescriptorCount);address+=4;
    memory->writed(address, s->runtimeDescriptorArray);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxUpdateAfterBindDescriptorsInAllPools = (uint32_t)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->robustBufferAccessUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->quadDivergentImplicitLod = (VkBool32)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageUpdateAfterBindResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxUpdateAfterBindDescriptorsInAllPools);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->robustBufferAccessUpdateAfterBind);address+=4;
    memory->writed(address, s->quadDivergentImplicitLod);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->maxPerStageUpdateAfterBindResources);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInputAttachments);address+=4;
}
void MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::read(KMemory* memory, U32 address, VkDescriptorSetLayoutBindingFlagsCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->bindingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBindingFlags = NULL;
    } else {
        s->pBindingFlags = new VkDescriptorBindingFlags[(U32)s->bindingCount * sizeof(VkDescriptorBindingFlags)];
        memory->memcpy((VkDescriptorBindingFlags*)s->pBindingFlags, paramAddress, (U32)s->bindingCount * sizeof(VkDescriptorBindingFlags));
    }
}
void MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::write(KMemory* memory, U32 address, VkDescriptorSetLayoutBindingFlagsCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->bindingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::read(KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorCounts = NULL;
    } else {
        s->pDescriptorCounts = new uint32_t[(U32)s->descriptorSetCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pDescriptorCounts, paramAddress, (U32)s->descriptorSetCount * sizeof(uint32_t));
    }
}
void MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::write(KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->descriptorSetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::read(KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountLayoutSupport* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxVariableDescriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::write(KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountLayoutSupport* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxVariableDescriptorCount);address+=4;
}
void MarshalVkAttachmentDescription2::read(KMemory* memory, U32 address, VkAttachmentDescription2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentDescription2::write(KMemory* memory, U32 address, VkAttachmentDescription2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->loadOp);address+=4;
    memory->writed(address, s->storeOp);address+=4;
    memory->writed(address, s->stencilLoadOp);address+=4;
    memory->writed(address, s->stencilStoreOp);address+=4;
    memory->writed(address, s->initialLayout);address+=4;
    memory->writed(address, s->finalLayout);address+=4;
}
void MarshalVkAttachmentReference2::read(KMemory* memory, U32 address, VkAttachmentReference2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->attachment = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkImageLayout)memory->readd(address);address+=4;
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReference2::write(KMemory* memory, U32 address, VkAttachmentReference2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->attachment);address+=4;
    memory->writed(address, s->layout);address+=4;
    memory->writed(address, s->aspectMask);address+=4;
}
void MarshalVkSubpassDescription2::read(KMemory* memory, U32 address, VkSubpassDescription2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAttachments = NULL;
    } else {
        VkAttachmentReference2* pInputAttachments = new VkAttachmentReference2[s->inputAttachmentCount];
        for (U32 i = 0; i < s->inputAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(memory, paramAddress + i*20, &pInputAttachments[i]);
        }
        s->pInputAttachments = pInputAttachments;
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachments = NULL;
    } else {
        VkAttachmentReference2* pColorAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(memory, paramAddress + i*20, &pColorAttachments[i]);
        }
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResolveAttachments = NULL;
    } else {
        VkAttachmentReference2* pResolveAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(memory, paramAddress + i*20, &pResolveAttachments[i]);
        }
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilAttachment = NULL;
    } else {
        VkAttachmentReference2* pDepthStencilAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPreserveAttachments = NULL;
    } else {
        s->pPreserveAttachments = new uint32_t[(U32)s->preserveAttachmentCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, (U32)s->preserveAttachmentCount * sizeof(uint32_t));
    }
}
void MarshalVkSubpassDescription2::write(KMemory* memory, U32 address, VkSubpassDescription2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->inputAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pInputAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pInputAttachments);
        s->pInputAttachments = pInputAttachments;
    }
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pColorAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pColorAttachments);
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pResolveAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pResolveAttachments);
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pDepthStencilAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    memory->writed(address, s->preserveAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSubpassDependency2::read(KMemory* memory, U32 address, VkSubpassDependency2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcSubpass = (uint32_t)memory->readd(address);address+=4;
    s->dstSubpass = (uint32_t)memory->readd(address);address+=4;
    s->srcStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->dstStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
    s->viewOffset = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkSubpassDependency2::write(KMemory* memory, U32 address, VkSubpassDependency2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->srcSubpass);address+=4;
    memory->writed(address, s->dstSubpass);address+=4;
    memory->writed(address, s->srcStageMask);address+=4;
    memory->writed(address, s->dstStageMask);address+=4;
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->dependencyFlags);address+=4;
    memory->writed(address, s->viewOffset);address+=4;
}
void MarshalVkRenderPassCreateInfo2::read(KMemory* memory, U32 address, VkRenderPassCreateInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkAttachmentDescription2* pAttachments = new VkAttachmentDescription2[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkAttachmentDescription2::read(memory, paramAddress + i*44, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubpasses = NULL;
    } else {
        VkSubpassDescription2* pSubpasses = new VkSubpassDescription2[s->subpassCount];
        for (U32 i = 0; i < s->subpassCount; i++) {
            MarshalVkSubpassDescription2::read(memory, paramAddress + i*52, &pSubpasses[i]);
        }
        s->pSubpasses = pSubpasses;
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDependencies = NULL;
    } else {
        VkSubpassDependency2* pDependencies = new VkSubpassDependency2[s->dependencyCount];
        for (U32 i = 0; i < s->dependencyCount; i++) {
            MarshalVkSubpassDependency2::read(memory, paramAddress + i*40, &pDependencies[i]);
        }
        s->pDependencies = pDependencies;
    }
    s->correlatedViewMaskCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCorrelatedViewMasks = NULL;
    } else {
        s->pCorrelatedViewMasks = new uint32_t[(U32)s->correlatedViewMaskCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pCorrelatedViewMasks, paramAddress, (U32)s->correlatedViewMaskCount * sizeof(uint32_t));
    }
}
void MarshalVkRenderPassCreateInfo2::write(KMemory* memory, U32 address, VkRenderPassCreateInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentDescription2* pAttachments = new VkAttachmentDescription2();
        MarshalVkAttachmentDescription2::read(memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDescription2* pSubpasses = new VkSubpassDescription2();
        MarshalVkSubpassDescription2::read(memory, paramAddress, pSubpasses);
        s->pSubpasses = pSubpasses;
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDependency2* pDependencies = new VkSubpassDependency2();
        MarshalVkSubpassDependency2::read(memory, paramAddress, pDependencies);
        s->pDependencies = pDependencies;
    }
    memory->writed(address, s->correlatedViewMaskCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSubpassBeginInfo::read(KMemory* memory, U32 address, VkSubpassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->contents = (VkSubpassContents)memory->readd(address);address+=4;
}
void MarshalVkSubpassBeginInfo::write(KMemory* memory, U32 address, VkSubpassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->contents);address+=4;
}
void MarshalVkSubpassEndInfo::read(KMemory* memory, U32 address, VkSubpassEndInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
}
void MarshalVkSubpassEndInfo::write(KMemory* memory, U32 address, VkSubpassEndInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
}
void MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->timelineSemaphore = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->timelineSemaphore);address+=4;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxTimelineSemaphoreValueDifference = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->maxTimelineSemaphoreValueDifference);address+=8;
}
void MarshalVkSemaphoreTypeCreateInfo::read(KMemory* memory, U32 address, VkSemaphoreTypeCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->semaphoreType = (VkSemaphoreType)memory->readd(address);address+=4;
    s->initialValue = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkSemaphoreTypeCreateInfo::write(KMemory* memory, U32 address, VkSemaphoreTypeCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->semaphoreType);address+=4;
    memory->writeq(address, s->initialValue);address+=8;
}
void MarshalVkTimelineSemaphoreSubmitInfo::read(KMemory* memory, U32 address, VkTimelineSemaphoreSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->waitSemaphoreValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreValues = NULL;
    } else {
        s->pWaitSemaphoreValues = new uint64_t[(U32)s->waitSemaphoreValueCount * sizeof(uint64_t)];
        memory->memcpy((uint64_t*)s->pWaitSemaphoreValues, paramAddress, (U32)s->waitSemaphoreValueCount * sizeof(uint64_t));
    }
    s->signalSemaphoreValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreValues = NULL;
    } else {
        s->pSignalSemaphoreValues = new uint64_t[(U32)s->signalSemaphoreValueCount * sizeof(uint64_t)];
        memory->memcpy((uint64_t*)s->pSignalSemaphoreValues, paramAddress, (U32)s->signalSemaphoreValueCount * sizeof(uint64_t));
    }
}
void MarshalVkTimelineSemaphoreSubmitInfo::write(KMemory* memory, U32 address, VkTimelineSemaphoreSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->waitSemaphoreValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSemaphoreWaitInfo::read(KMemory* memory, U32 address, VkSemaphoreWaitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSemaphoreWaitFlags)memory->readd(address);address+=4;
    s->semaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSemaphores = NULL;
    } else {
        s->pSemaphores = new VkSemaphore[(U32)s->semaphoreCount * sizeof(VkSemaphore)];
        memory->memcpy((VkSemaphore*)s->pSemaphores, paramAddress, (U32)s->semaphoreCount * sizeof(VkSemaphore));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pValues = NULL;
    } else {
        s->pValues = new uint64_t[(U32)s->semaphoreCount * sizeof(uint64_t)];
        memory->memcpy((uint64_t*)s->pValues, paramAddress, (U32)s->semaphoreCount * sizeof(uint64_t));
    }
}
void MarshalVkSemaphoreWaitInfo::write(KMemory* memory, U32 address, VkSemaphoreWaitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->semaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkSemaphoreSignalInfo::read(KMemory* memory, U32 address, VkSemaphoreSignalInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->value = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkSemaphoreSignalInfo::write(KMemory* memory, U32 address, VkSemaphoreSignalInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, s->value);address+=8;
}
void MarshalVkVertexInputBindingDivisorDescriptionEXT::read(KMemory* memory, U32 address, VkVertexInputBindingDivisorDescriptionEXT* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->divisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineVertexInputDivisorStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineVertexInputDivisorStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexBindingDivisorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexBindingDivisors = NULL;
    } else {
        s->pVertexBindingDivisors = new VkVertexInputBindingDivisorDescriptionEXT[(U32)s->vertexBindingDivisorCount * sizeof(VkVertexInputBindingDivisorDescriptionEXT)];
        memory->memcpy((VkVertexInputBindingDivisorDescriptionEXT*)s->pVertexBindingDivisors, paramAddress, (U32)s->vertexBindingDivisorCount * sizeof(VkVertexInputBindingDivisorDescriptionEXT));
    }
}
void MarshalVkPipelineVertexInputDivisorStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineVertexInputDivisorStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->vertexBindingDivisorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors = new VkVertexInputBindingDivisorDescriptionEXT();
        MarshalVkVertexInputBindingDivisorDescriptionEXT::read(memory, paramAddress, pVertexBindingDivisors);
        s->pVertexBindingDivisors = pVertexBindingDivisors;
    }
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxVertexAttribDivisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxVertexAttribDivisor);address+=4;
}
void MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDevicePCIBusInfoPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pciDomain = (uint32_t)memory->readd(address);address+=4;
    s->pciBus = (uint32_t)memory->readd(address);address+=4;
    s->pciDevice = (uint32_t)memory->readd(address);address+=4;
    s->pciFunction = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDevicePCIBusInfoPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pciDomain);address+=4;
    memory->writed(address, s->pciBus);address+=4;
    memory->writed(address, s->pciDevice);address+=4;
    memory->writed(address, s->pciFunction);address+=4;
}
void MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::read(KMemory* memory, U32 address, VkCommandBufferInheritanceConditionalRenderingInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->conditionalRenderingEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::write(KMemory* memory, U32 address, VkCommandBufferInheritanceConditionalRenderingInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->conditionalRenderingEnable);address+=4;
}
void MarshalVkPhysicalDevice8BitStorageFeatures::read(KMemory* memory, U32 address, VkPhysicalDevice8BitStorageFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->storageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice8BitStorageFeatures::write(KMemory* memory, U32 address, VkPhysicalDevice8BitStorageFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->storageBuffer8BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer8BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant8);address+=4;
}
void MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceConditionalRenderingFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->conditionalRendering = (VkBool32)memory->readd(address);address+=4;
    s->inheritedConditionalRendering = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceConditionalRenderingFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->conditionalRendering);address+=4;
    memory->writed(address, s->inheritedConditionalRendering);address+=4;
}
void MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceVulkanMemoryModelFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vulkanMemoryModel = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelDeviceScope = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelAvailabilityVisibilityChains = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceVulkanMemoryModelFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->vulkanMemoryModel);address+=4;
    memory->writed(address, s->vulkanMemoryModelDeviceScope);address+=4;
    memory->writed(address, s->vulkanMemoryModelAvailabilityVisibilityChains);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicInt64Features::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicInt64Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderBufferInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedInt64Atomics = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicInt64Features::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicInt64Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderBufferInt64Atomics);address+=4;
    memory->writed(address, s->shaderSharedInt64Atomics);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderBufferFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat64AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat64AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderBufferFloat32Atomics);address+=4;
    memory->writed(address, s->shaderBufferFloat32AtomicAdd);address+=4;
    memory->writed(address, s->shaderBufferFloat64Atomics);address+=4;
    memory->writed(address, s->shaderBufferFloat64AtomicAdd);address+=4;
    memory->writed(address, s->shaderSharedFloat32Atomics);address+=4;
    memory->writed(address, s->shaderSharedFloat32AtomicAdd);address+=4;
    memory->writed(address, s->shaderSharedFloat64Atomics);address+=4;
    memory->writed(address, s->shaderSharedFloat64AtomicAdd);address+=4;
    memory->writed(address, s->shaderImageFloat32Atomics);address+=4;
    memory->writed(address, s->shaderImageFloat32AtomicAdd);address+=4;
    memory->writed(address, s->sparseImageFloat32Atomics);address+=4;
    memory->writed(address, s->sparseImageFloat32AtomicAdd);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexAttributeInstanceRateDivisor = (VkBool32)memory->readd(address);address+=4;
    s->vertexAttributeInstanceRateZeroDivisor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->vertexAttributeInstanceRateDivisor);address+=4;
    memory->writed(address, s->vertexAttributeInstanceRateZeroDivisor);address+=4;
}
void MarshalVkQueueFamilyCheckpointPropertiesNV::read(KMemory* memory, U32 address, VkQueueFamilyCheckpointPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->checkpointExecutionStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
}
void MarshalVkQueueFamilyCheckpointPropertiesNV::write(KMemory* memory, U32 address, VkQueueFamilyCheckpointPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->checkpointExecutionStageMask);address+=4;
}
void MarshalVkPhysicalDeviceDepthStencilResolveProperties::read(KMemory* memory, U32 address, VkPhysicalDeviceDepthStencilResolveProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->supportedDepthResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->supportedStencilResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->independentResolveNone = (VkBool32)memory->readd(address);address+=4;
    s->independentResolve = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthStencilResolveProperties::write(KMemory* memory, U32 address, VkPhysicalDeviceDepthStencilResolveProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->supportedDepthResolveModes);address+=4;
    memory->writed(address, s->supportedStencilResolveModes);address+=4;
    memory->writed(address, s->independentResolveNone);address+=4;
    memory->writed(address, s->independentResolve);address+=4;
}
void MarshalVkSubpassDescriptionDepthStencilResolve::read(KMemory* memory, U32 address, VkSubpassDescriptionDepthStencilResolve* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->depthResolveMode = (VkResolveModeFlagBits)memory->readd(address);address+=4;
    s->stencilResolveMode = (VkResolveModeFlagBits)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilResolveAttachment = NULL;
    } else {
        VkAttachmentReference2* pDepthStencilResolveAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pDepthStencilResolveAttachment);
        s->pDepthStencilResolveAttachment = pDepthStencilResolveAttachment;
    }
}
void MarshalVkSubpassDescriptionDepthStencilResolve::write(KMemory* memory, U32 address, VkSubpassDescriptionDepthStencilResolve* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->depthResolveMode);address+=4;
    memory->writed(address, s->stencilResolveMode);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pDepthStencilResolveAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pDepthStencilResolveAttachment);
        s->pDepthStencilResolveAttachment = pDepthStencilResolveAttachment;
    }
}
void MarshalVkImageViewASTCDecodeModeEXT::read(KMemory* memory, U32 address, VkImageViewASTCDecodeModeEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->decodeMode = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkImageViewASTCDecodeModeEXT::write(KMemory* memory, U32 address, VkImageViewASTCDecodeModeEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->decodeMode);address+=4;
}
void MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceASTCDecodeFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->decodeModeSharedExponent = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceASTCDecodeFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->decodeModeSharedExponent);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->transformFeedback = (VkBool32)memory->readd(address);address+=4;
    s->geometryStreams = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->transformFeedback);address+=4;
    memory->writed(address, s->geometryStreams);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxTransformFeedbackStreams = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxTransformFeedbackStreamDataSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferDataSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferDataStride = (uint32_t)memory->readd(address);address+=4;
    s->transformFeedbackQueries = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackStreamsLinesTriangles = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackRasterizationStreamSelect = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackDraw = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxTransformFeedbackStreams);address+=4;
    memory->writed(address, s->maxTransformFeedbackBuffers);address+=4;
    memory->writeq(address, s->maxTransformFeedbackBufferSize);address+=8;
    memory->writed(address, s->maxTransformFeedbackStreamDataSize);address+=4;
    memory->writed(address, s->maxTransformFeedbackBufferDataSize);address+=4;
    memory->writed(address, s->maxTransformFeedbackBufferDataStride);address+=4;
    memory->writed(address, s->transformFeedbackQueries);address+=4;
    memory->writed(address, s->transformFeedbackStreamsLinesTriangles);address+=4;
    memory->writed(address, s->transformFeedbackRasterizationStreamSelect);address+=4;
    memory->writed(address, s->transformFeedbackDraw);address+=4;
}
void MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineRasterizationStateStreamCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationStateStreamCreateFlagsEXT)memory->readd(address);address+=4;
    s->rasterizationStream = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineRasterizationStateStreamCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rasterizationStream);address+=4;
}
void MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->representativeFragmentTest = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->representativeFragmentTest);address+=4;
}
void MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineRepresentativeFragmentTestStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->representativeFragmentTestEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineRepresentativeFragmentTestStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->representativeFragmentTestEnable);address+=4;
}
void MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceExclusiveScissorFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->exclusiveScissor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceExclusiveScissorFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->exclusiveScissor);address+=4;
}
void MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineViewportExclusiveScissorStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->exclusiveScissorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pExclusiveScissors = NULL;
    } else {
        s->pExclusiveScissors = new VkRect2D[(U32)s->exclusiveScissorCount * sizeof(VkRect2D)];
        memory->memcpy((VkRect2D*)s->pExclusiveScissors, paramAddress, (U32)s->exclusiveScissorCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineViewportExclusiveScissorStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->exclusiveScissorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pExclusiveScissors = new VkRect2D();
        MarshalVkRect2D::read(memory, paramAddress, pExclusiveScissors);
        s->pExclusiveScissors = pExclusiveScissors;
    }
}
void MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceCornerSampledImageFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->cornerSampledImage = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceCornerSampledImageFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->cornerSampledImage);address+=4;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->computeDerivativeGroupQuads = (VkBool32)memory->readd(address);address+=4;
    s->computeDerivativeGroupLinear = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->computeDerivativeGroupQuads);address+=4;
    memory->writed(address, s->computeDerivativeGroupLinear);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fragmentShaderBarycentric = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->fragmentShaderBarycentric);address+=4;
}
void MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderImageFootprintFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->imageFootprint = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderImageFootprintFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->imageFootprint);address+=4;
}
void MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dedicatedAllocationImageAliasing = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->dedicatedAllocationImageAliasing);address+=4;
}
void MarshalVkShadingRatePaletteNV::read(KMemory* memory, U32 address, VkShadingRatePaletteNV* s) {
    s->shadingRatePaletteEntryCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShadingRatePaletteEntries = NULL;
    } else {
        s->pShadingRatePaletteEntries = new VkShadingRatePaletteEntryNV[(U32)s->shadingRatePaletteEntryCount * sizeof(VkShadingRatePaletteEntryNV)];
        memory->memcpy((VkShadingRatePaletteEntryNV*)s->pShadingRatePaletteEntries, paramAddress, (U32)s->shadingRatePaletteEntryCount * sizeof(VkShadingRatePaletteEntryNV));
    }
}
void MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineViewportShadingRateImageStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shadingRateImageEnable = (VkBool32)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShadingRatePalettes = NULL;
    } else {
        VkShadingRatePaletteNV* pShadingRatePalettes = new VkShadingRatePaletteNV[s->viewportCount];
        for (U32 i = 0; i < s->viewportCount; i++) {
            MarshalVkShadingRatePaletteNV::read(memory, paramAddress + i*8, &pShadingRatePalettes[i]);
        }
        s->pShadingRatePalettes = pShadingRatePalettes;
    }
}
void MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineViewportShadingRateImageStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shadingRateImageEnable);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkShadingRatePaletteNV* pShadingRatePalettes = new VkShadingRatePaletteNV();
        MarshalVkShadingRatePaletteNV::read(memory, paramAddress, pShadingRatePalettes);
        s->pShadingRatePalettes = pShadingRatePalettes;
    }
}
void MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImageFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shadingRateImage = (VkBool32)memory->readd(address);address+=4;
    s->shadingRateCoarseSampleOrder = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImageFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shadingRateImage);address+=4;
    memory->writed(address, s->shadingRateCoarseSampleOrder);address+=4;
}
void MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImagePropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->shadingRateTexelSize, address, 8);address+=8;
    s->shadingRatePaletteSize = (uint32_t)memory->readd(address);address+=4;
    s->shadingRateMaxCoarseSamples = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImagePropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->shadingRateTexelSize, 8); address+=8;
    memory->writed(address, s->shadingRatePaletteSize);address+=4;
    memory->writed(address, s->shadingRateMaxCoarseSamples);address+=4;
}
void MarshalVkCoarseSampleOrderCustomNV::read(KMemory* memory, U32 address, VkCoarseSampleOrderCustomNV* s) {
    s->shadingRate = (VkShadingRatePaletteEntryNV)memory->readd(address);address+=4;
    s->sampleCount = (uint32_t)memory->readd(address);address+=4;
    s->sampleLocationCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleLocations = NULL;
    } else {
        s->pSampleLocations = new VkCoarseSampleLocationNV[(U32)s->sampleLocationCount * sizeof(VkCoarseSampleLocationNV)];
        memory->memcpy((VkCoarseSampleLocationNV*)s->pSampleLocations, paramAddress, (U32)s->sampleLocationCount * sizeof(VkCoarseSampleLocationNV));
    }
}
void MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sampleOrderType = (VkCoarseSampleOrderTypeNV)memory->readd(address);address+=4;
    s->customSampleOrderCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCustomSampleOrders = NULL;
    } else {
        VkCoarseSampleOrderCustomNV* pCustomSampleOrders = new VkCoarseSampleOrderCustomNV[s->customSampleOrderCount];
        for (U32 i = 0; i < s->customSampleOrderCount; i++) {
            MarshalVkCoarseSampleOrderCustomNV::read(memory, paramAddress + i*16, &pCustomSampleOrders[i]);
        }
        s->pCustomSampleOrders = pCustomSampleOrders;
    }
}
void MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sampleOrderType);address+=4;
    memory->writed(address, s->customSampleOrderCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCoarseSampleOrderCustomNV* pCustomSampleOrders = new VkCoarseSampleOrderCustomNV();
        MarshalVkCoarseSampleOrderCustomNV::read(memory, paramAddress, pCustomSampleOrders);
        s->pCustomSampleOrders = pCustomSampleOrders;
    }
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->taskShader = (VkBool32)memory->readd(address);address+=4;
    s->meshShader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->taskShader);address+=4;
    memory->writed(address, s->meshShader);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxDrawMeshTasksCount = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxTaskWorkGroupSize, address, 3);address+=3;
    s->maxTaskTotalMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskOutputCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxMeshWorkGroupSize, address, 3);address+=3;
    s->maxMeshTotalMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputVertices = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputPrimitives = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerVertexGranularity = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerPrimitiveGranularity = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxDrawMeshTasksCount);address+=4;
    memory->writed(address, s->maxTaskWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxTaskWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxTaskTotalMemorySize);address+=4;
    memory->writed(address, s->maxTaskOutputCount);address+=4;
    memory->writed(address, s->maxMeshWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxMeshWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxMeshTotalMemorySize);address+=4;
    memory->writed(address, s->maxMeshOutputVertices);address+=4;
    memory->writed(address, s->maxMeshOutputPrimitives);address+=4;
    memory->writed(address, s->maxMeshMultiviewViewCount);address+=4;
    memory->writed(address, s->meshOutputPerVertexGranularity);address+=4;
    memory->writed(address, s->meshOutputPerPrimitiveGranularity);address+=4;
}
void MarshalVkRayTracingShaderGroupCreateInfoNV::read(KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->type = (VkRayTracingShaderGroupTypeKHR)memory->readd(address);address+=4;
    s->generalShader = (uint32_t)memory->readd(address);address+=4;
    s->closestHitShader = (uint32_t)memory->readd(address);address+=4;
    s->anyHitShader = (uint32_t)memory->readd(address);address+=4;
    s->intersectionShader = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingShaderGroupCreateInfoNV::write(KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->generalShader);address+=4;
    memory->writed(address, s->closestHitShader);address+=4;
    memory->writed(address, s->anyHitShader);address+=4;
    memory->writed(address, s->intersectionShader);address+=4;
}
void MarshalVkRayTracingPipelineCreateInfoNV::read(KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    s->groupCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGroups = NULL;
    } else {
        VkRayTracingShaderGroupCreateInfoNV* pGroups = new VkRayTracingShaderGroupCreateInfoNV[s->groupCount];
        for (U32 i = 0; i < s->groupCount; i++) {
            MarshalVkRayTracingShaderGroupCreateInfoNV::read(memory, paramAddress + i*28, &pGroups[i]);
        }
        s->pGroups = pGroups;
    }
    s->maxRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingPipelineCreateInfoNV::write(KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    memory->writed(address, s->groupCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRayTracingShaderGroupCreateInfoNV* pGroups = new VkRayTracingShaderGroupCreateInfoNV();
        MarshalVkRayTracingShaderGroupCreateInfoNV::read(memory, paramAddress, pGroups);
        s->pGroups = pGroups;
    }
    memory->writed(address, s->maxRecursionDepth);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
void MarshalVkGeometryTrianglesNV::read(KMemory* memory, U32 address, VkGeometryTrianglesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexData = (VkBuffer)memory->readq(address);address+=8;
    s->vertexOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->vertexCount = (uint32_t)memory->readd(address);address+=4;
    s->vertexStride = (VkDeviceSize)memory->readq(address);address+=8;
    s->vertexFormat = (VkFormat)memory->readd(address);address+=4;
    s->indexData = (VkBuffer)memory->readq(address);address+=8;
    s->indexOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->indexCount = (uint32_t)memory->readd(address);address+=4;
    s->indexType = (VkIndexType)memory->readd(address);address+=4;
    s->transformData = (VkBuffer)memory->readq(address);address+=8;
    s->transformOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeometryTrianglesNV::write(KMemory* memory, U32 address, VkGeometryTrianglesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->vertexData);address+=8;
    memory->writeq(address, s->vertexOffset);address+=8;
    memory->writed(address, s->vertexCount);address+=4;
    memory->writeq(address, s->vertexStride);address+=8;
    memory->writed(address, s->vertexFormat);address+=4;
    memory->writeq(address, (U64)s->indexData);address+=8;
    memory->writeq(address, s->indexOffset);address+=8;
    memory->writed(address, s->indexCount);address+=4;
    memory->writed(address, s->indexType);address+=4;
    memory->writeq(address, (U64)s->transformData);address+=8;
    memory->writeq(address, s->transformOffset);address+=8;
}
void MarshalVkGeometryAABBNV::read(KMemory* memory, U32 address, VkGeometryAABBNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->aabbData = (VkBuffer)memory->readq(address);address+=8;
    s->numAABBs = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeometryAABBNV::write(KMemory* memory, U32 address, VkGeometryAABBNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->aabbData);address+=8;
    memory->writed(address, s->numAABBs);address+=4;
    memory->writed(address, s->stride);address+=4;
    memory->writeq(address, s->offset);address+=8;
}
void MarshalVkGeometryDataNV::read(KMemory* memory, U32 address, VkGeometryDataNV* s) {
    MarshalVkGeometryTrianglesNV::read(memory, address, &s->triangles); address+=80;
    MarshalVkGeometryAABBNV::read(memory, address, &s->aabbs); address+=32;
}
void MarshalVkGeometryNV::read(KMemory* memory, U32 address, VkGeometryNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->geometryType = (VkGeometryTypeKHR)memory->readd(address);address+=4;
    MarshalVkGeometryDataNV::read(memory, address, &s->geometry); address+=112;
    s->flags = (VkGeometryFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkGeometryNV::write(KMemory* memory, U32 address, VkGeometryNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->geometryType);address+=4;
    memory->memcpy(address, &s->geometry, 112); address+=112;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkAccelerationStructureInfoNV::read(KMemory* memory, U32 address, VkAccelerationStructureInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
    s->flags = (VkBuildAccelerationStructureFlagsKHR)memory->readd(address);address+=4;
    s->instanceCount = (uint32_t)memory->readd(address);address+=4;
    s->geometryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGeometries = NULL;
    } else {
        VkGeometryNV* pGeometries = new VkGeometryNV[s->geometryCount];
        for (U32 i = 0; i < s->geometryCount; i++) {
            MarshalVkGeometryNV::read(memory, paramAddress + i*128, &pGeometries[i]);
        }
        s->pGeometries = pGeometries;
    }
}
void MarshalVkAccelerationStructureInfoNV::write(KMemory* memory, U32 address, VkAccelerationStructureInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->instanceCount);address+=4;
    memory->writed(address, s->geometryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkGeometryNV* pGeometries = new VkGeometryNV();
        MarshalVkGeometryNV::read(memory, paramAddress, pGeometries);
        s->pGeometries = pGeometries;
    }
}
void MarshalVkAccelerationStructureCreateInfoNV::read(KMemory* memory, U32 address, VkAccelerationStructureCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->compactedSize = (VkDeviceSize)memory->readq(address);address+=8;
    MarshalVkAccelerationStructureInfoNV::read(memory, address, &s->info); address+=28;
}
void MarshalVkAccelerationStructureCreateInfoNV::write(KMemory* memory, U32 address, VkAccelerationStructureCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->compactedSize);address+=8;
    memory->memcpy(address, &s->info, 28); address+=28;
}
void MarshalVkBindAccelerationStructureMemoryInfoNV::read(KMemory* memory, U32 address, VkBindAccelerationStructureMemoryInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount * sizeof(uint32_t));
    }
}
void MarshalVkBindAccelerationStructureMemoryInfoNV::write(KMemory* memory, U32 address, VkBindAccelerationStructureMemoryInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureKHR::read(KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAccelerationStructures = NULL;
    } else {
        s->pAccelerationStructures = new VkAccelerationStructureKHR[(U32)s->accelerationStructureCount * sizeof(VkAccelerationStructureKHR)];
        memory->memcpy((VkAccelerationStructureKHR*)s->pAccelerationStructures, paramAddress, (U32)s->accelerationStructureCount * sizeof(VkAccelerationStructureKHR));
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureKHR::write(KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->accelerationStructureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureNV::read(KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAccelerationStructures = NULL;
    } else {
        s->pAccelerationStructures = new VkAccelerationStructureNV[(U32)s->accelerationStructureCount * sizeof(VkAccelerationStructureNV)];
        memory->memcpy((VkAccelerationStructureNV*)s->pAccelerationStructures, paramAddress, (U32)s->accelerationStructureCount * sizeof(VkAccelerationStructureNV));
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureNV::write(KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->accelerationStructureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkAccelerationStructureMemoryRequirementsInfoNV::read(KMemory* memory, U32 address, VkAccelerationStructureMemoryRequirementsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->type = (VkAccelerationStructureMemoryRequirementsTypeNV)memory->readd(address);address+=4;
    s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureMemoryRequirementsInfoNV::write(KMemory* memory, U32 address, VkAccelerationStructureMemoryRequirementsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
}
void MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructureFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructure = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureIndirectBuild = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureHostCommands = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingAccelerationStructureUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructureFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->accelerationStructure);address+=4;
    memory->writed(address, s->accelerationStructureCaptureReplay);address+=4;
    memory->writed(address, s->accelerationStructureIndirectBuild);address+=4;
    memory->writed(address, s->accelerationStructureHostCommands);address+=4;
    memory->writed(address, s->descriptorBindingAccelerationStructureUpdateAfterBind);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelineFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->rayTracingPipeline = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineShaderGroupHandleCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineTraceRaysIndirect = (VkBool32)memory->readd(address);address+=4;
    s->rayTraversalPrimitiveCulling = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelineFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->rayTracingPipeline);address+=4;
    memory->writed(address, s->rayTracingPipelineShaderGroupHandleCaptureReplay);address+=4;
    memory->writed(address, s->rayTracingPipelineShaderGroupHandleCaptureReplayMixed);address+=4;
    memory->writed(address, s->rayTracingPipelineTraceRaysIndirect);address+=4;
    memory->writed(address, s->rayTraversalPrimitiveCulling);address+=4;
}
void MarshalVkPhysicalDeviceRayQueryFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceRayQueryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->rayQuery = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayQueryFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceRayQueryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->rayQuery);address+=4;
}
void MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructurePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxGeometryCount = (uint64_t)memory->readq(address);address+=8;
    s->maxInstanceCount = (uint64_t)memory->readq(address);address+=8;
    s->maxPrimitiveCount = (uint64_t)memory->readq(address);address+=8;
    s->maxPerStageDescriptorAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->minAccelerationStructureScratchOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructurePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->maxGeometryCount);address+=8;
    memory->writeq(address, s->maxInstanceCount);address+=8;
    memory->writeq(address, s->maxPrimitiveCount);address+=8;
    memory->writed(address, s->maxPerStageDescriptorAccelerationStructures);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindAccelerationStructures);address+=4;
    memory->writed(address, s->maxDescriptorSetAccelerationStructures);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindAccelerationStructures);address+=4;
    memory->writed(address, s->minAccelerationStructureScratchOffsetAlignment);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelinePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderGroupHandleSize = (uint32_t)memory->readd(address);address+=4;
    s->maxRayRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->maxShaderGroupStride = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupBaseAlignment = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupHandleCaptureReplaySize = (uint32_t)memory->readd(address);address+=4;
    s->maxRayDispatchInvocationCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupHandleAlignment = (uint32_t)memory->readd(address);address+=4;
    s->maxRayHitAttributeSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelinePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderGroupHandleSize);address+=4;
    memory->writed(address, s->maxRayRecursionDepth);address+=4;
    memory->writed(address, s->maxShaderGroupStride);address+=4;
    memory->writed(address, s->shaderGroupBaseAlignment);address+=4;
    memory->writed(address, s->shaderGroupHandleCaptureReplaySize);address+=4;
    memory->writed(address, s->maxRayDispatchInvocationCount);address+=4;
    memory->writed(address, s->shaderGroupHandleAlignment);address+=4;
    memory->writed(address, s->maxRayHitAttributeSize);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderGroupHandleSize = (uint32_t)memory->readd(address);address+=4;
    s->maxRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->maxShaderGroupStride = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupBaseAlignment = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryCount = (uint64_t)memory->readq(address);address+=8;
    s->maxInstanceCount = (uint64_t)memory->readq(address);address+=8;
    s->maxTriangleCount = (uint64_t)memory->readq(address);address+=8;
    s->maxDescriptorSetAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderGroupHandleSize);address+=4;
    memory->writed(address, s->maxRecursionDepth);address+=4;
    memory->writed(address, s->maxShaderGroupStride);address+=4;
    memory->writed(address, s->shaderGroupBaseAlignment);address+=4;
    memory->writeq(address, s->maxGeometryCount);address+=8;
    memory->writeq(address, s->maxInstanceCount);address+=8;
    memory->writeq(address, s->maxTriangleCount);address+=8;
    memory->writed(address, s->maxDescriptorSetAccelerationStructures);address+=4;
}
void MarshalVkDrmFormatModifierPropertiesListEXT::read(KMemory* memory, U32 address, VkDrmFormatModifierPropertiesListEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->drmFormatModifierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDrmFormatModifierProperties = NULL;
    } else {
        s->pDrmFormatModifierProperties = new VkDrmFormatModifierPropertiesEXT[(U32)s->drmFormatModifierCount * sizeof(VkDrmFormatModifierPropertiesEXT)];
        memory->memcpy((VkDrmFormatModifierPropertiesEXT*)s->pDrmFormatModifierProperties, paramAddress, (U32)s->drmFormatModifierCount * sizeof(VkDrmFormatModifierPropertiesEXT));
    }
}
void MarshalVkDrmFormatModifierPropertiesListEXT::write(KMemory* memory, U32 address, VkDrmFormatModifierPropertiesListEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->drmFormatModifierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties = new VkDrmFormatModifierPropertiesEXT();
        MarshalVkDrmFormatModifierPropertiesEXT::read(memory, paramAddress, pDrmFormatModifierProperties);
        s->pDrmFormatModifierProperties = pDrmFormatModifierProperties;
    }
}
void MarshalVkPhysicalDeviceImageDrmFormatModifierInfoEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceImageDrmFormatModifierInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->drmFormatModifier = (uint64_t)memory->readq(address);address+=8;
    s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount * sizeof(uint32_t));
    }
}
void MarshalVkPhysicalDeviceImageDrmFormatModifierInfoEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceImageDrmFormatModifierInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->drmFormatModifier);address+=8;
    memory->writed(address, s->sharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkImageDrmFormatModifierListCreateInfoEXT::read(KMemory* memory, U32 address, VkImageDrmFormatModifierListCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->drmFormatModifierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDrmFormatModifiers = NULL;
    } else {
        s->pDrmFormatModifiers = new uint64_t[(U32)s->drmFormatModifierCount * sizeof(uint64_t)];
        memory->memcpy((uint64_t*)s->pDrmFormatModifiers, paramAddress, (U32)s->drmFormatModifierCount * sizeof(uint64_t));
    }
}
void MarshalVkImageDrmFormatModifierListCreateInfoEXT::write(KMemory* memory, U32 address, VkImageDrmFormatModifierListCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->drmFormatModifierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkImageDrmFormatModifierExplicitCreateInfoEXT::read(KMemory* memory, U32 address, VkImageDrmFormatModifierExplicitCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->drmFormatModifier = (uint64_t)memory->readq(address);address+=8;
    s->drmFormatModifierPlaneCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPlaneLayouts = NULL;
    } else {
        s->pPlaneLayouts = new VkSubresourceLayout[(U32)s->drmFormatModifierPlaneCount * sizeof(VkSubresourceLayout)];
        memory->memcpy((VkSubresourceLayout*)s->pPlaneLayouts, paramAddress, (U32)s->drmFormatModifierPlaneCount * sizeof(VkSubresourceLayout));
    }
}
void MarshalVkImageDrmFormatModifierExplicitCreateInfoEXT::write(KMemory* memory, U32 address, VkImageDrmFormatModifierExplicitCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->drmFormatModifier);address+=8;
    memory->writed(address, s->drmFormatModifierPlaneCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubresourceLayout* pPlaneLayouts = new VkSubresourceLayout();
        MarshalVkSubresourceLayout::read(memory, paramAddress, pPlaneLayouts);
        s->pPlaneLayouts = pPlaneLayouts;
    }
}
void MarshalVkImageDrmFormatModifierPropertiesEXT::read(KMemory* memory, U32 address, VkImageDrmFormatModifierPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->drmFormatModifier = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkImageDrmFormatModifierPropertiesEXT::write(KMemory* memory, U32 address, VkImageDrmFormatModifierPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->drmFormatModifier);address+=8;
}
void MarshalVkImageStencilUsageCreateInfo::read(KMemory* memory, U32 address, VkImageStencilUsageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->stencilUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkImageStencilUsageCreateInfo::write(KMemory* memory, U32 address, VkImageStencilUsageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->stencilUsage);address+=4;
}
void MarshalVkDeviceMemoryOverallocationCreateInfoAMD::read(KMemory* memory, U32 address, VkDeviceMemoryOverallocationCreateInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->overallocationBehavior = (VkMemoryOverallocationBehaviorAMD)memory->readd(address);address+=4;
}
void MarshalVkDeviceMemoryOverallocationCreateInfoAMD::write(KMemory* memory, U32 address, VkDeviceMemoryOverallocationCreateInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->overallocationBehavior);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fragmentDensityMap = (VkBool32)memory->readd(address);address+=4;
    s->fragmentDensityMapDynamic = (VkBool32)memory->readd(address);address+=4;
    s->fragmentDensityMapNonSubsampledImages = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->fragmentDensityMap);address+=4;
    memory->writed(address, s->fragmentDensityMapDynamic);address+=4;
    memory->writed(address, s->fragmentDensityMapNonSubsampledImages);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fragmentDensityMapDeferred = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->fragmentDensityMapDeferred);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->minFragmentDensityTexelSize, address, 8);address+=8;
    memory->memcpy(&s->maxFragmentDensityTexelSize, address, 8);address+=8;
    s->fragmentDensityInvocations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->minFragmentDensityTexelSize, 8); address+=8;
    memory->memcpy(address, &s->maxFragmentDensityTexelSize, 8); address+=8;
    memory->writed(address, s->fragmentDensityInvocations);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->subsampledLoads = (VkBool32)memory->readd(address);address+=4;
    s->subsampledCoarseReconstructionEarlyAccess = (VkBool32)memory->readd(address);address+=4;
    s->maxSubsampledArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSubsampledSamplers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->subsampledLoads);address+=4;
    memory->writed(address, s->subsampledCoarseReconstructionEarlyAccess);address+=4;
    memory->writed(address, s->maxSubsampledArrayLayers);address+=4;
    memory->writed(address, s->maxDescriptorSetSubsampledSamplers);address+=4;
}
void MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::read(KMemory* memory, U32 address, VkRenderPassFragmentDensityMapCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalVkAttachmentReference::read(memory, address, &s->fragmentDensityMapAttachment); address+=8;
}
void MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::write(KMemory* memory, U32 address, VkRenderPassFragmentDensityMapCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->fragmentDensityMapAttachment, 8); address+=8;
}
void MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceScalarBlockLayoutFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->scalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceScalarBlockLayoutFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->scalarBlockLayout);address+=4;
}
void MarshalVkSurfaceProtectedCapabilitiesKHR::read(KMemory* memory, U32 address, VkSurfaceProtectedCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->supportsProtected = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSurfaceProtectedCapabilitiesKHR::write(KMemory* memory, U32 address, VkSurfaceProtectedCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->supportsProtected);address+=4;
}
void MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->uniformBufferStandardLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->uniformBufferStandardLayout);address+=4;
}
void MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceDepthClipEnableFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->depthClipEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceDepthClipEnableFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->depthClipEnable);address+=4;
}
void MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineRasterizationDepthClipStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationDepthClipStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->depthClipEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineRasterizationDepthClipStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthClipEnable);address+=4;
}
void MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceMemoryBudgetPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->heapBudget, address, 16);address+=16;
    memory->memcpy(&s->heapUsage, address, 16);address+=16;
}
void MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceMemoryBudgetPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->heapBudget, 128); address+=128;
    memory->memcpy(address, s->heapUsage, 128); address+=128;
}
void MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceMemoryPriorityFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memoryPriority = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceMemoryPriorityFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->memoryPriority);address+=4;
}
void MarshalVkMemoryPriorityAllocateInfoEXT::read(KMemory* memory, U32 address, VkMemoryPriorityAllocateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    MarshalFloat priorityFloat;
    priorityFloat.i = memory->readd(address);address+=4;
    s->priority = priorityFloat.f;
}
void MarshalVkMemoryPriorityAllocateInfoEXT::write(KMemory* memory, U32 address, VkMemoryPriorityAllocateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    MarshalFloat priorityFloat;
    priorityFloat.f = s->priority;
    memory->writed(address, priorityFloat.i);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
}
void MarshalVkBufferDeviceAddressInfo::read(KMemory* memory, U32 address, VkBufferDeviceAddressInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkBufferDeviceAddressInfo::write(KMemory* memory, U32 address, VkBufferDeviceAddressInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
void MarshalVkBufferOpaqueCaptureAddressCreateInfo::read(KMemory* memory, U32 address, VkBufferOpaqueCaptureAddressCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->opaqueCaptureAddress = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkBufferOpaqueCaptureAddressCreateInfo::write(KMemory* memory, U32 address, VkBufferOpaqueCaptureAddressCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->opaqueCaptureAddress);address+=8;
}
void MarshalVkBufferDeviceAddressCreateInfoEXT::read(KMemory* memory, U32 address, VkBufferDeviceAddressCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkBufferDeviceAddressCreateInfoEXT::write(KMemory* memory, U32 address, VkBufferDeviceAddressCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->deviceAddress);address+=8;
}
void MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceImageViewImageFormatInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->imageViewType = (VkImageViewType)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceImageViewImageFormatInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->imageViewType);address+=4;
}
void MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::read(KMemory* memory, U32 address, VkFilterCubicImageViewImageFormatPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->filterCubic = (VkBool32)memory->readd(address);address+=4;
    s->filterCubicMinmax = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::write(KMemory* memory, U32 address, VkFilterCubicImageViewImageFormatPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->filterCubic);address+=4;
    memory->writed(address, s->filterCubicMinmax);address+=4;
}
void MarshalVkPhysicalDeviceImagelessFramebufferFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceImagelessFramebufferFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->imagelessFramebuffer = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImagelessFramebufferFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceImagelessFramebufferFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->imagelessFramebuffer);address+=4;
}
void MarshalVkFramebufferAttachmentsCreateInfo::read(KMemory* memory, U32 address, VkFramebufferAttachmentsCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->attachmentImageInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachmentImageInfos = NULL;
    } else {
        VkFramebufferAttachmentImageInfo* pAttachmentImageInfos = new VkFramebufferAttachmentImageInfo[s->attachmentImageInfoCount];
        for (U32 i = 0; i < s->attachmentImageInfoCount; i++) {
            MarshalVkFramebufferAttachmentImageInfo::read(memory, paramAddress + i*36, &pAttachmentImageInfos[i]);
        }
        s->pAttachmentImageInfos = pAttachmentImageInfos;
    }
}
void MarshalVkFramebufferAttachmentsCreateInfo::write(KMemory* memory, U32 address, VkFramebufferAttachmentsCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->attachmentImageInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkFramebufferAttachmentImageInfo* pAttachmentImageInfos = new VkFramebufferAttachmentImageInfo();
        MarshalVkFramebufferAttachmentImageInfo::read(memory, paramAddress, pAttachmentImageInfos);
        s->pAttachmentImageInfos = pAttachmentImageInfos;
    }
}
void MarshalVkRenderPassAttachmentBeginInfo::read(KMemory* memory, U32 address, VkRenderPassAttachmentBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        s->pAttachments = new VkImageView[(U32)s->attachmentCount * sizeof(VkImageView)];
        memory->memcpy((VkImageView*)s->pAttachments, paramAddress, (U32)s->attachmentCount * sizeof(VkImageView));
    }
}
void MarshalVkRenderPassAttachmentBeginInfo::write(KMemory* memory, U32 address, VkRenderPassAttachmentBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->textureCompressionASTC_HDR = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->textureCompressionASTC_HDR);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->cooperativeMatrix = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixRobustBufferAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->cooperativeMatrix);address+=4;
    memory->writed(address, s->cooperativeMatrixRobustBufferAccess);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->cooperativeMatrixSupportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->cooperativeMatrixSupportedStages);address+=4;
}
void MarshalVkCooperativeMatrixPropertiesNV::read(KMemory* memory, U32 address, VkCooperativeMatrixPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->MSize = (uint32_t)memory->readd(address);address+=4;
    s->NSize = (uint32_t)memory->readd(address);address+=4;
    s->KSize = (uint32_t)memory->readd(address);address+=4;
    s->AType = (VkComponentTypeNV)memory->readd(address);address+=4;
    s->BType = (VkComponentTypeNV)memory->readd(address);address+=4;
    s->CType = (VkComponentTypeNV)memory->readd(address);address+=4;
    s->DType = (VkComponentTypeNV)memory->readd(address);address+=4;
    s->scope = (VkScopeNV)memory->readd(address);address+=4;
}
void MarshalVkCooperativeMatrixPropertiesNV::write(KMemory* memory, U32 address, VkCooperativeMatrixPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->MSize);address+=4;
    memory->writed(address, s->NSize);address+=4;
    memory->writed(address, s->KSize);address+=4;
    memory->writed(address, s->AType);address+=4;
    memory->writed(address, s->BType);address+=4;
    memory->writed(address, s->CType);address+=4;
    memory->writed(address, s->DType);address+=4;
    memory->writed(address, s->scope);address+=4;
}
void MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->ycbcrImageArrays = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->ycbcrImageArrays);address+=4;
}
void MarshalVkImageViewHandleInfoNVX::read(KMemory* memory, U32 address, VkImageViewHandleInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->sampler = (VkSampler)memory->readq(address);address+=8;
}
void MarshalVkImageViewHandleInfoNVX::write(KMemory* memory, U32 address, VkImageViewHandleInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->imageView);address+=8;
    memory->writed(address, s->descriptorType);address+=4;
    memory->writeq(address, (U64)s->sampler);address+=8;
}
void MarshalVkImageViewAddressPropertiesNVX::read(KMemory* memory, U32 address, VkImageViewAddressPropertiesNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkImageViewAddressPropertiesNVX::write(KMemory* memory, U32 address, VkImageViewAddressPropertiesNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->deviceAddress);address+=8;
    memory->writeq(address, s->size);address+=8;
}
void MarshalVkPipelineCreationFeedbackEXT::read(KMemory* memory, U32 address, VkPipelineCreationFeedbackEXT* s) {
    s->flags = (VkPipelineCreationFeedbackFlagsEXT)memory->readd(address);address+=4;
    s->duration = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPipelineCreationFeedbackCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineCreationFeedbackCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineCreationFeedback = NULL;
    } else {
        VkPipelineCreationFeedbackEXT* pPipelineCreationFeedback = new VkPipelineCreationFeedbackEXT();
        MarshalVkPipelineCreationFeedbackEXT::read(memory, paramAddress, pPipelineCreationFeedback);
        s->pPipelineCreationFeedback = pPipelineCreationFeedback;
    }
    s->pipelineStageCreationFeedbackCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineStageCreationFeedbacks = NULL;
    } else {
        s->pPipelineStageCreationFeedbacks = new VkPipelineCreationFeedbackEXT[(U32)s->pipelineStageCreationFeedbackCount * sizeof(VkPipelineCreationFeedbackEXT)];
        memory->memcpy((VkPipelineCreationFeedbackEXT*)s->pPipelineStageCreationFeedbacks, paramAddress, (U32)s->pipelineStageCreationFeedbackCount * sizeof(VkPipelineCreationFeedbackEXT));
    }
}
void MarshalVkPipelineCreationFeedbackCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineCreationFeedbackCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineCreationFeedbackEXT* pPipelineCreationFeedback = new VkPipelineCreationFeedbackEXT();
        MarshalVkPipelineCreationFeedbackEXT::read(memory, paramAddress, pPipelineCreationFeedback);
        s->pPipelineCreationFeedback = pPipelineCreationFeedback;
    }
    memory->writed(address, s->pipelineStageCreationFeedbackCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineCreationFeedbackEXT* pPipelineStageCreationFeedbacks = new VkPipelineCreationFeedbackEXT();
        MarshalVkPipelineCreationFeedbackEXT::read(memory, paramAddress, pPipelineStageCreationFeedbacks);
        s->pPipelineStageCreationFeedbacks = pPipelineStageCreationFeedbacks;
    }
}
void MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->performanceCounterQueryPools = (VkBool32)memory->readd(address);address+=4;
    s->performanceCounterMultipleQueryPools = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->performanceCounterQueryPools);address+=4;
    memory->writed(address, s->performanceCounterMultipleQueryPools);address+=4;
}
void MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::read(KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->allowCommandBufferQueryCopies = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::write(KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->allowCommandBufferQueryCopies);address+=4;
}
void MarshalVkPerformanceCounterKHR::read(KMemory* memory, U32 address, VkPerformanceCounterKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->unit = (VkPerformanceCounterUnitKHR)memory->readd(address);address+=4;
    s->scope = (VkPerformanceCounterScopeKHR)memory->readd(address);address+=4;
    s->storage = (VkPerformanceCounterStorageKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->uuid, address, 16);address+=16;
}
void MarshalVkPerformanceCounterKHR::write(KMemory* memory, U32 address, VkPerformanceCounterKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->unit);address+=4;
    memory->writed(address, s->scope);address+=4;
    memory->writed(address, s->storage);address+=4;
    memory->memcpy(address, s->uuid, 16); address+=16;
}
void MarshalVkPerformanceCounterDescriptionKHR::read(KMemory* memory, U32 address, VkPerformanceCounterDescriptionKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPerformanceCounterDescriptionFlagsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->category, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
}
void MarshalVkPerformanceCounterDescriptionKHR::write(KMemory* memory, U32 address, VkPerformanceCounterDescriptionKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->category, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
}
void MarshalVkQueryPoolPerformanceCreateInfoKHR::read(KMemory* memory, U32 address, VkQueryPoolPerformanceCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->counterIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCounterIndices = NULL;
    } else {
        s->pCounterIndices = new uint32_t[(U32)s->counterIndexCount * sizeof(uint32_t)];
        memory->memcpy((uint32_t*)s->pCounterIndices, paramAddress, (U32)s->counterIndexCount * sizeof(uint32_t));
    }
}
void MarshalVkQueryPoolPerformanceCreateInfoKHR::write(KMemory* memory, U32 address, VkQueryPoolPerformanceCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->counterIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkAcquireProfilingLockInfoKHR::read(KMemory* memory, U32 address, VkAcquireProfilingLockInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkAcquireProfilingLockFlagsKHR)memory->readd(address);address+=4;
    s->timeout = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkAcquireProfilingLockInfoKHR::write(KMemory* memory, U32 address, VkAcquireProfilingLockInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->timeout);address+=8;
}
void MarshalVkPerformanceQuerySubmitInfoKHR::read(KMemory* memory, U32 address, VkPerformanceQuerySubmitInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->counterPassIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPerformanceQuerySubmitInfoKHR::write(KMemory* memory, U32 address, VkPerformanceQuerySubmitInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->counterPassIndex);address+=4;
}
void MarshalVkHeadlessSurfaceCreateInfoEXT::read(KMemory* memory, U32 address, VkHeadlessSurfaceCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkHeadlessSurfaceCreateFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkHeadlessSurfaceCreateInfoEXT::write(KMemory* memory, U32 address, VkHeadlessSurfaceCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceCoverageReductionModeFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->coverageReductionMode = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceCoverageReductionModeFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->coverageReductionMode);address+=4;
}
void MarshalVkPipelineCoverageReductionStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineCoverageReductionStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageReductionStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageReductionMode = (VkCoverageReductionModeNV)memory->readd(address);address+=4;
}
void MarshalVkPipelineCoverageReductionStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineCoverageReductionStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageReductionMode);address+=4;
}
void MarshalVkFramebufferMixedSamplesCombinationNV::read(KMemory* memory, U32 address, VkFramebufferMixedSamplesCombinationNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->coverageReductionMode = (VkCoverageReductionModeNV)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->depthStencilSamples = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->colorSamples = (VkSampleCountFlags)memory->readd(address);address+=4;
}
void MarshalVkFramebufferMixedSamplesCombinationNV::write(KMemory* memory, U32 address, VkFramebufferMixedSamplesCombinationNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->coverageReductionMode);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
    memory->writed(address, s->depthStencilSamples);address+=4;
    memory->writed(address, s->colorSamples);address+=4;
}
void MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderIntegerFunctions2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderIntegerFunctions2);address+=4;
}
void MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::read(KMemory* memory, U32 address, VkQueryPoolPerformanceQueryCreateInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->performanceCountersSampling = (VkQueryPoolSamplingModeINTEL)memory->readd(address);address+=4;
}
void MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::write(KMemory* memory, U32 address, VkQueryPoolPerformanceQueryCreateInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->performanceCountersSampling);address+=4;
}
void MarshalVkPerformanceMarkerInfoINTEL::read(KMemory* memory, U32 address, VkPerformanceMarkerInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->marker = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPerformanceMarkerInfoINTEL::write(KMemory* memory, U32 address, VkPerformanceMarkerInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->marker);address+=8;
}
void MarshalVkPerformanceStreamMarkerInfoINTEL::read(KMemory* memory, U32 address, VkPerformanceStreamMarkerInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->marker = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPerformanceStreamMarkerInfoINTEL::write(KMemory* memory, U32 address, VkPerformanceStreamMarkerInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->marker);address+=4;
}
void MarshalVkPerformanceOverrideInfoINTEL::read(KMemory* memory, U32 address, VkPerformanceOverrideInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->type = (VkPerformanceOverrideTypeINTEL)memory->readd(address);address+=4;
    s->enable = (VkBool32)memory->readd(address);address+=4;
    s->parameter = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPerformanceOverrideInfoINTEL::write(KMemory* memory, U32 address, VkPerformanceOverrideInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->enable);address+=4;
    memory->writeq(address, s->parameter);address+=8;
}
void MarshalVkPerformanceConfigurationAcquireInfoINTEL::read(KMemory* memory, U32 address, VkPerformanceConfigurationAcquireInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->type = (VkPerformanceConfigurationTypeINTEL)memory->readd(address);address+=4;
}
void MarshalVkPerformanceConfigurationAcquireInfoINTEL::write(KMemory* memory, U32 address, VkPerformanceConfigurationAcquireInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->type);address+=4;
}
void MarshalVkPhysicalDeviceShaderClockFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderClockFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderSubgroupClock = (VkBool32)memory->readd(address);address+=4;
    s->shaderDeviceClock = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderClockFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderClockFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderSubgroupClock);address+=4;
    memory->writed(address, s->shaderDeviceClock);address+=4;
}
void MarshalVkPhysicalDeviceIndexTypeUint8FeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceIndexTypeUint8FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->indexTypeUint8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceIndexTypeUint8FeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceIndexTypeUint8FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->indexTypeUint8);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderSMCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderWarpsPerSM = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderSMCount);address+=4;
    memory->writed(address, s->shaderWarpsPerSM);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderSMBuiltins = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderSMBuiltins);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fragmentShaderSampleInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShaderPixelInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShaderShadingRateInterlock = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->fragmentShaderSampleInterlock);address+=4;
    memory->writed(address, s->fragmentShaderPixelInterlock);address+=4;
    memory->writed(address, s->fragmentShaderShadingRateInterlock);address+=4;
}
void MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->separateDepthStencilLayouts = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::write(KMemory* memory, U32 address, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->separateDepthStencilLayouts);address+=4;
}
void MarshalVkAttachmentReferenceStencilLayout::read(KMemory* memory, U32 address, VkAttachmentReferenceStencilLayout* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->stencilLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReferenceStencilLayout::write(KMemory* memory, U32 address, VkAttachmentReferenceStencilLayout* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->stencilLayout);address+=4;
}
void MarshalVkAttachmentDescriptionStencilLayout::read(KMemory* memory, U32 address, VkAttachmentDescriptionStencilLayout* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->stencilInitialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->stencilFinalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentDescriptionStencilLayout::write(KMemory* memory, U32 address, VkAttachmentDescriptionStencilLayout* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->stencilInitialLayout);address+=4;
    memory->writed(address, s->stencilFinalLayout);address+=4;
}
void MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipelineExecutableInfo = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pipelineExecutableInfo);address+=4;
}
void MarshalVkPipelineInfoKHR::read(KMemory* memory, U32 address, VkPipelineInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkPipelineInfoKHR::write(KMemory* memory, U32 address, VkPipelineInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
void MarshalVkPipelineExecutablePropertiesKHR::read(KMemory* memory, U32 address, VkPipelineExecutablePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->stages = (VkShaderStageFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineExecutablePropertiesKHR::write(KMemory* memory, U32 address, VkPipelineExecutablePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->stages);address+=4;
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->subgroupSize);address+=4;
}
void MarshalVkPipelineExecutableInfoKHR::read(KMemory* memory, U32 address, VkPipelineExecutableInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->executableIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineExecutableInfoKHR::write(KMemory* memory, U32 address, VkPipelineExecutableInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writed(address, s->executableIndex);address+=4;
}
void MarshalVkPipelineExecutableStatisticKHR::read(KMemory* memory, U32 address, VkPipelineExecutableStatisticKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->format = (VkPipelineExecutableStatisticFormatKHR)memory->readd(address);address+=4;
    s->value.u64 = memory->readq(address);address+=8;
}
void MarshalVkPipelineExecutableStatisticKHR::write(KMemory* memory, U32 address, VkPipelineExecutableStatisticKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->format);address+=4;
    memory->writeq(address, s->value.i64);address+=8;
}
void MarshalVkPipelineExecutableInternalRepresentationKHR::read(KMemory* memory, U32 address, VkPipelineExecutableInternalRepresentationKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->isText = (VkBool32)memory->readd(address);address+=4;
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkPipelineExecutableInternalRepresentationKHR::write(KMemory* memory, U32 address, VkPipelineExecutableInternalRepresentationKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->isText);address+=4;
    memory->writed(address, (U32)s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderDemoteToHelperInvocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderDemoteToHelperInvocation);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->texelBufferAlignment = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->texelBufferAlignment);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->storageTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->storageTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
    s->uniformTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->uniformTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->storageTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->storageTexelBufferOffsetSingleTexelAlignment);address+=4;
    memory->writeq(address, s->uniformTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->uniformTexelBufferOffsetSingleTexelAlignment);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->subgroupSizeControl = (VkBool32)memory->readd(address);address+=4;
    s->computeFullSubgroups = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->subgroupSizeControl);address+=4;
    memory->writed(address, s->computeFullSubgroups);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->minSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxComputeWorkgroupSubgroups = (uint32_t)memory->readd(address);address+=4;
    s->requiredSubgroupSizeStages = (VkShaderStageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->minSubgroupSize);address+=4;
    memory->writed(address, s->maxSubgroupSize);address+=4;
    memory->writed(address, s->maxComputeWorkgroupSubgroups);address+=4;
    memory->writed(address, s->requiredSubgroupSizeStages);address+=4;
}
void MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->requiredSubgroupSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->requiredSubgroupSize);address+=4;
}
void MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::read(KMemory* memory, U32 address, VkSubpassShadingPipelineCreateInfoHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::write(KMemory* memory, U32 address, VkSubpassShadingPipelineCreateInfoHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::read(KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxSubpassShadingWorkgroupSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::write(KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxSubpassShadingWorkgroupSizeAspectRatio);address+=4;
}
void MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::read(KMemory* memory, U32 address, VkMemoryOpaqueCaptureAddressAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->opaqueCaptureAddress = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::write(KMemory* memory, U32 address, VkMemoryOpaqueCaptureAddressAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->opaqueCaptureAddress);address+=8;
}
void MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::read(KMemory* memory, U32 address, VkDeviceMemoryOpaqueCaptureAddressInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
}
void MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::write(KMemory* memory, U32 address, VkDeviceMemoryOpaqueCaptureAddressInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->memory);address+=8;
}
void MarshalVkPhysicalDeviceLineRasterizationFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->rectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->bresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->smoothLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledRectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledBresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledSmoothLines = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLineRasterizationFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->rectangularLines);address+=4;
    memory->writed(address, s->bresenhamLines);address+=4;
    memory->writed(address, s->smoothLines);address+=4;
    memory->writed(address, s->stippledRectangularLines);address+=4;
    memory->writed(address, s->stippledBresenhamLines);address+=4;
    memory->writed(address, s->stippledSmoothLines);address+=4;
}
void MarshalVkPhysicalDeviceLineRasterizationPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->lineSubPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLineRasterizationPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->lineSubPixelPrecisionBits);address+=4;
}
void MarshalVkPipelineRasterizationLineStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineRasterizationLineStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->lineRasterizationMode = (VkLineRasterizationModeEXT)memory->readd(address);address+=4;
    s->stippledLineEnable = (VkBool32)memory->readd(address);address+=4;
    s->lineStippleFactor = (uint32_t)memory->readd(address);address+=4;
    s->lineStipplePattern = (uint16_t)memory->readw(address);address+=2;
}
void MarshalVkPipelineRasterizationLineStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineRasterizationLineStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->lineRasterizationMode);address+=4;
    memory->writed(address, s->stippledLineEnable);address+=4;
    memory->writed(address, s->lineStippleFactor);address+=4;
    memory->writew(address, s->lineStipplePattern);address+=2;
}
void MarshalVkPhysicalDevicePipelineCreationCacheControlFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipelineCreationCacheControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineCreationCacheControlFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pipelineCreationCacheControl);address+=4;
}
void MarshalVkPhysicalDeviceVulkan11Features::read(KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->storageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant16 = (VkBool32)memory->readd(address);address+=4;
    s->storageInputOutput16 = (VkBool32)memory->readd(address);address+=4;
    s->multiview = (VkBool32)memory->readd(address);address+=4;
    s->multiviewGeometryShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewTessellationShader = (VkBool32)memory->readd(address);address+=4;
    s->variablePointersStorageBuffer = (VkBool32)memory->readd(address);address+=4;
    s->variablePointers = (VkBool32)memory->readd(address);address+=4;
    s->protectedMemory = (VkBool32)memory->readd(address);address+=4;
    s->samplerYcbcrConversion = (VkBool32)memory->readd(address);address+=4;
    s->shaderDrawParameters = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan11Features::write(KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->storageBuffer16BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer16BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant16);address+=4;
    memory->writed(address, s->storageInputOutput16);address+=4;
    memory->writed(address, s->multiview);address+=4;
    memory->writed(address, s->multiviewGeometryShader);address+=4;
    memory->writed(address, s->multiviewTessellationShader);address+=4;
    memory->writed(address, s->variablePointersStorageBuffer);address+=4;
    memory->writed(address, s->variablePointers);address+=4;
    memory->writed(address, s->protectedMemory);address+=4;
    memory->writed(address, s->samplerYcbcrConversion);address+=4;
    memory->writed(address, s->shaderDrawParameters);address+=4;
}
void MarshalVkPhysicalDeviceVulkan11Properties::read(KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->deviceUUID, address, 16);address+=16;
    memory->memcpy(&s->driverUUID, address, 16);address+=16;
    memory->memcpy(&s->deviceLUID, address, 8);address+=8;
    s->deviceNodeMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceLUIDValid = (VkBool32)memory->readd(address);address+=4;
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->subgroupSupportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->subgroupSupportedOperations = (VkSubgroupFeatureFlags)memory->readd(address);address+=4;
    s->subgroupQuadOperationsInAllStages = (VkBool32)memory->readd(address);address+=4;
    s->pointClippingBehavior = (VkPointClippingBehavior)memory->readd(address);address+=4;
    s->maxMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMultiviewInstanceIndex = (uint32_t)memory->readd(address);address+=4;
    s->protectedNoFault = (VkBool32)memory->readd(address);address+=4;
    s->maxPerSetDescriptors = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceVulkan11Properties::write(KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->deviceUUID, 16); address+=16;
    memory->memcpy(address, s->driverUUID, 16); address+=16;
    memory->memcpy(address, s->deviceLUID, 8); address+=8;
    memory->writed(address, s->deviceNodeMask);address+=4;
    memory->writed(address, s->deviceLUIDValid);address+=4;
    memory->writed(address, s->subgroupSize);address+=4;
    memory->writed(address, s->subgroupSupportedStages);address+=4;
    memory->writed(address, s->subgroupSupportedOperations);address+=4;
    memory->writed(address, s->subgroupQuadOperationsInAllStages);address+=4;
    memory->writed(address, s->pointClippingBehavior);address+=4;
    memory->writed(address, s->maxMultiviewViewCount);address+=4;
    memory->writed(address, s->maxMultiviewInstanceIndex);address+=4;
    memory->writed(address, s->protectedNoFault);address+=4;
    memory->writed(address, s->maxPerSetDescriptors);address+=4;
    memory->writeq(address, s->maxMemoryAllocationSize);address+=8;
}
void MarshalVkPhysicalDeviceVulkan12Features::read(KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->samplerMirrorClampToEdge = (VkBool32)memory->readd(address);address+=4;
    s->drawIndirectCount = (VkBool32)memory->readd(address);address+=4;
    s->storageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant8 = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt8 = (VkBool32)memory->readd(address);address+=4;
    s->descriptorIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingSampledImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUpdateUnusedWhilePending = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingPartiallyBound = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingVariableDescriptorCount = (VkBool32)memory->readd(address);address+=4;
    s->runtimeDescriptorArray = (VkBool32)memory->readd(address);address+=4;
    s->samplerFilterMinmax = (VkBool32)memory->readd(address);address+=4;
    s->scalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
    s->imagelessFramebuffer = (VkBool32)memory->readd(address);address+=4;
    s->uniformBufferStandardLayout = (VkBool32)memory->readd(address);address+=4;
    s->shaderSubgroupExtendedTypes = (VkBool32)memory->readd(address);address+=4;
    s->separateDepthStencilLayouts = (VkBool32)memory->readd(address);address+=4;
    s->hostQueryReset = (VkBool32)memory->readd(address);address+=4;
    s->timelineSemaphore = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModel = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelDeviceScope = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelAvailabilityVisibilityChains = (VkBool32)memory->readd(address);address+=4;
    s->shaderOutputViewportIndex = (VkBool32)memory->readd(address);address+=4;
    s->shaderOutputLayer = (VkBool32)memory->readd(address);address+=4;
    s->subgroupBroadcastDynamicId = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan12Features::write(KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->samplerMirrorClampToEdge);address+=4;
    memory->writed(address, s->drawIndirectCount);address+=4;
    memory->writed(address, s->storageBuffer8BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer8BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant8);address+=4;
    memory->writed(address, s->shaderBufferInt64Atomics);address+=4;
    memory->writed(address, s->shaderSharedInt64Atomics);address+=4;
    memory->writed(address, s->shaderFloat16);address+=4;
    memory->writed(address, s->shaderInt8);address+=4;
    memory->writed(address, s->descriptorIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->descriptorBindingUniformBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingSampledImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUniformTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUpdateUnusedWhilePending);address+=4;
    memory->writed(address, s->descriptorBindingPartiallyBound);address+=4;
    memory->writed(address, s->descriptorBindingVariableDescriptorCount);address+=4;
    memory->writed(address, s->runtimeDescriptorArray);address+=4;
    memory->writed(address, s->samplerFilterMinmax);address+=4;
    memory->writed(address, s->scalarBlockLayout);address+=4;
    memory->writed(address, s->imagelessFramebuffer);address+=4;
    memory->writed(address, s->uniformBufferStandardLayout);address+=4;
    memory->writed(address, s->shaderSubgroupExtendedTypes);address+=4;
    memory->writed(address, s->separateDepthStencilLayouts);address+=4;
    memory->writed(address, s->hostQueryReset);address+=4;
    memory->writed(address, s->timelineSemaphore);address+=4;
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
    memory->writed(address, s->vulkanMemoryModel);address+=4;
    memory->writed(address, s->vulkanMemoryModelDeviceScope);address+=4;
    memory->writed(address, s->vulkanMemoryModelAvailabilityVisibilityChains);address+=4;
    memory->writed(address, s->shaderOutputViewportIndex);address+=4;
    memory->writed(address, s->shaderOutputLayer);address+=4;
    memory->writed(address, s->subgroupBroadcastDynamicId);address+=4;
}
void MarshalVkPhysicalDeviceVulkan12Properties::read(KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->driverID = (VkDriverId)memory->readd(address);address+=4;
    memory->memcpy(&s->driverName, address, 256);address+=256;
    memory->memcpy(&s->driverInfo, address, 256);address+=256;
    memory->memcpy(&s->conformanceVersion, address, 4);address+=4;
    s->denormBehaviorIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->roundingModeIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->maxUpdateAfterBindDescriptorsInAllPools = (uint32_t)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->robustBufferAccessUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->quadDivergentImplicitLod = (VkBool32)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageUpdateAfterBindResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->supportedDepthResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->supportedStencilResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->independentResolveNone = (VkBool32)memory->readd(address);address+=4;
    s->independentResolve = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxSingleComponentFormats = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxImageComponentMapping = (VkBool32)memory->readd(address);address+=4;
    s->maxTimelineSemaphoreValueDifference = (uint64_t)memory->readq(address);address+=8;
    s->framebufferIntegerColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan12Properties::write(KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->driverID);address+=4;
    memory->memcpy(address, s->driverName, 256); address+=256;
    memory->memcpy(address, s->driverInfo, 256); address+=256;
    memory->memcpy(address, &s->conformanceVersion, 4); address+=4;
    memory->writed(address, s->denormBehaviorIndependence);address+=4;
    memory->writed(address, s->roundingModeIndependence);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat16);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat32);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat16);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat32);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat16);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat32);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat64);address+=4;
    memory->writed(address, s->maxUpdateAfterBindDescriptorsInAllPools);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->robustBufferAccessUpdateAfterBind);address+=4;
    memory->writed(address, s->quadDivergentImplicitLod);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->maxPerStageUpdateAfterBindResources);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->supportedDepthResolveModes);address+=4;
    memory->writed(address, s->supportedStencilResolveModes);address+=4;
    memory->writed(address, s->independentResolveNone);address+=4;
    memory->writed(address, s->independentResolve);address+=4;
    memory->writed(address, s->filterMinmaxSingleComponentFormats);address+=4;
    memory->writed(address, s->filterMinmaxImageComponentMapping);address+=4;
    memory->writeq(address, s->maxTimelineSemaphoreValueDifference);address+=8;
    memory->writed(address, s->framebufferIntegerColorSampleCounts);address+=4;
}
void MarshalVkPipelineCompilerControlCreateInfoAMD::read(KMemory* memory, U32 address, VkPipelineCompilerControlCreateInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->compilerControlFlags = (VkPipelineCompilerControlFlagsAMD)memory->readd(address);address+=4;
}
void MarshalVkPipelineCompilerControlCreateInfoAMD::write(KMemory* memory, U32 address, VkPipelineCompilerControlCreateInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->compilerControlFlags);address+=4;
}
void MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::read(KMemory* memory, U32 address, VkPhysicalDeviceCoherentMemoryFeaturesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->deviceCoherentMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::write(KMemory* memory, U32 address, VkPhysicalDeviceCoherentMemoryFeaturesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->deviceCoherentMemory);address+=4;
}
void MarshalVkPhysicalDeviceToolPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceToolPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->version, address, 256);address+=256;
    s->purposes = (VkToolPurposeFlagsEXT)memory->readd(address);address+=4;
    memory->memcpy(&s->description, address, 256);address+=256;
    memory->memcpy(&s->layer, address, 256);address+=256;
}
void MarshalVkPhysicalDeviceToolPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceToolPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->version, 256); address+=256;
    memory->writed(address, s->purposes);address+=4;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->memcpy(address, s->layer, 256); address+=256;
}
void MarshalVkSamplerCustomBorderColorCreateInfoEXT::read(KMemory* memory, U32 address, VkSamplerCustomBorderColorCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->customBorderColor, address, 16);address+=16;
    s->format = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkSamplerCustomBorderColorCreateInfoEXT::write(KMemory* memory, U32 address, VkSamplerCustomBorderColorCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->customBorderColor, 16); address+=16;
    memory->writed(address, s->format);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxCustomBorderColorSamplers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxCustomBorderColorSamplers);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->customBorderColors = (VkBool32)memory->readd(address);address+=4;
    s->customBorderColorWithoutFormat = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->customBorderColors);address+=4;
    memory->writed(address, s->customBorderColorWithoutFormat);address+=4;
}
void MarshalVkAccelerationStructureGeometryTrianglesDataKHR::read(KMemory* memory, U32 address, VkAccelerationStructureGeometryTrianglesDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexFormat = (VkFormat)memory->readd(address);address+=4;
    s->vertexData.deviceAddress = memory->readq(address);address+=8;
    s->vertexStride = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxVertex = (uint32_t)memory->readd(address);address+=4;
    s->indexType = (VkIndexType)memory->readd(address);address+=4;
    s->indexData.deviceAddress = memory->readq(address);address+=8;
    s->transformData.deviceAddress = memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryTrianglesDataKHR::write(KMemory* memory, U32 address, VkAccelerationStructureGeometryTrianglesDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->vertexFormat);address+=4;
    memory->writeq(address, s->vertexData.deviceAddress);address+=8;
    memory->writeq(address, s->vertexStride);address+=8;
    memory->writed(address, s->maxVertex);address+=4;
    memory->writed(address, s->indexType);address+=4;
    memory->writeq(address, s->indexData.deviceAddress);address+=8;
    memory->writeq(address, s->transformData.deviceAddress);address+=8;
}
void MarshalVkAccelerationStructureGeometryAabbsDataKHR::read(KMemory* memory, U32 address, VkAccelerationStructureGeometryAabbsDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->data.deviceAddress = memory->readq(address);address+=8;
    s->stride = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryAabbsDataKHR::write(KMemory* memory, U32 address, VkAccelerationStructureGeometryAabbsDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->data.deviceAddress);address+=8;
    memory->writeq(address, s->stride);address+=8;
}
void MarshalVkAccelerationStructureGeometryInstancesDataKHR::read(KMemory* memory, U32 address, VkAccelerationStructureGeometryInstancesDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->arrayOfPointers = (VkBool32)memory->readd(address);address+=4;
    s->data.deviceAddress = memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryInstancesDataKHR::write(KMemory* memory, U32 address, VkAccelerationStructureGeometryInstancesDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->arrayOfPointers);address+=4;
    memory->writeq(address, s->data.deviceAddress);address+=8;
}
void MarshalVkAccelerationStructureGeometryKHR::read(KMemory* memory, U32 address, VkAccelerationStructureGeometryKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->geometryType = (VkGeometryTypeKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->geometry, address, 52);address+=52;
    s->flags = (VkGeometryFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkAccelerationStructureGeometryKHR::write(KMemory* memory, U32 address, VkAccelerationStructureGeometryKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->geometryType);address+=4;
    memory->memcpy(address, &s->geometry, 52); address+=52;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkAccelerationStructureCreateInfoKHR::read(KMemory* memory, U32 address, VkAccelerationStructureCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->createFlags = (VkAccelerationStructureCreateFlagsKHR)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureCreateInfoKHR::write(KMemory* memory, U32 address, VkAccelerationStructureCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->createFlags);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, s->deviceAddress);address+=8;
}
void MarshalVkAccelerationStructureDeviceAddressInfoKHR::read(KMemory* memory, U32 address, VkAccelerationStructureDeviceAddressInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructure = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureDeviceAddressInfoKHR::write(KMemory* memory, U32 address, VkAccelerationStructureDeviceAddressInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
}
void MarshalVkAccelerationStructureVersionInfoKHR::read(KMemory* memory, U32 address, VkAccelerationStructureVersionInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVersionData = NULL;
    } else {
        s->pVersionData = new uint8_t[2*VK_UUID_SIZE * sizeof(uint8_t)];
        memory->memcpy((uint8_t*)s->pVersionData, paramAddress, 2*VK_UUID_SIZE * sizeof(uint8_t));
    }
}
void MarshalVkAccelerationStructureVersionInfoKHR::write(KMemory* memory, U32 address, VkAccelerationStructureVersionInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkCopyAccelerationStructureInfoKHR::read(KMemory* memory, U32 address, VkCopyAccelerationStructureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->src = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->dst = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyAccelerationStructureInfoKHR::write(KMemory* memory, U32 address, VkCopyAccelerationStructureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
void MarshalVkCopyAccelerationStructureToMemoryInfoKHR::read(KMemory* memory, U32 address, VkCopyAccelerationStructureToMemoryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->src = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->dst.deviceAddress = memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyAccelerationStructureToMemoryInfoKHR::write(KMemory* memory, U32 address, VkCopyAccelerationStructureToMemoryInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, s->dst.deviceAddress);address+=8;
    memory->writed(address, s->mode);address+=4;
}
void MarshalVkCopyMemoryToAccelerationStructureInfoKHR::read(KMemory* memory, U32 address, VkCopyMemoryToAccelerationStructureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->src.deviceAddress = memory->readq(address);address+=8;
    s->dst = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyMemoryToAccelerationStructureInfoKHR::write(KMemory* memory, U32 address, VkCopyMemoryToAccelerationStructureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->src.deviceAddress);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->extendedDynamicState = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->extendedDynamicState);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->extendedDynamicState2 = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState2LogicOp = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState2PatchControlPoints = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->extendedDynamicState2);address+=4;
    memory->writed(address, s->extendedDynamicState2LogicOp);address+=4;
    memory->writed(address, s->extendedDynamicState2PatchControlPoints);address+=4;
}
void MarshalVkRenderPassTransformBeginInfoQCOM::read(KMemory* memory, U32 address, VkRenderPassTransformBeginInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkRenderPassTransformBeginInfoQCOM::write(KMemory* memory, U32 address, VkRenderPassTransformBeginInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->transform);address+=4;
}
void MarshalVkCopyCommandTransformInfoQCOM::read(KMemory* memory, U32 address, VkCopyCommandTransformInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyCommandTransformInfoQCOM::write(KMemory* memory, U32 address, VkCopyCommandTransformInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->transform);address+=4;
}
void MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::read(KMemory* memory, U32 address, VkCommandBufferInheritanceRenderPassTransformInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->renderArea, address, 16);address+=16;
}
void MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::write(KMemory* memory, U32 address, VkCommandBufferInheritanceRenderPassTransformInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->transform);address+=4;
    memory->memcpy(address, &s->renderArea, 16); address+=16;
}
void MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceDiagnosticsConfigFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->diagnosticsConfig = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceDiagnosticsConfigFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->diagnosticsConfig);address+=4;
}
void MarshalVkDeviceDiagnosticsConfigCreateInfoNV::read(KMemory* memory, U32 address, VkDeviceDiagnosticsConfigCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkDeviceDiagnosticsConfigFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkDeviceDiagnosticsConfigCreateInfoNV::write(KMemory* memory, U32 address, VkDeviceDiagnosticsConfigCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderZeroInitializeWorkgroupMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderZeroInitializeWorkgroupMemory);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderSubgroupUniformControlFlow = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderSubgroupUniformControlFlow);address+=4;
}
void MarshalVkPhysicalDeviceRobustness2FeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceRobustness2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->robustBufferAccess2 = (VkBool32)memory->readd(address);address+=4;
    s->robustImageAccess2 = (VkBool32)memory->readd(address);address+=4;
    s->nullDescriptor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRobustness2FeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceRobustness2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->robustBufferAccess2);address+=4;
    memory->writed(address, s->robustImageAccess2);address+=4;
    memory->writed(address, s->nullDescriptor);address+=4;
}
void MarshalVkPhysicalDeviceRobustness2PropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceRobustness2PropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->robustStorageBufferAccessSizeAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->robustUniformBufferAccessSizeAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceRobustness2PropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceRobustness2PropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->robustStorageBufferAccessSizeAlignment);address+=8;
    memory->writeq(address, s->robustUniformBufferAccessSizeAlignment);address+=8;
}
void MarshalVkPhysicalDeviceImageRobustnessFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceImageRobustnessFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->robustImageAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageRobustnessFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceImageRobustnessFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->robustImageAccess);address+=4;
}
void MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->workgroupMemoryExplicitLayout = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayoutScalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayout8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayout16BitAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->workgroupMemoryExplicitLayout);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayoutScalarBlockLayout);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayout8BitAccess);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayout16BitAccess);address+=4;
}
void MarshalVkPhysicalDevice4444FormatsFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDevice4444FormatsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->formatA4R4G4B4 = (VkBool32)memory->readd(address);address+=4;
    s->formatA4B4G4R4 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice4444FormatsFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDevice4444FormatsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->formatA4R4G4B4);address+=4;
    memory->writed(address, s->formatA4B4G4R4);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::read(KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->subpassShading = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::write(KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->subpassShading);address+=4;
}
void MarshalVkBufferCopy2KHR::read(KMemory* memory, U32 address, VkBufferCopy2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->dstOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferCopy2KHR::write(KMemory* memory, U32 address, VkBufferCopy2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->srcOffset);address+=8;
    memory->writeq(address, s->dstOffset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
void MarshalVkImageCopy2KHR::read(KMemory* memory, U32 address, VkImageCopy2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkImageCopy2KHR::write(KMemory* memory, U32 address, VkImageCopy2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, &s->srcOffset, 12); address+=12;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, &s->dstOffset, 12); address+=12;
    memory->memcpy(address, &s->extent, 12); address+=12;
}
void MarshalVkImageBlit2KHR::read(KMemory* memory, U32 address, VkImageBlit2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffsets, address, 2);address+=2;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffsets, address, 2);address+=2;
}
void MarshalVkImageBlit2KHR::write(KMemory* memory, U32 address, VkImageBlit2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, s->srcOffsets, 24); address+=24;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, s->dstOffsets, 24); address+=24;
}
void MarshalVkBufferImageCopy2KHR::read(KMemory* memory, U32 address, VkBufferImageCopy2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->bufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->bufferRowLength = (uint32_t)memory->readd(address);address+=4;
    s->bufferImageHeight = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->imageSubresource, address, 16);address+=16;
    memory->memcpy(&s->imageOffset, address, 12);address+=12;
    memory->memcpy(&s->imageExtent, address, 12);address+=12;
}
void MarshalVkBufferImageCopy2KHR::write(KMemory* memory, U32 address, VkBufferImageCopy2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->bufferOffset);address+=8;
    memory->writed(address, s->bufferRowLength);address+=4;
    memory->writed(address, s->bufferImageHeight);address+=4;
    memory->memcpy(address, &s->imageSubresource, 16); address+=16;
    memory->memcpy(address, &s->imageOffset, 12); address+=12;
    memory->memcpy(address, &s->imageExtent, 12); address+=12;
}
void MarshalVkImageResolve2KHR::read(KMemory* memory, U32 address, VkImageResolve2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkImageResolve2KHR::write(KMemory* memory, U32 address, VkImageResolve2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, &s->srcOffset, 12); address+=12;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, &s->dstOffset, 12); address+=12;
    memory->memcpy(address, &s->extent, 12); address+=12;
}
void MarshalVkCopyBufferInfo2KHR::read(KMemory* memory, U32 address, VkCopyBufferInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferCopy2KHR* pRegions = new VkBufferCopy2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferCopy2KHR::read(memory, paramAddress + i*32, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyBufferInfo2KHR::write(KMemory* memory, U32 address, VkCopyBufferInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcBuffer);address+=8;
    memory->writeq(address, (U64)s->dstBuffer);address+=8;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferCopy2KHR* pRegions = new VkBufferCopy2KHR();
        MarshalVkBufferCopy2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageInfo2KHR::read(KMemory* memory, U32 address, VkCopyImageInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageCopy2KHR* pRegions = new VkImageCopy2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageCopy2KHR::read(memory, paramAddress + i*76, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageInfo2KHR::write(KMemory* memory, U32 address, VkCopyImageInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageCopy2KHR* pRegions = new VkImageCopy2KHR();
        MarshalVkImageCopy2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkBlitImageInfo2KHR::read(KMemory* memory, U32 address, VkBlitImageInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageBlit2KHR* pRegions = new VkImageBlit2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageBlit2KHR::read(memory, paramAddress + i*88, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
    s->filter = (VkFilter)memory->readd(address);address+=4;
}
void MarshalVkBlitImageInfo2KHR::write(KMemory* memory, U32 address, VkBlitImageInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageBlit2KHR* pRegions = new VkImageBlit2KHR();
        MarshalVkImageBlit2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
    memory->writed(address, s->filter);address+=4;
}
void MarshalVkCopyBufferToImageInfo2KHR::read(KMemory* memory, U32 address, VkCopyBufferToImageInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferImageCopy2KHR::read(memory, paramAddress + i*64, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyBufferToImageInfo2KHR::write(KMemory* memory, U32 address, VkCopyBufferToImageInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcBuffer);address+=8;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR();
        MarshalVkBufferImageCopy2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageToBufferInfo2KHR::read(KMemory* memory, U32 address, VkCopyImageToBufferInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferImageCopy2KHR::read(memory, paramAddress + i*64, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageToBufferInfo2KHR::write(KMemory* memory, U32 address, VkCopyImageToBufferInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstBuffer);address+=8;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferImageCopy2KHR* pRegions = new VkBufferImageCopy2KHR();
        MarshalVkBufferImageCopy2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkResolveImageInfo2KHR::read(KMemory* memory, U32 address, VkResolveImageInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageResolve2KHR* pRegions = new VkImageResolve2KHR[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageResolve2KHR::read(memory, paramAddress + i*76, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkResolveImageInfo2KHR::write(KMemory* memory, U32 address, VkResolveImageInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageResolve2KHR* pRegions = new VkImageResolve2KHR();
        MarshalVkImageResolve2KHR::read(memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
void MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderImageInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageInt64Atomics = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderImageInt64Atomics);address+=4;
    memory->writed(address, s->sparseImageInt64Atomics);address+=4;
}
void MarshalVkFragmentShadingRateAttachmentInfoKHR::read(KMemory* memory, U32 address, VkFragmentShadingRateAttachmentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFragmentShadingRateAttachment = NULL;
    } else {
        VkAttachmentReference2* pFragmentShadingRateAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pFragmentShadingRateAttachment);
        s->pFragmentShadingRateAttachment = pFragmentShadingRateAttachment;
    }
    memory->memcpy(&s->shadingRateAttachmentTexelSize, address, 8);address+=8;
}
void MarshalVkFragmentShadingRateAttachmentInfoKHR::write(KMemory* memory, U32 address, VkFragmentShadingRateAttachmentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pFragmentShadingRateAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(memory, paramAddress, pFragmentShadingRateAttachment);
        s->pFragmentShadingRateAttachment = pFragmentShadingRateAttachment;
    }
    memory->memcpy(address, &s->shadingRateAttachmentTexelSize, 8); address+=8;
}
void MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::read(KMemory* memory, U32 address, VkPipelineFragmentShadingRateStateCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->fragmentSize, address, 8);address+=8;
    memory->memcpy(&s->combinerOps, address, 2);address+=2;
}
void MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::write(KMemory* memory, U32 address, VkPipelineFragmentShadingRateStateCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->fragmentSize, 8); address+=8;
    memory->memcpy(address, s->combinerOps, 8); address+=8;
}
void MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->pipelineFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
    s->primitiveFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
    s->attachmentFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->pipelineFragmentShadingRate);address+=4;
    memory->writed(address, s->primitiveFragmentShadingRate);address+=4;
    memory->writed(address, s->attachmentFragmentShadingRate);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRatePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    memory->memcpy(&s->minFragmentShadingRateAttachmentTexelSize, address, 8);address+=8;
    memory->memcpy(&s->maxFragmentShadingRateAttachmentTexelSize, address, 8);address+=8;
    s->maxFragmentShadingRateAttachmentTexelSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
    s->primitiveFragmentShadingRateWithMultipleViewports = (VkBool32)memory->readd(address);address+=4;
    s->layeredShadingRateAttachments = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateNonTrivialCombinerOps = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxFragmentSize, address, 8);address+=8;
    s->maxFragmentSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentShadingRateCoverageSamples = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentShadingRateRasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->fragmentShadingRateWithShaderDepthStencilWrites = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithSampleMask = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithShaderSampleMask = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithConservativeRasterization = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithFragmentShaderInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithCustomSampleLocations = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateStrictMultiplyCombiner = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRatePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->memcpy(address, &s->minFragmentShadingRateAttachmentTexelSize, 8); address+=8;
    memory->memcpy(address, &s->maxFragmentShadingRateAttachmentTexelSize, 8); address+=8;
    memory->writed(address, s->maxFragmentShadingRateAttachmentTexelSizeAspectRatio);address+=4;
    memory->writed(address, s->primitiveFragmentShadingRateWithMultipleViewports);address+=4;
    memory->writed(address, s->layeredShadingRateAttachments);address+=4;
    memory->writed(address, s->fragmentShadingRateNonTrivialCombinerOps);address+=4;
    memory->memcpy(address, &s->maxFragmentSize, 8); address+=8;
    memory->writed(address, s->maxFragmentSizeAspectRatio);address+=4;
    memory->writed(address, s->maxFragmentShadingRateCoverageSamples);address+=4;
    memory->writed(address, s->maxFragmentShadingRateRasterizationSamples);address+=4;
    memory->writed(address, s->fragmentShadingRateWithShaderDepthStencilWrites);address+=4;
    memory->writed(address, s->fragmentShadingRateWithSampleMask);address+=4;
    memory->writed(address, s->fragmentShadingRateWithShaderSampleMask);address+=4;
    memory->writed(address, s->fragmentShadingRateWithConservativeRasterization);address+=4;
    memory->writed(address, s->fragmentShadingRateWithFragmentShaderInterlock);address+=4;
    memory->writed(address, s->fragmentShadingRateWithCustomSampleLocations);address+=4;
    memory->writed(address, s->fragmentShadingRateStrictMultiplyCombiner);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->sampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->fragmentSize, address, 8);address+=8;
}
void MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->sampleCounts);address+=4;
    memory->memcpy(address, &s->fragmentSize, 8); address+=8;
}
void MarshalVkPhysicalDeviceShaderTerminateInvocationFeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shaderTerminateInvocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderTerminateInvocationFeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shaderTerminateInvocation);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->fragmentShadingRateEnums = (VkBool32)memory->readd(address);address+=4;
    s->supersampleFragmentShadingRates = (VkBool32)memory->readd(address);address+=4;
    s->noInvocationFragmentShadingRates = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->fragmentShadingRateEnums);address+=4;
    memory->writed(address, s->supersampleFragmentShadingRates);address+=4;
    memory->writed(address, s->noInvocationFragmentShadingRates);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxFragmentShadingRateInvocationCount = (VkSampleCountFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxFragmentShadingRateInvocationCount);address+=4;
}
void MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::read(KMemory* memory, U32 address, VkPipelineFragmentShadingRateEnumStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->shadingRateType = (VkFragmentShadingRateTypeNV)memory->readd(address);address+=4;
    s->shadingRate = (VkFragmentShadingRateNV)memory->readd(address);address+=4;
    memory->memcpy(&s->combinerOps, address, 2);address+=2;
}
void MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::write(KMemory* memory, U32 address, VkPipelineFragmentShadingRateEnumStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->shadingRateType);address+=4;
    memory->writed(address, s->shadingRate);address+=4;
    memory->memcpy(address, s->combinerOps, 8); address+=8;
}
void MarshalVkAccelerationStructureBuildSizesInfoKHR::read(KMemory* memory, U32 address, VkAccelerationStructureBuildSizesInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->accelerationStructureSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->updateScratchSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->buildScratchSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureBuildSizesInfoKHR::write(KMemory* memory, U32 address, VkAccelerationStructureBuildSizesInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->accelerationStructureSize);address+=8;
    memory->writeq(address, s->updateScratchSize);address+=8;
    memory->writeq(address, s->buildScratchSize);address+=8;
}
void MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE::read(KMemory* memory, U32 address, VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->mutableDescriptorType = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE::write(KMemory* memory, U32 address, VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->mutableDescriptorType);address+=4;
}
void MarshalVkMutableDescriptorTypeListVALVE::read(KMemory* memory, U32 address, VkMutableDescriptorTypeListVALVE* s) {
    s->descriptorTypeCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorTypes = NULL;
    } else {
        s->pDescriptorTypes = new VkDescriptorType[(U32)s->descriptorTypeCount * sizeof(VkDescriptorType)];
        memory->memcpy((VkDescriptorType*)s->pDescriptorTypes, paramAddress, (U32)s->descriptorTypeCount * sizeof(VkDescriptorType));
    }
}
void MarshalVkMutableDescriptorTypeCreateInfoVALVE::read(KMemory* memory, U32 address, VkMutableDescriptorTypeCreateInfoVALVE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->mutableDescriptorTypeListCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMutableDescriptorTypeLists = NULL;
    } else {
        VkMutableDescriptorTypeListVALVE* pMutableDescriptorTypeLists = new VkMutableDescriptorTypeListVALVE[s->mutableDescriptorTypeListCount];
        for (U32 i = 0; i < s->mutableDescriptorTypeListCount; i++) {
            MarshalVkMutableDescriptorTypeListVALVE::read(memory, paramAddress + i*8, &pMutableDescriptorTypeLists[i]);
        }
        s->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists;
    }
}
void MarshalVkMutableDescriptorTypeCreateInfoVALVE::write(KMemory* memory, U32 address, VkMutableDescriptorTypeCreateInfoVALVE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->mutableDescriptorTypeListCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkMutableDescriptorTypeListVALVE* pMutableDescriptorTypeLists = new VkMutableDescriptorTypeListVALVE();
        MarshalVkMutableDescriptorTypeListVALVE::read(memory, paramAddress, pMutableDescriptorTypeLists);
        s->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists;
    }
}
void MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexInputDynamicState = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->vertexInputDynamicState);address+=4;
}
void MarshalVkVertexInputBindingDescription2EXT::read(KMemory* memory, U32 address, VkVertexInputBindingDescription2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
    s->divisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVertexInputBindingDescription2EXT::write(KMemory* memory, U32 address, VkVertexInputBindingDescription2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->binding);address+=4;
    memory->writed(address, s->stride);address+=4;
    memory->writed(address, s->inputRate);address+=4;
    memory->writed(address, s->divisor);address+=4;
}
void MarshalVkVertexInputAttributeDescription2EXT::read(KMemory* memory, U32 address, VkVertexInputAttributeDescription2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->location = (uint32_t)memory->readd(address);address+=4;
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVertexInputAttributeDescription2EXT::write(KMemory* memory, U32 address, VkVertexInputAttributeDescription2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->location);address+=4;
    memory->writed(address, s->binding);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->offset);address+=4;
}
void MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceColorWriteEnableFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->colorWriteEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceColorWriteEnableFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->colorWriteEnable);address+=4;
}
void MarshalVkPipelineColorWriteCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineColorWriteCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorWriteEnables = NULL;
    } else {
        s->pColorWriteEnables = new VkBool32[(U32)s->attachmentCount * sizeof(VkBool32)];
        memory->memcpy((VkBool32*)s->pColorWriteEnables, paramAddress, (U32)s->attachmentCount * sizeof(VkBool32));
    }
}
void MarshalVkPipelineColorWriteCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineColorWriteCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkMemoryBarrier2KHR::read(KMemory* memory, U32 address, VkMemoryBarrier2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
}
void MarshalVkMemoryBarrier2KHR::write(KMemory* memory, U32 address, VkMemoryBarrier2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
}
void MarshalVkImageMemoryBarrier2KHR::read(KMemory* memory, U32 address, VkImageMemoryBarrier2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageMemoryBarrier2KHR::write(KMemory* memory, U32 address, VkImageMemoryBarrier2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
    memory->writed(address, s->oldLayout);address+=4;
    memory->writed(address, s->newLayout);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
void MarshalVkBufferMemoryBarrier2KHR::read(KMemory* memory, U32 address, VkBufferMemoryBarrier2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2KHR)memory->readq(address);address+=8;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryBarrier2KHR::write(KMemory* memory, U32 address, VkBufferMemoryBarrier2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
void MarshalVkDependencyInfoKHR::read(KMemory* memory, U32 address, VkDependencyInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
    s->memoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMemoryBarriers = NULL;
    } else {
        VkMemoryBarrier2KHR* pMemoryBarriers = new VkMemoryBarrier2KHR[s->memoryBarrierCount];
        for (U32 i = 0; i < s->memoryBarrierCount; i++) {
            MarshalVkMemoryBarrier2KHR::read(memory, paramAddress + i*40, &pMemoryBarriers[i]);
        }
        s->pMemoryBarriers = pMemoryBarriers;
    }
    s->bufferMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferMemoryBarriers = NULL;
    } else {
        VkBufferMemoryBarrier2KHR* pBufferMemoryBarriers = new VkBufferMemoryBarrier2KHR[s->bufferMemoryBarrierCount];
        for (U32 i = 0; i < s->bufferMemoryBarrierCount; i++) {
            MarshalVkBufferMemoryBarrier2KHR::read(memory, paramAddress + i*72, &pBufferMemoryBarriers[i]);
        }
        s->pBufferMemoryBarriers = pBufferMemoryBarriers;
    }
    s->imageMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageMemoryBarriers = NULL;
    } else {
        VkImageMemoryBarrier2KHR* pImageMemoryBarriers = new VkImageMemoryBarrier2KHR[s->imageMemoryBarrierCount];
        for (U32 i = 0; i < s->imageMemoryBarrierCount; i++) {
            MarshalVkImageMemoryBarrier2KHR::read(memory, paramAddress + i*84, &pImageMemoryBarriers[i]);
        }
        s->pImageMemoryBarriers = pImageMemoryBarriers;
    }
}
void MarshalVkDependencyInfoKHR::write(KMemory* memory, U32 address, VkDependencyInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->dependencyFlags);address+=4;
    memory->writed(address, s->memoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkMemoryBarrier2KHR* pMemoryBarriers = new VkMemoryBarrier2KHR();
        MarshalVkMemoryBarrier2KHR::read(memory, paramAddress, pMemoryBarriers);
        s->pMemoryBarriers = pMemoryBarriers;
    }
    memory->writed(address, s->bufferMemoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferMemoryBarrier2KHR* pBufferMemoryBarriers = new VkBufferMemoryBarrier2KHR();
        MarshalVkBufferMemoryBarrier2KHR::read(memory, paramAddress, pBufferMemoryBarriers);
        s->pBufferMemoryBarriers = pBufferMemoryBarriers;
    }
    memory->writed(address, s->imageMemoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageMemoryBarrier2KHR* pImageMemoryBarriers = new VkImageMemoryBarrier2KHR();
        MarshalVkImageMemoryBarrier2KHR::read(memory, paramAddress, pImageMemoryBarriers);
        s->pImageMemoryBarriers = pImageMemoryBarriers;
    }
}
void MarshalVkSemaphoreSubmitInfoKHR::read(KMemory* memory, U32 address, VkSemaphoreSubmitInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->value = (uint64_t)memory->readq(address);address+=8;
    s->stageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
    s->deviceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSemaphoreSubmitInfoKHR::write(KMemory* memory, U32 address, VkSemaphoreSubmitInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, s->value);address+=8;
    memory->writeq(address, s->stageMask);address+=8;
    memory->writed(address, s->deviceIndex);address+=4;
}
void MarshalVkCommandBufferSubmitInfoKHR::read(KMemory* memory, U32 address, VkCommandBufferSubmitInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->commandBuffer = (VkCommandBuffer)getVulkanPtr(memory, memory->readd(address));address+=4;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferSubmitInfoKHR::write(KMemory* memory, U32 address, VkCommandBufferSubmitInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    kpanic("VkCommandBufferSubmitInfoKHR.commandBuffer did not marshal write correctly");
    memory->writed(address, s->deviceMask);address+=4;
}
void MarshalVkSubmitInfo2KHR::read(KMemory* memory, U32 address, VkSubmitInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkSubmitFlagsKHR)memory->readd(address);address+=4;
    s->waitSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreInfos = NULL;
    } else {
        VkSemaphoreSubmitInfoKHR* pWaitSemaphoreInfos = new VkSemaphoreSubmitInfoKHR[s->waitSemaphoreInfoCount];
        for (U32 i = 0; i < s->waitSemaphoreInfoCount; i++) {
            MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress + i*36, &pWaitSemaphoreInfos[i]);
        }
        s->pWaitSemaphoreInfos = pWaitSemaphoreInfos;
    }
    s->commandBufferInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBufferInfos = NULL;
    } else {
        VkCommandBufferSubmitInfoKHR* pCommandBufferInfos = new VkCommandBufferSubmitInfoKHR[s->commandBufferInfoCount];
        for (U32 i = 0; i < s->commandBufferInfoCount; i++) {
            MarshalVkCommandBufferSubmitInfoKHR::read(memory, paramAddress + i*16, &pCommandBufferInfos[i]);
        }
        s->pCommandBufferInfos = pCommandBufferInfos;
    }
    s->signalSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreInfos = NULL;
    } else {
        VkSemaphoreSubmitInfoKHR* pSignalSemaphoreInfos = new VkSemaphoreSubmitInfoKHR[s->signalSemaphoreInfoCount];
        for (U32 i = 0; i < s->signalSemaphoreInfoCount; i++) {
            MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress + i*36, &pSignalSemaphoreInfos[i]);
        }
        s->pSignalSemaphoreInfos = pSignalSemaphoreInfos;
    }
}
void MarshalVkSubmitInfo2KHR::write(KMemory* memory, U32 address, VkSubmitInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->waitSemaphoreInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSemaphoreSubmitInfoKHR* pWaitSemaphoreInfos = new VkSemaphoreSubmitInfoKHR();
        MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress, pWaitSemaphoreInfos);
        s->pWaitSemaphoreInfos = pWaitSemaphoreInfos;
    }
    memory->writed(address, s->commandBufferInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCommandBufferSubmitInfoKHR* pCommandBufferInfos = new VkCommandBufferSubmitInfoKHR();
        MarshalVkCommandBufferSubmitInfoKHR::read(memory, paramAddress, pCommandBufferInfos);
        s->pCommandBufferInfos = pCommandBufferInfos;
    }
    memory->writed(address, s->signalSemaphoreInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSemaphoreSubmitInfoKHR* pSignalSemaphoreInfos = new VkSemaphoreSubmitInfoKHR();
        MarshalVkSemaphoreSubmitInfoKHR::read(memory, paramAddress, pSignalSemaphoreInfos);
        s->pSignalSemaphoreInfos = pSignalSemaphoreInfos;
    }
}
void MarshalVkQueueFamilyCheckpointProperties2NV::read(KMemory* memory, U32 address, VkQueueFamilyCheckpointProperties2NV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->checkpointExecutionStageMask = (VkPipelineStageFlags2KHR)memory->readq(address);address+=8;
}
void MarshalVkQueueFamilyCheckpointProperties2NV::write(KMemory* memory, U32 address, VkQueueFamilyCheckpointProperties2NV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->checkpointExecutionStageMask);address+=8;
}
void MarshalVkCheckpointData2NV::write(KMemory* memory, U32 address, VkCheckpointData2NV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->stage);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPhysicalDeviceSynchronization2FeaturesKHR::read(KMemory* memory, U32 address, VkPhysicalDeviceSynchronization2FeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->synchronization2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSynchronization2FeaturesKHR::write(KMemory* memory, U32 address, VkPhysicalDeviceSynchronization2FeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->synchronization2);address+=4;
}
void MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceInheritedViewportScissorFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->inheritedViewportScissor2D = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceInheritedViewportScissorFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->inheritedViewportScissor2D);address+=4;
}
void MarshalVkCommandBufferInheritanceViewportScissorInfoNV::read(KMemory* memory, U32 address, VkCommandBufferInheritanceViewportScissorInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->viewportScissor2D = (VkBool32)memory->readd(address);address+=4;
    s->viewportDepthCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportDepths = NULL;
    } else {
        VkViewport* pViewportDepths = new VkViewport();
        MarshalVkViewport::read(memory, paramAddress, pViewportDepths);
        s->pViewportDepths = pViewportDepths;
    }
}
void MarshalVkCommandBufferInheritanceViewportScissorInfoNV::write(KMemory* memory, U32 address, VkCommandBufferInheritanceViewportScissorInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->viewportScissor2D);address+=4;
    memory->writed(address, s->viewportDepthCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewport* pViewportDepths = new VkViewport();
        MarshalVkViewport::read(memory, paramAddress, pViewportDepths);
        s->pViewportDepths = pViewportDepths;
    }
}
void MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->ycbcr2plane444Formats = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->ycbcr2plane444Formats);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->provokingVertexLast = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackPreservesProvokingVertex = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->provokingVertexLast);address+=4;
    memory->writed(address, s->transformFeedbackPreservesProvokingVertex);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->provokingVertexModePerPipeline = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackPreservesTriangleFanProvokingVertex = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->provokingVertexModePerPipeline);address+=4;
    memory->writed(address, s->transformFeedbackPreservesTriangleFanProvokingVertex);address+=4;
}
void MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::read(KMemory* memory, U32 address, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->provokingVertexMode = (VkProvokingVertexModeEXT)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::write(KMemory* memory, U32 address, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->provokingVertexMode);address+=4;
}
void MarshalVkCuFunctionCreateInfoNVX::read(KMemory* memory, U32 address, VkCuFunctionCreateInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->module = (VkCuModuleNVX)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen * sizeof(char)];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen * sizeof(char));
    }
}
void MarshalVkCuFunctionCreateInfoNVX::write(KMemory* memory, U32 address, VkCuFunctionCreateInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, (U64)s->module);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
void MarshalVkPhysicalDeviceDrmPropertiesEXT::read(KMemory* memory, U32 address, VkPhysicalDeviceDrmPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->hasPrimary = (VkBool32)memory->readd(address);address+=4;
    s->hasRender = (VkBool32)memory->readd(address);address+=4;
    s->primaryMajor = (int64_t)memory->readq(address);address+=8;
    s->primaryMinor = (int64_t)memory->readq(address);address+=8;
    s->renderMajor = (int64_t)memory->readq(address);address+=8;
    s->renderMinor = (int64_t)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceDrmPropertiesEXT::write(KMemory* memory, U32 address, VkPhysicalDeviceDrmPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->hasPrimary);address+=4;
    memory->writed(address, s->hasRender);address+=4;
    memory->writeq(address, s->primaryMajor);address+=8;
    memory->writeq(address, s->primaryMinor);address+=8;
    memory->writeq(address, s->renderMajor);address+=8;
    memory->writeq(address, s->renderMinor);address+=8;
}
void MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::read(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->rayTracingMotionBlur = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingMotionBlurPipelineTraceRaysIndirect = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::write(KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->rayTracingMotionBlur);address+=4;
    memory->writed(address, s->rayTracingMotionBlurPipelineTraceRaysIndirect);address+=4;
}
void MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::read(KMemory* memory, U32 address, VkAccelerationStructureGeometryMotionTrianglesDataNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->vertexData.deviceAddress = memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::write(KMemory* memory, U32 address, VkAccelerationStructureGeometryMotionTrianglesDataNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writeq(address, s->vertexData.deviceAddress);address+=8;
}
void MarshalVkAccelerationStructureMotionInfoNV::read(KMemory* memory, U32 address, VkAccelerationStructureMotionInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->maxInstances = (uint32_t)memory->readd(address);address+=4;
    s->flags = (VkAccelerationStructureMotionInfoFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkAccelerationStructureMotionInfoNV::write(KMemory* memory, U32 address, VkAccelerationStructureMotionInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(memory, paramAddress, s->pNext);
        delete s->pNext;
    }
    memory->writed(address, s->maxInstances);address+=4;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkDrmFormatModifierPropertiesEXT::read(KMemory* memory, U32 address, VkDrmFormatModifierPropertiesEXT* s) {
    s->drmFormatModifier = (uint64_t)memory->readq(address);address+=8;
    s->drmFormatModifierPlaneCount = (uint32_t)memory->readd(address);address+=4;
    s->drmFormatModifierTilingFeatures = (VkFormatFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFeatures::read(KMemory* memory, U32 address, VkPhysicalDeviceFeatures* s) {
    s->robustBufferAccess = (VkBool32)memory->readd(address);address+=4;
    s->fullDrawIndexUint32 = (VkBool32)memory->readd(address);address+=4;
    s->imageCubeArray = (VkBool32)memory->readd(address);address+=4;
    s->independentBlend = (VkBool32)memory->readd(address);address+=4;
    s->geometryShader = (VkBool32)memory->readd(address);address+=4;
    s->tessellationShader = (VkBool32)memory->readd(address);address+=4;
    s->sampleRateShading = (VkBool32)memory->readd(address);address+=4;
    s->dualSrcBlend = (VkBool32)memory->readd(address);address+=4;
    s->logicOp = (VkBool32)memory->readd(address);address+=4;
    s->multiDrawIndirect = (VkBool32)memory->readd(address);address+=4;
    s->drawIndirectFirstInstance = (VkBool32)memory->readd(address);address+=4;
    s->depthClamp = (VkBool32)memory->readd(address);address+=4;
    s->depthBiasClamp = (VkBool32)memory->readd(address);address+=4;
    s->fillModeNonSolid = (VkBool32)memory->readd(address);address+=4;
    s->depthBounds = (VkBool32)memory->readd(address);address+=4;
    s->wideLines = (VkBool32)memory->readd(address);address+=4;
    s->largePoints = (VkBool32)memory->readd(address);address+=4;
    s->alphaToOne = (VkBool32)memory->readd(address);address+=4;
    s->multiViewport = (VkBool32)memory->readd(address);address+=4;
    s->samplerAnisotropy = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionETC2 = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionASTC_LDR = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionBC = (VkBool32)memory->readd(address);address+=4;
    s->occlusionQueryPrecise = (VkBool32)memory->readd(address);address+=4;
    s->pipelineStatisticsQuery = (VkBool32)memory->readd(address);address+=4;
    s->vertexPipelineStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
    s->fragmentStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderTessellationAndGeometryPointSize = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageGatherExtended = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageExtendedFormats = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageMultisample = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageReadWithoutFormat = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageWriteWithoutFormat = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderClipDistance = (VkBool32)memory->readd(address);address+=4;
    s->shaderCullDistance = (VkBool32)memory->readd(address);address+=4;
    s->shaderFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderResourceResidency = (VkBool32)memory->readd(address);address+=4;
    s->shaderResourceMinLod = (VkBool32)memory->readd(address);address+=4;
    s->sparseBinding = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyBuffer = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyImage2D = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyImage3D = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency2Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency4Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency8Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency16Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyAliased = (VkBool32)memory->readd(address);address+=4;
    s->variableMultisampleRate = (VkBool32)memory->readd(address);address+=4;
    s->inheritedQueries = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkFramebufferAttachmentImageInfo::read(KMemory* memory, U32 address, VkFramebufferAttachmentImageInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(memory, paramAddress);
    }
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
    s->viewFormatCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewFormats = NULL;
    } else {
        s->pViewFormats = new VkFormat[(U32)s->viewFormatCount * sizeof(VkFormat)];
        memory->memcpy((VkFormat*)s->pViewFormats, paramAddress, (U32)s->viewFormatCount * sizeof(VkFormat));
    }
}
void MarshalVkPresentRegionKHR::read(KMemory* memory, U32 address, VkPresentRegionKHR* s) {
    s->rectangleCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRectangles = NULL;
    } else {
        s->pRectangles = new VkRectLayerKHR[(U32)s->rectangleCount * sizeof(VkRectLayerKHR)];
        memory->memcpy((VkRectLayerKHR*)s->pRectangles, paramAddress, (U32)s->rectangleCount * sizeof(VkRectLayerKHR));
    }
}
void MarshalVkPhysicalDeviceLimits::read(KMemory* memory, U32 address, VkPhysicalDeviceLimits* s) {
    s->maxImageDimension1D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimension2D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimension3D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimensionCube = (uint32_t)memory->readd(address);address+=4;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxTexelBufferElements = (uint32_t)memory->readd(address);address+=4;
    s->maxUniformBufferRange = (uint32_t)memory->readd(address);address+=4;
    s->maxStorageBufferRange = (uint32_t)memory->readd(address);address+=4;
    s->maxPushConstantsSize = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationCount = (uint32_t)memory->readd(address);address+=4;
    s->maxSamplerAllocationCount = (uint32_t)memory->readd(address);address+=4;
    s->bufferImageGranularity = (VkDeviceSize)memory->readq(address);address+=8;
    s->sparseAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxBoundDescriptorSets = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputAttributes = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputAttributeOffset = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputBindingStride = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationGenerationLevel = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationPatchSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerVertexInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerPatchOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationEvaluationInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationEvaluationOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryShaderInvocations = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryOutputVertices = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentOutputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentDualSrcAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentCombinedOutputResources = (uint32_t)memory->readd(address);address+=4;
    s->maxComputeSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxComputeWorkGroupCount, address, 3);address+=3;
    s->maxComputeWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxComputeWorkGroupSize, address, 3);address+=3;
    s->subPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->subTexelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->mipmapPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->maxDrawIndexedIndexValue = (uint32_t)memory->readd(address);address+=4;
    s->maxDrawIndirectCount = (uint32_t)memory->readd(address);address+=4;
    MarshalFloat maxSamplerLodBiasFloat;
    maxSamplerLodBiasFloat.i = memory->readd(address);address+=4;
    s->maxSamplerLodBias = maxSamplerLodBiasFloat.f;
    MarshalFloat maxSamplerAnisotropyFloat;
    maxSamplerAnisotropyFloat.i = memory->readd(address);address+=4;
    s->maxSamplerAnisotropy = maxSamplerAnisotropyFloat.f;
    s->maxViewports = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxViewportDimensions, address, 2);address+=2;
    memory->memcpy(&s->viewportBoundsRange, address, 2);address+=2;
    s->viewportSubPixelBits = (uint32_t)memory->readd(address);address+=4;
    s->minMemoryMapAlignment = (size_t)memory->readd(address);address+=4;
    s->minTexelBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minUniformBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minStorageBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minTexelOffset = (int32_t)memory->readd(address);address+=4;
    s->maxTexelOffset = (uint32_t)memory->readd(address);address+=4;
    s->minTexelGatherOffset = (int32_t)memory->readd(address);address+=4;
    s->maxTexelGatherOffset = (uint32_t)memory->readd(address);address+=4;
    MarshalFloat minInterpolationOffsetFloat;
    minInterpolationOffsetFloat.i = memory->readd(address);address+=4;
    s->minInterpolationOffset = minInterpolationOffsetFloat.f;
    MarshalFloat maxInterpolationOffsetFloat;
    maxInterpolationOffsetFloat.i = memory->readd(address);address+=4;
    s->maxInterpolationOffset = maxInterpolationOffsetFloat.f;
    s->subPixelInterpolationOffsetBits = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferWidth = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferHeight = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferLayers = (uint32_t)memory->readd(address);address+=4;
    s->framebufferColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferNoAttachmentsSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->maxColorAttachments = (uint32_t)memory->readd(address);address+=4;
    s->sampledImageColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageIntegerSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->storageImageSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->maxSampleMaskWords = (uint32_t)memory->readd(address);address+=4;
    s->timestampComputeAndGraphics = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat timestampPeriodFloat;
    timestampPeriodFloat.i = memory->readd(address);address+=4;
    s->timestampPeriod = timestampPeriodFloat.f;
    s->maxClipDistances = (uint32_t)memory->readd(address);address+=4;
    s->maxCullDistances = (uint32_t)memory->readd(address);address+=4;
    s->maxCombinedClipAndCullDistances = (uint32_t)memory->readd(address);address+=4;
    s->discreteQueuePriorities = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->pointSizeRange, address, 2);address+=2;
    memory->memcpy(&s->lineWidthRange, address, 2);address+=2;
    MarshalFloat pointSizeGranularityFloat;
    pointSizeGranularityFloat.i = memory->readd(address);address+=4;
    s->pointSizeGranularity = pointSizeGranularityFloat.f;
    MarshalFloat lineWidthGranularityFloat;
    lineWidthGranularityFloat.i = memory->readd(address);address+=4;
    s->lineWidthGranularity = lineWidthGranularityFloat.f;
    s->strictLines = (VkBool32)memory->readd(address);address+=4;
    s->standardSampleLocations = (VkBool32)memory->readd(address);address+=4;
    s->optimalBufferCopyOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->optimalBufferCopyRowPitchAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->nonCoherentAtomSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPresentTimeGOOGLE::read(KMemory* memory, U32 address, VkPresentTimeGOOGLE* s) {
    s->presentID = (uint32_t)memory->readd(address);address+=4;
    s->desiredPresentTime = (uint64_t)memory->readq(address);address+=8;
}
#endif

