// DON'T MODIFY, this is autogenerated
#include "boxedwine.h"
#ifdef BOXEDWINE_VULKAN
#include <SDL.h>
#include <SDL_vulkan.h>
#define VK_NO_PROTOTYPES
#include "vk/vulkan.h"
#include "vk/vulkan_core.h"
#include "vk_host.h"

#include "vk_host_marshal.h"

void MarshalVkBaseOutStructure::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBaseOutStructure* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
}
void MarshalVkBaseOutStructure::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBaseOutStructure* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
}
MarshalVkBaseOutStructure::~MarshalVkBaseOutStructure() {
    delete s.pNext;
}
void MarshalVkOffset2D::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOffset2D* s) {
    s->x = (int32_t)memory->readd(address);address+=4;
    s->y = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkExtent2D::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExtent2D* s) {
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkExtent2D::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExtent2D* s) {
    memory->writed(address, s->width);address+=4;
    memory->writed(address, s->height);address+=4;
}
void MarshalVkViewport::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkViewport* s) {
    MarshalFloat xFloat;
    xFloat.i = memory->readd(address);address+=4;
    s->x = xFloat.f;
    MarshalFloat yFloat;
    yFloat.i = memory->readd(address);address+=4;
    s->y = yFloat.f;
    MarshalFloat widthFloat;
    widthFloat.i = memory->readd(address);address+=4;
    s->width = widthFloat.f;
    MarshalFloat heightFloat;
    heightFloat.i = memory->readd(address);address+=4;
    s->height = heightFloat.f;
    MarshalFloat minDepthFloat;
    minDepthFloat.i = memory->readd(address);address+=4;
    s->minDepth = minDepthFloat.f;
    MarshalFloat maxDepthFloat;
    maxDepthFloat.i = memory->readd(address);address+=4;
    s->maxDepth = maxDepthFloat.f;
}
void MarshalVkRect2D::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRect2D* s) {
    memory->memcpy(&s->offset, address, 8);address+=8;
    memory->memcpy(&s->extent, address, 8);address+=8;
}
void MarshalVkRect2D::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRect2D* s) {
    memory->memcpy(address, &s->offset, 8); address+=8;
    memory->memcpy(address, &s->extent, 8); address+=8;
}
void MarshalVkClearRect::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkClearRect* s) {
    memory->memcpy(&s->rect, address, 16);address+=16;
    s->baseArrayLayer = (uint32_t)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkComponentMapping::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkComponentMapping* s) {
    s->r = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->g = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->b = (VkComponentSwizzle)memory->readd(address);address+=4;
    s->a = (VkComponentSwizzle)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
    s->apiVersion = (uint32_t)memory->readd(address);address+=4;
    s->driverVersion = (uint32_t)memory->readd(address);address+=4;
    s->vendorID = (uint32_t)memory->readd(address);address+=4;
    s->deviceID = (uint32_t)memory->readd(address);address+=4;
    s->deviceType = (VkPhysicalDeviceType)memory->readd(address);address+=4;
    memory->memcpy(&s->deviceName, address, 256);address+=256;
    memory->memcpy(&s->pipelineCacheUUID, address, 16);address+=16;
    MarshalVkPhysicalDeviceLimits::read(pBoxedInfo, memory, address, &s->limits); address+=456;
    memory->memcpy(&s->sparseProperties, address, 20);address+=20;
}
void MarshalVkPhysicalDeviceProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProperties* s) {
    memory->writed(address, s->apiVersion);address+=4;
    memory->writed(address, s->driverVersion);address+=4;
    memory->writed(address, s->vendorID);address+=4;
    memory->writed(address, s->deviceID);address+=4;
    memory->writed(address, s->deviceType);address+=4;
    memory->memcpy(address, s->deviceName, 256); address+=256;
    memory->memcpy(address, s->pipelineCacheUUID, 16); address+=16;
    memory->memcpy(address, &s->limits, 456); address+=456;
    memory->memcpy(address, &s->sparseProperties, 20); address+=20;
}
void MarshalVkExtensionProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExtensionProperties* s) {
    memory->memcpy(&s->extensionName, address, 256);address+=256;
    s->specVersion = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkExtensionProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExtensionProperties* s) {
    memory->memcpy(address, s->extensionName, 256); address+=256;
    memory->writed(address, s->specVersion);address+=4;
}
void MarshalVkLayerProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLayerProperties* s) {
    memory->memcpy(address, s->layerName, 256); address+=256;
    memory->writed(address, s->specVersion);address+=4;
    memory->writed(address, s->implementationVersion);address+=4;
    memory->memcpy(address, s->description, 256); address+=256;
}
void MarshalVkApplicationInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkApplicationInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pApplicationName = NULL;
    } else {
        U32 pApplicationNameLen = memory->strlen(paramAddress)+1;
        s->pApplicationName = new char[pApplicationNameLen];
        memory->memcpy((char*)s->pApplicationName, paramAddress, pApplicationNameLen);
    }
    s->applicationVersion = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEngineName = NULL;
    } else {
        U32 pEngineNameLen = memory->strlen(paramAddress)+1;
        s->pEngineName = new char[pEngineNameLen];
        memory->memcpy((char*)s->pEngineName, paramAddress, pEngineNameLen);
    }
    s->engineVersion = (uint32_t)memory->readd(address);address+=4;
    s->apiVersion = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkApplicationInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkApplicationInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->applicationVersion);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->engineVersion);address+=4;
    memory->writed(address, s->apiVersion);address+=4;
}
MarshalVkApplicationInfo::~MarshalVkApplicationInfo() {
    delete s.pNext;
    delete[] s.pApplicationName;
    delete[] s.pEngineName;
}
void MarshalVkDeviceQueueCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->queueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueuePriorities = NULL;
    } else {
        s->pQueuePriorities = new float[(U32)s->queueCount];
        memory->memcpy((float*)s->pQueuePriorities, paramAddress, (U32)s->queueCount);
    }
}
void MarshalVkDeviceQueueCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->queueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDeviceQueueCreateInfo::~MarshalVkDeviceQueueCreateInfo() {
    delete s.pNext;
    delete[] s.pQueuePriorities;
}
void MarshalVkDeviceCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDeviceCreateFlags)memory->readd(address);address+=4;
    s->queueCreateInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueCreateInfos = NULL;
    } else {
        VkDeviceQueueCreateInfo* pQueueCreateInfos = new VkDeviceQueueCreateInfo[s->queueCreateInfoCount];
        for (U32 i = 0; i < s->queueCreateInfoCount; i++) {
            MarshalVkDeviceQueueCreateInfo::read(pBoxedInfo, memory, paramAddress + i*24, &pQueueCreateInfos[i]);
        }
        s->pQueueCreateInfos = pQueueCreateInfos;
    }
    s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledLayerNames = NULL;
    } else {
        char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
        for (int i=0;i<(int)s->enabledLayerCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledLayerNames[i] = new char[size];
            memory->memcpy(ppEnabledLayerNames[i], itemAddress, size);
        }
        s->ppEnabledLayerNames = ppEnabledLayerNames;
    }
    s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledExtensionNames = NULL;
    } else {
        char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
        for (int i=0;i<(int)s->enabledExtensionCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledExtensionNames[i] = new char[size];
            memory->memcpy(ppEnabledExtensionNames[i], itemAddress, size);
        }
        s->ppEnabledExtensionNames = ppEnabledExtensionNames;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEnabledFeatures = NULL;
    } else {
        VkPhysicalDeviceFeatures* pEnabledFeatures = new VkPhysicalDeviceFeatures();
        MarshalVkPhysicalDeviceFeatures::read(pBoxedInfo, memory, paramAddress, pEnabledFeatures);
        s->pEnabledFeatures = pEnabledFeatures;
    }
}
void MarshalVkDeviceCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueCreateInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDeviceQueueCreateInfo* pQueueCreateInfos = new VkDeviceQueueCreateInfo();
        MarshalVkDeviceQueueCreateInfo::read(pBoxedInfo, memory, paramAddress, pQueueCreateInfos);
        s->pQueueCreateInfos = pQueueCreateInfos;
    }
    memory->writed(address, s->enabledLayerCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->enabledExtensionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPhysicalDeviceFeatures* pEnabledFeatures = new VkPhysicalDeviceFeatures();
        MarshalVkPhysicalDeviceFeatures::read(pBoxedInfo, memory, paramAddress, pEnabledFeatures);
        s->pEnabledFeatures = pEnabledFeatures;
    }
}
MarshalVkDeviceCreateInfo::~MarshalVkDeviceCreateInfo() {
    delete s.pNext;
    delete[] s.pQueueCreateInfos;
    delete[] s.ppEnabledLayerNames;
    delete[] s.ppEnabledExtensionNames;
    delete s.pEnabledFeatures;
}
void MarshalVkInstanceCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkInstanceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkInstanceCreateFlags)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pApplicationInfo = NULL;
    } else {
        VkApplicationInfo* pApplicationInfo = new VkApplicationInfo();
        MarshalVkApplicationInfo::read(pBoxedInfo, memory, paramAddress, pApplicationInfo);
        s->pApplicationInfo = pApplicationInfo;
    }
    s->enabledLayerCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledLayerNames = NULL;
    } else {
        char** ppEnabledLayerNames = new char*[s->enabledLayerCount];
        for (int i=0;i<(int)s->enabledLayerCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledLayerNames[i] = new char[size];
            memory->memcpy(ppEnabledLayerNames[i], itemAddress, size);
        }
        s->ppEnabledLayerNames = ppEnabledLayerNames;
    }
    s->enabledExtensionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppEnabledExtensionNames = NULL;
    } else {
        char** ppEnabledExtensionNames = new char*[s->enabledExtensionCount];
        for (int i=0;i<(int)s->enabledExtensionCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            U32 size = memory->strlen(itemAddress)+1;
            ppEnabledExtensionNames[i] = new char[size];
            memory->memcpy(ppEnabledExtensionNames[i], itemAddress, size);
        }
        s->ppEnabledExtensionNames = ppEnabledExtensionNames;
    }
}
void MarshalVkInstanceCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkInstanceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkApplicationInfo* pApplicationInfo = new VkApplicationInfo();
        MarshalVkApplicationInfo::read(pBoxedInfo, memory, paramAddress, pApplicationInfo);
        s->pApplicationInfo = pApplicationInfo;
    }
    memory->writed(address, s->enabledLayerCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->enabledExtensionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkInstanceCreateInfo::~MarshalVkInstanceCreateInfo() {
    delete s.pNext;
    delete s.pApplicationInfo;
    delete[] s.ppEnabledLayerNames;
    delete[] s.ppEnabledExtensionNames;
}
void MarshalVkQueueFamilyProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyProperties* s) {
    memory->writed(address, s->queueFlags);address+=4;
    memory->writed(address, s->queueCount);address+=4;
    memory->writed(address, s->timestampValidBits);address+=4;
    memory->memcpy(address, &s->minImageTransferGranularity, 12); address+=12;
}
void MarshalVkPhysicalDeviceMemoryProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties* s) {
    s->memoryTypeCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->memoryTypes, address, 256);address+=256;
    s->memoryHeapCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->memoryHeaps, address, 192);address+=192;
}
void MarshalVkPhysicalDeviceMemoryProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties* s) {
    memory->writed(address, s->memoryTypeCount);address+=4;
    memory->memcpy(address, s->memoryTypes, 256); address+=256;
    memory->writed(address, s->memoryHeapCount);address+=4;
    memory->memcpy(address, s->memoryHeaps, 192); address+=192;
}
void MarshalVkMemoryAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->allocationSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->memoryTypeIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->allocationSize);address+=8;
    memory->writed(address, s->memoryTypeIndex);address+=4;
}
MarshalVkMemoryAllocateInfo::~MarshalVkMemoryAllocateInfo() {
    delete s.pNext;
}
void MarshalVkMemoryRequirements::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryRequirements* s) {
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->alignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->memoryTypeBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryRequirements::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryRequirements* s) {
    memory->writeq(address, s->size);address+=8;
    memory->writeq(address, s->alignment);address+=8;
    memory->writed(address, s->memoryTypeBits);address+=4;
}
void MarshalVkSparseImageFormatProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageFormatProperties* s) {
    memory->writed(address, s->aspectMask);address+=4;
    memory->memcpy(address, &s->imageGranularity, 12); address+=12;
    memory->writed(address, s->flags);address+=4;
}
void MarshalVkSparseImageMemoryRequirements::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageMemoryRequirements* s) {
    memory->memcpy(address, &s->formatProperties, 20); address+=20;
    memory->writed(address, s->imageMipTailFirstLod);address+=4;
    memory->writeq(address, s->imageMipTailSize);address+=8;
    memory->writeq(address, s->imageMipTailOffset);address+=8;
    memory->writeq(address, s->imageMipTailStride);address+=8;
}
void MarshalVkMappedMemoryRange::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMappedMemoryRange* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkMappedMemoryRange::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMappedMemoryRange* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkMappedMemoryRange::~MarshalVkMappedMemoryRange() {
    delete s.pNext;
}
void MarshalVkFormatProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties* s) {
    s->linearTilingFeatures = (VkFormatFeatureFlags)memory->readd(address);address+=4;
    s->optimalTilingFeatures = (VkFormatFeatureFlags)memory->readd(address);address+=4;
    s->bufferFeatures = (VkFormatFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkFormatProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties* s) {
    memory->writed(address, s->linearTilingFeatures);address+=4;
    memory->writed(address, s->optimalTilingFeatures);address+=4;
    memory->writed(address, s->bufferFeatures);address+=4;
}
void MarshalVkImageFormatProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatProperties* s) {
    memory->memcpy(&s->maxExtent, address, 12);address+=12;
    s->maxMipLevels = (uint32_t)memory->readd(address);address+=4;
    s->maxArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->sampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->maxResourceSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkImageFormatProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatProperties* s) {
    memory->memcpy(address, &s->maxExtent, 12); address+=12;
    memory->writed(address, s->maxMipLevels);address+=4;
    memory->writed(address, s->maxArrayLayers);address+=4;
    memory->writed(address, s->sampleCounts);address+=4;
    memory->writeq(address, s->maxResourceSize);address+=8;
}
void MarshalVkDescriptorBufferInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorBufferInfo* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->range = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkDescriptorImageInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorImageInfo* s) {
    s->sampler = (VkSampler)memory->readq(address);address+=8;
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->imageLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkWriteDescriptorSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSet* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageInfo = NULL;
    } else {
        VkDescriptorImageInfo* pImageInfo = new VkDescriptorImageInfo[s->descriptorCount];
        for (U32 i = 0; i < s->descriptorCount; i++) {
            MarshalVkDescriptorImageInfo::read(pBoxedInfo, memory, paramAddress + i*20, &pImageInfo[i]);
        }
        s->pImageInfo = pImageInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferInfo = NULL;
    } else {
        s->pBufferInfo = new VkDescriptorBufferInfo[(U32)s->descriptorCount];
        memory->memcpy((VkDescriptorBufferInfo*)s->pBufferInfo, paramAddress, (U32)s->descriptorCount * sizeof(VkDescriptorBufferInfo));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTexelBufferView = NULL;
    } else {
        s->pTexelBufferView = new VkBufferView[(U32)s->descriptorCount];
        memory->memcpy((VkBufferView*)s->pTexelBufferView, paramAddress, (U32)s->descriptorCount);
    }
}
void MarshalVkWriteDescriptorSet::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSet* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->dstSet);address+=8;
    memory->writed(address, s->dstBinding);address+=4;
    memory->writed(address, s->dstArrayElement);address+=4;
    memory->writed(address, s->descriptorCount);address+=4;
    memory->writed(address, s->descriptorType);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorImageInfo* pImageInfo = new VkDescriptorImageInfo();
        MarshalVkDescriptorImageInfo::read(pBoxedInfo, memory, paramAddress, pImageInfo);
        s->pImageInfo = pImageInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorBufferInfo* pBufferInfo = new VkDescriptorBufferInfo();
        MarshalVkDescriptorBufferInfo::read(pBoxedInfo, memory, paramAddress, pBufferInfo);
        s->pBufferInfo = pBufferInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkWriteDescriptorSet::~MarshalVkWriteDescriptorSet() {
    delete s.pNext;
    delete[] s.pImageInfo;
    delete[] s.pBufferInfo;
    delete[] s.pTexelBufferView;
}
void MarshalVkCopyDescriptorSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyDescriptorSet* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->srcBinding = (uint32_t)memory->readd(address);address+=4;
    s->srcArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->dstSet = (VkDescriptorSet)memory->readq(address);address+=8;
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCopyDescriptorSet::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyDescriptorSet* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcSet);address+=8;
    memory->writed(address, s->srcBinding);address+=4;
    memory->writed(address, s->srcArrayElement);address+=4;
    memory->writeq(address, (U64)s->dstSet);address+=8;
    memory->writed(address, s->dstBinding);address+=4;
    memory->writed(address, s->dstArrayElement);address+=4;
    memory->writed(address, s->descriptorCount);address+=4;
}
MarshalVkCopyDescriptorSet::~MarshalVkCopyDescriptorSet() {
    delete s.pNext;
}
void MarshalVkBufferUsageFlags2CreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferUsageFlags2CreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->usage = (VkBufferUsageFlags2)memory->readq(address);address+=8;
}
void MarshalVkBufferUsageFlags2CreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferUsageFlags2CreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->usage);address+=8;
}
MarshalVkBufferUsageFlags2CreateInfo::~MarshalVkBufferUsageFlags2CreateInfo() {
    delete s.pNext;
}
void MarshalVkBufferCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
    s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount);
    }
}
void MarshalVkBufferCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->sharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkBufferCreateInfo::~MarshalVkBufferCreateInfo() {
    delete s.pNext;
    delete[] s.pQueueFamilyIndices;
}
void MarshalVkBufferViewCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferViewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkBufferViewCreateFlags)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->range = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferViewCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferViewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writed(address, s->format);address+=4;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->range);address+=8;
}
MarshalVkBufferViewCreateInfo::~MarshalVkBufferViewCreateInfo() {
    delete s.pNext;
}
void MarshalVkImageSubresource::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSubresource* s) {
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
    s->mipLevel = (uint32_t)memory->readd(address);address+=4;
    s->arrayLayer = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkImageSubresourceLayers::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSubresourceLayers* s) {
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
    s->mipLevel = (uint32_t)memory->readd(address);address+=4;
    s->baseArrayLayer = (uint32_t)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkImageSubresourceRange::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSubresourceRange* s) {
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
    s->baseMipLevel = (uint32_t)memory->readd(address);address+=4;
    s->levelCount = (uint32_t)memory->readd(address);address+=4;
    s->baseArrayLayer = (uint32_t)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryBarrier::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
}
void MarshalVkMemoryBarrier::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
}
MarshalVkMemoryBarrier::~MarshalVkMemoryBarrier() {
    delete s.pNext;
}
void MarshalVkBufferMemoryBarrier::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryBarrier::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkBufferMemoryBarrier::~MarshalVkBufferMemoryBarrier() {
    delete s.pNext;
}
void MarshalVkImageMemoryBarrier::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryBarrier* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageMemoryBarrier::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryBarrier* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->oldLayout);address+=4;
    memory->writed(address, s->newLayout);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
MarshalVkImageMemoryBarrier::~MarshalVkImageMemoryBarrier() {
    delete s.pNext;
}
void MarshalVkImageCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
    s->imageType = (VkImageType)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    memory->memcpy(&s->extent, address, 12);address+=12;
    s->mipLevels = (uint32_t)memory->readd(address);address+=4;
    s->arrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->sharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount);
    }
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkImageCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->imageType);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->memcpy(address, &s->extent, 12); address+=12;
    memory->writed(address, s->mipLevels);address+=4;
    memory->writed(address, s->arrayLayers);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->tiling);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->sharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->initialLayout);address+=4;
}
MarshalVkImageCreateInfo::~MarshalVkImageCreateInfo() {
    delete s.pNext;
    delete[] s.pQueueFamilyIndices;
}
void MarshalVkSubresourceLayout::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceLayout* s) {
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->rowPitch = (VkDeviceSize)memory->readq(address);address+=8;
    s->arrayPitch = (VkDeviceSize)memory->readq(address);address+=8;
    s->depthPitch = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkSubresourceLayout::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceLayout* s) {
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writeq(address, s->rowPitch);address+=8;
    memory->writeq(address, s->arrayPitch);address+=8;
    memory->writeq(address, s->depthPitch);address+=8;
}
void MarshalVkImageViewCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkImageViewCreateFlags)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    s->viewType = (VkImageViewType)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    MarshalVkComponentMapping::read(pBoxedInfo, memory, address, &s->components); address+=16;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageViewCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writed(address, s->viewType);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->memcpy(address, &s->components, 16); address+=16;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
MarshalVkImageViewCreateInfo::~MarshalVkImageViewCreateInfo() {
    delete s.pNext;
}
void MarshalVkBufferCopy::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCopy* s) {
    s->srcOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->dstOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkSparseBufferMemoryBindInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseBufferMemoryBindInfo* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseMemoryBind[(U32)s->bindCount];
        memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseMemoryBind));
    }
}
MarshalVkSparseBufferMemoryBindInfo::~MarshalVkSparseBufferMemoryBindInfo() {
    delete[] s.pBinds;
}
void MarshalVkSparseImageOpaqueMemoryBindInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageOpaqueMemoryBindInfo* s) {
    s->image = (VkImage)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseMemoryBind[(U32)s->bindCount];
        memory->memcpy((VkSparseMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseMemoryBind));
    }
}
MarshalVkSparseImageOpaqueMemoryBindInfo::~MarshalVkSparseImageOpaqueMemoryBindInfo() {
    delete[] s.pBinds;
}
void MarshalVkSparseImageMemoryBindInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageMemoryBindInfo* s) {
    s->image = (VkImage)memory->readq(address);address+=8;
    s->bindCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBinds = NULL;
    } else {
        s->pBinds = new VkSparseImageMemoryBind[(U32)s->bindCount];
        memory->memcpy((VkSparseImageMemoryBind*)s->pBinds, paramAddress, (U32)s->bindCount * sizeof(VkSparseImageMemoryBind));
    }
}
MarshalVkSparseImageMemoryBindInfo::~MarshalVkSparseImageMemoryBindInfo() {
    delete[] s.pBinds;
}
void MarshalVkBindSparseInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindSparseInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount);
    }
    s->bufferBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferBinds = NULL;
    } else {
        s->pBufferBinds = new VkSparseBufferMemoryBindInfo[(U32)s->bufferBindCount];
        memory->memcpy((VkSparseBufferMemoryBindInfo*)s->pBufferBinds, paramAddress, (U32)s->bufferBindCount * sizeof(VkSparseBufferMemoryBindInfo));
    }
    s->imageOpaqueBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageOpaqueBinds = NULL;
    } else {
        s->pImageOpaqueBinds = new VkSparseImageOpaqueMemoryBindInfo[(U32)s->imageOpaqueBindCount];
        memory->memcpy((VkSparseImageOpaqueMemoryBindInfo*)s->pImageOpaqueBinds, paramAddress, (U32)s->imageOpaqueBindCount * sizeof(VkSparseImageOpaqueMemoryBindInfo));
    }
    s->imageBindCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageBinds = NULL;
    } else {
        s->pImageBinds = new VkSparseImageMemoryBindInfo[(U32)s->imageBindCount];
        memory->memcpy((VkSparseImageMemoryBindInfo*)s->pImageBinds, paramAddress, (U32)s->imageBindCount * sizeof(VkSparseImageMemoryBindInfo));
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphores = NULL;
    } else {
        s->pSignalSemaphores = new VkSemaphore[(U32)s->signalSemaphoreCount];
        memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, (U32)s->signalSemaphoreCount);
    }
}
void MarshalVkBindSparseInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindSparseInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->bufferBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseBufferMemoryBindInfo* pBufferBinds = new VkSparseBufferMemoryBindInfo();
        MarshalVkSparseBufferMemoryBindInfo::read(pBoxedInfo, memory, paramAddress, pBufferBinds);
        s->pBufferBinds = pBufferBinds;
    }
    memory->writed(address, s->imageOpaqueBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = new VkSparseImageOpaqueMemoryBindInfo();
        MarshalVkSparseImageOpaqueMemoryBindInfo::read(pBoxedInfo, memory, paramAddress, pImageOpaqueBinds);
        s->pImageOpaqueBinds = pImageOpaqueBinds;
    }
    memory->writed(address, s->imageBindCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSparseImageMemoryBindInfo* pImageBinds = new VkSparseImageMemoryBindInfo();
        MarshalVkSparseImageMemoryBindInfo::read(pBoxedInfo, memory, paramAddress, pImageBinds);
        s->pImageBinds = pImageBinds;
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkBindSparseInfo::~MarshalVkBindSparseInfo() {
    delete s.pNext;
    delete[] s.pWaitSemaphores;
    delete[] s.pBufferBinds;
    delete[] s.pImageOpaqueBinds;
    delete[] s.pImageBinds;
    delete[] s.pSignalSemaphores;
}
void MarshalVkImageCopy::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCopy* s) {
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkImageBlit::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageBlit* s) {
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffsets, address, 24);address+=24;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffsets, address, 24);address+=24;
}
void MarshalVkBufferImageCopy::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferImageCopy* s) {
    s->bufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->bufferRowLength = (uint32_t)memory->readd(address);address+=4;
    s->bufferImageHeight = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->imageSubresource, address, 16);address+=16;
    memory->memcpy(&s->imageOffset, address, 12);address+=12;
    memory->memcpy(&s->imageExtent, address, 12);address+=12;
}
void MarshalVkImageResolve::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageResolve* s) {
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkShaderModuleCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkShaderModuleCreateFlags)memory->readd(address);address+=4;
    s->codeSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCode = NULL;
    } else {
        s->pCode = new uint32_t[(U32)s->codeSize / 4];
        memory->memcpy((uint32_t*)s->pCode, paramAddress, (U32)s->codeSize / 4);
    }
}
void MarshalVkShaderModuleCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->codeSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkShaderModuleCreateInfo::~MarshalVkShaderModuleCreateInfo() {
    delete s.pNext;
    delete[] s.pCode;
}
void MarshalVkDescriptorSetLayoutBinding::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutBinding* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImmutableSamplers = NULL;
    } else {
        s->pImmutableSamplers = new VkSampler[(U32)s->descriptorCount];
        memory->memcpy((VkSampler*)s->pImmutableSamplers, paramAddress, (U32)s->descriptorCount);
    }
}
MarshalVkDescriptorSetLayoutBinding::~MarshalVkDescriptorSetLayoutBinding() {
    delete[] s.pImmutableSamplers;
}
void MarshalVkDescriptorSetLayoutCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDescriptorSetLayoutCreateFlags)memory->readd(address);address+=4;
    s->bindingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBindings = NULL;
    } else {
        VkDescriptorSetLayoutBinding* pBindings = new VkDescriptorSetLayoutBinding[s->bindingCount];
        for (U32 i = 0; i < s->bindingCount; i++) {
            MarshalVkDescriptorSetLayoutBinding::read(pBoxedInfo, memory, paramAddress + i*20, &pBindings[i]);
        }
        s->pBindings = pBindings;
    }
}
void MarshalVkDescriptorSetLayoutCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->bindingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorSetLayoutBinding* pBindings = new VkDescriptorSetLayoutBinding();
        MarshalVkDescriptorSetLayoutBinding::read(pBoxedInfo, memory, paramAddress, pBindings);
        s->pBindings = pBindings;
    }
}
MarshalVkDescriptorSetLayoutCreateInfo::~MarshalVkDescriptorSetLayoutCreateInfo() {
    delete s.pNext;
    delete[] s.pBindings;
}
void MarshalVkDescriptorPoolSize::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorPoolSize* s) {
    s->type = (VkDescriptorType)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorPoolCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDescriptorPoolCreateFlags)memory->readd(address);address+=4;
    s->maxSets = (uint32_t)memory->readd(address);address+=4;
    s->poolSizeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPoolSizes = NULL;
    } else {
        VkDescriptorPoolSize* pPoolSizes = new VkDescriptorPoolSize[s->poolSizeCount];
        for (U32 i = 0; i < s->poolSizeCount; i++) {
            MarshalVkDescriptorPoolSize::read(pBoxedInfo, memory, paramAddress + i*8, &pPoolSizes[i]);
        }
        s->pPoolSizes = pPoolSizes;
    }
}
void MarshalVkDescriptorPoolCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->maxSets);address+=4;
    memory->writed(address, s->poolSizeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorPoolSize* pPoolSizes = new VkDescriptorPoolSize();
        MarshalVkDescriptorPoolSize::read(pBoxedInfo, memory, paramAddress, pPoolSizes);
        s->pPoolSizes = pPoolSizes;
    }
}
MarshalVkDescriptorPoolCreateInfo::~MarshalVkDescriptorPoolCreateInfo() {
    delete s.pNext;
    delete[] s.pPoolSizes;
}
void MarshalVkDescriptorSetAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorPool = (VkDescriptorPool)memory->readq(address);address+=8;
    s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->descriptorSetCount];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->descriptorSetCount);
    }
}
void MarshalVkDescriptorSetAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->descriptorPool);address+=8;
    memory->writed(address, s->descriptorSetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDescriptorSetAllocateInfo::~MarshalVkDescriptorSetAllocateInfo() {
    delete s.pNext;
    delete[] s.pSetLayouts;
}
void MarshalVkSpecializationMapEntry::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSpecializationMapEntry* s) {
    s->constantID = (uint32_t)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->size = (size_t)memory->readd(address);address+=4;
}
void MarshalVkSpecializationInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSpecializationInfo* s) {
    s->mapEntryCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMapEntries = NULL;
    } else {
        VkSpecializationMapEntry* pMapEntries = new VkSpecializationMapEntry[s->mapEntryCount];
        for (U32 i = 0; i < s->mapEntryCount; i++) {
            MarshalVkSpecializationMapEntry::read(pBoxedInfo, memory, paramAddress + i*12, &pMapEntries[i]);
        }
        s->pMapEntries = pMapEntries;
    }
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
MarshalVkSpecializationInfo::~MarshalVkSpecializationInfo() {
    delete[] s.pMapEntries;
    delete[] s.pData;
}
void MarshalVkPipelineShaderStageCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineShaderStageCreateFlags)memory->readd(address);address+=4;
    s->stage = (VkShaderStageFlagBits)memory->readd(address);address+=4;
    s->module = (VkShaderModule)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSpecializationInfo = NULL;
    } else {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(pBoxedInfo, memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
void MarshalVkPipelineShaderStageCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stage);address+=4;
    memory->writeq(address, (U64)s->module);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(pBoxedInfo, memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
MarshalVkPipelineShaderStageCreateInfo::~MarshalVkPipelineShaderStageCreateInfo() {
    delete s.pNext;
    delete[] s.pName;
    delete s.pSpecializationInfo;
}
void MarshalVkComputePipelineCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkComputePipelineCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, address, &s->stage); address+=32;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkComputePipelineCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkComputePipelineCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, &s->stage, 32); address+=32;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
MarshalVkComputePipelineCreateInfo::~MarshalVkComputePipelineCreateInfo() {
    delete s.pNext;
}
void MarshalVkComputePipelineIndirectBufferInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkComputePipelineIndirectBufferInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->pipelineDeviceAddressCaptureReplay = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkComputePipelineIndirectBufferInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkComputePipelineIndirectBufferInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->deviceAddress);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writeq(address, s->pipelineDeviceAddressCaptureReplay);address+=8;
}
MarshalVkComputePipelineIndirectBufferInfoNV::~MarshalVkComputePipelineIndirectBufferInfoNV() {
    delete s.pNext;
}
void MarshalVkPipelineCreateFlags2CreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreateFlags2CreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags2)memory->readq(address);address+=8;
}
void MarshalVkPipelineCreateFlags2CreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreateFlags2CreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->flags);address+=8;
}
MarshalVkPipelineCreateFlags2CreateInfo::~MarshalVkPipelineCreateFlags2CreateInfo() {
    delete s.pNext;
}
void MarshalVkVertexInputBindingDescription::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputBindingDescription* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
}
void MarshalVkVertexInputAttributeDescription::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputAttributeDescription* s) {
    s->location = (uint32_t)memory->readd(address);address+=4;
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineVertexInputStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineVertexInputStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineVertexInputStateCreateFlags)memory->readd(address);address+=4;
    s->vertexBindingDescriptionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexBindingDescriptions = NULL;
    } else {
        VkVertexInputBindingDescription* pVertexBindingDescriptions = new VkVertexInputBindingDescription[s->vertexBindingDescriptionCount];
        for (U32 i = 0; i < s->vertexBindingDescriptionCount; i++) {
            MarshalVkVertexInputBindingDescription::read(pBoxedInfo, memory, paramAddress + i*12, &pVertexBindingDescriptions[i]);
        }
        s->pVertexBindingDescriptions = pVertexBindingDescriptions;
    }
    s->vertexAttributeDescriptionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexAttributeDescriptions = NULL;
    } else {
        VkVertexInputAttributeDescription* pVertexAttributeDescriptions = new VkVertexInputAttributeDescription[s->vertexAttributeDescriptionCount];
        for (U32 i = 0; i < s->vertexAttributeDescriptionCount; i++) {
            MarshalVkVertexInputAttributeDescription::read(pBoxedInfo, memory, paramAddress + i*16, &pVertexAttributeDescriptions[i]);
        }
        s->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
    }
}
void MarshalVkPipelineVertexInputStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineVertexInputStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->vertexBindingDescriptionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputBindingDescription* pVertexBindingDescriptions = new VkVertexInputBindingDescription();
        MarshalVkVertexInputBindingDescription::read(pBoxedInfo, memory, paramAddress, pVertexBindingDescriptions);
        s->pVertexBindingDescriptions = pVertexBindingDescriptions;
    }
    memory->writed(address, s->vertexAttributeDescriptionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputAttributeDescription* pVertexAttributeDescriptions = new VkVertexInputAttributeDescription();
        MarshalVkVertexInputAttributeDescription::read(pBoxedInfo, memory, paramAddress, pVertexAttributeDescriptions);
        s->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
    }
}
MarshalVkPipelineVertexInputStateCreateInfo::~MarshalVkPipelineVertexInputStateCreateInfo() {
    delete s.pNext;
    delete[] s.pVertexBindingDescriptions;
    delete[] s.pVertexAttributeDescriptions;
}
void MarshalVkPipelineInputAssemblyStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineInputAssemblyStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineInputAssemblyStateCreateFlags)memory->readd(address);address+=4;
    s->topology = (VkPrimitiveTopology)memory->readd(address);address+=4;
    s->primitiveRestartEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineInputAssemblyStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineInputAssemblyStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->topology);address+=4;
    memory->writed(address, s->primitiveRestartEnable);address+=4;
}
MarshalVkPipelineInputAssemblyStateCreateInfo::~MarshalVkPipelineInputAssemblyStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkPipelineTessellationStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineTessellationStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineTessellationStateCreateFlags)memory->readd(address);address+=4;
    s->patchControlPoints = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineTessellationStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineTessellationStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->patchControlPoints);address+=4;
}
MarshalVkPipelineTessellationStateCreateInfo::~MarshalVkPipelineTessellationStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkPipelineViewportStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineViewportStateCreateFlags)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewports = NULL;
    } else {
        s->pViewports = new VkViewport[(U32)s->viewportCount];
        memory->memcpy((VkViewport*)s->pViewports, paramAddress, (U32)s->viewportCount * sizeof(VkViewport));
    }
    s->scissorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pScissors = NULL;
    } else {
        s->pScissors = new VkRect2D[(U32)s->scissorCount];
        memory->memcpy((VkRect2D*)s->pScissors, paramAddress, (U32)s->scissorCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineViewportStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewport* pViewports = new VkViewport();
        MarshalVkViewport::read(pBoxedInfo, memory, paramAddress, pViewports);
        s->pViewports = pViewports;
    }
    memory->writed(address, s->scissorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pScissors = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pScissors);
        s->pScissors = pScissors;
    }
}
MarshalVkPipelineViewportStateCreateInfo::~MarshalVkPipelineViewportStateCreateInfo() {
    delete s.pNext;
    delete[] s.pViewports;
    delete[] s.pScissors;
}
void MarshalVkPipelineRasterizationStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationStateCreateFlags)memory->readd(address);address+=4;
    s->depthClampEnable = (VkBool32)memory->readd(address);address+=4;
    s->rasterizerDiscardEnable = (VkBool32)memory->readd(address);address+=4;
    s->polygonMode = (VkPolygonMode)memory->readd(address);address+=4;
    s->cullMode = (VkCullModeFlags)memory->readd(address);address+=4;
    s->frontFace = (VkFrontFace)memory->readd(address);address+=4;
    s->depthBiasEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasConstantFactor = depthBiasConstantFactorFloat.f;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.i = memory->readd(address);address+=4;
    s->depthBiasClamp = depthBiasClampFloat.f;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasSlopeFactor = depthBiasSlopeFactorFloat.f;
    MarshalFloat lineWidthFloat;
    lineWidthFloat.i = memory->readd(address);address+=4;
    s->lineWidth = lineWidthFloat.f;
}
void MarshalVkPipelineRasterizationStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthClampEnable);address+=4;
    memory->writed(address, s->rasterizerDiscardEnable);address+=4;
    memory->writed(address, s->polygonMode);address+=4;
    memory->writed(address, s->cullMode);address+=4;
    memory->writed(address, s->frontFace);address+=4;
    memory->writed(address, s->depthBiasEnable);address+=4;
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.f = s->depthBiasConstantFactor;
    memory->writed(address, depthBiasConstantFactorFloat.i);address+=4;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.f = s->depthBiasClamp;
    memory->writed(address, depthBiasClampFloat.i);address+=4;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.f = s->depthBiasSlopeFactor;
    memory->writed(address, depthBiasSlopeFactorFloat.i);address+=4;
    MarshalFloat lineWidthFloat;
    lineWidthFloat.f = s->lineWidth;
    memory->writed(address, lineWidthFloat.i);address+=4;
}
MarshalVkPipelineRasterizationStateCreateInfo::~MarshalVkPipelineRasterizationStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkPipelineMultisampleStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineMultisampleStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineMultisampleStateCreateFlags)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->sampleShadingEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat minSampleShadingFloat;
    minSampleShadingFloat.i = memory->readd(address);address+=4;
    s->minSampleShading = minSampleShadingFloat.f;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleMask = NULL;
    } else {
        s->pSampleMask = new VkSampleMask[(s->rasterizationSamples + 31) / 32];
        memory->memcpy((VkSampleMask*)s->pSampleMask, paramAddress, (s->rasterizationSamples + 31) / 32);
    }
    s->alphaToCoverageEnable = (VkBool32)memory->readd(address);address+=4;
    s->alphaToOneEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineMultisampleStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineMultisampleStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
    memory->writed(address, s->sampleShadingEnable);address+=4;
    MarshalFloat minSampleShadingFloat;
    minSampleShadingFloat.f = s->minSampleShading;
    memory->writed(address, minSampleShadingFloat.i);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->alphaToCoverageEnable);address+=4;
    memory->writed(address, s->alphaToOneEnable);address+=4;
}
MarshalVkPipelineMultisampleStateCreateInfo::~MarshalVkPipelineMultisampleStateCreateInfo() {
    delete s.pNext;
    delete[] s.pSampleMask;
}
void MarshalVkPipelineColorBlendAttachmentState::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorBlendAttachmentState* s) {
    s->blendEnable = (VkBool32)memory->readd(address);address+=4;
    s->srcColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->colorBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->srcAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->alphaBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->colorWriteMask = (VkColorComponentFlags)memory->readd(address);address+=4;
}
void MarshalVkPipelineColorBlendStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorBlendStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineColorBlendStateCreateFlags)memory->readd(address);address+=4;
    s->logicOpEnable = (VkBool32)memory->readd(address);address+=4;
    s->logicOp = (VkLogicOp)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkPipelineColorBlendAttachmentState* pAttachments = new VkPipelineColorBlendAttachmentState[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkPipelineColorBlendAttachmentState::read(pBoxedInfo, memory, paramAddress + i*32, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    memory->memcpy(&s->blendConstants, address, 16);address+=16;
}
void MarshalVkPipelineColorBlendStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorBlendStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->logicOpEnable);address+=4;
    memory->writed(address, s->logicOp);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineColorBlendAttachmentState* pAttachments = new VkPipelineColorBlendAttachmentState();
        MarshalVkPipelineColorBlendAttachmentState::read(pBoxedInfo, memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->memcpy(address, s->blendConstants, 16); address+=16;
}
MarshalVkPipelineColorBlendStateCreateInfo::~MarshalVkPipelineColorBlendStateCreateInfo() {
    delete s.pNext;
    delete[] s.pAttachments;
}
void MarshalVkPipelineDynamicStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDynamicStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineDynamicStateCreateFlags)memory->readd(address);address+=4;
    s->dynamicStateCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicStates = NULL;
    } else {
        s->pDynamicStates = new VkDynamicState[(U32)s->dynamicStateCount];
        memory->memcpy((VkDynamicState*)s->pDynamicStates, paramAddress, (U32)s->dynamicStateCount);
    }
}
void MarshalVkPipelineDynamicStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDynamicStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->dynamicStateCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineDynamicStateCreateInfo::~MarshalVkPipelineDynamicStateCreateInfo() {
    delete s.pNext;
    delete[] s.pDynamicStates;
}
void MarshalVkStencilOpState::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkStencilOpState* s) {
    s->failOp = (VkStencilOp)memory->readd(address);address+=4;
    s->passOp = (VkStencilOp)memory->readd(address);address+=4;
    s->depthFailOp = (VkStencilOp)memory->readd(address);address+=4;
    s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
    s->compareMask = (uint32_t)memory->readd(address);address+=4;
    s->writeMask = (uint32_t)memory->readd(address);address+=4;
    s->reference = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineDepthStencilStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDepthStencilStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineDepthStencilStateCreateFlags)memory->readd(address);address+=4;
    s->depthTestEnable = (VkBool32)memory->readd(address);address+=4;
    s->depthWriteEnable = (VkBool32)memory->readd(address);address+=4;
    s->depthCompareOp = (VkCompareOp)memory->readd(address);address+=4;
    s->depthBoundsTestEnable = (VkBool32)memory->readd(address);address+=4;
    s->stencilTestEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalVkStencilOpState::read(pBoxedInfo, memory, address, &s->front); address+=28;
    MarshalVkStencilOpState::read(pBoxedInfo, memory, address, &s->back); address+=28;
    MarshalFloat minDepthBoundsFloat;
    minDepthBoundsFloat.i = memory->readd(address);address+=4;
    s->minDepthBounds = minDepthBoundsFloat.f;
    MarshalFloat maxDepthBoundsFloat;
    maxDepthBoundsFloat.i = memory->readd(address);address+=4;
    s->maxDepthBounds = maxDepthBoundsFloat.f;
}
void MarshalVkPipelineDepthStencilStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDepthStencilStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthTestEnable);address+=4;
    memory->writed(address, s->depthWriteEnable);address+=4;
    memory->writed(address, s->depthCompareOp);address+=4;
    memory->writed(address, s->depthBoundsTestEnable);address+=4;
    memory->writed(address, s->stencilTestEnable);address+=4;
    memory->memcpy(address, &s->front, 28); address+=28;
    memory->memcpy(address, &s->back, 28); address+=28;
    MarshalFloat minDepthBoundsFloat;
    minDepthBoundsFloat.f = s->minDepthBounds;
    memory->writed(address, minDepthBoundsFloat.i);address+=4;
    MarshalFloat maxDepthBoundsFloat;
    maxDepthBoundsFloat.f = s->maxDepthBounds;
    memory->writed(address, maxDepthBoundsFloat.i);address+=4;
}
MarshalVkPipelineDepthStencilStateCreateInfo::~MarshalVkPipelineDepthStencilStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkGraphicsPipelineCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexInputState = NULL;
    } else {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAssemblyState = NULL;
    } else {
        VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo();
        MarshalVkPipelineInputAssemblyStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pInputAssemblyState);
        s->pInputAssemblyState = pInputAssemblyState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTessellationState = NULL;
    } else {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportState = NULL;
    } else {
        VkPipelineViewportStateCreateInfo* pViewportState = new VkPipelineViewportStateCreateInfo();
        MarshalVkPipelineViewportStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pViewportState);
        s->pViewportState = pViewportState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRasterizationState = NULL;
    } else {
        VkPipelineRasterizationStateCreateInfo* pRasterizationState = new VkPipelineRasterizationStateCreateInfo();
        MarshalVkPipelineRasterizationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pRasterizationState);
        s->pRasterizationState = pRasterizationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMultisampleState = NULL;
    } else {
        VkPipelineMultisampleStateCreateInfo* pMultisampleState = new VkPipelineMultisampleStateCreateInfo();
        MarshalVkPipelineMultisampleStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pMultisampleState);
        s->pMultisampleState = pMultisampleState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilState = NULL;
    } else {
        VkPipelineDepthStencilStateCreateInfo* pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo();
        MarshalVkPipelineDepthStencilStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDepthStencilState);
        s->pDepthStencilState = pDepthStencilState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorBlendState = NULL;
    } else {
        VkPipelineColorBlendStateCreateInfo* pColorBlendState = new VkPipelineColorBlendStateCreateInfo();
        MarshalVkPipelineColorBlendStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pColorBlendState);
        s->pColorBlendState = pColorBlendState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicState = NULL;
    } else {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkGraphicsPipelineCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo();
        MarshalVkPipelineInputAssemblyStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pInputAssemblyState);
        s->pInputAssemblyState = pInputAssemblyState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineViewportStateCreateInfo* pViewportState = new VkPipelineViewportStateCreateInfo();
        MarshalVkPipelineViewportStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pViewportState);
        s->pViewportState = pViewportState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineRasterizationStateCreateInfo* pRasterizationState = new VkPipelineRasterizationStateCreateInfo();
        MarshalVkPipelineRasterizationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pRasterizationState);
        s->pRasterizationState = pRasterizationState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineMultisampleStateCreateInfo* pMultisampleState = new VkPipelineMultisampleStateCreateInfo();
        MarshalVkPipelineMultisampleStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pMultisampleState);
        s->pMultisampleState = pMultisampleState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineDepthStencilStateCreateInfo* pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo();
        MarshalVkPipelineDepthStencilStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDepthStencilState);
        s->pDepthStencilState = pDepthStencilState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineColorBlendStateCreateInfo* pColorBlendState = new VkPipelineColorBlendStateCreateInfo();
        MarshalVkPipelineColorBlendStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pColorBlendState);
        s->pColorBlendState = pColorBlendState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
MarshalVkGraphicsPipelineCreateInfo::~MarshalVkGraphicsPipelineCreateInfo() {
    delete s.pNext;
    delete[] s.pStages;
    delete s.pVertexInputState;
    delete s.pInputAssemblyState;
    delete s.pTessellationState;
    delete s.pViewportState;
    delete s.pRasterizationState;
    delete s.pMultisampleState;
    delete s.pDepthStencilState;
    delete s.pColorBlendState;
    delete s.pDynamicState;
}
void MarshalVkPipelineCacheCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCacheCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCacheCreateFlags)memory->readd(address);address+=4;
    s->initialDataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInitialData = NULL;
    } else {
        s->pInitialData = new char[(U32)s->initialDataSize];
        memory->memcpy((void*)s->pInitialData, paramAddress, (U32)s->initialDataSize);
    }
}
void MarshalVkPipelineCacheCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCacheCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->initialDataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineCacheCreateInfo::~MarshalVkPipelineCacheCreateInfo() {
    delete s.pNext;
    delete[] s.pInitialData;
}
void MarshalVkPushConstantRange::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushConstantRange* s) {
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->size = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineBinaryCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pKeysAndDataInfo = NULL;
    } else {
        VkPipelineBinaryKeysAndDataKHR* pKeysAndDataInfo = new VkPipelineBinaryKeysAndDataKHR();
        MarshalVkPipelineBinaryKeysAndDataKHR::read(pBoxedInfo, memory, paramAddress, pKeysAndDataInfo);
        s->pKeysAndDataInfo = pKeysAndDataInfo;
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineCreateInfo = NULL;
    } else {
        VkPipelineCreateInfoKHR* pPipelineCreateInfo = new VkPipelineCreateInfoKHR();
        MarshalVkPipelineCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pPipelineCreateInfo);
        s->pPipelineCreateInfo = pPipelineCreateInfo;
    }
}
void MarshalVkPipelineBinaryCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineBinaryKeysAndDataKHR* pKeysAndDataInfo = new VkPipelineBinaryKeysAndDataKHR();
        MarshalVkPipelineBinaryKeysAndDataKHR::read(pBoxedInfo, memory, paramAddress, pKeysAndDataInfo);
        s->pKeysAndDataInfo = pKeysAndDataInfo;
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineCreateInfoKHR* pPipelineCreateInfo = new VkPipelineCreateInfoKHR();
        MarshalVkPipelineCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pPipelineCreateInfo);
        s->pPipelineCreateInfo = pPipelineCreateInfo;
    }
}
MarshalVkPipelineBinaryCreateInfoKHR::~MarshalVkPipelineBinaryCreateInfoKHR() {
    delete s.pNext;
    delete s.pKeysAndDataInfo;
    delete s.pPipelineCreateInfo;
}
void MarshalVkPipelineBinaryHandlesInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryHandlesInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBinaryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineBinaries = NULL;
    } else {
        s->pPipelineBinaries = new VkPipelineBinaryKHR[(U32)s->pipelineBinaryCount];
        memory->memcpy((VkPipelineBinaryKHR*)s->pPipelineBinaries, paramAddress, (U32)s->pipelineBinaryCount);
    }
}
void MarshalVkPipelineBinaryHandlesInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryHandlesInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBinaryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineBinaryHandlesInfoKHR::~MarshalVkPipelineBinaryHandlesInfoKHR() {
    delete s.pNext;
    delete[] s.pPipelineBinaries;
}
void MarshalVkPipelineBinaryDataKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryDataKHR* s) {
    s->dataSize = (size_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
MarshalVkPipelineBinaryDataKHR::~MarshalVkPipelineBinaryDataKHR() {
    delete[] s.pData;
}
void MarshalVkPipelineBinaryKeysAndDataKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryKeysAndDataKHR* s) {
    s->binaryCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineBinaryKeys = NULL;
    } else {
        VkPipelineBinaryKeyKHR* pPipelineBinaryKeys = new VkPipelineBinaryKeyKHR[s->binaryCount];
        for (U32 i = 0; i < s->binaryCount; i++) {
            MarshalVkPipelineBinaryKeyKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pPipelineBinaryKeys[i]);
        }
        s->pPipelineBinaryKeys = pPipelineBinaryKeys;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineBinaryData = NULL;
    } else {
        VkPipelineBinaryDataKHR* pPipelineBinaryData = new VkPipelineBinaryDataKHR[s->binaryCount];
        for (U32 i = 0; i < s->binaryCount; i++) {
            MarshalVkPipelineBinaryDataKHR::read(pBoxedInfo, memory, paramAddress + i*8, &pPipelineBinaryData[i]);
        }
        s->pPipelineBinaryData = pPipelineBinaryData;
    }
}
MarshalVkPipelineBinaryKeysAndDataKHR::~MarshalVkPipelineBinaryKeysAndDataKHR() {
    delete[] s.pPipelineBinaryKeys;
    delete[] s.pPipelineBinaryData;
}
void MarshalVkPipelineBinaryKeyKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryKeyKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->keySize = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->key, address, 32);address+=32;
}
void MarshalVkPipelineBinaryKeyKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryKeyKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->keySize);address+=4;
    memory->memcpy(address, s->key, 32); address+=32;
}
MarshalVkPipelineBinaryKeyKHR::~MarshalVkPipelineBinaryKeyKHR() {
    delete s.pNext;
}
void MarshalVkPipelineBinaryInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->binaryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineBinaries = NULL;
    } else {
        s->pPipelineBinaries = new VkPipelineBinaryKHR[(U32)s->binaryCount];
        memory->memcpy((VkPipelineBinaryKHR*)s->pPipelineBinaries, paramAddress, (U32)s->binaryCount);
    }
}
void MarshalVkPipelineBinaryInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->binaryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineBinaryInfoKHR::~MarshalVkPipelineBinaryInfoKHR() {
    delete s.pNext;
    delete[] s.pPipelineBinaries;
}
void MarshalVkReleaseCapturedPipelineDataInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkReleaseCapturedPipelineDataInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkReleaseCapturedPipelineDataInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkReleaseCapturedPipelineDataInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
MarshalVkReleaseCapturedPipelineDataInfoKHR::~MarshalVkReleaseCapturedPipelineDataInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineBinaryDataInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryDataInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBinary = (VkPipelineBinaryKHR)memory->readq(address);address+=8;
}
void MarshalVkPipelineBinaryDataInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineBinaryDataInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->pipelineBinary);address+=8;
}
MarshalVkPipelineBinaryDataInfoKHR::~MarshalVkPipelineBinaryDataInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
}
void MarshalVkPipelineCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
}
MarshalVkPipelineCreateInfoKHR::~MarshalVkPipelineCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineLayoutCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineLayoutCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineLayoutCreateFlags)memory->readd(address);address+=4;
    s->setLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->setLayoutCount];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->setLayoutCount);
    }
    s->pushConstantRangeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPushConstantRanges = NULL;
    } else {
        s->pPushConstantRanges = new VkPushConstantRange[(U32)s->pushConstantRangeCount];
        memory->memcpy((VkPushConstantRange*)s->pPushConstantRanges, paramAddress, (U32)s->pushConstantRangeCount * sizeof(VkPushConstantRange));
    }
}
void MarshalVkPipelineLayoutCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineLayoutCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->setLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->pushConstantRangeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPushConstantRange* pPushConstantRanges = new VkPushConstantRange();
        MarshalVkPushConstantRange::read(pBoxedInfo, memory, paramAddress, pPushConstantRanges);
        s->pPushConstantRanges = pPushConstantRanges;
    }
}
MarshalVkPipelineLayoutCreateInfo::~MarshalVkPipelineLayoutCreateInfo() {
    delete s.pNext;
    delete[] s.pSetLayouts;
    delete[] s.pPushConstantRanges;
}
void MarshalVkSamplerCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSamplerCreateFlags)memory->readd(address);address+=4;
    s->magFilter = (VkFilter)memory->readd(address);address+=4;
    s->minFilter = (VkFilter)memory->readd(address);address+=4;
    s->mipmapMode = (VkSamplerMipmapMode)memory->readd(address);address+=4;
    s->addressModeU = (VkSamplerAddressMode)memory->readd(address);address+=4;
    s->addressModeV = (VkSamplerAddressMode)memory->readd(address);address+=4;
    s->addressModeW = (VkSamplerAddressMode)memory->readd(address);address+=4;
    MarshalFloat mipLodBiasFloat;
    mipLodBiasFloat.i = memory->readd(address);address+=4;
    s->mipLodBias = mipLodBiasFloat.f;
    s->anisotropyEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat maxAnisotropyFloat;
    maxAnisotropyFloat.i = memory->readd(address);address+=4;
    s->maxAnisotropy = maxAnisotropyFloat.f;
    s->compareEnable = (VkBool32)memory->readd(address);address+=4;
    s->compareOp = (VkCompareOp)memory->readd(address);address+=4;
    MarshalFloat minLodFloat;
    minLodFloat.i = memory->readd(address);address+=4;
    s->minLod = minLodFloat.f;
    MarshalFloat maxLodFloat;
    maxLodFloat.i = memory->readd(address);address+=4;
    s->maxLod = maxLodFloat.f;
    s->borderColor = (VkBorderColor)memory->readd(address);address+=4;
    s->unnormalizedCoordinates = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->magFilter);address+=4;
    memory->writed(address, s->minFilter);address+=4;
    memory->writed(address, s->mipmapMode);address+=4;
    memory->writed(address, s->addressModeU);address+=4;
    memory->writed(address, s->addressModeV);address+=4;
    memory->writed(address, s->addressModeW);address+=4;
    MarshalFloat mipLodBiasFloat;
    mipLodBiasFloat.f = s->mipLodBias;
    memory->writed(address, mipLodBiasFloat.i);address+=4;
    memory->writed(address, s->anisotropyEnable);address+=4;
    MarshalFloat maxAnisotropyFloat;
    maxAnisotropyFloat.f = s->maxAnisotropy;
    memory->writed(address, maxAnisotropyFloat.i);address+=4;
    memory->writed(address, s->compareEnable);address+=4;
    memory->writed(address, s->compareOp);address+=4;
    MarshalFloat minLodFloat;
    minLodFloat.f = s->minLod;
    memory->writed(address, minLodFloat.i);address+=4;
    MarshalFloat maxLodFloat;
    maxLodFloat.f = s->maxLod;
    memory->writed(address, maxLodFloat.i);address+=4;
    memory->writed(address, s->borderColor);address+=4;
    memory->writed(address, s->unnormalizedCoordinates);address+=4;
}
MarshalVkSamplerCreateInfo::~MarshalVkSamplerCreateInfo() {
    delete s.pNext;
}
void MarshalVkCommandPoolCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkCommandPoolCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandPoolCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
}
MarshalVkCommandPoolCreateInfo::~MarshalVkCommandPoolCreateInfo() {
    delete s.pNext;
}
void MarshalVkCommandBufferAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->commandPool = (VkCommandPool)memory->readq(address);address+=8;
    s->level = (VkCommandBufferLevel)memory->readd(address);address+=4;
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->commandPool);address+=8;
    memory->writed(address, s->level);address+=4;
    memory->writed(address, s->commandBufferCount);address+=4;
}
MarshalVkCommandBufferAllocateInfo::~MarshalVkCommandBufferAllocateInfo() {
    delete s.pNext;
}
void MarshalVkCommandBufferInheritanceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
    s->occlusionQueryEnable = (VkBool32)memory->readd(address);address+=4;
    s->queryFlags = (VkQueryControlFlags)memory->readd(address);address+=4;
    s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferInheritanceInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
    memory->writeq(address, (U64)s->framebuffer);address+=8;
    memory->writed(address, s->occlusionQueryEnable);address+=4;
    memory->writed(address, s->queryFlags);address+=4;
    memory->writed(address, s->pipelineStatistics);address+=4;
}
MarshalVkCommandBufferInheritanceInfo::~MarshalVkCommandBufferInheritanceInfo() {
    delete s.pNext;
}
void MarshalVkCommandBufferBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkCommandBufferUsageFlags)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInheritanceInfo = NULL;
    } else {
        VkCommandBufferInheritanceInfo* pInheritanceInfo = new VkCommandBufferInheritanceInfo();
        MarshalVkCommandBufferInheritanceInfo::read(pBoxedInfo, memory, paramAddress, pInheritanceInfo);
        s->pInheritanceInfo = pInheritanceInfo;
    }
}
void MarshalVkCommandBufferBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCommandBufferInheritanceInfo* pInheritanceInfo = new VkCommandBufferInheritanceInfo();
        MarshalVkCommandBufferInheritanceInfo::read(pBoxedInfo, memory, paramAddress, pInheritanceInfo);
        s->pInheritanceInfo = pInheritanceInfo;
    }
}
MarshalVkCommandBufferBeginInfo::~MarshalVkCommandBufferBeginInfo() {
    delete s.pNext;
    delete s.pInheritanceInfo;
}
void MarshalVkRenderPassBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->framebuffer = (VkFramebuffer)memory->readq(address);address+=8;
    memory->memcpy(&s->renderArea, address, 16);address+=16;
    s->clearValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pClearValues = NULL;
    } else {
        s->pClearValues = new VkClearValue[(U32)s->clearValueCount];
        memory->memcpy((VkClearValue*)s->pClearValues, paramAddress, (U32)s->clearValueCount);
    }
}
void MarshalVkRenderPassBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writeq(address, (U64)s->framebuffer);address+=8;
    memory->memcpy(address, &s->renderArea, 16); address+=16;
    memory->writed(address, s->clearValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRenderPassBeginInfo::~MarshalVkRenderPassBeginInfo() {
    delete s.pNext;
    delete[] s.pClearValues;
}
void MarshalVkClearColorValue::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkClearColorValue* s) {
    memory->memcpy(&s->float32, address, 16);address+=16;
    memory->memcpy(&s->int32, address, 16);address+=16;
    memory->memcpy(&s->uint32, address, 16);address+=16;
}
void MarshalVkClearDepthStencilValue::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkClearDepthStencilValue* s) {
    MarshalFloat depthFloat;
    depthFloat.i = memory->readd(address);address+=4;
    s->depth = depthFloat.f;
    s->stencil = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkClearAttachment::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkClearAttachment* s) {
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
    s->colorAttachment = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->clearValue, address, 16);address+=16;
}
void MarshalVkAttachmentDescription::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentDescription* s) {
    s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReference::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentReference* s) {
    s->attachment = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkSubpassDescription::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDescription* s) {
    s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAttachments = NULL;
    } else {
        VkAttachmentReference* pInputAttachments = new VkAttachmentReference[s->inputAttachmentCount];
        for (U32 i = 0; i < s->inputAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(pBoxedInfo, memory, paramAddress + i*8, &pInputAttachments[i]);
        }
        s->pInputAttachments = pInputAttachments;
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachments = NULL;
    } else {
        VkAttachmentReference* pColorAttachments = new VkAttachmentReference[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(pBoxedInfo, memory, paramAddress + i*8, &pColorAttachments[i]);
        }
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResolveAttachments = NULL;
    } else {
        VkAttachmentReference* pResolveAttachments = new VkAttachmentReference[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference::read(pBoxedInfo, memory, paramAddress + i*8, &pResolveAttachments[i]);
        }
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilAttachment = NULL;
    } else {
        VkAttachmentReference* pDepthStencilAttachment = new VkAttachmentReference();
        MarshalVkAttachmentReference::read(pBoxedInfo, memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPreserveAttachments = NULL;
    } else {
        s->pPreserveAttachments = new uint32_t[(U32)s->preserveAttachmentCount];
        memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, (U32)s->preserveAttachmentCount);
    }
}
MarshalVkSubpassDescription::~MarshalVkSubpassDescription() {
    delete[] s.pInputAttachments;
    delete[] s.pColorAttachments;
    delete[] s.pResolveAttachments;
    delete s.pDepthStencilAttachment;
    delete[] s.pPreserveAttachments;
}
void MarshalVkSubpassDependency::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDependency* s) {
    s->srcSubpass = (uint32_t)memory->readd(address);address+=4;
    s->dstSubpass = (uint32_t)memory->readd(address);address+=4;
    s->srcStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->dstStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
}
void MarshalVkRenderPassCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkAttachmentDescription* pAttachments = new VkAttachmentDescription[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkAttachmentDescription::read(pBoxedInfo, memory, paramAddress + i*36, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubpasses = NULL;
    } else {
        VkSubpassDescription* pSubpasses = new VkSubpassDescription[s->subpassCount];
        for (U32 i = 0; i < s->subpassCount; i++) {
            MarshalVkSubpassDescription::read(pBoxedInfo, memory, paramAddress + i*40, &pSubpasses[i]);
        }
        s->pSubpasses = pSubpasses;
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDependencies = NULL;
    } else {
        s->pDependencies = new VkSubpassDependency[(U32)s->dependencyCount];
        memory->memcpy((VkSubpassDependency*)s->pDependencies, paramAddress, (U32)s->dependencyCount * sizeof(VkSubpassDependency));
    }
}
void MarshalVkRenderPassCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentDescription* pAttachments = new VkAttachmentDescription();
        MarshalVkAttachmentDescription::read(pBoxedInfo, memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDescription* pSubpasses = new VkSubpassDescription();
        MarshalVkSubpassDescription::read(pBoxedInfo, memory, paramAddress, pSubpasses);
        s->pSubpasses = pSubpasses;
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDependency* pDependencies = new VkSubpassDependency();
        MarshalVkSubpassDependency::read(pBoxedInfo, memory, paramAddress, pDependencies);
        s->pDependencies = pDependencies;
    }
}
MarshalVkRenderPassCreateInfo::~MarshalVkRenderPassCreateInfo() {
    delete s.pNext;
    delete[] s.pAttachments;
    delete[] s.pSubpasses;
    delete[] s.pDependencies;
}
void MarshalVkEventCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkEventCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkEventCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkEventCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkEventCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkEventCreateInfo::~MarshalVkEventCreateInfo() {
    delete s.pNext;
}
void MarshalVkFenceCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFenceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkFenceCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkFenceCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFenceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkFenceCreateInfo::~MarshalVkFenceCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFeatures* s) {
    s->robustBufferAccess = (VkBool32)memory->readd(address);address+=4;
    s->fullDrawIndexUint32 = (VkBool32)memory->readd(address);address+=4;
    s->imageCubeArray = (VkBool32)memory->readd(address);address+=4;
    s->independentBlend = (VkBool32)memory->readd(address);address+=4;
    s->geometryShader = (VkBool32)memory->readd(address);address+=4;
    s->tessellationShader = (VkBool32)memory->readd(address);address+=4;
    s->sampleRateShading = (VkBool32)memory->readd(address);address+=4;
    s->dualSrcBlend = (VkBool32)memory->readd(address);address+=4;
    s->logicOp = (VkBool32)memory->readd(address);address+=4;
    s->multiDrawIndirect = (VkBool32)memory->readd(address);address+=4;
    s->drawIndirectFirstInstance = (VkBool32)memory->readd(address);address+=4;
    s->depthClamp = (VkBool32)memory->readd(address);address+=4;
    s->depthBiasClamp = (VkBool32)memory->readd(address);address+=4;
    s->fillModeNonSolid = (VkBool32)memory->readd(address);address+=4;
    s->depthBounds = (VkBool32)memory->readd(address);address+=4;
    s->wideLines = (VkBool32)memory->readd(address);address+=4;
    s->largePoints = (VkBool32)memory->readd(address);address+=4;
    s->alphaToOne = (VkBool32)memory->readd(address);address+=4;
    s->multiViewport = (VkBool32)memory->readd(address);address+=4;
    s->samplerAnisotropy = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionETC2 = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionASTC_LDR = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionBC = (VkBool32)memory->readd(address);address+=4;
    s->occlusionQueryPrecise = (VkBool32)memory->readd(address);address+=4;
    s->pipelineStatisticsQuery = (VkBool32)memory->readd(address);address+=4;
    s->vertexPipelineStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
    s->fragmentStoresAndAtomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderTessellationAndGeometryPointSize = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageGatherExtended = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageExtendedFormats = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageMultisample = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageReadWithoutFormat = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageWriteWithoutFormat = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderClipDistance = (VkBool32)memory->readd(address);address+=4;
    s->shaderCullDistance = (VkBool32)memory->readd(address);address+=4;
    s->shaderFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderResourceResidency = (VkBool32)memory->readd(address);address+=4;
    s->shaderResourceMinLod = (VkBool32)memory->readd(address);address+=4;
    s->sparseBinding = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyBuffer = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyImage2D = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyImage3D = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency2Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency4Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency8Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidency16Samples = (VkBool32)memory->readd(address);address+=4;
    s->sparseResidencyAliased = (VkBool32)memory->readd(address);address+=4;
    s->variableMultisampleRate = (VkBool32)memory->readd(address);address+=4;
    s->inheritedQueries = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFeatures* s) {
    memory->writed(address, s->robustBufferAccess);address+=4;
    memory->writed(address, s->fullDrawIndexUint32);address+=4;
    memory->writed(address, s->imageCubeArray);address+=4;
    memory->writed(address, s->independentBlend);address+=4;
    memory->writed(address, s->geometryShader);address+=4;
    memory->writed(address, s->tessellationShader);address+=4;
    memory->writed(address, s->sampleRateShading);address+=4;
    memory->writed(address, s->dualSrcBlend);address+=4;
    memory->writed(address, s->logicOp);address+=4;
    memory->writed(address, s->multiDrawIndirect);address+=4;
    memory->writed(address, s->drawIndirectFirstInstance);address+=4;
    memory->writed(address, s->depthClamp);address+=4;
    memory->writed(address, s->depthBiasClamp);address+=4;
    memory->writed(address, s->fillModeNonSolid);address+=4;
    memory->writed(address, s->depthBounds);address+=4;
    memory->writed(address, s->wideLines);address+=4;
    memory->writed(address, s->largePoints);address+=4;
    memory->writed(address, s->alphaToOne);address+=4;
    memory->writed(address, s->multiViewport);address+=4;
    memory->writed(address, s->samplerAnisotropy);address+=4;
    memory->writed(address, s->textureCompressionETC2);address+=4;
    memory->writed(address, s->textureCompressionASTC_LDR);address+=4;
    memory->writed(address, s->textureCompressionBC);address+=4;
    memory->writed(address, s->occlusionQueryPrecise);address+=4;
    memory->writed(address, s->pipelineStatisticsQuery);address+=4;
    memory->writed(address, s->vertexPipelineStoresAndAtomics);address+=4;
    memory->writed(address, s->fragmentStoresAndAtomics);address+=4;
    memory->writed(address, s->shaderTessellationAndGeometryPointSize);address+=4;
    memory->writed(address, s->shaderImageGatherExtended);address+=4;
    memory->writed(address, s->shaderStorageImageExtendedFormats);address+=4;
    memory->writed(address, s->shaderStorageImageMultisample);address+=4;
    memory->writed(address, s->shaderStorageImageReadWithoutFormat);address+=4;
    memory->writed(address, s->shaderStorageImageWriteWithoutFormat);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderSampledImageArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageImageArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderClipDistance);address+=4;
    memory->writed(address, s->shaderCullDistance);address+=4;
    memory->writed(address, s->shaderFloat64);address+=4;
    memory->writed(address, s->shaderInt64);address+=4;
    memory->writed(address, s->shaderInt16);address+=4;
    memory->writed(address, s->shaderResourceResidency);address+=4;
    memory->writed(address, s->shaderResourceMinLod);address+=4;
    memory->writed(address, s->sparseBinding);address+=4;
    memory->writed(address, s->sparseResidencyBuffer);address+=4;
    memory->writed(address, s->sparseResidencyImage2D);address+=4;
    memory->writed(address, s->sparseResidencyImage3D);address+=4;
    memory->writed(address, s->sparseResidency2Samples);address+=4;
    memory->writed(address, s->sparseResidency4Samples);address+=4;
    memory->writed(address, s->sparseResidency8Samples);address+=4;
    memory->writed(address, s->sparseResidency16Samples);address+=4;
    memory->writed(address, s->sparseResidencyAliased);address+=4;
    memory->writed(address, s->variableMultisampleRate);address+=4;
    memory->writed(address, s->inheritedQueries);address+=4;
}
void MarshalVkPhysicalDeviceLimits::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLimits* s) {
    s->maxImageDimension1D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimension2D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimension3D = (uint32_t)memory->readd(address);address+=4;
    s->maxImageDimensionCube = (uint32_t)memory->readd(address);address+=4;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxTexelBufferElements = (uint32_t)memory->readd(address);address+=4;
    s->maxUniformBufferRange = (uint32_t)memory->readd(address);address+=4;
    s->maxStorageBufferRange = (uint32_t)memory->readd(address);address+=4;
    s->maxPushConstantsSize = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationCount = (uint32_t)memory->readd(address);address+=4;
    s->maxSamplerAllocationCount = (uint32_t)memory->readd(address);address+=4;
    s->bufferImageGranularity = (VkDeviceSize)memory->readq(address);address+=8;
    s->sparseAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxBoundDescriptorSets = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputAttributes = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputAttributeOffset = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexInputBindingStride = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationGenerationLevel = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationPatchSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerVertexInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerVertexOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlPerPatchOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationControlTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationEvaluationInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxTessellationEvaluationOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryShaderInvocations = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryOutputVertices = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryTotalOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentInputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentOutputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentDualSrcAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentCombinedOutputResources = (uint32_t)memory->readd(address);address+=4;
    s->maxComputeSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxComputeWorkGroupCount, address, 12);address+=12;
    s->maxComputeWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxComputeWorkGroupSize, address, 12);address+=12;
    s->subPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->subTexelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->mipmapPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->maxDrawIndexedIndexValue = (uint32_t)memory->readd(address);address+=4;
    s->maxDrawIndirectCount = (uint32_t)memory->readd(address);address+=4;
    MarshalFloat maxSamplerLodBiasFloat;
    maxSamplerLodBiasFloat.i = memory->readd(address);address+=4;
    s->maxSamplerLodBias = maxSamplerLodBiasFloat.f;
    MarshalFloat maxSamplerAnisotropyFloat;
    maxSamplerAnisotropyFloat.i = memory->readd(address);address+=4;
    s->maxSamplerAnisotropy = maxSamplerAnisotropyFloat.f;
    s->maxViewports = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxViewportDimensions, address, 8);address+=8;
    memory->memcpy(&s->viewportBoundsRange, address, 8);address+=8;
    s->viewportSubPixelBits = (uint32_t)memory->readd(address);address+=4;
    s->minMemoryMapAlignment = (size_t)memory->readd(address);address+=4;
    s->minTexelBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minUniformBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minStorageBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minTexelOffset = (int32_t)memory->readd(address);address+=4;
    s->maxTexelOffset = (uint32_t)memory->readd(address);address+=4;
    s->minTexelGatherOffset = (int32_t)memory->readd(address);address+=4;
    s->maxTexelGatherOffset = (uint32_t)memory->readd(address);address+=4;
    MarshalFloat minInterpolationOffsetFloat;
    minInterpolationOffsetFloat.i = memory->readd(address);address+=4;
    s->minInterpolationOffset = minInterpolationOffsetFloat.f;
    MarshalFloat maxInterpolationOffsetFloat;
    maxInterpolationOffsetFloat.i = memory->readd(address);address+=4;
    s->maxInterpolationOffset = maxInterpolationOffsetFloat.f;
    s->subPixelInterpolationOffsetBits = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferWidth = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferHeight = (uint32_t)memory->readd(address);address+=4;
    s->maxFramebufferLayers = (uint32_t)memory->readd(address);address+=4;
    s->framebufferColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->framebufferNoAttachmentsSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->maxColorAttachments = (uint32_t)memory->readd(address);address+=4;
    s->sampledImageColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageIntegerSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageDepthSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->sampledImageStencilSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->storageImageSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->maxSampleMaskWords = (uint32_t)memory->readd(address);address+=4;
    s->timestampComputeAndGraphics = (VkBool32)memory->readd(address);address+=4;
    MarshalFloat timestampPeriodFloat;
    timestampPeriodFloat.i = memory->readd(address);address+=4;
    s->timestampPeriod = timestampPeriodFloat.f;
    s->maxClipDistances = (uint32_t)memory->readd(address);address+=4;
    s->maxCullDistances = (uint32_t)memory->readd(address);address+=4;
    s->maxCombinedClipAndCullDistances = (uint32_t)memory->readd(address);address+=4;
    s->discreteQueuePriorities = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->pointSizeRange, address, 8);address+=8;
    memory->memcpy(&s->lineWidthRange, address, 8);address+=8;
    MarshalFloat pointSizeGranularityFloat;
    pointSizeGranularityFloat.i = memory->readd(address);address+=4;
    s->pointSizeGranularity = pointSizeGranularityFloat.f;
    MarshalFloat lineWidthGranularityFloat;
    lineWidthGranularityFloat.i = memory->readd(address);address+=4;
    s->lineWidthGranularity = lineWidthGranularityFloat.f;
    s->strictLines = (VkBool32)memory->readd(address);address+=4;
    s->standardSampleLocations = (VkBool32)memory->readd(address);address+=4;
    s->optimalBufferCopyOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->optimalBufferCopyRowPitchAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->nonCoherentAtomSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkSemaphoreCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSemaphoreCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkSemaphoreCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkSemaphoreCreateInfo::~MarshalVkSemaphoreCreateInfo() {
    delete s.pNext;
}
void MarshalVkQueryPoolCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkQueryPoolCreateFlags)memory->readd(address);address+=4;
    s->queryType = (VkQueryType)memory->readd(address);address+=4;
    s->queryCount = (uint32_t)memory->readd(address);address+=4;
    s->pipelineStatistics = (VkQueryPipelineStatisticFlags)memory->readd(address);address+=4;
}
void MarshalVkQueryPoolCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queryType);address+=4;
    memory->writed(address, s->queryCount);address+=4;
    memory->writed(address, s->pipelineStatistics);address+=4;
}
MarshalVkQueryPoolCreateInfo::~MarshalVkQueryPoolCreateInfo() {
    delete s.pNext;
}
void MarshalVkFramebufferCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkFramebufferCreateFlags)memory->readd(address);address+=4;
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        s->pAttachments = new VkImageView[(U32)s->attachmentCount];
        memory->memcpy((VkImageView*)s->pAttachments, paramAddress, (U32)s->attachmentCount);
    }
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
    s->layers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkFramebufferCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->width);address+=4;
    memory->writed(address, s->height);address+=4;
    memory->writed(address, s->layers);address+=4;
}
MarshalVkFramebufferCreateInfo::~MarshalVkFramebufferCreateInfo() {
    delete s.pNext;
    delete[] s.pAttachments;
}
void MarshalVkMultiDrawInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiDrawInfoEXT* s) {
    s->firstVertex = (uint32_t)memory->readd(address);address+=4;
    s->vertexCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMultiDrawIndexedInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiDrawIndexedInfoEXT* s) {
    s->firstIndex = (uint32_t)memory->readd(address);address+=4;
    s->indexCount = (uint32_t)memory->readd(address);address+=4;
    s->vertexOffset = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitDstStageMask = NULL;
    } else {
        s->pWaitDstStageMask = new VkPipelineStageFlags[(U32)s->waitSemaphoreCount];
        memory->memcpy((VkPipelineStageFlags*)s->pWaitDstStageMask, paramAddress, (U32)s->waitSemaphoreCount);
    }
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBuffers = NULL;
    } else {
        VkCommandBuffer* pCommandBuffers = new VkCommandBuffer[s->commandBufferCount];
        for (int i=0;i<(int)s->commandBufferCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            pCommandBuffers[i] = (VkCommandBuffer)getVulkanPtr(memory, itemAddress);
        }
        s->pCommandBuffers = pCommandBuffers;
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphores = NULL;
    } else {
        s->pSignalSemaphores = new VkSemaphore[(U32)s->signalSemaphoreCount];
        memory->memcpy((VkSemaphore*)s->pSignalSemaphores, paramAddress, (U32)s->signalSemaphoreCount);
    }
}
void MarshalVkSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->commandBufferCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSubmitInfo::~MarshalVkSubmitInfo() {
    delete s.pNext;
    delete[] s.pWaitSemaphores;
    delete[] s.pWaitDstStageMask;
    delete s.pCommandBuffers;
    delete[] s.pSignalSemaphores;
}
void MarshalVkDisplaySurfaceStereoCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplaySurfaceStereoCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stereoType = (VkDisplaySurfaceStereoTypeNV)memory->readd(address);address+=4;
}
void MarshalVkDisplaySurfaceStereoCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplaySurfaceStereoCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stereoType);address+=4;
}
MarshalVkDisplaySurfaceStereoCreateInfoNV::~MarshalVkDisplaySurfaceStereoCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkDisplayPresentInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->srcRect, address, 16);address+=16;
    memory->memcpy(&s->dstRect, address, 16);address+=16;
    s->persistent = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDisplayPresentInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->srcRect, 16); address+=16;
    memory->memcpy(address, &s->dstRect, 16); address+=16;
    memory->writed(address, s->persistent);address+=4;
}
MarshalVkDisplayPresentInfoKHR::~MarshalVkDisplayPresentInfoKHR() {
    delete s.pNext;
}
void MarshalVkSurfaceCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->maxImageCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->currentExtent, address, 8);address+=8;
    memory->memcpy(&s->minImageExtent, address, 8);address+=8;
    memory->memcpy(&s->maxImageExtent, address, 8);address+=8;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
    s->currentTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)memory->readd(address);address+=4;
    s->supportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkSurfaceCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilitiesKHR* s) {
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->maxImageCount);address+=4;
    memory->memcpy(address, &s->currentExtent, 8); address+=8;
    memory->memcpy(address, &s->minImageExtent, 8); address+=8;
    memory->memcpy(address, &s->maxImageExtent, 8); address+=8;
    memory->writed(address, s->maxImageArrayLayers);address+=4;
    memory->writed(address, s->supportedTransforms);address+=4;
    memory->writed(address, s->currentTransform);address+=4;
    memory->writed(address, s->supportedCompositeAlpha);address+=4;
    memory->writed(address, s->supportedUsageFlags);address+=4;
}
void MarshalVkSurfaceFormatKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceFormatKHR* s) {
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->colorSpace = (VkColorSpaceKHR)memory->readd(address);address+=4;
}
void MarshalVkSurfaceFormatKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceFormatKHR* s) {
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->colorSpace);address+=4;
}
void MarshalVkSwapchainCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSwapchainCreateFlagsKHR)memory->readd(address);address+=4;
    s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->imageFormat = (VkFormat)memory->readd(address);address+=4;
    s->imageColorSpace = (VkColorSpaceKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->imageExtent, address, 8);address+=8;
    s->imageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->imageUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->imageSharingMode = (VkSharingMode)memory->readd(address);address+=4;
    s->queueFamilyIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueFamilyIndices = NULL;
    } else {
        s->pQueueFamilyIndices = new uint32_t[(U32)s->queueFamilyIndexCount];
        memory->memcpy((uint32_t*)s->pQueueFamilyIndices, paramAddress, (U32)s->queueFamilyIndexCount);
    }
    s->preTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->compositeAlpha = (VkCompositeAlphaFlagBitsKHR)memory->readd(address);address+=4;
    s->presentMode = (VkPresentModeKHR)memory->readd(address);address+=4;
    s->clipped = (VkBool32)memory->readd(address);address+=4;
    s->oldSwapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
}
void MarshalVkSwapchainCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->surface);address+=8;
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->imageFormat);address+=4;
    memory->writed(address, s->imageColorSpace);address+=4;
    memory->memcpy(address, &s->imageExtent, 8); address+=8;
    memory->writed(address, s->imageArrayLayers);address+=4;
    memory->writed(address, s->imageUsage);address+=4;
    memory->writed(address, s->imageSharingMode);address+=4;
    memory->writed(address, s->queueFamilyIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->preTransform);address+=4;
    memory->writed(address, s->compositeAlpha);address+=4;
    memory->writed(address, s->presentMode);address+=4;
    memory->writed(address, s->clipped);address+=4;
    memory->writeq(address, (U64)s->oldSwapchain);address+=8;
}
MarshalVkSwapchainCreateInfoKHR::~MarshalVkSwapchainCreateInfoKHR() {
    delete s.pNext;
    delete[] s.pQueueFamilyIndices;
}
void MarshalVkPresentInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphores = NULL;
    } else {
        s->pWaitSemaphores = new VkSemaphore[(U32)s->waitSemaphoreCount];
        memory->memcpy((VkSemaphore*)s->pWaitSemaphores, paramAddress, (U32)s->waitSemaphoreCount);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSwapchains = NULL;
    } else {
        s->pSwapchains = new VkSwapchainKHR[(U32)s->swapchainCount];
        memory->memcpy((VkSwapchainKHR*)s->pSwapchains, paramAddress, (U32)s->swapchainCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageIndices = NULL;
    } else {
        s->pImageIndices = new uint32_t[(U32)s->swapchainCount];
        memory->memcpy((uint32_t*)s->pImageIndices, paramAddress, (U32)s->swapchainCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResults = NULL;
    } else {
        s->pResults = new VkResult[(U32)s->swapchainCount];
        memory->memcpy((VkResult*)s->pResults, paramAddress, (U32)s->swapchainCount);
    }
}
void MarshalVkPresentInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPresentInfoKHR::~MarshalVkPresentInfoKHR() {
    delete s.pNext;
    delete[] s.pWaitSemaphores;
    delete[] s.pSwapchains;
    delete[] s.pImageIndices;
    delete[] s.pResults;
}
void MarshalVkDebugReportCallbackCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugReportCallbackCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDebugReportFlagsEXT)memory->readd(address);address+=4;
    s->pfnCallback = boxed_vkDebugReportCallbackEXT;
    MarshalCallbackData* pData = new MarshalCallbackData();
    pData->callbackAddress = memory->readd(address); address += 4;
    pData->userData = memory->readd(address);address+=4;
    s->pUserData = pData;
}
void MarshalVkDebugReportCallbackCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugReportCallbackCreateInfoEXT* s) {
    kpanic("MarshalVkDebugReportCallbackCreateInfoEXT::write");
}
MarshalVkDebugReportCallbackCreateInfoEXT::~MarshalVkDebugReportCallbackCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkValidationFlagsEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationFlagsEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->disabledValidationCheckCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDisabledValidationChecks = NULL;
    } else {
        s->pDisabledValidationChecks = new VkValidationCheckEXT[(U32)s->disabledValidationCheckCount];
        memory->memcpy((VkValidationCheckEXT*)s->pDisabledValidationChecks, paramAddress, (U32)s->disabledValidationCheckCount);
    }
}
void MarshalVkValidationFlagsEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationFlagsEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->disabledValidationCheckCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkValidationFlagsEXT::~MarshalVkValidationFlagsEXT() {
    delete s.pNext;
    delete[] s.pDisabledValidationChecks;
}
void MarshalVkValidationFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->enabledValidationFeatureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pEnabledValidationFeatures = NULL;
    } else {
        s->pEnabledValidationFeatures = new VkValidationFeatureEnableEXT[(U32)s->enabledValidationFeatureCount];
        memory->memcpy((VkValidationFeatureEnableEXT*)s->pEnabledValidationFeatures, paramAddress, (U32)s->enabledValidationFeatureCount);
    }
    s->disabledValidationFeatureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDisabledValidationFeatures = NULL;
    } else {
        s->pDisabledValidationFeatures = new VkValidationFeatureDisableEXT[(U32)s->disabledValidationFeatureCount];
        memory->memcpy((VkValidationFeatureDisableEXT*)s->pDisabledValidationFeatures, paramAddress, (U32)s->disabledValidationFeatureCount);
    }
}
void MarshalVkValidationFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->enabledValidationFeatureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->disabledValidationFeatureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkValidationFeaturesEXT::~MarshalVkValidationFeaturesEXT() {
    delete s.pNext;
    delete[] s.pEnabledValidationFeatures;
    delete[] s.pDisabledValidationFeatures;
}
void MarshalVkLayerSettingsCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLayerSettingsCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->settingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSettings = NULL;
    } else {
        VkLayerSettingEXT* pSettings = new VkLayerSettingEXT[s->settingCount];
        for (U32 i = 0; i < s->settingCount; i++) {
            MarshalVkLayerSettingEXT::read(pBoxedInfo, memory, paramAddress + i*20, &pSettings[i]);
        }
        s->pSettings = pSettings;
    }
}
void MarshalVkLayerSettingsCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLayerSettingsCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->settingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkLayerSettingEXT* pSettings = new VkLayerSettingEXT();
        MarshalVkLayerSettingEXT::read(pBoxedInfo, memory, paramAddress, pSettings);
        s->pSettings = pSettings;
    }
}
MarshalVkLayerSettingsCreateInfoEXT::~MarshalVkLayerSettingsCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pSettings;
}
void MarshalVkLayerSettingEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLayerSettingEXT* s) {
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLayerName = NULL;
    } else {
        U32 pLayerNameLen = memory->strlen(paramAddress)+1;
        s->pLayerName = new char[pLayerNameLen];
        memory->memcpy((char*)s->pLayerName, paramAddress, pLayerNameLen);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSettingName = NULL;
    } else {
        U32 pSettingNameLen = memory->strlen(paramAddress)+1;
        s->pSettingName = new char[pSettingNameLen];
        memory->memcpy((char*)s->pSettingName, paramAddress, pSettingNameLen);
    }
    s->type = (VkLayerSettingTypeEXT)memory->readd(address);address+=4;
    s->valueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pValues = NULL;
    } else {
        s->pValues = new char[(U32)s->valueCount];
        memory->memcpy((void*)s->pValues, paramAddress, (U32)s->valueCount);
    }
}
MarshalVkLayerSettingEXT::~MarshalVkLayerSettingEXT() {
    delete[] s.pLayerName;
    delete[] s.pSettingName;
    delete[] s.pValues;
}
void MarshalVkPipelineRasterizationStateRasterizationOrderAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateRasterizationOrderAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rasterizationOrder = (VkRasterizationOrderAMD)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationStateRasterizationOrderAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateRasterizationOrderAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rasterizationOrder);address+=4;
}
MarshalVkPipelineRasterizationStateRasterizationOrderAMD::~MarshalVkPipelineRasterizationStateRasterizationOrderAMD() {
    delete s.pNext;
}
void MarshalVkDebugMarkerObjectNameInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerObjectNameInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->objectType = (VkDebugReportObjectTypeEXT)memory->readd(address);address+=4;
    s->object = (uint64_t)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjectName = NULL;
    } else {
        U32 pObjectNameLen = memory->strlen(paramAddress)+1;
        s->pObjectName = new char[pObjectNameLen];
        memory->memcpy((char*)s->pObjectName, paramAddress, pObjectNameLen);
    }
}
void MarshalVkDebugMarkerObjectNameInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerObjectNameInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->object);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDebugMarkerObjectNameInfoEXT::~MarshalVkDebugMarkerObjectNameInfoEXT() {
    delete s.pNext;
    delete[] s.pObjectName;
}
void MarshalVkDebugMarkerObjectTagInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerObjectTagInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->objectType = (VkDebugReportObjectTypeEXT)memory->readd(address);address+=4;
    s->object = (uint64_t)memory->readq(address);address+=8;
    s->tagName = (uint64_t)memory->readq(address);address+=8;
    s->tagSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTag = NULL;
    } else {
        s->pTag = new char[(U32)s->tagSize];
        memory->memcpy((void*)s->pTag, paramAddress, (U32)s->tagSize);
    }
}
void MarshalVkDebugMarkerObjectTagInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerObjectTagInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->object);address+=8;
    memory->writeq(address, s->tagName);address+=8;
    memory->writed(address, (U32)s->tagSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDebugMarkerObjectTagInfoEXT::~MarshalVkDebugMarkerObjectTagInfoEXT() {
    delete s.pNext;
    delete[] s.pTag;
}
void MarshalVkDebugMarkerMarkerInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerMarkerInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMarkerName = NULL;
    } else {
        U32 pMarkerNameLen = memory->strlen(paramAddress)+1;
        s->pMarkerName = new char[pMarkerNameLen];
        memory->memcpy((char*)s->pMarkerName, paramAddress, pMarkerNameLen);
    }
    memory->memcpy(&s->color, address, 16);address+=16;
}
void MarshalVkDebugMarkerMarkerInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugMarkerMarkerInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->color, 16); address+=16;
}
MarshalVkDebugMarkerMarkerInfoEXT::~MarshalVkDebugMarkerMarkerInfoEXT() {
    delete s.pNext;
    delete[] s.pMarkerName;
}
void MarshalVkDedicatedAllocationImageCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationImageCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDedicatedAllocationImageCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationImageCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dedicatedAllocation);address+=4;
}
MarshalVkDedicatedAllocationImageCreateInfoNV::~MarshalVkDedicatedAllocationImageCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkDedicatedAllocationBufferCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationBufferCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDedicatedAllocationBufferCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationBufferCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dedicatedAllocation);address+=4;
}
MarshalVkDedicatedAllocationBufferCreateInfoNV::~MarshalVkDedicatedAllocationBufferCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkDedicatedAllocationMemoryAllocateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationMemoryAllocateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkDedicatedAllocationMemoryAllocateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDedicatedAllocationMemoryAllocateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkDedicatedAllocationMemoryAllocateInfoNV::~MarshalVkDedicatedAllocationMemoryAllocateInfoNV() {
    delete s.pNext;
}
void MarshalVkExternalMemoryImageCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryImageCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryImageCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryImageCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExternalMemoryImageCreateInfoNV::~MarshalVkExternalMemoryImageCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkExportMemoryAllocateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportMemoryAllocateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkExportMemoryAllocateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportMemoryAllocateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExportMemoryAllocateInfoNV::~MarshalVkExportMemoryAllocateInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceGeneratedCommands = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceGeneratedCommands);address+=4;
}
MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::~MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceGeneratedCompute = (VkBool32)memory->readd(address);address+=4;
    s->deviceGeneratedComputePipelines = (VkBool32)memory->readd(address);address+=4;
    s->deviceGeneratedComputeCaptureReplay = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceGeneratedCompute);address+=4;
    memory->writed(address, s->deviceGeneratedComputePipelines);address+=4;
    memory->writed(address, s->deviceGeneratedComputeCaptureReplay);address+=4;
}
MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::~MarshalVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV() {
    delete s.pNext;
}
void MarshalVkDevicePrivateDataCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDevicePrivateDataCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->privateDataSlotRequestCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDevicePrivateDataCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDevicePrivateDataCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->privateDataSlotRequestCount);address+=4;
}
MarshalVkDevicePrivateDataCreateInfo::~MarshalVkDevicePrivateDataCreateInfo() {
    delete s.pNext;
}
void MarshalVkPrivateDataSlotCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPrivateDataSlotCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPrivateDataSlotCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkPrivateDataSlotCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPrivateDataSlotCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkPrivateDataSlotCreateInfo::~MarshalVkPrivateDataSlotCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePrivateDataFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrivateDataFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->privateData = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePrivateDataFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrivateDataFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->privateData);address+=4;
}
MarshalVkPhysicalDevicePrivateDataFeatures::~MarshalVkPhysicalDevicePrivateDataFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxGraphicsShaderGroupCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectSequenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsStreamCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenOffset = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsStreamStride = (uint32_t)memory->readd(address);address+=4;
    s->minSequencesCountBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
    s->minSequencesIndexBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
    s->minIndirectCommandsBufferOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxGraphicsShaderGroupCount);address+=4;
    memory->writed(address, s->maxIndirectSequenceCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsStreamCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenOffset);address+=4;
    memory->writed(address, s->maxIndirectCommandsStreamStride);address+=4;
    memory->writed(address, s->minSequencesCountBufferOffsetAlignment);address+=4;
    memory->writed(address, s->minSequencesIndexBufferOffsetAlignment);address+=4;
    memory->writed(address, s->minIndirectCommandsBufferOffsetAlignment);address+=4;
}
MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::~MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxMultiDrawCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxMultiDrawCount);address+=4;
}
MarshalVkPhysicalDeviceMultiDrawPropertiesEXT::~MarshalVkPhysicalDeviceMultiDrawPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkGraphicsShaderGroupCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsShaderGroupCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexInputState = NULL;
    } else {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTessellationState = NULL;
    } else {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
}
void MarshalVkGraphicsShaderGroupCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsShaderGroupCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineVertexInputStateCreateInfo* pVertexInputState = new VkPipelineVertexInputStateCreateInfo();
        MarshalVkPipelineVertexInputStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pVertexInputState);
        s->pVertexInputState = pVertexInputState;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineTessellationStateCreateInfo* pTessellationState = new VkPipelineTessellationStateCreateInfo();
        MarshalVkPipelineTessellationStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pTessellationState);
        s->pTessellationState = pTessellationState;
    }
}
MarshalVkGraphicsShaderGroupCreateInfoNV::~MarshalVkGraphicsShaderGroupCreateInfoNV() {
    delete s.pNext;
    delete[] s.pStages;
    delete s.pVertexInputState;
    delete s.pTessellationState;
}
void MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineShaderGroupsCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->groupCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGroups = NULL;
    } else {
        VkGraphicsShaderGroupCreateInfoNV* pGroups = new VkGraphicsShaderGroupCreateInfoNV[s->groupCount];
        for (U32 i = 0; i < s->groupCount; i++) {
            MarshalVkGraphicsShaderGroupCreateInfoNV::read(pBoxedInfo, memory, paramAddress + i*24, &pGroups[i]);
        }
        s->pGroups = pGroups;
    }
    s->pipelineCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelines = NULL;
    } else {
        s->pPipelines = new VkPipeline[(U32)s->pipelineCount];
        memory->memcpy((VkPipeline*)s->pPipelines, paramAddress, (U32)s->pipelineCount);
    }
}
void MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineShaderGroupsCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->groupCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkGraphicsShaderGroupCreateInfoNV* pGroups = new VkGraphicsShaderGroupCreateInfoNV();
        MarshalVkGraphicsShaderGroupCreateInfoNV::read(pBoxedInfo, memory, paramAddress, pGroups);
        s->pGroups = pGroups;
    }
    memory->writed(address, s->pipelineCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV::~MarshalVkGraphicsPipelineShaderGroupsCreateInfoNV() {
    delete s.pNext;
    delete[] s.pGroups;
    delete[] s.pPipelines;
}
void MarshalVkIndirectCommandsStreamNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsStreamNV* s) {
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkIndirectCommandsLayoutTokenNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->tokenType = (VkIndirectCommandsTokenTypeNV)memory->readd(address);address+=4;
    s->stream = (uint32_t)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->vertexBindingUnit = (uint32_t)memory->readd(address);address+=4;
    s->vertexDynamicStride = (VkBool32)memory->readd(address);address+=4;
    s->pushconstantPipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->pushconstantShaderStageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->pushconstantOffset = (uint32_t)memory->readd(address);address+=4;
    s->pushconstantSize = (uint32_t)memory->readd(address);address+=4;
    s->indirectStateFlags = (VkIndirectStateFlagsNV)memory->readd(address);address+=4;
    s->indexTypeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pIndexTypes = NULL;
    } else {
        s->pIndexTypes = new VkIndexType[(U32)s->indexTypeCount];
        memory->memcpy((VkIndexType*)s->pIndexTypes, paramAddress, (U32)s->indexTypeCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pIndexTypeValues = NULL;
    } else {
        s->pIndexTypeValues = new uint32_t[(U32)s->indexTypeCount];
        memory->memcpy((uint32_t*)s->pIndexTypeValues, paramAddress, (U32)s->indexTypeCount);
    }
}
void MarshalVkIndirectCommandsLayoutTokenNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->tokenType);address+=4;
    memory->writed(address, s->stream);address+=4;
    memory->writed(address, s->offset);address+=4;
    memory->writed(address, s->vertexBindingUnit);address+=4;
    memory->writed(address, s->vertexDynamicStride);address+=4;
    memory->writeq(address, (U64)s->pushconstantPipelineLayout);address+=8;
    memory->writed(address, s->pushconstantShaderStageFlags);address+=4;
    memory->writed(address, s->pushconstantOffset);address+=4;
    memory->writed(address, s->pushconstantSize);address+=4;
    memory->writed(address, s->indirectStateFlags);address+=4;
    memory->writed(address, s->indexTypeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkIndirectCommandsLayoutTokenNV::~MarshalVkIndirectCommandsLayoutTokenNV() {
    delete s.pNext;
    delete[] s.pIndexTypes;
    delete[] s.pIndexTypeValues;
}
void MarshalVkIndirectCommandsLayoutCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkIndirectCommandsLayoutUsageFlagsNV)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->tokenCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTokens = NULL;
    } else {
        VkIndirectCommandsLayoutTokenNV* pTokens = new VkIndirectCommandsLayoutTokenNV[s->tokenCount];
        for (U32 i = 0; i < s->tokenCount; i++) {
            MarshalVkIndirectCommandsLayoutTokenNV::read(pBoxedInfo, memory, paramAddress + i*64, &pTokens[i]);
        }
        s->pTokens = pTokens;
    }
    s->streamCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStreamStrides = NULL;
    } else {
        s->pStreamStrides = new uint32_t[(U32)s->streamCount];
        memory->memcpy((uint32_t*)s->pStreamStrides, paramAddress, (U32)s->streamCount);
    }
}
void MarshalVkIndirectCommandsLayoutCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writed(address, s->tokenCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectCommandsLayoutTokenNV* pTokens = new VkIndirectCommandsLayoutTokenNV();
        MarshalVkIndirectCommandsLayoutTokenNV::read(pBoxedInfo, memory, paramAddress, pTokens);
        s->pTokens = pTokens;
    }
    memory->writed(address, s->streamCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkIndirectCommandsLayoutCreateInfoNV::~MarshalVkIndirectCommandsLayoutCreateInfoNV() {
    delete s.pNext;
    delete[] s.pTokens;
    delete[] s.pStreamStrides;
}
void MarshalVkGeneratedCommandsInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
    s->streamCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStreams = NULL;
    } else {
        s->pStreams = new VkIndirectCommandsStreamNV[(U32)s->streamCount];
        memory->memcpy((VkIndirectCommandsStreamNV*)s->pStreams, paramAddress, (U32)s->streamCount * sizeof(VkIndirectCommandsStreamNV));
    }
    s->sequencesCount = (uint32_t)memory->readd(address);address+=4;
    s->preprocessBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->preprocessOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->preprocessSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->sequencesCountBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->sequencesCountOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->sequencesIndexBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->sequencesIndexOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeneratedCommandsInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writed(address, s->streamCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectCommandsStreamNV* pStreams = new VkIndirectCommandsStreamNV();
        MarshalVkIndirectCommandsStreamNV::read(pBoxedInfo, memory, paramAddress, pStreams);
        s->pStreams = pStreams;
    }
    memory->writed(address, s->sequencesCount);address+=4;
    memory->writeq(address, (U64)s->preprocessBuffer);address+=8;
    memory->writeq(address, s->preprocessOffset);address+=8;
    memory->writeq(address, s->preprocessSize);address+=8;
    memory->writeq(address, (U64)s->sequencesCountBuffer);address+=8;
    memory->writeq(address, s->sequencesCountOffset);address+=8;
    memory->writeq(address, (U64)s->sequencesIndexBuffer);address+=8;
    memory->writeq(address, s->sequencesIndexOffset);address+=8;
}
MarshalVkGeneratedCommandsInfoNV::~MarshalVkGeneratedCommandsInfoNV() {
    delete s.pNext;
    delete[] s.pStreams;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)memory->readq(address);address+=8;
    s->maxSequencesCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writed(address, s->maxSequencesCount);address+=4;
}
MarshalVkGeneratedCommandsMemoryRequirementsInfoNV::~MarshalVkGeneratedCommandsMemoryRequirementsInfoNV() {
    delete s.pNext;
}
void MarshalVkPipelineIndirectDeviceAddressInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineIndirectDeviceAddressInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkPipelineIndirectDeviceAddressInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineIndirectDeviceAddressInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
MarshalVkPipelineIndirectDeviceAddressInfoNV::~MarshalVkPipelineIndirectDeviceAddressInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFeatures2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->features, address, 220);address+=220;
}
void MarshalVkPhysicalDeviceFeatures2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFeatures2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->features, 220); address+=220;
}
MarshalVkPhysicalDeviceFeatures2::~MarshalVkPhysicalDeviceFeatures2() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalVkPhysicalDeviceProperties::read(pBoxedInfo, memory, address, &s->properties); address+=500;
}
void MarshalVkPhysicalDeviceProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->properties, 500); address+=500;
}
MarshalVkPhysicalDeviceProperties2::~MarshalVkPhysicalDeviceProperties2() {
    delete s.pNext;
}
void MarshalVkFormatProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->formatProperties, address, 12);address+=12;
}
void MarshalVkFormatProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->formatProperties, 12); address+=12;
}
MarshalVkFormatProperties2::~MarshalVkFormatProperties2() {
    delete s.pNext;
}
void MarshalVkImageFormatProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->imageFormatProperties, address, 32);address+=32;
}
void MarshalVkImageFormatProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->imageFormatProperties, 32); address+=32;
}
MarshalVkImageFormatProperties2::~MarshalVkImageFormatProperties2() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageFormatInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageFormatInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->type = (VkImageType)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageFormatInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageFormatInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->tiling);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkPhysicalDeviceImageFormatInfo2::~MarshalVkPhysicalDeviceImageFormatInfo2() {
    delete s.pNext;
}
void MarshalVkQueueFamilyProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->queueFamilyProperties, address, 24);address+=24;
}
void MarshalVkQueueFamilyProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->queueFamilyProperties, 24); address+=24;
}
MarshalVkQueueFamilyProperties2::~MarshalVkQueueFamilyProperties2() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMemoryProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->memoryProperties, address, 28);address+=28;
}
void MarshalVkPhysicalDeviceMemoryProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->memoryProperties, 28); address+=28;
}
MarshalVkPhysicalDeviceMemoryProperties2::~MarshalVkPhysicalDeviceMemoryProperties2() {
    delete s.pNext;
}
void MarshalVkSparseImageFormatProperties2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageFormatProperties2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->properties, address, 20);address+=20;
}
void MarshalVkSparseImageFormatProperties2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageFormatProperties2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->properties, 20); address+=20;
}
MarshalVkSparseImageFormatProperties2::~MarshalVkSparseImageFormatProperties2() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSparseImageFormatInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSparseImageFormatInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->type = (VkImageType)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->tiling = (VkImageTiling)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSparseImageFormatInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSparseImageFormatInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->tiling);address+=4;
}
MarshalVkPhysicalDeviceSparseImageFormatInfo2::~MarshalVkPhysicalDeviceSparseImageFormatInfo2() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePushDescriptorProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePushDescriptorProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxPushDescriptors = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePushDescriptorProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePushDescriptorProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxPushDescriptors);address+=4;
}
MarshalVkPhysicalDevicePushDescriptorProperties::~MarshalVkPhysicalDevicePushDescriptorProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDriverProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDriverProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->driverID = (VkDriverId)memory->readd(address);address+=4;
    memory->memcpy(&s->driverName, address, 256);address+=256;
    memory->memcpy(&s->driverInfo, address, 256);address+=256;
    memory->memcpy(&s->conformanceVersion, address, 4);address+=4;
}
void MarshalVkPhysicalDeviceDriverProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDriverProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->driverID);address+=4;
    memory->memcpy(address, s->driverName, 256); address+=256;
    memory->memcpy(address, s->driverInfo, 256); address+=256;
    memory->memcpy(address, &s->conformanceVersion, 4); address+=4;
}
MarshalVkPhysicalDeviceDriverProperties::~MarshalVkPhysicalDeviceDriverProperties() {
    delete s.pNext;
}
void MarshalVkPresentRegionsKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentRegionsKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        s->pRegions = new VkPresentRegionKHR[(U32)s->swapchainCount];
        memory->memcpy((VkPresentRegionKHR*)s->pRegions, paramAddress, (U32)s->swapchainCount * sizeof(VkPresentRegionKHR));
    }
}
void MarshalVkPresentRegionsKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentRegionsKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPresentRegionKHR* pRegions = new VkPresentRegionKHR();
        MarshalVkPresentRegionKHR::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkPresentRegionsKHR::~MarshalVkPresentRegionsKHR() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkPresentRegionKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentRegionKHR* s) {
    s->rectangleCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRectangles = NULL;
    } else {
        s->pRectangles = new VkRectLayerKHR[(U32)s->rectangleCount];
        memory->memcpy((VkRectLayerKHR*)s->pRectangles, paramAddress, (U32)s->rectangleCount * sizeof(VkRectLayerKHR));
    }
}
MarshalVkPresentRegionKHR::~MarshalVkPresentRegionKHR() {
    delete[] s.pRectangles;
}
void MarshalVkPhysicalDeviceVariablePointersFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVariablePointersFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->variablePointersStorageBuffer = (VkBool32)memory->readd(address);address+=4;
    s->variablePointers = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVariablePointersFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVariablePointersFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->variablePointersStorageBuffer);address+=4;
    memory->writed(address, s->variablePointers);address+=4;
}
MarshalVkPhysicalDeviceVariablePointersFeatures::~MarshalVkPhysicalDeviceVariablePointersFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExternalImageFormatInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalImageFormatInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalImageFormatInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalImageFormatInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleType);address+=4;
}
MarshalVkPhysicalDeviceExternalImageFormatInfo::~MarshalVkPhysicalDeviceExternalImageFormatInfo() {
    delete s.pNext;
}
void MarshalVkExternalImageFormatProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalImageFormatProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->externalMemoryProperties, address, 12);address+=12;
}
void MarshalVkExternalImageFormatProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalImageFormatProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->externalMemoryProperties, 12); address+=12;
}
MarshalVkExternalImageFormatProperties::~MarshalVkExternalImageFormatProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExternalBufferInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalBufferInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkBufferCreateFlags)memory->readd(address);address+=4;
    s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
    s->handleType = (VkExternalMemoryHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalBufferInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalBufferInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->handleType);address+=4;
}
MarshalVkPhysicalDeviceExternalBufferInfo::~MarshalVkPhysicalDeviceExternalBufferInfo() {
    delete s.pNext;
}
void MarshalVkExternalBufferProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalBufferProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->externalMemoryProperties, address, 12);address+=12;
}
void MarshalVkExternalBufferProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalBufferProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->externalMemoryProperties, 12); address+=12;
}
MarshalVkExternalBufferProperties::~MarshalVkExternalBufferProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceIDProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->deviceUUID, address, 16);address+=16;
    memory->memcpy(&s->driverUUID, address, 16);address+=16;
    memory->memcpy(&s->deviceLUID, address, 8);address+=8;
    s->deviceNodeMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceLUIDValid = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceIDProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceIDProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->deviceUUID, 16); address+=16;
    memory->memcpy(address, s->driverUUID, 16); address+=16;
    memory->memcpy(address, s->deviceLUID, 8); address+=8;
    memory->writed(address, s->deviceNodeMask);address+=4;
    memory->writed(address, s->deviceLUIDValid);address+=4;
}
MarshalVkPhysicalDeviceIDProperties::~MarshalVkPhysicalDeviceIDProperties() {
    delete s.pNext;
}
void MarshalVkExternalMemoryImageCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryImageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryImageCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryImageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExternalMemoryImageCreateInfo::~MarshalVkExternalMemoryImageCreateInfo() {
    delete s.pNext;
}
void MarshalVkExternalMemoryBufferCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryBufferCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryBufferCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryBufferCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExternalMemoryBufferCreateInfo::~MarshalVkExternalMemoryBufferCreateInfo() {
    delete s.pNext;
}
void MarshalVkExportMemoryAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportMemoryAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalMemoryHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportMemoryAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportMemoryAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExportMemoryAllocateInfo::~MarshalVkExportMemoryAllocateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExternalSemaphoreInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalSemaphoreInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleType = (VkExternalSemaphoreHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalSemaphoreInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalSemaphoreInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleType);address+=4;
}
MarshalVkPhysicalDeviceExternalSemaphoreInfo::~MarshalVkPhysicalDeviceExternalSemaphoreInfo() {
    delete s.pNext;
}
void MarshalVkExternalSemaphoreProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->exportFromImportedHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
    s->compatibleHandleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
    s->externalSemaphoreFeatures = (VkExternalSemaphoreFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalSemaphoreProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalSemaphoreProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
    memory->writed(address, s->compatibleHandleTypes);address+=4;
    memory->writed(address, s->externalSemaphoreFeatures);address+=4;
}
MarshalVkExternalSemaphoreProperties::~MarshalVkExternalSemaphoreProperties() {
    delete s.pNext;
}
void MarshalVkExportSemaphoreCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportSemaphoreCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalSemaphoreHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportSemaphoreCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportSemaphoreCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExportSemaphoreCreateInfo::~MarshalVkExportSemaphoreCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExternalFenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalFenceInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleType = (VkExternalFenceHandleTypeFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExternalFenceInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalFenceInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleType);address+=4;
}
MarshalVkPhysicalDeviceExternalFenceInfo::~MarshalVkPhysicalDeviceExternalFenceInfo() {
    delete s.pNext;
}
void MarshalVkExternalFenceProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalFenceProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->exportFromImportedHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
    s->compatibleHandleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
    s->externalFenceFeatures = (VkExternalFenceFeatureFlags)memory->readd(address);address+=4;
}
void MarshalVkExternalFenceProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalFenceProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->exportFromImportedHandleTypes);address+=4;
    memory->writed(address, s->compatibleHandleTypes);address+=4;
    memory->writed(address, s->externalFenceFeatures);address+=4;
}
MarshalVkExternalFenceProperties::~MarshalVkExternalFenceProperties() {
    delete s.pNext;
}
void MarshalVkExportFenceCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportFenceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->handleTypes = (VkExternalFenceHandleTypeFlags)memory->readd(address);address+=4;
}
void MarshalVkExportFenceCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExportFenceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->handleTypes);address+=4;
}
MarshalVkExportFenceCreateInfo::~MarshalVkExportFenceCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiviewFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multiview = (VkBool32)memory->readd(address);address+=4;
    s->multiviewGeometryShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewTessellationShader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multiview);address+=4;
    memory->writed(address, s->multiviewGeometryShader);address+=4;
    memory->writed(address, s->multiviewTessellationShader);address+=4;
}
MarshalVkPhysicalDeviceMultiviewFeatures::~MarshalVkPhysicalDeviceMultiviewFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiviewProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMultiviewInstanceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxMultiviewViewCount);address+=4;
    memory->writed(address, s->maxMultiviewInstanceIndex);address+=4;
}
MarshalVkPhysicalDeviceMultiviewProperties::~MarshalVkPhysicalDeviceMultiviewProperties() {
    delete s.pNext;
}
void MarshalVkRenderPassMultiviewCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassMultiviewCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewMasks = NULL;
    } else {
        s->pViewMasks = new uint32_t[(U32)s->subpassCount];
        memory->memcpy((uint32_t*)s->pViewMasks, paramAddress, (U32)s->subpassCount);
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewOffsets = NULL;
    } else {
        s->pViewOffsets = new int32_t[(U32)s->dependencyCount];
        memory->memcpy((int32_t*)s->pViewOffsets, paramAddress, (U32)s->dependencyCount);
    }
    s->correlationMaskCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCorrelationMasks = NULL;
    } else {
        s->pCorrelationMasks = new uint32_t[(U32)s->correlationMaskCount];
        memory->memcpy((uint32_t*)s->pCorrelationMasks, paramAddress, (U32)s->correlationMaskCount);
    }
}
void MarshalVkRenderPassMultiviewCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassMultiviewCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->correlationMaskCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRenderPassMultiviewCreateInfo::~MarshalVkRenderPassMultiviewCreateInfo() {
    delete s.pNext;
    delete[] s.pViewMasks;
    delete[] s.pViewOffsets;
    delete[] s.pCorrelationMasks;
}
void MarshalVkSurfaceCapabilities2EXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilities2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minImageCount = (uint32_t)memory->readd(address);address+=4;
    s->maxImageCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->currentExtent, address, 8);address+=8;
    memory->memcpy(&s->minImageExtent, address, 8);address+=8;
    memory->memcpy(&s->maxImageExtent, address, 8);address+=8;
    s->maxImageArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->supportedTransforms = (VkSurfaceTransformFlagsKHR)memory->readd(address);address+=4;
    s->currentTransform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    s->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)memory->readd(address);address+=4;
    s->supportedUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->supportedSurfaceCounters = (VkSurfaceCounterFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkSurfaceCapabilities2EXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilities2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minImageCount);address+=4;
    memory->writed(address, s->maxImageCount);address+=4;
    memory->memcpy(address, &s->currentExtent, 8); address+=8;
    memory->memcpy(address, &s->minImageExtent, 8); address+=8;
    memory->memcpy(address, &s->maxImageExtent, 8); address+=8;
    memory->writed(address, s->maxImageArrayLayers);address+=4;
    memory->writed(address, s->supportedTransforms);address+=4;
    memory->writed(address, s->currentTransform);address+=4;
    memory->writed(address, s->supportedCompositeAlpha);address+=4;
    memory->writed(address, s->supportedUsageFlags);address+=4;
    memory->writed(address, s->supportedSurfaceCounters);address+=4;
}
MarshalVkSurfaceCapabilities2EXT::~MarshalVkSurfaceCapabilities2EXT() {
    delete s.pNext;
}
void MarshalVkDisplayPowerInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPowerInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->powerState = (VkDisplayPowerStateEXT)memory->readd(address);address+=4;
}
void MarshalVkDisplayPowerInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPowerInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->powerState);address+=4;
}
MarshalVkDisplayPowerInfoEXT::~MarshalVkDisplayPowerInfoEXT() {
    delete s.pNext;
}
void MarshalVkDeviceEventInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceEventInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceEvent = (VkDeviceEventTypeEXT)memory->readd(address);address+=4;
}
void MarshalVkDeviceEventInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceEventInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceEvent);address+=4;
}
MarshalVkDeviceEventInfoEXT::~MarshalVkDeviceEventInfoEXT() {
    delete s.pNext;
}
void MarshalVkDisplayEventInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayEventInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->displayEvent = (VkDisplayEventTypeEXT)memory->readd(address);address+=4;
}
void MarshalVkDisplayEventInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayEventInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->displayEvent);address+=4;
}
MarshalVkDisplayEventInfoEXT::~MarshalVkDisplayEventInfoEXT() {
    delete s.pNext;
}
void MarshalVkSwapchainCounterCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainCounterCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->surfaceCounters = (VkSurfaceCounterFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkSwapchainCounterCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainCounterCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->surfaceCounters);address+=4;
}
MarshalVkSwapchainCounterCreateInfoEXT::~MarshalVkSwapchainCounterCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceGroupProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGroupProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->physicalDeviceCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->physicalDevices, address, 128);address+=128;
    s->subsetAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGroupProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGroupProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->physicalDeviceCount);address+=4;
    memory->memcpy(address, s->physicalDevices, 128); address+=128;
    memory->writed(address, s->subsetAllocation);address+=4;
}
MarshalVkPhysicalDeviceGroupProperties::~MarshalVkPhysicalDeviceGroupProperties() {
    delete s.pNext;
}
void MarshalVkMemoryAllocateFlagsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryAllocateFlagsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkMemoryAllocateFlags)memory->readd(address);address+=4;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryAllocateFlagsInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryAllocateFlagsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->deviceMask);address+=4;
}
MarshalVkMemoryAllocateFlagsInfo::~MarshalVkMemoryAllocateFlagsInfo() {
    delete s.pNext;
}
void MarshalVkBindBufferMemoryInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindBufferMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBindBufferMemoryInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindBufferMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
}
MarshalVkBindBufferMemoryInfo::~MarshalVkBindBufferMemoryInfo() {
    delete s.pNext;
}
void MarshalVkBindBufferMemoryDeviceGroupInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindBufferMemoryDeviceGroupInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount);
    }
}
void MarshalVkBindBufferMemoryDeviceGroupInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindBufferMemoryDeviceGroupInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkBindBufferMemoryDeviceGroupInfo::~MarshalVkBindBufferMemoryDeviceGroupInfo() {
    delete s.pNext;
    delete[] s.pDeviceIndices;
}
void MarshalVkBindImageMemoryInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBindImageMemoryInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
}
MarshalVkBindImageMemoryInfo::~MarshalVkBindImageMemoryInfo() {
    delete s.pNext;
}
void MarshalVkBindImageMemoryDeviceGroupInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemoryDeviceGroupInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount);
    }
    s->splitInstanceBindRegionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSplitInstanceBindRegions = NULL;
    } else {
        s->pSplitInstanceBindRegions = new VkRect2D[(U32)s->splitInstanceBindRegionCount];
        memory->memcpy((VkRect2D*)s->pSplitInstanceBindRegions, paramAddress, (U32)s->splitInstanceBindRegionCount * sizeof(VkRect2D));
    }
}
void MarshalVkBindImageMemoryDeviceGroupInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemoryDeviceGroupInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->splitInstanceBindRegionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pSplitInstanceBindRegions = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pSplitInstanceBindRegions);
        s->pSplitInstanceBindRegions = pSplitInstanceBindRegions;
    }
}
MarshalVkBindImageMemoryDeviceGroupInfo::~MarshalVkBindImageMemoryDeviceGroupInfo() {
    delete s.pNext;
    delete[] s.pDeviceIndices;
    delete[] s.pSplitInstanceBindRegions;
}
void MarshalVkDeviceGroupRenderPassBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupRenderPassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceRenderAreaCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceRenderAreas = NULL;
    } else {
        s->pDeviceRenderAreas = new VkRect2D[(U32)s->deviceRenderAreaCount];
        memory->memcpy((VkRect2D*)s->pDeviceRenderAreas, paramAddress, (U32)s->deviceRenderAreaCount * sizeof(VkRect2D));
    }
}
void MarshalVkDeviceGroupRenderPassBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupRenderPassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceMask);address+=4;
    memory->writed(address, s->deviceRenderAreaCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pDeviceRenderAreas = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pDeviceRenderAreas);
        s->pDeviceRenderAreas = pDeviceRenderAreas;
    }
}
MarshalVkDeviceGroupRenderPassBeginInfo::~MarshalVkDeviceGroupRenderPassBeginInfo() {
    delete s.pNext;
    delete[] s.pDeviceRenderAreas;
}
void MarshalVkDeviceGroupCommandBufferBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupCommandBufferBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupCommandBufferBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupCommandBufferBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceMask);address+=4;
}
MarshalVkDeviceGroupCommandBufferBeginInfo::~MarshalVkDeviceGroupCommandBufferBeginInfo() {
    delete s.pNext;
}
void MarshalVkDeviceGroupSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->waitSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreDeviceIndices = NULL;
    } else {
        s->pWaitSemaphoreDeviceIndices = new uint32_t[(U32)s->waitSemaphoreCount];
        memory->memcpy((uint32_t*)s->pWaitSemaphoreDeviceIndices, paramAddress, (U32)s->waitSemaphoreCount);
    }
    s->commandBufferCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBufferDeviceMasks = NULL;
    } else {
        s->pCommandBufferDeviceMasks = new uint32_t[(U32)s->commandBufferCount];
        memory->memcpy((uint32_t*)s->pCommandBufferDeviceMasks, paramAddress, (U32)s->commandBufferCount);
    }
    s->signalSemaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreDeviceIndices = NULL;
    } else {
        s->pSignalSemaphoreDeviceIndices = new uint32_t[(U32)s->signalSemaphoreCount];
        memory->memcpy((uint32_t*)s->pSignalSemaphoreDeviceIndices, paramAddress, (U32)s->signalSemaphoreCount);
    }
}
void MarshalVkDeviceGroupSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->waitSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->commandBufferCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDeviceGroupSubmitInfo::~MarshalVkDeviceGroupSubmitInfo() {
    delete s.pNext;
    delete[] s.pWaitSemaphoreDeviceIndices;
    delete[] s.pCommandBufferDeviceMasks;
    delete[] s.pSignalSemaphoreDeviceIndices;
}
void MarshalVkDeviceGroupBindSparseInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupBindSparseInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->resourceDeviceIndex = (uint32_t)memory->readd(address);address+=4;
    s->memoryDeviceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupBindSparseInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupBindSparseInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->resourceDeviceIndex);address+=4;
    memory->writed(address, s->memoryDeviceIndex);address+=4;
}
MarshalVkDeviceGroupBindSparseInfo::~MarshalVkDeviceGroupBindSparseInfo() {
    delete s.pNext;
}
void MarshalVkDeviceGroupPresentCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->presentMask, address, 128);address+=128;
    s->modes = (VkDeviceGroupPresentModeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupPresentCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupPresentCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->presentMask, 128); address+=128;
    memory->writed(address, s->modes);address+=4;
}
MarshalVkDeviceGroupPresentCapabilitiesKHR::~MarshalVkDeviceGroupPresentCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkImageSwapchainCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
}
void MarshalVkImageSwapchainCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
}
MarshalVkImageSwapchainCreateInfoKHR::~MarshalVkImageSwapchainCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkBindImageMemorySwapchainInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemorySwapchainInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    s->imageIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkBindImageMemorySwapchainInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImageMemorySwapchainInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
    memory->writed(address, s->imageIndex);address+=4;
}
MarshalVkBindImageMemorySwapchainInfoKHR::~MarshalVkBindImageMemorySwapchainInfoKHR() {
    delete s.pNext;
}
void MarshalVkAcquireNextImageInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAcquireNextImageInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    s->timeout = (uint64_t)memory->readq(address);address+=8;
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->fence = (VkFence)memory->readq(address);address+=8;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkAcquireNextImageInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAcquireNextImageInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
    memory->writeq(address, s->timeout);address+=8;
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, (U64)s->fence);address+=8;
    memory->writed(address, s->deviceMask);address+=4;
}
MarshalVkAcquireNextImageInfoKHR::~MarshalVkAcquireNextImageInfoKHR() {
    delete s.pNext;
}
void MarshalVkDeviceGroupPresentInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupPresentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceMasks = NULL;
    } else {
        s->pDeviceMasks = new uint32_t[(U32)s->swapchainCount];
        memory->memcpy((uint32_t*)s->pDeviceMasks, paramAddress, (U32)s->swapchainCount);
    }
    s->mode = (VkDeviceGroupPresentModeFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupPresentInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupPresentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->mode);address+=4;
}
MarshalVkDeviceGroupPresentInfoKHR::~MarshalVkDeviceGroupPresentInfoKHR() {
    delete s.pNext;
    delete[] s.pDeviceMasks;
}
void MarshalVkDeviceGroupDeviceCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupDeviceCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->physicalDeviceCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPhysicalDevices = NULL;
    } else {
        VkPhysicalDevice* pPhysicalDevices = new VkPhysicalDevice[s->physicalDeviceCount];
        for (int i=0;i<(int)s->physicalDeviceCount;i++) {
            U32 itemAddress = memory->readd(paramAddress + i*4);
            pPhysicalDevices[i] = (VkPhysicalDevice)getVulkanPtr(memory, itemAddress);
        }
        s->pPhysicalDevices = pPhysicalDevices;
    }
}
void MarshalVkDeviceGroupDeviceCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupDeviceCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->physicalDeviceCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDeviceGroupDeviceCreateInfo::~MarshalVkDeviceGroupDeviceCreateInfo() {
    delete s.pNext;
    delete s.pPhysicalDevices;
}
void MarshalVkDeviceGroupSwapchainCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupSwapchainCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->modes = (VkDeviceGroupPresentModeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkDeviceGroupSwapchainCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceGroupSwapchainCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->modes);address+=4;
}
MarshalVkDeviceGroupSwapchainCreateInfoKHR::~MarshalVkDeviceGroupSwapchainCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkDescriptorUpdateTemplateEntry::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorUpdateTemplateEntry* s) {
    s->dstBinding = (uint32_t)memory->readd(address);address+=4;
    s->dstArrayElement = (uint32_t)memory->readd(address);address+=4;
    s->descriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->offset = (size_t)memory->readd(address);address+=4;
    s->stride = (size_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorUpdateTemplateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorUpdateTemplateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDescriptorUpdateTemplateCreateFlags)memory->readd(address);address+=4;
    s->descriptorUpdateEntryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorUpdateEntries = NULL;
    } else {
        VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = new VkDescriptorUpdateTemplateEntry[s->descriptorUpdateEntryCount];
        for (U32 i = 0; i < s->descriptorUpdateEntryCount; i++) {
            MarshalVkDescriptorUpdateTemplateEntry::read(pBoxedInfo, memory, paramAddress + i*24, &pDescriptorUpdateEntries[i]);
        }
        s->pDescriptorUpdateEntries = pDescriptorUpdateEntries;
    }
    s->templateType = (VkDescriptorUpdateTemplateType)memory->readd(address);address+=4;
    s->descriptorSetLayout = (VkDescriptorSetLayout)memory->readq(address);address+=8;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->pipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->set = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorUpdateTemplateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorUpdateTemplateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->descriptorUpdateEntryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = new VkDescriptorUpdateTemplateEntry();
        MarshalVkDescriptorUpdateTemplateEntry::read(pBoxedInfo, memory, paramAddress, pDescriptorUpdateEntries);
        s->pDescriptorUpdateEntries = pDescriptorUpdateEntries;
    }
    memory->writed(address, s->templateType);address+=4;
    memory->writeq(address, (U64)s->descriptorSetLayout);address+=8;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writeq(address, (U64)s->pipelineLayout);address+=8;
    memory->writed(address, s->set);address+=4;
}
MarshalVkDescriptorUpdateTemplateCreateInfo::~MarshalVkDescriptorUpdateTemplateCreateInfo() {
    delete s.pNext;
    delete[] s.pDescriptorUpdateEntries;
}
void MarshalVkPhysicalDevicePresentIdFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentIdFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentId = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePresentIdFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentIdFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentId);address+=4;
}
MarshalVkPhysicalDevicePresentIdFeaturesKHR::~MarshalVkPhysicalDevicePresentIdFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPresentIdKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentIdKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentIds = NULL;
    } else {
        s->pPresentIds = new uint64_t[(U32)s->swapchainCount];
        memory->memcpy((uint64_t*)s->pPresentIds, paramAddress, (U32)s->swapchainCount);
    }
}
void MarshalVkPresentIdKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPresentIdKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPresentIdKHR::~MarshalVkPresentIdKHR() {
    delete s.pNext;
    delete[] s.pPresentIds;
}
void MarshalVkPhysicalDevicePresentWaitFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentWaitFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentWait = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePresentWaitFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentWaitFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentWait);address+=4;
}
MarshalVkPhysicalDevicePresentWaitFeaturesKHR::~MarshalVkPhysicalDevicePresentWaitFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkHdrMetadataEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHdrMetadataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->displayPrimaryRed, address, 8);address+=8;
    memory->memcpy(&s->displayPrimaryGreen, address, 8);address+=8;
    memory->memcpy(&s->displayPrimaryBlue, address, 8);address+=8;
    memory->memcpy(&s->whitePoint, address, 8);address+=8;
    MarshalFloat maxLuminanceFloat;
    maxLuminanceFloat.i = memory->readd(address);address+=4;
    s->maxLuminance = maxLuminanceFloat.f;
    MarshalFloat minLuminanceFloat;
    minLuminanceFloat.i = memory->readd(address);address+=4;
    s->minLuminance = minLuminanceFloat.f;
    MarshalFloat maxContentLightLevelFloat;
    maxContentLightLevelFloat.i = memory->readd(address);address+=4;
    s->maxContentLightLevel = maxContentLightLevelFloat.f;
    MarshalFloat maxFrameAverageLightLevelFloat;
    maxFrameAverageLightLevelFloat.i = memory->readd(address);address+=4;
    s->maxFrameAverageLightLevel = maxFrameAverageLightLevelFloat.f;
}
void MarshalVkHdrMetadataEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHdrMetadataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->displayPrimaryRed, 8); address+=8;
    memory->memcpy(address, &s->displayPrimaryGreen, 8); address+=8;
    memory->memcpy(address, &s->displayPrimaryBlue, 8); address+=8;
    memory->memcpy(address, &s->whitePoint, 8); address+=8;
    MarshalFloat maxLuminanceFloat;
    maxLuminanceFloat.f = s->maxLuminance;
    memory->writed(address, maxLuminanceFloat.i);address+=4;
    MarshalFloat minLuminanceFloat;
    minLuminanceFloat.f = s->minLuminance;
    memory->writed(address, minLuminanceFloat.i);address+=4;
    MarshalFloat maxContentLightLevelFloat;
    maxContentLightLevelFloat.f = s->maxContentLightLevel;
    memory->writed(address, maxContentLightLevelFloat.i);address+=4;
    MarshalFloat maxFrameAverageLightLevelFloat;
    maxFrameAverageLightLevelFloat.f = s->maxFrameAverageLightLevel;
    memory->writed(address, maxFrameAverageLightLevelFloat.i);address+=4;
}
MarshalVkHdrMetadataEXT::~MarshalVkHdrMetadataEXT() {
    delete s.pNext;
}
void MarshalVkHdrVividDynamicMetadataHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHdrVividDynamicMetadataHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dynamicMetadataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicMetadata = NULL;
    } else {
        s->pDynamicMetadata = new char[(U32)s->dynamicMetadataSize];
        memory->memcpy((void*)s->pDynamicMetadata, paramAddress, (U32)s->dynamicMetadataSize);
    }
}
void MarshalVkHdrVividDynamicMetadataHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHdrVividDynamicMetadataHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->dynamicMetadataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkHdrVividDynamicMetadataHUAWEI::~MarshalVkHdrVividDynamicMetadataHUAWEI() {
    delete s.pNext;
    delete[] s.pDynamicMetadata;
}
void MarshalVkViewportWScalingNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkViewportWScalingNV* s) {
    MarshalFloat xcoeffFloat;
    xcoeffFloat.i = memory->readd(address);address+=4;
    s->xcoeff = xcoeffFloat.f;
    MarshalFloat ycoeffFloat;
    ycoeffFloat.i = memory->readd(address);address+=4;
    s->ycoeff = ycoeffFloat.f;
}
void MarshalVkPipelineViewportWScalingStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportWScalingStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->viewportWScalingEnable = (VkBool32)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportWScalings = NULL;
    } else {
        s->pViewportWScalings = new VkViewportWScalingNV[(U32)s->viewportCount];
        memory->memcpy((VkViewportWScalingNV*)s->pViewportWScalings, paramAddress, (U32)s->viewportCount * sizeof(VkViewportWScalingNV));
    }
}
void MarshalVkPipelineViewportWScalingStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportWScalingStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->viewportWScalingEnable);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewportWScalingNV* pViewportWScalings = new VkViewportWScalingNV();
        MarshalVkViewportWScalingNV::read(pBoxedInfo, memory, paramAddress, pViewportWScalings);
        s->pViewportWScalings = pViewportWScalings;
    }
}
MarshalVkPipelineViewportWScalingStateCreateInfoNV::~MarshalVkPipelineViewportWScalingStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pViewportWScalings;
}
void MarshalVkViewportSwizzleNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkViewportSwizzleNV* s) {
    s->x = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->y = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->z = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
    s->w = (VkViewportCoordinateSwizzleNV)memory->readd(address);address+=4;
}
void MarshalVkPipelineViewportSwizzleStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportSwizzleStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineViewportSwizzleStateCreateFlagsNV)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportSwizzles = NULL;
    } else {
        VkViewportSwizzleNV* pViewportSwizzles = new VkViewportSwizzleNV[s->viewportCount];
        for (U32 i = 0; i < s->viewportCount; i++) {
            MarshalVkViewportSwizzleNV::read(pBoxedInfo, memory, paramAddress + i*16, &pViewportSwizzles[i]);
        }
        s->pViewportSwizzles = pViewportSwizzles;
    }
}
void MarshalVkPipelineViewportSwizzleStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportSwizzleStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewportSwizzleNV* pViewportSwizzles = new VkViewportSwizzleNV();
        MarshalVkViewportSwizzleNV::read(pBoxedInfo, memory, paramAddress, pViewportSwizzles);
        s->pViewportSwizzles = pViewportSwizzles;
    }
}
MarshalVkPipelineViewportSwizzleStateCreateInfoNV::~MarshalVkPipelineViewportSwizzleStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pViewportSwizzles;
}
void MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDiscardRectanglePropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxDiscardRectangles = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDiscardRectanglePropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxDiscardRectangles);address+=4;
}
MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT::~MarshalVkPhysicalDeviceDiscardRectanglePropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDiscardRectangleStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineDiscardRectangleStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->discardRectangleMode = (VkDiscardRectangleModeEXT)memory->readd(address);address+=4;
    s->discardRectangleCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDiscardRectangles = NULL;
    } else {
        s->pDiscardRectangles = new VkRect2D[(U32)s->discardRectangleCount];
        memory->memcpy((VkRect2D*)s->pDiscardRectangles, paramAddress, (U32)s->discardRectangleCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineDiscardRectangleStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->discardRectangleMode);address+=4;
    memory->writed(address, s->discardRectangleCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pDiscardRectangles = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pDiscardRectangles);
        s->pDiscardRectangles = pDiscardRectangles;
    }
}
MarshalVkPipelineDiscardRectangleStateCreateInfoEXT::~MarshalVkPipelineDiscardRectangleStateCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pDiscardRectangles;
}
void MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->perViewPositionAllComponents = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->perViewPositionAllComponents);address+=4;
}
MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::~MarshalVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
    delete s.pNext;
}
void MarshalVkInputAttachmentAspectReference::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkInputAttachmentAspectReference* s) {
    s->subpass = (uint32_t)memory->readd(address);address+=4;
    s->inputAttachmentIndex = (uint32_t)memory->readd(address);address+=4;
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
}
void MarshalVkRenderPassInputAttachmentAspectCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassInputAttachmentAspectCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->aspectReferenceCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAspectReferences = NULL;
    } else {
        s->pAspectReferences = new VkInputAttachmentAspectReference[(U32)s->aspectReferenceCount];
        memory->memcpy((VkInputAttachmentAspectReference*)s->pAspectReferences, paramAddress, (U32)s->aspectReferenceCount * sizeof(VkInputAttachmentAspectReference));
    }
}
void MarshalVkRenderPassInputAttachmentAspectCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassInputAttachmentAspectCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->aspectReferenceCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkInputAttachmentAspectReference* pAspectReferences = new VkInputAttachmentAspectReference();
        MarshalVkInputAttachmentAspectReference::read(pBoxedInfo, memory, paramAddress, pAspectReferences);
        s->pAspectReferences = pAspectReferences;
    }
}
MarshalVkRenderPassInputAttachmentAspectCreateInfo::~MarshalVkRenderPassInputAttachmentAspectCreateInfo() {
    delete s.pNext;
    delete[] s.pAspectReferences;
}
void MarshalVkPhysicalDeviceSurfaceInfo2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSurfaceInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->surface = (VkSurfaceKHR)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceSurfaceInfo2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSurfaceInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->surface);address+=8;
}
MarshalVkPhysicalDeviceSurfaceInfo2KHR::~MarshalVkPhysicalDeviceSurfaceInfo2KHR() {
    delete s.pNext;
}
void MarshalVkSurfaceCapabilities2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalVkSurfaceCapabilitiesKHR::read(pBoxedInfo, memory, address, &s->surfaceCapabilities); address+=52;
}
void MarshalVkSurfaceCapabilities2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilities2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->surfaceCapabilities, 52); address+=52;
}
MarshalVkSurfaceCapabilities2KHR::~MarshalVkSurfaceCapabilities2KHR() {
    delete s.pNext;
}
void MarshalVkSurfaceFormat2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceFormat2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalVkSurfaceFormatKHR::read(pBoxedInfo, memory, address, &s->surfaceFormat); address+=8;
}
void MarshalVkSurfaceFormat2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceFormat2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->surfaceFormat, 8); address+=8;
}
MarshalVkSurfaceFormat2KHR::~MarshalVkSurfaceFormat2KHR() {
    delete s.pNext;
}
void MarshalVkDisplayProperties2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->displayProperties, address, 40);address+=40;
}
void MarshalVkDisplayProperties2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->displayProperties, 40); address+=40;
}
MarshalVkDisplayProperties2KHR::~MarshalVkDisplayProperties2KHR() {
    delete s.pNext;
}
void MarshalVkDisplayPlaneProperties2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->displayPlaneProperties, address, 12);address+=12;
}
void MarshalVkDisplayPlaneProperties2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->displayPlaneProperties, 12); address+=12;
}
MarshalVkDisplayPlaneProperties2KHR::~MarshalVkDisplayPlaneProperties2KHR() {
    delete s.pNext;
}
void MarshalVkDisplayModeProperties2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayModeProperties2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->displayModeProperties, address, 20);address+=20;
}
void MarshalVkDisplayModeProperties2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayModeProperties2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->displayModeProperties, 20); address+=20;
}
MarshalVkDisplayModeProperties2KHR::~MarshalVkDisplayModeProperties2KHR() {
    delete s.pNext;
}
void MarshalVkDisplayModeStereoPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayModeStereoPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hdmi3DSupported = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDisplayModeStereoPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayModeStereoPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hdmi3DSupported);address+=4;
}
MarshalVkDisplayModeStereoPropertiesNV::~MarshalVkDisplayModeStereoPropertiesNV() {
    delete s.pNext;
}
void MarshalVkDisplayPlaneInfo2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneInfo2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->mode = (VkDisplayModeKHR)memory->readq(address);address+=8;
    s->planeIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDisplayPlaneInfo2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneInfo2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->mode);address+=8;
    memory->writed(address, s->planeIndex);address+=4;
}
MarshalVkDisplayPlaneInfo2KHR::~MarshalVkDisplayPlaneInfo2KHR() {
    delete s.pNext;
}
void MarshalVkDisplayPlaneCapabilities2KHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneCapabilities2KHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->capabilities, address, 68);address+=68;
}
void MarshalVkDisplayPlaneCapabilities2KHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDisplayPlaneCapabilities2KHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->capabilities, 68); address+=68;
}
MarshalVkDisplayPlaneCapabilities2KHR::~MarshalVkDisplayPlaneCapabilities2KHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDevice16BitStorageFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice16BitStorageFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->storageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant16 = (VkBool32)memory->readd(address);address+=4;
    s->storageInputOutput16 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice16BitStorageFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice16BitStorageFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->storageBuffer16BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer16BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant16);address+=4;
    memory->writed(address, s->storageInputOutput16);address+=4;
}
MarshalVkPhysicalDevice16BitStorageFeatures::~MarshalVkPhysicalDevice16BitStorageFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSubgroupProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->supportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->supportedOperations = (VkSubgroupFeatureFlags)memory->readd(address);address+=4;
    s->quadOperationsInAllStages = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subgroupSize);address+=4;
    memory->writed(address, s->supportedStages);address+=4;
    memory->writed(address, s->supportedOperations);address+=4;
    memory->writed(address, s->quadOperationsInAllStages);address+=4;
}
MarshalVkPhysicalDeviceSubgroupProperties::~MarshalVkPhysicalDeviceSubgroupProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSubgroupExtendedTypes = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSubgroupExtendedTypes);address+=4;
}
MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::~MarshalVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures() {
    delete s.pNext;
}
void MarshalVkBufferMemoryRequirementsInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryRequirementsInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkBufferMemoryRequirementsInfo2::~MarshalVkBufferMemoryRequirementsInfo2() {
    delete s.pNext;
}
void MarshalVkDeviceBufferMemoryRequirements::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceBufferMemoryRequirements* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCreateInfo = NULL;
    } else {
        VkBufferCreateInfo* pCreateInfo = new VkBufferCreateInfo();
        MarshalVkBufferCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
}
void MarshalVkDeviceBufferMemoryRequirements::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceBufferMemoryRequirements* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferCreateInfo* pCreateInfo = new VkBufferCreateInfo();
        MarshalVkBufferCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
}
MarshalVkDeviceBufferMemoryRequirements::~MarshalVkDeviceBufferMemoryRequirements() {
    delete s.pNext;
    delete s.pCreateInfo;
}
void MarshalVkImageMemoryRequirementsInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
}
void MarshalVkImageMemoryRequirementsInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
}
MarshalVkImageMemoryRequirementsInfo2::~MarshalVkImageMemoryRequirementsInfo2() {
    delete s.pNext;
}
void MarshalVkImageSparseMemoryRequirementsInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSparseMemoryRequirementsInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
}
void MarshalVkImageSparseMemoryRequirementsInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSparseMemoryRequirementsInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
}
MarshalVkImageSparseMemoryRequirementsInfo2::~MarshalVkImageSparseMemoryRequirementsInfo2() {
    delete s.pNext;
}
void MarshalVkDeviceImageMemoryRequirements::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceImageMemoryRequirements* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCreateInfo = NULL;
    } else {
        VkImageCreateInfo* pCreateInfo = new VkImageCreateInfo();
        MarshalVkImageCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
    s->planeAspect = (VkImageAspectFlagBits)memory->readd(address);address+=4;
}
void MarshalVkDeviceImageMemoryRequirements::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceImageMemoryRequirements* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageCreateInfo* pCreateInfo = new VkImageCreateInfo();
        MarshalVkImageCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
    memory->writed(address, s->planeAspect);address+=4;
}
MarshalVkDeviceImageMemoryRequirements::~MarshalVkDeviceImageMemoryRequirements() {
    delete s.pNext;
    delete s.pCreateInfo;
}
void MarshalVkMemoryRequirements2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryRequirements2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->memoryRequirements, address, 20);address+=20;
}
void MarshalVkMemoryRequirements2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryRequirements2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->memoryRequirements, 20); address+=20;
}
MarshalVkMemoryRequirements2::~MarshalVkMemoryRequirements2() {
    delete s.pNext;
}
void MarshalVkSparseImageMemoryRequirements2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageMemoryRequirements2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->memoryRequirements, address, 48);address+=48;
}
void MarshalVkSparseImageMemoryRequirements2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSparseImageMemoryRequirements2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->memoryRequirements, 48); address+=48;
}
MarshalVkSparseImageMemoryRequirements2::~MarshalVkSparseImageMemoryRequirements2() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePointClippingProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePointClippingProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pointClippingBehavior = (VkPointClippingBehavior)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePointClippingProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePointClippingProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pointClippingBehavior);address+=4;
}
MarshalVkPhysicalDevicePointClippingProperties::~MarshalVkPhysicalDevicePointClippingProperties() {
    delete s.pNext;
}
void MarshalVkMemoryDedicatedRequirements::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryDedicatedRequirements* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->prefersDedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
    s->requiresDedicatedAllocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkMemoryDedicatedRequirements::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryDedicatedRequirements* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->prefersDedicatedAllocation);address+=4;
    memory->writed(address, s->requiresDedicatedAllocation);address+=4;
}
MarshalVkMemoryDedicatedRequirements::~MarshalVkMemoryDedicatedRequirements() {
    delete s.pNext;
}
void MarshalVkMemoryDedicatedAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryDedicatedAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkMemoryDedicatedAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryDedicatedAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkMemoryDedicatedAllocateInfo::~MarshalVkMemoryDedicatedAllocateInfo() {
    delete s.pNext;
}
void MarshalVkImageViewUsageCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewUsageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkImageViewUsageCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewUsageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->usage);address+=4;
}
MarshalVkImageViewUsageCreateInfo::~MarshalVkImageViewUsageCreateInfo() {
    delete s.pNext;
}
void MarshalVkImageViewSlicedCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewSlicedCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sliceOffset = (uint32_t)memory->readd(address);address+=4;
    s->sliceCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkImageViewSlicedCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewSlicedCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sliceOffset);address+=4;
    memory->writed(address, s->sliceCount);address+=4;
}
MarshalVkImageViewSlicedCreateInfoEXT::~MarshalVkImageViewSlicedCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPipelineTessellationDomainOriginStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineTessellationDomainOriginStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->domainOrigin = (VkTessellationDomainOrigin)memory->readd(address);address+=4;
}
void MarshalVkPipelineTessellationDomainOriginStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineTessellationDomainOriginStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->domainOrigin);address+=4;
}
MarshalVkPipelineTessellationDomainOriginStateCreateInfo::~MarshalVkPipelineTessellationDomainOriginStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkSamplerYcbcrConversionInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->conversion = (VkSamplerYcbcrConversion)memory->readq(address);address+=8;
}
void MarshalVkSamplerYcbcrConversionInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->conversion);address+=8;
}
MarshalVkSamplerYcbcrConversionInfo::~MarshalVkSamplerYcbcrConversionInfo() {
    delete s.pNext;
}
void MarshalVkSamplerYcbcrConversionCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->ycbcrModel = (VkSamplerYcbcrModelConversion)memory->readd(address);address+=4;
    s->ycbcrRange = (VkSamplerYcbcrRange)memory->readd(address);address+=4;
    MarshalVkComponentMapping::read(pBoxedInfo, memory, address, &s->components); address+=16;
    s->xChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
    s->yChromaOffset = (VkChromaLocation)memory->readd(address);address+=4;
    s->chromaFilter = (VkFilter)memory->readd(address);address+=4;
    s->forceExplicitReconstruction = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerYcbcrConversionCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->ycbcrModel);address+=4;
    memory->writed(address, s->ycbcrRange);address+=4;
    memory->memcpy(address, &s->components, 16); address+=16;
    memory->writed(address, s->xChromaOffset);address+=4;
    memory->writed(address, s->yChromaOffset);address+=4;
    memory->writed(address, s->chromaFilter);address+=4;
    memory->writed(address, s->forceExplicitReconstruction);address+=4;
}
MarshalVkSamplerYcbcrConversionCreateInfo::~MarshalVkSamplerYcbcrConversionCreateInfo() {
    delete s.pNext;
}
void MarshalVkBindImagePlaneMemoryInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImagePlaneMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->planeAspect = (VkImageAspectFlagBits)memory->readd(address);address+=4;
}
void MarshalVkBindImagePlaneMemoryInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindImagePlaneMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->planeAspect);address+=4;
}
MarshalVkBindImagePlaneMemoryInfo::~MarshalVkBindImagePlaneMemoryInfo() {
    delete s.pNext;
}
void MarshalVkImagePlaneMemoryRequirementsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImagePlaneMemoryRequirementsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->planeAspect = (VkImageAspectFlagBits)memory->readd(address);address+=4;
}
void MarshalVkImagePlaneMemoryRequirementsInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImagePlaneMemoryRequirementsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->planeAspect);address+=4;
}
MarshalVkImagePlaneMemoryRequirementsInfo::~MarshalVkImagePlaneMemoryRequirementsInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSamplerYcbcrConversionFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->samplerYcbcrConversion = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSamplerYcbcrConversionFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->samplerYcbcrConversion);address+=4;
}
MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures::~MarshalVkPhysicalDeviceSamplerYcbcrConversionFeatures() {
    delete s.pNext;
}
void MarshalVkSamplerYcbcrConversionImageFormatProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionImageFormatProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->combinedImageSamplerDescriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSamplerYcbcrConversionImageFormatProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionImageFormatProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->combinedImageSamplerDescriptorCount);address+=4;
}
MarshalVkSamplerYcbcrConversionImageFormatProperties::~MarshalVkSamplerYcbcrConversionImageFormatProperties() {
    delete s.pNext;
}
void MarshalVkTextureLODGatherFormatPropertiesAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTextureLODGatherFormatPropertiesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportsTextureGatherLODBiasAMD = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkTextureLODGatherFormatPropertiesAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTextureLODGatherFormatPropertiesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportsTextureGatherLODBiasAMD);address+=4;
}
MarshalVkTextureLODGatherFormatPropertiesAMD::~MarshalVkTextureLODGatherFormatPropertiesAMD() {
    delete s.pNext;
}
void MarshalVkConditionalRenderingBeginInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkConditionalRenderingBeginInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->flags = (VkConditionalRenderingFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkConditionalRenderingBeginInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkConditionalRenderingBeginInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkConditionalRenderingBeginInfoEXT::~MarshalVkConditionalRenderingBeginInfoEXT() {
    delete s.pNext;
}
void MarshalVkProtectedSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkProtectedSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->protectedSubmit = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkProtectedSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkProtectedSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->protectedSubmit);address+=4;
}
MarshalVkProtectedSubmitInfo::~MarshalVkProtectedSubmitInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceProtectedMemoryFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->protectedMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->protectedMemory);address+=4;
}
MarshalVkPhysicalDeviceProtectedMemoryFeatures::~MarshalVkPhysicalDeviceProtectedMemoryFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceProtectedMemoryProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->protectedNoFault = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProtectedMemoryProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProtectedMemoryProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->protectedNoFault);address+=4;
}
MarshalVkPhysicalDeviceProtectedMemoryProperties::~MarshalVkPhysicalDeviceProtectedMemoryProperties() {
    delete s.pNext;
}
void MarshalVkDeviceQueueInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDeviceQueueCreateFlags)memory->readd(address);address+=4;
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->queueIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceQueueInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->queueIndex);address+=4;
}
MarshalVkDeviceQueueInfo2::~MarshalVkDeviceQueueInfo2() {
    delete s.pNext;
}
void MarshalVkPipelineCoverageToColorStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageToColorStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageToColorStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageToColorEnable = (VkBool32)memory->readd(address);address+=4;
    s->coverageToColorLocation = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineCoverageToColorStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageToColorStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageToColorEnable);address+=4;
    memory->writed(address, s->coverageToColorLocation);address+=4;
}
MarshalVkPipelineCoverageToColorStateCreateInfoNV::~MarshalVkPipelineCoverageToColorStateCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSamplerFilterMinmaxProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->filterMinmaxSingleComponentFormats = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxImageComponentMapping = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSamplerFilterMinmaxProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->filterMinmaxSingleComponentFormats);address+=4;
    memory->writed(address, s->filterMinmaxImageComponentMapping);address+=4;
}
MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties::~MarshalVkPhysicalDeviceSamplerFilterMinmaxProperties() {
    delete s.pNext;
}
void MarshalVkSampleLocationEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSampleLocationEXT* s) {
    MarshalFloat xFloat;
    xFloat.i = memory->readd(address);address+=4;
    s->x = xFloat.f;
    MarshalFloat yFloat;
    yFloat.i = memory->readd(address);address+=4;
    s->y = yFloat.f;
}
void MarshalVkSampleLocationsInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSampleLocationsInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampleLocationsPerPixel = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    memory->memcpy(&s->sampleLocationGridSize, address, 8);address+=8;
    s->sampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleLocations = NULL;
    } else {
        s->pSampleLocations = new VkSampleLocationEXT[(U32)s->sampleLocationsCount];
        memory->memcpy((VkSampleLocationEXT*)s->pSampleLocations, paramAddress, (U32)s->sampleLocationsCount * sizeof(VkSampleLocationEXT));
    }
}
void MarshalVkSampleLocationsInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSampleLocationsInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sampleLocationsPerPixel);address+=4;
    memory->memcpy(address, &s->sampleLocationGridSize, 8); address+=8;
    memory->writed(address, s->sampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSampleLocationEXT* pSampleLocations = new VkSampleLocationEXT();
        MarshalVkSampleLocationEXT::read(pBoxedInfo, memory, paramAddress, pSampleLocations);
        s->pSampleLocations = pSampleLocations;
    }
}
MarshalVkSampleLocationsInfoEXT::~MarshalVkSampleLocationsInfoEXT() {
    delete s.pNext;
    delete[] s.pSampleLocations;
}
void MarshalVkAttachmentSampleLocationsEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentSampleLocationsEXT* s) {
    s->attachmentIndex = (uint32_t)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(pBoxedInfo, memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkSubpassSampleLocationsEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassSampleLocationsEXT* s) {
    s->subpassIndex = (uint32_t)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(pBoxedInfo, memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkRenderPassSampleLocationsBeginInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassSampleLocationsBeginInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentInitialSampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachmentInitialSampleLocations = NULL;
    } else {
        VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = new VkAttachmentSampleLocationsEXT[s->attachmentInitialSampleLocationsCount];
        for (U32 i = 0; i < s->attachmentInitialSampleLocationsCount; i++) {
            MarshalVkAttachmentSampleLocationsEXT::read(pBoxedInfo, memory, paramAddress + i*32, &pAttachmentInitialSampleLocations[i]);
        }
        s->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations;
    }
    s->postSubpassSampleLocationsCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPostSubpassSampleLocations = NULL;
    } else {
        VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations = new VkSubpassSampleLocationsEXT[s->postSubpassSampleLocationsCount];
        for (U32 i = 0; i < s->postSubpassSampleLocationsCount; i++) {
            MarshalVkSubpassSampleLocationsEXT::read(pBoxedInfo, memory, paramAddress + i*32, &pPostSubpassSampleLocations[i]);
        }
        s->pPostSubpassSampleLocations = pPostSubpassSampleLocations;
    }
}
void MarshalVkRenderPassSampleLocationsBeginInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassSampleLocationsBeginInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentInitialSampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = new VkAttachmentSampleLocationsEXT();
        MarshalVkAttachmentSampleLocationsEXT::read(pBoxedInfo, memory, paramAddress, pAttachmentInitialSampleLocations);
        s->pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations;
    }
    memory->writed(address, s->postSubpassSampleLocationsCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations = new VkSubpassSampleLocationsEXT();
        MarshalVkSubpassSampleLocationsEXT::read(pBoxedInfo, memory, paramAddress, pPostSubpassSampleLocations);
        s->pPostSubpassSampleLocations = pPostSubpassSampleLocations;
    }
}
MarshalVkRenderPassSampleLocationsBeginInfoEXT::~MarshalVkRenderPassSampleLocationsBeginInfoEXT() {
    delete s.pNext;
    delete[] s.pAttachmentInitialSampleLocations;
    delete[] s.pPostSubpassSampleLocations;
}
void MarshalVkPipelineSampleLocationsStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineSampleLocationsStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampleLocationsEnable = (VkBool32)memory->readd(address);address+=4;
    MarshalVkSampleLocationsInfoEXT::read(pBoxedInfo, memory, address, &s->sampleLocationsInfo); address+=28;
}
void MarshalVkPipelineSampleLocationsStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineSampleLocationsStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sampleLocationsEnable);address+=4;
    memory->memcpy(address, &s->sampleLocationsInfo, 28); address+=28;
}
MarshalVkPipelineSampleLocationsStateCreateInfoEXT::~MarshalVkPipelineSampleLocationsStateCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSampleLocationsPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampleLocationSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->maxSampleLocationGridSize, address, 8);address+=8;
    memory->memcpy(&s->sampleLocationCoordinateRange, address, 8);address+=8;
    s->sampleLocationSubPixelBits = (uint32_t)memory->readd(address);address+=4;
    s->variableSampleLocations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSampleLocationsPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sampleLocationSampleCounts);address+=4;
    memory->memcpy(address, &s->maxSampleLocationGridSize, 8); address+=8;
    memory->memcpy(address, s->sampleLocationCoordinateRange, 8); address+=8;
    memory->writed(address, s->sampleLocationSubPixelBits);address+=4;
    memory->writed(address, s->variableSampleLocations);address+=4;
}
MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT::~MarshalVkPhysicalDeviceSampleLocationsPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkMultisamplePropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->maxSampleLocationGridSize, address, 8);address+=8;
}
void MarshalVkMultisamplePropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultisamplePropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->maxSampleLocationGridSize, 8); address+=8;
}
MarshalVkMultisamplePropertiesEXT::~MarshalVkMultisamplePropertiesEXT() {
    delete s.pNext;
}
void MarshalVkSamplerReductionModeCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerReductionModeCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->reductionMode = (VkSamplerReductionMode)memory->readd(address);address+=4;
}
void MarshalVkSamplerReductionModeCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerReductionModeCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->reductionMode);address+=4;
}
MarshalVkSamplerReductionModeCreateInfo::~MarshalVkSamplerReductionModeCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->advancedBlendCoherentOperations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->advancedBlendCoherentOperations);address+=4;
}
MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::~MarshalVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multiDraw = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiDrawFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multiDraw);address+=4;
}
MarshalVkPhysicalDeviceMultiDrawFeaturesEXT::~MarshalVkPhysicalDeviceMultiDrawFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->advancedBlendMaxColorAttachments = (uint32_t)memory->readd(address);address+=4;
    s->advancedBlendIndependentBlend = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendNonPremultipliedSrcColor = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendNonPremultipliedDstColor = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendCorrelatedOverlap = (VkBool32)memory->readd(address);address+=4;
    s->advancedBlendAllOperations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->advancedBlendMaxColorAttachments);address+=4;
    memory->writed(address, s->advancedBlendIndependentBlend);address+=4;
    memory->writed(address, s->advancedBlendNonPremultipliedSrcColor);address+=4;
    memory->writed(address, s->advancedBlendNonPremultipliedDstColor);address+=4;
    memory->writed(address, s->advancedBlendCorrelatedOverlap);address+=4;
    memory->writed(address, s->advancedBlendAllOperations);address+=4;
}
MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::~MarshalVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorBlendAdvancedStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->dstPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->blendOverlap = (VkBlendOverlapEXT)memory->readd(address);address+=4;
}
void MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorBlendAdvancedStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->srcPremultiplied);address+=4;
    memory->writed(address, s->dstPremultiplied);address+=4;
    memory->writed(address, s->blendOverlap);address+=4;
}
MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT::~MarshalVkPipelineColorBlendAdvancedStateCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceInlineUniformBlockFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->inlineUniformBlock = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingInlineUniformBlockUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->inlineUniformBlock);address+=4;
    memory->writed(address, s->descriptorBindingInlineUniformBlockUpdateAfterBind);address+=4;
}
MarshalVkPhysicalDeviceInlineUniformBlockFeatures::~MarshalVkPhysicalDeviceInlineUniformBlockFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceInlineUniformBlockProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxInlineUniformBlockSize = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInlineUniformBlockProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInlineUniformBlockProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxInlineUniformBlockSize);address+=4;
    memory->writed(address, s->maxPerStageDescriptorInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks);address+=4;
}
MarshalVkPhysicalDeviceInlineUniformBlockProperties::~MarshalVkPhysicalDeviceInlineUniformBlockProperties() {
    delete s.pNext;
}
void MarshalVkWriteDescriptorSetInlineUniformBlock::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetInlineUniformBlock* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dataSize = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkWriteDescriptorSetInlineUniformBlock::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetInlineUniformBlock* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkWriteDescriptorSetInlineUniformBlock::~MarshalVkWriteDescriptorSetInlineUniformBlock() {
    delete s.pNext;
    delete[] s.pData;
}
void MarshalVkDescriptorPoolInlineUniformBlockCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorPoolInlineUniformBlockCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxInlineUniformBlockBindings = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorPoolInlineUniformBlockCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorPoolInlineUniformBlockCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxInlineUniformBlockBindings);address+=4;
}
MarshalVkDescriptorPoolInlineUniformBlockCreateInfo::~MarshalVkDescriptorPoolInlineUniformBlockCreateInfo() {
    delete s.pNext;
}
void MarshalVkPipelineCoverageModulationStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageModulationStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageModulationStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageModulationMode = (VkCoverageModulationModeNV)memory->readd(address);address+=4;
    s->coverageModulationTableEnable = (VkBool32)memory->readd(address);address+=4;
    s->coverageModulationTableCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCoverageModulationTable = NULL;
    } else {
        s->pCoverageModulationTable = new float[(U32)s->coverageModulationTableCount];
        memory->memcpy((float*)s->pCoverageModulationTable, paramAddress, (U32)s->coverageModulationTableCount);
    }
}
void MarshalVkPipelineCoverageModulationStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageModulationStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageModulationMode);address+=4;
    memory->writed(address, s->coverageModulationTableEnable);address+=4;
    memory->writed(address, s->coverageModulationTableCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineCoverageModulationStateCreateInfoNV::~MarshalVkPipelineCoverageModulationStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pCoverageModulationTable;
}
void MarshalVkImageFormatListCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatListCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->viewFormatCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewFormats = NULL;
    } else {
        s->pViewFormats = new VkFormat[(U32)s->viewFormatCount];
        memory->memcpy((VkFormat*)s->pViewFormats, paramAddress, (U32)s->viewFormatCount);
    }
}
void MarshalVkImageFormatListCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageFormatListCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->viewFormatCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkImageFormatListCreateInfo::~MarshalVkImageFormatListCreateInfo() {
    delete s.pNext;
    delete[] s.pViewFormats;
}
void MarshalVkValidationCacheCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationCacheCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkValidationCacheCreateFlagsEXT)memory->readd(address);address+=4;
    s->initialDataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInitialData = NULL;
    } else {
        s->pInitialData = new char[(U32)s->initialDataSize];
        memory->memcpy((void*)s->pInitialData, paramAddress, (U32)s->initialDataSize);
    }
}
void MarshalVkValidationCacheCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkValidationCacheCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, (U32)s->initialDataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkValidationCacheCreateInfoEXT::~MarshalVkValidationCacheCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pInitialData;
}
void MarshalVkShaderModuleValidationCacheCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleValidationCacheCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->validationCache = (VkValidationCacheEXT)memory->readq(address);address+=8;
}
void MarshalVkShaderModuleValidationCacheCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleValidationCacheCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->validationCache);address+=8;
}
MarshalVkShaderModuleValidationCacheCreateInfoEXT::~MarshalVkShaderModuleValidationCacheCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance3Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance3Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxPerSetDescriptors = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceMaintenance3Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance3Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxPerSetDescriptors);address+=4;
    memory->writeq(address, s->maxMemoryAllocationSize);address+=8;
}
MarshalVkPhysicalDeviceMaintenance3Properties::~MarshalVkPhysicalDeviceMaintenance3Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance4Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance4Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maintenance4 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMaintenance4Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance4Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maintenance4);address+=4;
}
MarshalVkPhysicalDeviceMaintenance4Features::~MarshalVkPhysicalDeviceMaintenance4Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance4Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance4Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxBufferSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceMaintenance4Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance4Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->maxBufferSize);address+=8;
}
MarshalVkPhysicalDeviceMaintenance4Properties::~MarshalVkPhysicalDeviceMaintenance4Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance5Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance5Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maintenance5 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMaintenance5Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance5Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maintenance5);address+=4;
}
MarshalVkPhysicalDeviceMaintenance5Features::~MarshalVkPhysicalDeviceMaintenance5Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance5Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance5Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->earlyFragmentMultisampleCoverageAfterSampleCounting = (VkBool32)memory->readd(address);address+=4;
    s->earlyFragmentSampleMaskTestBeforeSampleCounting = (VkBool32)memory->readd(address);address+=4;
    s->depthStencilSwizzleOneSupport = (VkBool32)memory->readd(address);address+=4;
    s->polygonModePointSize = (VkBool32)memory->readd(address);address+=4;
    s->nonStrictSinglePixelWideLinesUseParallelogram = (VkBool32)memory->readd(address);address+=4;
    s->nonStrictWideLinesUseParallelogram = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMaintenance5Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance5Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->earlyFragmentMultisampleCoverageAfterSampleCounting);address+=4;
    memory->writed(address, s->earlyFragmentSampleMaskTestBeforeSampleCounting);address+=4;
    memory->writed(address, s->depthStencilSwizzleOneSupport);address+=4;
    memory->writed(address, s->polygonModePointSize);address+=4;
    memory->writed(address, s->nonStrictSinglePixelWideLinesUseParallelogram);address+=4;
    memory->writed(address, s->nonStrictWideLinesUseParallelogram);address+=4;
}
MarshalVkPhysicalDeviceMaintenance5Properties::~MarshalVkPhysicalDeviceMaintenance5Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance6Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance6Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maintenance6 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMaintenance6Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance6Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maintenance6);address+=4;
}
MarshalVkPhysicalDeviceMaintenance6Features::~MarshalVkPhysicalDeviceMaintenance6Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMaintenance6Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance6Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->blockTexelViewCompatibleMultipleLayers = (VkBool32)memory->readd(address);address+=4;
    s->maxCombinedImageSamplerDescriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->fragmentShadingRateClampCombinerInputs = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMaintenance6Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMaintenance6Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->blockTexelViewCompatibleMultipleLayers);address+=4;
    memory->writed(address, s->maxCombinedImageSamplerDescriptorCount);address+=4;
    memory->writed(address, s->fragmentShadingRateClampCombinerInputs);address+=4;
}
MarshalVkPhysicalDeviceMaintenance6Properties::~MarshalVkPhysicalDeviceMaintenance6Properties() {
    delete s.pNext;
}
void MarshalVkRenderingAreaInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAreaInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachmentFormats = NULL;
    } else {
        s->pColorAttachmentFormats = new VkFormat[(U32)s->colorAttachmentCount];
        memory->memcpy((VkFormat*)s->pColorAttachmentFormats, paramAddress, (U32)s->colorAttachmentCount);
    }
    s->depthAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
    s->stencilAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkRenderingAreaInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAreaInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->depthAttachmentFormat);address+=4;
    memory->writed(address, s->stencilAttachmentFormat);address+=4;
}
MarshalVkRenderingAreaInfo::~MarshalVkRenderingAreaInfo() {
    delete s.pNext;
    delete[] s.pColorAttachmentFormats;
}
void MarshalVkDescriptorSetLayoutSupport::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supported = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetLayoutSupport::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutSupport* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supported);address+=4;
}
MarshalVkDescriptorSetLayoutSupport::~MarshalVkDescriptorSetLayoutSupport() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderDrawParametersFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderDrawParametersFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderDrawParameters = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderDrawParametersFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderDrawParametersFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderDrawParameters);address+=4;
}
MarshalVkPhysicalDeviceShaderDrawParametersFeatures::~MarshalVkPhysicalDeviceShaderDrawParametersFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderFloat16Int8Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderFloat16Int8Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderFloat16Int8Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderFloat16Int8Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderFloat16);address+=4;
    memory->writed(address, s->shaderInt8);address+=4;
}
MarshalVkPhysicalDeviceShaderFloat16Int8Features::~MarshalVkPhysicalDeviceShaderFloat16Int8Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFloatControlsProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFloatControlsProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->denormBehaviorIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->roundingModeIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat64 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFloatControlsProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFloatControlsProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->denormBehaviorIndependence);address+=4;
    memory->writed(address, s->roundingModeIndependence);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat16);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat32);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat16);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat32);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat16);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat32);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat64);address+=4;
}
MarshalVkPhysicalDeviceFloatControlsProperties::~MarshalVkPhysicalDeviceFloatControlsProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceHostQueryResetFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hostQueryReset = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceHostQueryResetFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostQueryResetFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hostQueryReset);address+=4;
}
MarshalVkPhysicalDeviceHostQueryResetFeatures::~MarshalVkPhysicalDeviceHostQueryResetFeatures() {
    delete s.pNext;
}
void MarshalVkDeviceQueueGlobalPriorityCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueGlobalPriorityCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->globalPriority = (VkQueueGlobalPriority)memory->readd(address);address+=4;
}
void MarshalVkDeviceQueueGlobalPriorityCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueGlobalPriorityCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->globalPriority);address+=4;
}
MarshalVkDeviceQueueGlobalPriorityCreateInfo::~MarshalVkDeviceQueueGlobalPriorityCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGlobalPriorityQueryFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->globalPriorityQuery = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGlobalPriorityQueryFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->globalPriorityQuery);address+=4;
}
MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures::~MarshalVkPhysicalDeviceGlobalPriorityQueryFeatures() {
    delete s.pNext;
}
void MarshalVkQueueFamilyGlobalPriorityProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyGlobalPriorityProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->priorityCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->priorities, address, 64);address+=64;
}
void MarshalVkQueueFamilyGlobalPriorityProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyGlobalPriorityProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->priorityCount);address+=4;
    memory->memcpy(address, s->priorities, 64); address+=64;
}
MarshalVkQueueFamilyGlobalPriorityProperties::~MarshalVkQueueFamilyGlobalPriorityProperties() {
    delete s.pNext;
}
void MarshalVkDebugUtilsObjectNameInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsObjectNameInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->objectType = (VkObjectType)memory->readd(address);address+=4;
    s->objectHandle = (uint64_t)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjectName = NULL;
    } else {
        U32 pObjectNameLen = memory->strlen(paramAddress)+1;
        s->pObjectName = new char[pObjectNameLen];
        memory->memcpy((char*)s->pObjectName, paramAddress, pObjectNameLen);
    }
}
void MarshalVkDebugUtilsObjectNameInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsObjectNameInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->objectHandle);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDebugUtilsObjectNameInfoEXT::~MarshalVkDebugUtilsObjectNameInfoEXT() {
    delete s.pNext;
    delete[] s.pObjectName;
}
void MarshalVkDebugUtilsObjectTagInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsObjectTagInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->objectType = (VkObjectType)memory->readd(address);address+=4;
    s->objectHandle = (uint64_t)memory->readq(address);address+=8;
    s->tagName = (uint64_t)memory->readq(address);address+=8;
    s->tagSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTag = NULL;
    } else {
        s->pTag = new char[(U32)s->tagSize];
        memory->memcpy((void*)s->pTag, paramAddress, (U32)s->tagSize);
    }
}
void MarshalVkDebugUtilsObjectTagInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsObjectTagInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->objectType);address+=4;
    memory->writeq(address, s->objectHandle);address+=8;
    memory->writeq(address, s->tagName);address+=8;
    memory->writed(address, (U32)s->tagSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDebugUtilsObjectTagInfoEXT::~MarshalVkDebugUtilsObjectTagInfoEXT() {
    delete s.pNext;
    delete[] s.pTag;
}
void MarshalVkDebugUtilsLabelEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsLabelEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLabelName = NULL;
    } else {
        U32 pLabelNameLen = memory->strlen(paramAddress)+1;
        s->pLabelName = new char[pLabelNameLen];
        memory->memcpy((char*)s->pLabelName, paramAddress, pLabelNameLen);
    }
    memory->memcpy(&s->color, address, 16);address+=16;
}
void MarshalVkDebugUtilsLabelEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsLabelEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->color, 16); address+=16;
}
MarshalVkDebugUtilsLabelEXT::~MarshalVkDebugUtilsLabelEXT() {
    delete s.pNext;
    delete[] s.pLabelName;
}
void MarshalVkDebugUtilsMessengerCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsMessengerCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDebugUtilsMessengerCreateFlagsEXT)memory->readd(address);address+=4;
    s->messageSeverity = (VkDebugUtilsMessageSeverityFlagsEXT)memory->readd(address);address+=4;
    s->messageType = (VkDebugUtilsMessageTypeFlagsEXT)memory->readd(address);address+=4;
    s->pfnUserCallback = boxed_vkDebugUtilsMessengerCallbackEXT;
    MarshalCallbackData* pData = new MarshalCallbackData();
    pData->callbackAddress = memory->readd(address); address += 4;
    pData->userData = memory->readd(address);address+=4;
    s->pUserData = pData;
}
void MarshalVkDebugUtilsMessengerCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsMessengerCreateInfoEXT* s) {
    kpanic("MarshalVkDebugUtilsMessengerCreateInfoEXT::write");
}
MarshalVkDebugUtilsMessengerCreateInfoEXT::~MarshalVkDebugUtilsMessengerCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkDebugUtilsMessengerCallbackDataEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsMessengerCallbackDataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDebugUtilsMessengerCallbackDataFlagsEXT)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMessageIdName = NULL;
    } else {
        U32 pMessageIdNameLen = memory->strlen(paramAddress)+1;
        s->pMessageIdName = new char[pMessageIdNameLen];
        memory->memcpy((char*)s->pMessageIdName, paramAddress, pMessageIdNameLen);
    }
    s->messageIdNumber = (int32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMessage = NULL;
    } else {
        U32 pMessageLen = memory->strlen(paramAddress)+1;
        s->pMessage = new char[pMessageLen];
        memory->memcpy((char*)s->pMessage, paramAddress, pMessageLen);
    }
    s->queueLabelCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQueueLabels = NULL;
    } else {
        VkDebugUtilsLabelEXT* pQueueLabels = new VkDebugUtilsLabelEXT[s->queueLabelCount];
        for (U32 i = 0; i < s->queueLabelCount; i++) {
            MarshalVkDebugUtilsLabelEXT::read(pBoxedInfo, memory, paramAddress + i*16, &pQueueLabels[i]);
        }
        s->pQueueLabels = pQueueLabels;
    }
    s->cmdBufLabelCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCmdBufLabels = NULL;
    } else {
        VkDebugUtilsLabelEXT* pCmdBufLabels = new VkDebugUtilsLabelEXT[s->cmdBufLabelCount];
        for (U32 i = 0; i < s->cmdBufLabelCount; i++) {
            MarshalVkDebugUtilsLabelEXT::read(pBoxedInfo, memory, paramAddress + i*16, &pCmdBufLabels[i]);
        }
        s->pCmdBufLabels = pCmdBufLabels;
    }
    s->objectCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pObjects = NULL;
    } else {
        VkDebugUtilsObjectNameInfoEXT* pObjects = new VkDebugUtilsObjectNameInfoEXT[s->objectCount];
        for (U32 i = 0; i < s->objectCount; i++) {
            MarshalVkDebugUtilsObjectNameInfoEXT::read(pBoxedInfo, memory, paramAddress + i*24, &pObjects[i]);
        }
        s->pObjects = pObjects;
    }
}
void MarshalVkDebugUtilsMessengerCallbackDataEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDebugUtilsMessengerCallbackDataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->messageIdNumber);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->queueLabelCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsLabelEXT* pQueueLabels = new VkDebugUtilsLabelEXT();
        MarshalVkDebugUtilsLabelEXT::read(pBoxedInfo, memory, paramAddress, pQueueLabels);
        s->pQueueLabels = pQueueLabels;
    }
    memory->writed(address, s->cmdBufLabelCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsLabelEXT* pCmdBufLabels = new VkDebugUtilsLabelEXT();
        MarshalVkDebugUtilsLabelEXT::read(pBoxedInfo, memory, paramAddress, pCmdBufLabels);
        s->pCmdBufLabels = pCmdBufLabels;
    }
    memory->writed(address, s->objectCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDebugUtilsObjectNameInfoEXT* pObjects = new VkDebugUtilsObjectNameInfoEXT();
        MarshalVkDebugUtilsObjectNameInfoEXT::read(pBoxedInfo, memory, paramAddress, pObjects);
        s->pObjects = pObjects;
    }
}
MarshalVkDebugUtilsMessengerCallbackDataEXT::~MarshalVkDebugUtilsMessengerCallbackDataEXT() {
    delete s.pNext;
    delete[] s.pMessageIdName;
    delete[] s.pMessage;
    delete[] s.pQueueLabels;
    delete[] s.pCmdBufLabels;
    delete[] s.pObjects;
}
void MarshalVkImportMemoryHostPointerInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImportMemoryHostPointerInfoEXT* s) {
    kpanic("MarshalVkImportMemoryHostPointerInfoEXT::read");
}
void MarshalVkImportMemoryHostPointerInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImportMemoryHostPointerInfoEXT* s) {
    kpanic("MarshalVkImportMemoryHostPointerInfoEXT::write");
}
void MarshalVkMemoryHostPointerPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryTypeBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkMemoryHostPointerPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryHostPointerPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryTypeBits);address+=4;
}
MarshalVkMemoryHostPointerPropertiesEXT::~MarshalVkMemoryHostPointerPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalMemoryHostPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minImportedHostPointerAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExternalMemoryHostPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->minImportedHostPointerAlignment);address+=8;
}
MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT::~MarshalVkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceConservativeRasterizationPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalFloat primitiveOverestimationSizeFloat;
    primitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->primitiveOverestimationSize = primitiveOverestimationSizeFloat.f;
    MarshalFloat maxExtraPrimitiveOverestimationSizeFloat;
    maxExtraPrimitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->maxExtraPrimitiveOverestimationSize = maxExtraPrimitiveOverestimationSizeFloat.f;
    MarshalFloat extraPrimitiveOverestimationSizeGranularityFloat;
    extraPrimitiveOverestimationSizeGranularityFloat.i = memory->readd(address);address+=4;
    s->extraPrimitiveOverestimationSizeGranularity = extraPrimitiveOverestimationSizeGranularityFloat.f;
    s->primitiveUnderestimation = (VkBool32)memory->readd(address);address+=4;
    s->conservativePointAndLineRasterization = (VkBool32)memory->readd(address);address+=4;
    s->degenerateTrianglesRasterized = (VkBool32)memory->readd(address);address+=4;
    s->degenerateLinesRasterized = (VkBool32)memory->readd(address);address+=4;
    s->fullyCoveredFragmentShaderInputVariable = (VkBool32)memory->readd(address);address+=4;
    s->conservativeRasterizationPostDepthCoverage = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceConservativeRasterizationPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    MarshalFloat primitiveOverestimationSizeFloat;
    primitiveOverestimationSizeFloat.f = s->primitiveOverestimationSize;
    memory->writed(address, primitiveOverestimationSizeFloat.i);address+=4;
    MarshalFloat maxExtraPrimitiveOverestimationSizeFloat;
    maxExtraPrimitiveOverestimationSizeFloat.f = s->maxExtraPrimitiveOverestimationSize;
    memory->writed(address, maxExtraPrimitiveOverestimationSizeFloat.i);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeGranularityFloat;
    extraPrimitiveOverestimationSizeGranularityFloat.f = s->extraPrimitiveOverestimationSizeGranularity;
    memory->writed(address, extraPrimitiveOverestimationSizeGranularityFloat.i);address+=4;
    memory->writed(address, s->primitiveUnderestimation);address+=4;
    memory->writed(address, s->conservativePointAndLineRasterization);address+=4;
    memory->writed(address, s->degenerateTrianglesRasterized);address+=4;
    memory->writed(address, s->degenerateLinesRasterized);address+=4;
    memory->writed(address, s->fullyCoveredFragmentShaderInputVariable);address+=4;
    memory->writed(address, s->conservativeRasterizationPostDepthCoverage);address+=4;
}
MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT::~MarshalVkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkCalibratedTimestampInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCalibratedTimestampInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->timeDomain = (VkTimeDomainKHR)memory->readd(address);address+=4;
}
void MarshalVkCalibratedTimestampInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCalibratedTimestampInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->timeDomain);address+=4;
}
MarshalVkCalibratedTimestampInfoKHR::~MarshalVkCalibratedTimestampInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderEngineCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderArraysPerEngineCount = (uint32_t)memory->readd(address);address+=4;
    s->computeUnitsPerShaderArray = (uint32_t)memory->readd(address);address+=4;
    s->simdPerComputeUnit = (uint32_t)memory->readd(address);address+=4;
    s->wavefrontsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->wavefrontSize = (uint32_t)memory->readd(address);address+=4;
    s->sgprsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->minSgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->maxSgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->sgprAllocationGranularity = (uint32_t)memory->readd(address);address+=4;
    s->vgprsPerSimd = (uint32_t)memory->readd(address);address+=4;
    s->minVgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->maxVgprAllocation = (uint32_t)memory->readd(address);address+=4;
    s->vgprAllocationGranularity = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderEngineCount);address+=4;
    memory->writed(address, s->shaderArraysPerEngineCount);address+=4;
    memory->writed(address, s->computeUnitsPerShaderArray);address+=4;
    memory->writed(address, s->simdPerComputeUnit);address+=4;
    memory->writed(address, s->wavefrontsPerSimd);address+=4;
    memory->writed(address, s->wavefrontSize);address+=4;
    memory->writed(address, s->sgprsPerSimd);address+=4;
    memory->writed(address, s->minSgprAllocation);address+=4;
    memory->writed(address, s->maxSgprAllocation);address+=4;
    memory->writed(address, s->sgprAllocationGranularity);address+=4;
    memory->writed(address, s->vgprsPerSimd);address+=4;
    memory->writed(address, s->minVgprAllocation);address+=4;
    memory->writed(address, s->maxVgprAllocation);address+=4;
    memory->writed(address, s->vgprAllocationGranularity);address+=4;
}
MarshalVkPhysicalDeviceShaderCorePropertiesAMD::~MarshalVkPhysicalDeviceShaderCorePropertiesAMD() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderCoreProperties2AMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreProperties2AMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCoreFeatures = (VkShaderCorePropertiesFlagsAMD)memory->readd(address);address+=4;
    s->activeComputeUnitCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCoreProperties2AMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreProperties2AMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderCoreFeatures);address+=4;
    memory->writed(address, s->activeComputeUnitCount);address+=4;
}
MarshalVkPhysicalDeviceShaderCoreProperties2AMD::~MarshalVkPhysicalDeviceShaderCoreProperties2AMD() {
    delete s.pNext;
}
void MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationConservativeStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationConservativeStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->conservativeRasterizationMode = (VkConservativeRasterizationModeEXT)memory->readd(address);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeFloat;
    extraPrimitiveOverestimationSizeFloat.i = memory->readd(address);address+=4;
    s->extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSizeFloat.f;
}
void MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationConservativeStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->conservativeRasterizationMode);address+=4;
    MarshalFloat extraPrimitiveOverestimationSizeFloat;
    extraPrimitiveOverestimationSizeFloat.f = s->extraPrimitiveOverestimationSize;
    memory->writed(address, extraPrimitiveOverestimationSizeFloat.i);address+=4;
}
MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT::~MarshalVkPipelineRasterizationConservativeStateCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorIndexingFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderInputAttachmentArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingSampledImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUpdateUnusedWhilePending = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingPartiallyBound = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingVariableDescriptorCount = (VkBool32)memory->readd(address);address+=4;
    s->runtimeDescriptorArray = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderInputAttachmentArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->descriptorBindingUniformBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingSampledImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUniformTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUpdateUnusedWhilePending);address+=4;
    memory->writed(address, s->descriptorBindingPartiallyBound);address+=4;
    memory->writed(address, s->descriptorBindingVariableDescriptorCount);address+=4;
    memory->writed(address, s->runtimeDescriptorArray);address+=4;
}
MarshalVkPhysicalDeviceDescriptorIndexingFeatures::~MarshalVkPhysicalDeviceDescriptorIndexingFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorIndexingProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxUpdateAfterBindDescriptorsInAllPools = (uint32_t)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->robustBufferAccessUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->quadDivergentImplicitLod = (VkBool32)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageUpdateAfterBindResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorIndexingProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorIndexingProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxUpdateAfterBindDescriptorsInAllPools);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->robustBufferAccessUpdateAfterBind);address+=4;
    memory->writed(address, s->quadDivergentImplicitLod);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->maxPerStageUpdateAfterBindResources);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInputAttachments);address+=4;
}
MarshalVkPhysicalDeviceDescriptorIndexingProperties::~MarshalVkPhysicalDeviceDescriptorIndexingProperties() {
    delete s.pNext;
}
void MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutBindingFlagsCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->bindingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBindingFlags = NULL;
    } else {
        s->pBindingFlags = new VkDescriptorBindingFlags[(U32)s->bindingCount];
        memory->memcpy((VkDescriptorBindingFlags*)s->pBindingFlags, paramAddress, (U32)s->bindingCount);
    }
}
void MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutBindingFlagsCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->bindingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo::~MarshalVkDescriptorSetLayoutBindingFlagsCreateInfo() {
    delete s.pNext;
    delete[] s.pBindingFlags;
}
void MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorCounts = NULL;
    } else {
        s->pDescriptorCounts = new uint32_t[(U32)s->descriptorSetCount];
        memory->memcpy((uint32_t*)s->pDescriptorCounts, paramAddress, (U32)s->descriptorSetCount);
    }
}
void MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->descriptorSetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo::~MarshalVkDescriptorSetVariableDescriptorCountAllocateInfo() {
    delete s.pNext;
    delete[] s.pDescriptorCounts;
}
void MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountLayoutSupport* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxVariableDescriptorCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetVariableDescriptorCountLayoutSupport* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxVariableDescriptorCount);address+=4;
}
MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport::~MarshalVkDescriptorSetVariableDescriptorCountLayoutSupport() {
    delete s.pNext;
}
void MarshalVkAttachmentDescription2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentDescription2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkAttachmentDescriptionFlags)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->samples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->stencilLoadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->stencilStoreOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    s->initialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->finalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentDescription2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentDescription2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->samples);address+=4;
    memory->writed(address, s->loadOp);address+=4;
    memory->writed(address, s->storeOp);address+=4;
    memory->writed(address, s->stencilLoadOp);address+=4;
    memory->writed(address, s->stencilStoreOp);address+=4;
    memory->writed(address, s->initialLayout);address+=4;
    memory->writed(address, s->finalLayout);address+=4;
}
MarshalVkAttachmentDescription2::~MarshalVkAttachmentDescription2() {
    delete s.pNext;
}
void MarshalVkAttachmentReference2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentReference2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachment = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkImageLayout)memory->readd(address);address+=4;
    s->aspectMask = (VkImageAspectFlags)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReference2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentReference2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachment);address+=4;
    memory->writed(address, s->layout);address+=4;
    memory->writed(address, s->aspectMask);address+=4;
}
MarshalVkAttachmentReference2::~MarshalVkAttachmentReference2() {
    delete s.pNext;
}
void MarshalVkSubpassDescription2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDescription2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSubpassDescriptionFlags)memory->readd(address);address+=4;
    s->pipelineBindPoint = (VkPipelineBindPoint)memory->readd(address);address+=4;
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->inputAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInputAttachments = NULL;
    } else {
        VkAttachmentReference2* pInputAttachments = new VkAttachmentReference2[s->inputAttachmentCount];
        for (U32 i = 0; i < s->inputAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress + i*20, &pInputAttachments[i]);
        }
        s->pInputAttachments = pInputAttachments;
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachments = NULL;
    } else {
        VkAttachmentReference2* pColorAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress + i*20, &pColorAttachments[i]);
        }
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pResolveAttachments = NULL;
    } else {
        VkAttachmentReference2* pResolveAttachments = new VkAttachmentReference2[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress + i*20, &pResolveAttachments[i]);
        }
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilAttachment = NULL;
    } else {
        VkAttachmentReference2* pDepthStencilAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    s->preserveAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPreserveAttachments = NULL;
    } else {
        s->pPreserveAttachments = new uint32_t[(U32)s->preserveAttachmentCount];
        memory->memcpy((uint32_t*)s->pPreserveAttachments, paramAddress, (U32)s->preserveAttachmentCount);
    }
}
void MarshalVkSubpassDescription2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDescription2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->pipelineBindPoint);address+=4;
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->inputAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pInputAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pInputAttachments);
        s->pInputAttachments = pInputAttachments;
    }
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pColorAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pColorAttachments);
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pResolveAttachments = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pResolveAttachments);
        s->pResolveAttachments = pResolveAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pDepthStencilAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pDepthStencilAttachment);
        s->pDepthStencilAttachment = pDepthStencilAttachment;
    }
    memory->writed(address, s->preserveAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSubpassDescription2::~MarshalVkSubpassDescription2() {
    delete s.pNext;
    delete[] s.pInputAttachments;
    delete[] s.pColorAttachments;
    delete[] s.pResolveAttachments;
    delete s.pDepthStencilAttachment;
    delete[] s.pPreserveAttachments;
}
void MarshalVkSubpassDependency2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDependency2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcSubpass = (uint32_t)memory->readd(address);address+=4;
    s->dstSubpass = (uint32_t)memory->readd(address);address+=4;
    s->srcStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->dstStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
    s->srcAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dstAccessMask = (VkAccessFlags)memory->readd(address);address+=4;
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
    s->viewOffset = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkSubpassDependency2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDependency2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->srcSubpass);address+=4;
    memory->writed(address, s->dstSubpass);address+=4;
    memory->writed(address, s->srcStageMask);address+=4;
    memory->writed(address, s->dstStageMask);address+=4;
    memory->writed(address, s->srcAccessMask);address+=4;
    memory->writed(address, s->dstAccessMask);address+=4;
    memory->writed(address, s->dependencyFlags);address+=4;
    memory->writed(address, s->viewOffset);address+=4;
}
MarshalVkSubpassDependency2::~MarshalVkSubpassDependency2() {
    delete s.pNext;
}
void MarshalVkRenderPassCreateInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreateInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkRenderPassCreateFlags)memory->readd(address);address+=4;
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        VkAttachmentDescription2* pAttachments = new VkAttachmentDescription2[s->attachmentCount];
        for (U32 i = 0; i < s->attachmentCount; i++) {
            MarshalVkAttachmentDescription2::read(pBoxedInfo, memory, paramAddress + i*44, &pAttachments[i]);
        }
        s->pAttachments = pAttachments;
    }
    s->subpassCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubpasses = NULL;
    } else {
        VkSubpassDescription2* pSubpasses = new VkSubpassDescription2[s->subpassCount];
        for (U32 i = 0; i < s->subpassCount; i++) {
            MarshalVkSubpassDescription2::read(pBoxedInfo, memory, paramAddress + i*52, &pSubpasses[i]);
        }
        s->pSubpasses = pSubpasses;
    }
    s->dependencyCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDependencies = NULL;
    } else {
        VkSubpassDependency2* pDependencies = new VkSubpassDependency2[s->dependencyCount];
        for (U32 i = 0; i < s->dependencyCount; i++) {
            MarshalVkSubpassDependency2::read(pBoxedInfo, memory, paramAddress + i*40, &pDependencies[i]);
        }
        s->pDependencies = pDependencies;
    }
    s->correlatedViewMaskCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCorrelatedViewMasks = NULL;
    } else {
        s->pCorrelatedViewMasks = new uint32_t[(U32)s->correlatedViewMaskCount];
        memory->memcpy((uint32_t*)s->pCorrelatedViewMasks, paramAddress, (U32)s->correlatedViewMaskCount);
    }
}
void MarshalVkRenderPassCreateInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreateInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentDescription2* pAttachments = new VkAttachmentDescription2();
        MarshalVkAttachmentDescription2::read(pBoxedInfo, memory, paramAddress, pAttachments);
        s->pAttachments = pAttachments;
    }
    memory->writed(address, s->subpassCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDescription2* pSubpasses = new VkSubpassDescription2();
        MarshalVkSubpassDescription2::read(pBoxedInfo, memory, paramAddress, pSubpasses);
        s->pSubpasses = pSubpasses;
    }
    memory->writed(address, s->dependencyCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSubpassDependency2* pDependencies = new VkSubpassDependency2();
        MarshalVkSubpassDependency2::read(pBoxedInfo, memory, paramAddress, pDependencies);
        s->pDependencies = pDependencies;
    }
    memory->writed(address, s->correlatedViewMaskCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRenderPassCreateInfo2::~MarshalVkRenderPassCreateInfo2() {
    delete s.pNext;
    delete[] s.pAttachments;
    delete[] s.pSubpasses;
    delete[] s.pDependencies;
    delete[] s.pCorrelatedViewMasks;
}
void MarshalVkSubpassBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->contents = (VkSubpassContents)memory->readd(address);address+=4;
}
void MarshalVkSubpassBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->contents);address+=4;
}
MarshalVkSubpassBeginInfo::~MarshalVkSubpassBeginInfo() {
    delete s.pNext;
}
void MarshalVkSubpassEndInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassEndInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
}
void MarshalVkSubpassEndInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassEndInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
}
MarshalVkSubpassEndInfo::~MarshalVkSubpassEndInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->timelineSemaphore = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->timelineSemaphore);address+=4;
}
MarshalVkPhysicalDeviceTimelineSemaphoreFeatures::~MarshalVkPhysicalDeviceTimelineSemaphoreFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxTimelineSemaphoreValueDifference = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceTimelineSemaphoreProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTimelineSemaphoreProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->maxTimelineSemaphoreValueDifference);address+=8;
}
MarshalVkPhysicalDeviceTimelineSemaphoreProperties::~MarshalVkPhysicalDeviceTimelineSemaphoreProperties() {
    delete s.pNext;
}
void MarshalVkSemaphoreTypeCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreTypeCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->semaphoreType = (VkSemaphoreType)memory->readd(address);address+=4;
    s->initialValue = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkSemaphoreTypeCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreTypeCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->semaphoreType);address+=4;
    memory->writeq(address, s->initialValue);address+=8;
}
MarshalVkSemaphoreTypeCreateInfo::~MarshalVkSemaphoreTypeCreateInfo() {
    delete s.pNext;
}
void MarshalVkTimelineSemaphoreSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTimelineSemaphoreSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->waitSemaphoreValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreValues = NULL;
    } else {
        s->pWaitSemaphoreValues = new uint64_t[(U32)s->waitSemaphoreValueCount];
        memory->memcpy((uint64_t*)s->pWaitSemaphoreValues, paramAddress, (U32)s->waitSemaphoreValueCount);
    }
    s->signalSemaphoreValueCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreValues = NULL;
    } else {
        s->pSignalSemaphoreValues = new uint64_t[(U32)s->signalSemaphoreValueCount];
        memory->memcpy((uint64_t*)s->pSignalSemaphoreValues, paramAddress, (U32)s->signalSemaphoreValueCount);
    }
}
void MarshalVkTimelineSemaphoreSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTimelineSemaphoreSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->waitSemaphoreValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->signalSemaphoreValueCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkTimelineSemaphoreSubmitInfo::~MarshalVkTimelineSemaphoreSubmitInfo() {
    delete s.pNext;
    delete[] s.pWaitSemaphoreValues;
    delete[] s.pSignalSemaphoreValues;
}
void MarshalVkSemaphoreWaitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreWaitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSemaphoreWaitFlags)memory->readd(address);address+=4;
    s->semaphoreCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSemaphores = NULL;
    } else {
        s->pSemaphores = new VkSemaphore[(U32)s->semaphoreCount];
        memory->memcpy((VkSemaphore*)s->pSemaphores, paramAddress, (U32)s->semaphoreCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pValues = NULL;
    } else {
        s->pValues = new uint64_t[(U32)s->semaphoreCount];
        memory->memcpy((uint64_t*)s->pValues, paramAddress, (U32)s->semaphoreCount);
    }
}
void MarshalVkSemaphoreWaitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreWaitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->semaphoreCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSemaphoreWaitInfo::~MarshalVkSemaphoreWaitInfo() {
    delete s.pNext;
    delete[] s.pSemaphores;
    delete[] s.pValues;
}
void MarshalVkSemaphoreSignalInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreSignalInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->value = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkSemaphoreSignalInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreSignalInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, s->value);address+=8;
}
MarshalVkSemaphoreSignalInfo::~MarshalVkSemaphoreSignalInfo() {
    delete s.pNext;
}
void MarshalVkVertexInputBindingDivisorDescription::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputBindingDivisorDescription* s) {
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->divisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineVertexInputDivisorStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineVertexInputDivisorStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexBindingDivisorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVertexBindingDivisors = NULL;
    } else {
        s->pVertexBindingDivisors = new VkVertexInputBindingDivisorDescription[(U32)s->vertexBindingDivisorCount];
        memory->memcpy((VkVertexInputBindingDivisorDescription*)s->pVertexBindingDivisors, paramAddress, (U32)s->vertexBindingDivisorCount * sizeof(VkVertexInputBindingDivisorDescription));
    }
}
void MarshalVkPipelineVertexInputDivisorStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineVertexInputDivisorStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vertexBindingDivisorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVertexInputBindingDivisorDescription* pVertexBindingDivisors = new VkVertexInputBindingDivisorDescription();
        MarshalVkVertexInputBindingDivisorDescription::read(pBoxedInfo, memory, paramAddress, pVertexBindingDivisors);
        s->pVertexBindingDivisors = pVertexBindingDivisors;
    }
}
MarshalVkPipelineVertexInputDivisorStateCreateInfo::~MarshalVkPipelineVertexInputDivisorStateCreateInfo() {
    delete s.pNext;
    delete[] s.pVertexBindingDivisors;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxVertexAttribDivisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxVertexAttribDivisor);address+=4;
}
MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::~MarshalVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxVertexAttribDivisor = (uint32_t)memory->readd(address);address+=4;
    s->supportsNonZeroFirstInstance = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxVertexAttribDivisor);address+=4;
    memory->writed(address, s->supportsNonZeroFirstInstance);address+=4;
}
MarshalVkPhysicalDeviceVertexAttributeDivisorProperties::~MarshalVkPhysicalDeviceVertexAttributeDivisorProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePCIBusInfoPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pciDomain = (uint32_t)memory->readd(address);address+=4;
    s->pciBus = (uint32_t)memory->readd(address);address+=4;
    s->pciDevice = (uint32_t)memory->readd(address);address+=4;
    s->pciFunction = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePCIBusInfoPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pciDomain);address+=4;
    memory->writed(address, s->pciBus);address+=4;
    memory->writed(address, s->pciDevice);address+=4;
    memory->writed(address, s->pciFunction);address+=4;
}
MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT::~MarshalVkPhysicalDevicePCIBusInfoPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceConditionalRenderingInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->conditionalRenderingEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceConditionalRenderingInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->conditionalRenderingEnable);address+=4;
}
MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT::~MarshalVkCommandBufferInheritanceConditionalRenderingInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevice8BitStorageFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice8BitStorageFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->storageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice8BitStorageFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice8BitStorageFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->storageBuffer8BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer8BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant8);address+=4;
}
MarshalVkPhysicalDevice8BitStorageFeatures::~MarshalVkPhysicalDevice8BitStorageFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceConditionalRenderingFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->conditionalRendering = (VkBool32)memory->readd(address);address+=4;
    s->inheritedConditionalRendering = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceConditionalRenderingFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->conditionalRendering);address+=4;
    memory->writed(address, s->inheritedConditionalRendering);address+=4;
}
MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT::~MarshalVkPhysicalDeviceConditionalRenderingFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkanMemoryModelFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vulkanMemoryModel = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelDeviceScope = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelAvailabilityVisibilityChains = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkanMemoryModelFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vulkanMemoryModel);address+=4;
    memory->writed(address, s->vulkanMemoryModelDeviceScope);address+=4;
    memory->writed(address, s->vulkanMemoryModelAvailabilityVisibilityChains);address+=4;
}
MarshalVkPhysicalDeviceVulkanMemoryModelFeatures::~MarshalVkPhysicalDeviceVulkanMemoryModelFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderAtomicInt64Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicInt64Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderBufferInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedInt64Atomics = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicInt64Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicInt64Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderBufferInt64Atomics);address+=4;
    memory->writed(address, s->shaderSharedInt64Atomics);address+=4;
}
MarshalVkPhysicalDeviceShaderAtomicInt64Features::~MarshalVkPhysicalDeviceShaderAtomicInt64Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderBufferFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat64AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat64AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageFloat32Atomics = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageFloat32AtomicAdd = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderBufferFloat32Atomics);address+=4;
    memory->writed(address, s->shaderBufferFloat32AtomicAdd);address+=4;
    memory->writed(address, s->shaderBufferFloat64Atomics);address+=4;
    memory->writed(address, s->shaderBufferFloat64AtomicAdd);address+=4;
    memory->writed(address, s->shaderSharedFloat32Atomics);address+=4;
    memory->writed(address, s->shaderSharedFloat32AtomicAdd);address+=4;
    memory->writed(address, s->shaderSharedFloat64Atomics);address+=4;
    memory->writed(address, s->shaderSharedFloat64AtomicAdd);address+=4;
    memory->writed(address, s->shaderImageFloat32Atomics);address+=4;
    memory->writed(address, s->shaderImageFloat32AtomicAdd);address+=4;
    memory->writed(address, s->sparseImageFloat32Atomics);address+=4;
    memory->writed(address, s->sparseImageFloat32AtomicAdd);address+=4;
}
MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT::~MarshalVkPhysicalDeviceShaderAtomicFloatFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderBufferFloat16Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat16AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat16AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat32AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferFloat64AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat16Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat16AtomicAdd = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat16AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat32AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedFloat64AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->shaderImageFloat32AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageFloat32AtomicMinMax = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderBufferFloat16Atomics);address+=4;
    memory->writed(address, s->shaderBufferFloat16AtomicAdd);address+=4;
    memory->writed(address, s->shaderBufferFloat16AtomicMinMax);address+=4;
    memory->writed(address, s->shaderBufferFloat32AtomicMinMax);address+=4;
    memory->writed(address, s->shaderBufferFloat64AtomicMinMax);address+=4;
    memory->writed(address, s->shaderSharedFloat16Atomics);address+=4;
    memory->writed(address, s->shaderSharedFloat16AtomicAdd);address+=4;
    memory->writed(address, s->shaderSharedFloat16AtomicMinMax);address+=4;
    memory->writed(address, s->shaderSharedFloat32AtomicMinMax);address+=4;
    memory->writed(address, s->shaderSharedFloat64AtomicMinMax);address+=4;
    memory->writed(address, s->shaderImageFloat32AtomicMinMax);address+=4;
    memory->writed(address, s->sparseImageFloat32AtomicMinMax);address+=4;
}
MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::~MarshalVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexAttributeInstanceRateDivisor = (VkBool32)memory->readd(address);address+=4;
    s->vertexAttributeInstanceRateZeroDivisor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeDivisorFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vertexAttributeInstanceRateDivisor);address+=4;
    memory->writed(address, s->vertexAttributeInstanceRateZeroDivisor);address+=4;
}
MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures::~MarshalVkPhysicalDeviceVertexAttributeDivisorFeatures() {
    delete s.pNext;
}
void MarshalVkQueueFamilyCheckpointPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyCheckpointPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->checkpointExecutionStageMask = (VkPipelineStageFlags)memory->readd(address);address+=4;
}
void MarshalVkQueueFamilyCheckpointPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyCheckpointPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->checkpointExecutionStageMask);address+=4;
}
MarshalVkQueueFamilyCheckpointPropertiesNV::~MarshalVkQueueFamilyCheckpointPropertiesNV() {
    delete s.pNext;
}
void MarshalVkCheckpointDataNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCheckpointDataNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stage = (VkPipelineStageFlagBits)memory->readd(address);address+=4;
    s->pCheckpointMarker = (void*)memory->readd(address);address+=4;
}
void MarshalVkCheckpointDataNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCheckpointDataNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stage);address+=4;
    memory->writed(address, (U32)s->pCheckpointMarker);address+=4;
}
MarshalVkCheckpointDataNV::~MarshalVkCheckpointDataNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDepthStencilResolveProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthStencilResolveProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportedDepthResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->supportedStencilResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->independentResolveNone = (VkBool32)memory->readd(address);address+=4;
    s->independentResolve = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthStencilResolveProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthStencilResolveProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportedDepthResolveModes);address+=4;
    memory->writed(address, s->supportedStencilResolveModes);address+=4;
    memory->writed(address, s->independentResolveNone);address+=4;
    memory->writed(address, s->independentResolve);address+=4;
}
MarshalVkPhysicalDeviceDepthStencilResolveProperties::~MarshalVkPhysicalDeviceDepthStencilResolveProperties() {
    delete s.pNext;
}
void MarshalVkSubpassDescriptionDepthStencilResolve::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDescriptionDepthStencilResolve* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthResolveMode = (VkResolveModeFlagBits)memory->readd(address);address+=4;
    s->stencilResolveMode = (VkResolveModeFlagBits)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthStencilResolveAttachment = NULL;
    } else {
        VkAttachmentReference2* pDepthStencilResolveAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pDepthStencilResolveAttachment);
        s->pDepthStencilResolveAttachment = pDepthStencilResolveAttachment;
    }
}
void MarshalVkSubpassDescriptionDepthStencilResolve::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassDescriptionDepthStencilResolve* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthResolveMode);address+=4;
    memory->writed(address, s->stencilResolveMode);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pDepthStencilResolveAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pDepthStencilResolveAttachment);
        s->pDepthStencilResolveAttachment = pDepthStencilResolveAttachment;
    }
}
MarshalVkSubpassDescriptionDepthStencilResolve::~MarshalVkSubpassDescriptionDepthStencilResolve() {
    delete s.pNext;
    delete s.pDepthStencilResolveAttachment;
}
void MarshalVkImageViewASTCDecodeModeEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewASTCDecodeModeEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->decodeMode = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkImageViewASTCDecodeModeEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewASTCDecodeModeEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->decodeMode);address+=4;
}
MarshalVkImageViewASTCDecodeModeEXT::~MarshalVkImageViewASTCDecodeModeEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceASTCDecodeFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->decodeModeSharedExponent = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceASTCDecodeFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->decodeModeSharedExponent);address+=4;
}
MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT::~MarshalVkPhysicalDeviceASTCDecodeFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->transformFeedback = (VkBool32)memory->readd(address);address+=4;
    s->geometryStreams = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->transformFeedback);address+=4;
    memory->writed(address, s->geometryStreams);address+=4;
}
MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT::~MarshalVkPhysicalDeviceTransformFeedbackFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxTransformFeedbackStreams = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxTransformFeedbackStreamDataSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferDataSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTransformFeedbackBufferDataStride = (uint32_t)memory->readd(address);address+=4;
    s->transformFeedbackQueries = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackStreamsLinesTriangles = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackRasterizationStreamSelect = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackDraw = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTransformFeedbackPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxTransformFeedbackStreams);address+=4;
    memory->writed(address, s->maxTransformFeedbackBuffers);address+=4;
    memory->writeq(address, s->maxTransformFeedbackBufferSize);address+=8;
    memory->writed(address, s->maxTransformFeedbackStreamDataSize);address+=4;
    memory->writed(address, s->maxTransformFeedbackBufferDataSize);address+=4;
    memory->writed(address, s->maxTransformFeedbackBufferDataStride);address+=4;
    memory->writed(address, s->transformFeedbackQueries);address+=4;
    memory->writed(address, s->transformFeedbackStreamsLinesTriangles);address+=4;
    memory->writed(address, s->transformFeedbackRasterizationStreamSelect);address+=4;
    memory->writed(address, s->transformFeedbackDraw);address+=4;
}
MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT::~MarshalVkPhysicalDeviceTransformFeedbackPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateStreamCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationStateStreamCreateFlagsEXT)memory->readd(address);address+=4;
    s->rasterizationStream = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationStateStreamCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rasterizationStream);address+=4;
}
MarshalVkPipelineRasterizationStateStreamCreateInfoEXT::~MarshalVkPipelineRasterizationStateStreamCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->representativeFragmentTest = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->representativeFragmentTest);address+=4;
}
MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::~MarshalVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRepresentativeFragmentTestStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->representativeFragmentTestEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRepresentativeFragmentTestStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->representativeFragmentTestEnable);address+=4;
}
MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV::~MarshalVkPipelineRepresentativeFragmentTestStateCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExclusiveScissorFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->exclusiveScissor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExclusiveScissorFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->exclusiveScissor);address+=4;
}
MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV::~MarshalVkPhysicalDeviceExclusiveScissorFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportExclusiveScissorStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->exclusiveScissorCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pExclusiveScissors = NULL;
    } else {
        s->pExclusiveScissors = new VkRect2D[(U32)s->exclusiveScissorCount];
        memory->memcpy((VkRect2D*)s->pExclusiveScissors, paramAddress, (U32)s->exclusiveScissorCount * sizeof(VkRect2D));
    }
}
void MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportExclusiveScissorStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->exclusiveScissorCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pExclusiveScissors = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pExclusiveScissors);
        s->pExclusiveScissors = pExclusiveScissors;
    }
}
MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV::~MarshalVkPipelineViewportExclusiveScissorStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pExclusiveScissors;
}
void MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCornerSampledImageFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cornerSampledImage = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCornerSampledImageFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cornerSampledImage);address+=4;
}
MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV::~MarshalVkPhysicalDeviceCornerSampledImageFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->computeDerivativeGroupQuads = (VkBool32)memory->readd(address);address+=4;
    s->computeDerivativeGroupLinear = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->computeDerivativeGroupQuads);address+=4;
    memory->writed(address, s->computeDerivativeGroupLinear);address+=4;
}
MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR::~MarshalVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->meshAndTaskShaderDerivatives = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->meshAndTaskShaderDerivatives);address+=4;
}
MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR::~MarshalVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderImageFootprintFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageFootprint = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderImageFootprintFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageFootprint);address+=4;
}
MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV::~MarshalVkPhysicalDeviceShaderImageFootprintFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dedicatedAllocationImageAliasing = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dedicatedAllocationImageAliasing);address+=4;
}
MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::~MarshalVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->indirectCopy = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->indirectCopy);address+=4;
}
MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV::~MarshalVkPhysicalDeviceCopyMemoryIndirectFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportedQueues = (VkQueueFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportedQueues);address+=4;
}
MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV::~MarshalVkPhysicalDeviceCopyMemoryIndirectPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryDecompressionFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryDecompression = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryDecompressionFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryDecompression);address+=4;
}
MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV::~MarshalVkPhysicalDeviceMemoryDecompressionFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryDecompressionPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->decompressionMethods = (VkMemoryDecompressionMethodFlagsNV)memory->readq(address);address+=8;
    s->maxDecompressionIndirectCount = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryDecompressionPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->decompressionMethods);address+=8;
    memory->writeq(address, s->maxDecompressionIndirectCount);address+=8;
}
MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV::~MarshalVkPhysicalDeviceMemoryDecompressionPropertiesNV() {
    delete s.pNext;
}
void MarshalVkShadingRatePaletteNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShadingRatePaletteNV* s) {
    s->shadingRatePaletteEntryCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShadingRatePaletteEntries = NULL;
    } else {
        s->pShadingRatePaletteEntries = new VkShadingRatePaletteEntryNV[(U32)s->shadingRatePaletteEntryCount];
        memory->memcpy((VkShadingRatePaletteEntryNV*)s->pShadingRatePaletteEntries, paramAddress, (U32)s->shadingRatePaletteEntryCount);
    }
}
MarshalVkShadingRatePaletteNV::~MarshalVkShadingRatePaletteNV() {
    delete[] s.pShadingRatePaletteEntries;
}
void MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportShadingRateImageStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shadingRateImageEnable = (VkBool32)memory->readd(address);address+=4;
    s->viewportCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShadingRatePalettes = NULL;
    } else {
        VkShadingRatePaletteNV* pShadingRatePalettes = new VkShadingRatePaletteNV[s->viewportCount];
        for (U32 i = 0; i < s->viewportCount; i++) {
            MarshalVkShadingRatePaletteNV::read(pBoxedInfo, memory, paramAddress + i*8, &pShadingRatePalettes[i]);
        }
        s->pShadingRatePalettes = pShadingRatePalettes;
    }
}
void MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportShadingRateImageStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shadingRateImageEnable);address+=4;
    memory->writed(address, s->viewportCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkShadingRatePaletteNV* pShadingRatePalettes = new VkShadingRatePaletteNV();
        MarshalVkShadingRatePaletteNV::read(pBoxedInfo, memory, paramAddress, pShadingRatePalettes);
        s->pShadingRatePalettes = pShadingRatePalettes;
    }
}
MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV::~MarshalVkPipelineViewportShadingRateImageStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pShadingRatePalettes;
}
void MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImageFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shadingRateImage = (VkBool32)memory->readd(address);address+=4;
    s->shadingRateCoarseSampleOrder = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImageFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shadingRateImage);address+=4;
    memory->writed(address, s->shadingRateCoarseSampleOrder);address+=4;
}
MarshalVkPhysicalDeviceShadingRateImageFeaturesNV::~MarshalVkPhysicalDeviceShadingRateImageFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImagePropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->shadingRateTexelSize, address, 8);address+=8;
    s->shadingRatePaletteSize = (uint32_t)memory->readd(address);address+=4;
    s->shadingRateMaxCoarseSamples = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShadingRateImagePropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->shadingRateTexelSize, 8); address+=8;
    memory->writed(address, s->shadingRatePaletteSize);address+=4;
    memory->writed(address, s->shadingRateMaxCoarseSamples);address+=4;
}
MarshalVkPhysicalDeviceShadingRateImagePropertiesNV::~MarshalVkPhysicalDeviceShadingRateImagePropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->invocationMask = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->invocationMask);address+=4;
}
MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI::~MarshalVkPhysicalDeviceInvocationMaskFeaturesHUAWEI() {
    delete s.pNext;
}
void MarshalVkCoarseSampleOrderCustomNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCoarseSampleOrderCustomNV* s) {
    s->shadingRate = (VkShadingRatePaletteEntryNV)memory->readd(address);address+=4;
    s->sampleCount = (uint32_t)memory->readd(address);address+=4;
    s->sampleLocationCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSampleLocations = NULL;
    } else {
        s->pSampleLocations = new VkCoarseSampleLocationNV[(U32)s->sampleLocationCount];
        memory->memcpy((VkCoarseSampleLocationNV*)s->pSampleLocations, paramAddress, (U32)s->sampleLocationCount * sizeof(VkCoarseSampleLocationNV));
    }
}
MarshalVkCoarseSampleOrderCustomNV::~MarshalVkCoarseSampleOrderCustomNV() {
    delete[] s.pSampleLocations;
}
void MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampleOrderType = (VkCoarseSampleOrderTypeNV)memory->readd(address);address+=4;
    s->customSampleOrderCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCustomSampleOrders = NULL;
    } else {
        VkCoarseSampleOrderCustomNV* pCustomSampleOrders = new VkCoarseSampleOrderCustomNV[s->customSampleOrderCount];
        for (U32 i = 0; i < s->customSampleOrderCount; i++) {
            MarshalVkCoarseSampleOrderCustomNV::read(pBoxedInfo, memory, paramAddress + i*16, &pCustomSampleOrders[i]);
        }
        s->pCustomSampleOrders = pCustomSampleOrders;
    }
}
void MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sampleOrderType);address+=4;
    memory->writed(address, s->customSampleOrderCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCoarseSampleOrderCustomNV* pCustomSampleOrders = new VkCoarseSampleOrderCustomNV();
        MarshalVkCoarseSampleOrderCustomNV::read(pBoxedInfo, memory, paramAddress, pCustomSampleOrders);
        s->pCustomSampleOrders = pCustomSampleOrders;
    }
}
MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV::~MarshalVkPipelineViewportCoarseSampleOrderStateCreateInfoNV() {
    delete s.pNext;
    delete[] s.pCustomSampleOrders;
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->taskShader = (VkBool32)memory->readd(address);address+=4;
    s->meshShader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->taskShader);address+=4;
    memory->writed(address, s->meshShader);address+=4;
}
MarshalVkPhysicalDeviceMeshShaderFeaturesNV::~MarshalVkPhysicalDeviceMeshShaderFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxDrawMeshTasksCount = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxTaskWorkGroupSize, address, 12);address+=12;
    s->maxTaskTotalMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskOutputCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxMeshWorkGroupSize, address, 12);address+=12;
    s->maxMeshTotalMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputVertices = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputPrimitives = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerVertexGranularity = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerPrimitiveGranularity = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxDrawMeshTasksCount);address+=4;
    memory->writed(address, s->maxTaskWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxTaskWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxTaskTotalMemorySize);address+=4;
    memory->writed(address, s->maxTaskOutputCount);address+=4;
    memory->writed(address, s->maxMeshWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxMeshWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxMeshTotalMemorySize);address+=4;
    memory->writed(address, s->maxMeshOutputVertices);address+=4;
    memory->writed(address, s->maxMeshOutputPrimitives);address+=4;
    memory->writed(address, s->maxMeshMultiviewViewCount);address+=4;
    memory->writed(address, s->meshOutputPerVertexGranularity);address+=4;
    memory->writed(address, s->meshOutputPerPrimitiveGranularity);address+=4;
}
MarshalVkPhysicalDeviceMeshShaderPropertiesNV::~MarshalVkPhysicalDeviceMeshShaderPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->taskShader = (VkBool32)memory->readd(address);address+=4;
    s->meshShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewMeshShader = (VkBool32)memory->readd(address);address+=4;
    s->primitiveFragmentShadingRateMeshShader = (VkBool32)memory->readd(address);address+=4;
    s->meshShaderQueries = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->taskShader);address+=4;
    memory->writed(address, s->meshShader);address+=4;
    memory->writed(address, s->multiviewMeshShader);address+=4;
    memory->writed(address, s->primitiveFragmentShadingRateMeshShader);address+=4;
    memory->writed(address, s->meshShaderQueries);address+=4;
}
MarshalVkPhysicalDeviceMeshShaderFeaturesEXT::~MarshalVkPhysicalDeviceMeshShaderFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxTaskWorkGroupTotalCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxTaskWorkGroupCount, address, 12);address+=12;
    s->maxTaskWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxTaskWorkGroupSize, address, 12);address+=12;
    s->maxTaskPayloadSize = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxTaskPayloadAndSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshWorkGroupTotalCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxMeshWorkGroupCount, address, 12);address+=12;
    s->maxMeshWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxMeshWorkGroupSize, address, 12);address+=12;
    s->maxMeshSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshPayloadAndSharedMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshPayloadAndOutputMemorySize = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputComponents = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputVertices = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputPrimitives = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshOutputLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxMeshMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerVertexGranularity = (uint32_t)memory->readd(address);address+=4;
    s->meshOutputPerPrimitiveGranularity = (uint32_t)memory->readd(address);address+=4;
    s->maxPreferredTaskWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    s->maxPreferredMeshWorkGroupInvocations = (uint32_t)memory->readd(address);address+=4;
    s->prefersLocalInvocationVertexOutput = (VkBool32)memory->readd(address);address+=4;
    s->prefersLocalInvocationPrimitiveOutput = (VkBool32)memory->readd(address);address+=4;
    s->prefersCompactVertexOutput = (VkBool32)memory->readd(address);address+=4;
    s->prefersCompactPrimitiveOutput = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMeshShaderPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMeshShaderPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxTaskWorkGroupTotalCount);address+=4;
    memory->memcpy(address, s->maxTaskWorkGroupCount, 12); address+=12;
    memory->writed(address, s->maxTaskWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxTaskWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxTaskPayloadSize);address+=4;
    memory->writed(address, s->maxTaskSharedMemorySize);address+=4;
    memory->writed(address, s->maxTaskPayloadAndSharedMemorySize);address+=4;
    memory->writed(address, s->maxMeshWorkGroupTotalCount);address+=4;
    memory->memcpy(address, s->maxMeshWorkGroupCount, 12); address+=12;
    memory->writed(address, s->maxMeshWorkGroupInvocations);address+=4;
    memory->memcpy(address, s->maxMeshWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxMeshSharedMemorySize);address+=4;
    memory->writed(address, s->maxMeshPayloadAndSharedMemorySize);address+=4;
    memory->writed(address, s->maxMeshOutputMemorySize);address+=4;
    memory->writed(address, s->maxMeshPayloadAndOutputMemorySize);address+=4;
    memory->writed(address, s->maxMeshOutputComponents);address+=4;
    memory->writed(address, s->maxMeshOutputVertices);address+=4;
    memory->writed(address, s->maxMeshOutputPrimitives);address+=4;
    memory->writed(address, s->maxMeshOutputLayers);address+=4;
    memory->writed(address, s->maxMeshMultiviewViewCount);address+=4;
    memory->writed(address, s->meshOutputPerVertexGranularity);address+=4;
    memory->writed(address, s->meshOutputPerPrimitiveGranularity);address+=4;
    memory->writed(address, s->maxPreferredTaskWorkGroupInvocations);address+=4;
    memory->writed(address, s->maxPreferredMeshWorkGroupInvocations);address+=4;
    memory->writed(address, s->prefersLocalInvocationVertexOutput);address+=4;
    memory->writed(address, s->prefersLocalInvocationPrimitiveOutput);address+=4;
    memory->writed(address, s->prefersCompactVertexOutput);address+=4;
    memory->writed(address, s->prefersCompactPrimitiveOutput);address+=4;
}
MarshalVkPhysicalDeviceMeshShaderPropertiesEXT::~MarshalVkPhysicalDeviceMeshShaderPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkRayTracingShaderGroupCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkRayTracingShaderGroupTypeKHR)memory->readd(address);address+=4;
    s->generalShader = (uint32_t)memory->readd(address);address+=4;
    s->closestHitShader = (uint32_t)memory->readd(address);address+=4;
    s->anyHitShader = (uint32_t)memory->readd(address);address+=4;
    s->intersectionShader = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingShaderGroupCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->generalShader);address+=4;
    memory->writed(address, s->closestHitShader);address+=4;
    memory->writed(address, s->anyHitShader);address+=4;
    memory->writed(address, s->intersectionShader);address+=4;
}
MarshalVkRayTracingShaderGroupCreateInfoNV::~MarshalVkRayTracingShaderGroupCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkRayTracingShaderGroupCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkRayTracingShaderGroupTypeKHR)memory->readd(address);address+=4;
    s->generalShader = (uint32_t)memory->readd(address);address+=4;
    s->closestHitShader = (uint32_t)memory->readd(address);address+=4;
    s->anyHitShader = (uint32_t)memory->readd(address);address+=4;
    s->intersectionShader = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShaderGroupCaptureReplayHandle = NULL;
    } else {
        s->pShaderGroupCaptureReplayHandle = pBoxedInfo->rayTracingCaptureReplayShaderGroupHandles[paramAddress];
        if (!s->pShaderGroupCaptureReplayHandle) {
            kpanic("MarshalVkRayTracingShaderGroupCreateInfoKHR::read oops");
        }
    }
}
void MarshalVkRayTracingShaderGroupCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingShaderGroupCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->generalShader);address+=4;
    memory->writed(address, s->closestHitShader);address+=4;
    memory->writed(address, s->anyHitShader);address+=4;
    memory->writed(address, s->intersectionShader);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRayTracingShaderGroupCreateInfoKHR::~MarshalVkRayTracingShaderGroupCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkRayTracingPipelineCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    s->groupCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGroups = NULL;
    } else {
        VkRayTracingShaderGroupCreateInfoNV* pGroups = new VkRayTracingShaderGroupCreateInfoNV[s->groupCount];
        for (U32 i = 0; i < s->groupCount; i++) {
            MarshalVkRayTracingShaderGroupCreateInfoNV::read(pBoxedInfo, memory, paramAddress + i*28, &pGroups[i]);
        }
        s->pGroups = pGroups;
    }
    s->maxRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingPipelineCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    memory->writed(address, s->groupCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRayTracingShaderGroupCreateInfoNV* pGroups = new VkRayTracingShaderGroupCreateInfoNV();
        MarshalVkRayTracingShaderGroupCreateInfoNV::read(pBoxedInfo, memory, paramAddress, pGroups);
        s->pGroups = pGroups;
    }
    memory->writed(address, s->maxRecursionDepth);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
MarshalVkRayTracingPipelineCreateInfoNV::~MarshalVkRayTracingPipelineCreateInfoNV() {
    delete s.pNext;
    delete[] s.pStages;
    delete[] s.pGroups;
}
void MarshalVkRayTracingPipelineCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCreateFlags)memory->readd(address);address+=4;
    s->stageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStages = NULL;
    } else {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo[s->stageCount];
        for (U32 i = 0; i < s->stageCount; i++) {
            MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress + i*32, &pStages[i]);
        }
        s->pStages = pStages;
    }
    s->groupCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGroups = NULL;
    } else {
        VkRayTracingShaderGroupCreateInfoKHR* pGroups = new VkRayTracingShaderGroupCreateInfoKHR[s->groupCount];
        for (U32 i = 0; i < s->groupCount; i++) {
            MarshalVkRayTracingShaderGroupCreateInfoKHR::read(pBoxedInfo, memory, paramAddress + i*32, &pGroups[i]);
        }
        s->pGroups = pGroups;
    }
    s->maxPipelineRayRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLibraryInfo = NULL;
    } else {
        VkPipelineLibraryCreateInfoKHR* pLibraryInfo = new VkPipelineLibraryCreateInfoKHR();
        MarshalVkPipelineLibraryCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pLibraryInfo);
        s->pLibraryInfo = pLibraryInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLibraryInterface = NULL;
    } else {
        VkRayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface = new VkRayTracingPipelineInterfaceCreateInfoKHR();
        MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pLibraryInterface);
        s->pLibraryInterface = pLibraryInterface;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicState = NULL;
    } else {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->basePipelineHandle = (VkPipeline)memory->readq(address);address+=8;
    s->basePipelineIndex = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingPipelineCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineShaderStageCreateInfo* pStages = new VkPipelineShaderStageCreateInfo();
        MarshalVkPipelineShaderStageCreateInfo::read(pBoxedInfo, memory, paramAddress, pStages);
        s->pStages = pStages;
    }
    memory->writed(address, s->groupCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRayTracingShaderGroupCreateInfoKHR* pGroups = new VkRayTracingShaderGroupCreateInfoKHR();
        MarshalVkRayTracingShaderGroupCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pGroups);
        s->pGroups = pGroups;
    }
    memory->writed(address, s->maxPipelineRayRecursionDepth);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineLibraryCreateInfoKHR* pLibraryInfo = new VkPipelineLibraryCreateInfoKHR();
        MarshalVkPipelineLibraryCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pLibraryInfo);
        s->pLibraryInfo = pLibraryInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface = new VkRayTracingPipelineInterfaceCreateInfoKHR();
        MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::read(pBoxedInfo, memory, paramAddress, pLibraryInterface);
        s->pLibraryInterface = pLibraryInterface;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineDynamicStateCreateInfo* pDynamicState = new VkPipelineDynamicStateCreateInfo();
        MarshalVkPipelineDynamicStateCreateInfo::read(pBoxedInfo, memory, paramAddress, pDynamicState);
        s->pDynamicState = pDynamicState;
    }
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writeq(address, (U64)s->basePipelineHandle);address+=8;
    memory->writed(address, s->basePipelineIndex);address+=4;
}
MarshalVkRayTracingPipelineCreateInfoKHR::~MarshalVkRayTracingPipelineCreateInfoKHR() {
    delete s.pNext;
    delete[] s.pStages;
    delete[] s.pGroups;
    delete s.pLibraryInfo;
    delete s.pLibraryInterface;
    delete s.pDynamicState;
}
void MarshalVkGeometryTrianglesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryTrianglesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexData = (VkBuffer)memory->readq(address);address+=8;
    s->vertexOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->vertexCount = (uint32_t)memory->readd(address);address+=4;
    s->vertexStride = (VkDeviceSize)memory->readq(address);address+=8;
    s->vertexFormat = (VkFormat)memory->readd(address);address+=4;
    s->indexData = (VkBuffer)memory->readq(address);address+=8;
    s->indexOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->indexCount = (uint32_t)memory->readd(address);address+=4;
    s->indexType = (VkIndexType)memory->readd(address);address+=4;
    s->transformData = (VkBuffer)memory->readq(address);address+=8;
    s->transformOffset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeometryTrianglesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryTrianglesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->vertexData);address+=8;
    memory->writeq(address, s->vertexOffset);address+=8;
    memory->writed(address, s->vertexCount);address+=4;
    memory->writeq(address, s->vertexStride);address+=8;
    memory->writed(address, s->vertexFormat);address+=4;
    memory->writeq(address, (U64)s->indexData);address+=8;
    memory->writeq(address, s->indexOffset);address+=8;
    memory->writed(address, s->indexCount);address+=4;
    memory->writed(address, s->indexType);address+=4;
    memory->writeq(address, (U64)s->transformData);address+=8;
    memory->writeq(address, s->transformOffset);address+=8;
}
MarshalVkGeometryTrianglesNV::~MarshalVkGeometryTrianglesNV() {
    delete s.pNext;
}
void MarshalVkGeometryAABBNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryAABBNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->aabbData = (VkBuffer)memory->readq(address);address+=8;
    s->numAABBs = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkGeometryAABBNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryAABBNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->aabbData);address+=8;
    memory->writed(address, s->numAABBs);address+=4;
    memory->writed(address, s->stride);address+=4;
    memory->writeq(address, s->offset);address+=8;
}
MarshalVkGeometryAABBNV::~MarshalVkGeometryAABBNV() {
    delete s.pNext;
}
void MarshalVkGeometryDataNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryDataNV* s) {
    MarshalVkGeometryTrianglesNV::read(pBoxedInfo, memory, address, &s->triangles); address+=80;
    MarshalVkGeometryAABBNV::read(pBoxedInfo, memory, address, &s->aabbs); address+=32;
}
void MarshalVkGeometryNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->geometryType = (VkGeometryTypeKHR)memory->readd(address);address+=4;
    MarshalVkGeometryDataNV::read(pBoxedInfo, memory, address, &s->geometry); address+=112;
    s->flags = (VkGeometryFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkGeometryNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeometryNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->geometryType);address+=4;
    memory->memcpy(address, &s->geometry, 112); address+=112;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkGeometryNV::~MarshalVkGeometryNV() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
    s->flags = (VkBuildAccelerationStructureFlagsKHR)memory->readd(address);address+=4;
    s->instanceCount = (uint32_t)memory->readd(address);address+=4;
    s->geometryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGeometries = NULL;
    } else {
        VkGeometryNV* pGeometries = new VkGeometryNV[s->geometryCount];
        for (U32 i = 0; i < s->geometryCount; i++) {
            MarshalVkGeometryNV::read(pBoxedInfo, memory, paramAddress + i*128, &pGeometries[i]);
        }
        s->pGeometries = pGeometries;
    }
}
void MarshalVkAccelerationStructureInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->instanceCount);address+=4;
    memory->writed(address, s->geometryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkGeometryNV* pGeometries = new VkGeometryNV();
        MarshalVkGeometryNV::read(pBoxedInfo, memory, paramAddress, pGeometries);
        s->pGeometries = pGeometries;
    }
}
MarshalVkAccelerationStructureInfoNV::~MarshalVkAccelerationStructureInfoNV() {
    delete s.pNext;
    delete[] s.pGeometries;
}
void MarshalVkAccelerationStructureCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->compactedSize = (VkDeviceSize)memory->readq(address);address+=8;
    MarshalVkAccelerationStructureInfoNV::read(pBoxedInfo, memory, address, &s->info); address+=28;
}
void MarshalVkAccelerationStructureCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->compactedSize);address+=8;
    memory->memcpy(address, &s->info, 28); address+=28;
}
MarshalVkAccelerationStructureCreateInfoNV::~MarshalVkAccelerationStructureCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkBindAccelerationStructureMemoryInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindAccelerationStructureMemoryInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->deviceIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDeviceIndices = NULL;
    } else {
        s->pDeviceIndices = new uint32_t[(U32)s->deviceIndexCount];
        memory->memcpy((uint32_t*)s->pDeviceIndices, paramAddress, (U32)s->deviceIndexCount);
    }
}
void MarshalVkBindAccelerationStructureMemoryInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindAccelerationStructureMemoryInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
    memory->writed(address, s->deviceIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkBindAccelerationStructureMemoryInfoNV::~MarshalVkBindAccelerationStructureMemoryInfoNV() {
    delete s.pNext;
    delete[] s.pDeviceIndices;
}
void MarshalVkWriteDescriptorSetAccelerationStructureKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAccelerationStructures = NULL;
    } else {
        s->pAccelerationStructures = new VkAccelerationStructureKHR[(U32)s->accelerationStructureCount];
        memory->memcpy((VkAccelerationStructureKHR*)s->pAccelerationStructures, paramAddress, (U32)s->accelerationStructureCount);
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->accelerationStructureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkWriteDescriptorSetAccelerationStructureKHR::~MarshalVkWriteDescriptorSetAccelerationStructureKHR() {
    delete s.pNext;
    delete[] s.pAccelerationStructures;
}
void MarshalVkWriteDescriptorSetAccelerationStructureNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructureCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAccelerationStructures = NULL;
    } else {
        s->pAccelerationStructures = new VkAccelerationStructureNV[(U32)s->accelerationStructureCount];
        memory->memcpy((VkAccelerationStructureNV*)s->pAccelerationStructures, paramAddress, (U32)s->accelerationStructureCount);
    }
}
void MarshalVkWriteDescriptorSetAccelerationStructureNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteDescriptorSetAccelerationStructureNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->accelerationStructureCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkWriteDescriptorSetAccelerationStructureNV::~MarshalVkWriteDescriptorSetAccelerationStructureNV() {
    delete s.pNext;
    delete[] s.pAccelerationStructures;
}
void MarshalVkAccelerationStructureMemoryRequirementsInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureMemoryRequirementsInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkAccelerationStructureMemoryRequirementsTypeNV)memory->readd(address);address+=4;
    s->accelerationStructure = (VkAccelerationStructureNV)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureMemoryRequirementsInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureMemoryRequirementsInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
}
MarshalVkAccelerationStructureMemoryRequirementsInfoNV::~MarshalVkAccelerationStructureMemoryRequirementsInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructureFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructure = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureIndirectBuild = (VkBool32)memory->readd(address);address+=4;
    s->accelerationStructureHostCommands = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingAccelerationStructureUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructureFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->accelerationStructure);address+=4;
    memory->writed(address, s->accelerationStructureCaptureReplay);address+=4;
    memory->writed(address, s->accelerationStructureIndirectBuild);address+=4;
    memory->writed(address, s->accelerationStructureHostCommands);address+=4;
    memory->writed(address, s->descriptorBindingAccelerationStructureUpdateAfterBind);address+=4;
}
MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR::~MarshalVkPhysicalDeviceAccelerationStructureFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelineFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingPipeline = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineShaderGroupHandleCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineTraceRaysIndirect = (VkBool32)memory->readd(address);address+=4;
    s->rayTraversalPrimitiveCulling = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelineFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingPipeline);address+=4;
    memory->writed(address, s->rayTracingPipelineShaderGroupHandleCaptureReplay);address+=4;
    memory->writed(address, s->rayTracingPipelineShaderGroupHandleCaptureReplayMixed);address+=4;
    memory->writed(address, s->rayTracingPipelineTraceRaysIndirect);address+=4;
    memory->writed(address, s->rayTraversalPrimitiveCulling);address+=4;
}
MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR::~MarshalVkPhysicalDeviceRayTracingPipelineFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayQueryFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayQueryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayQuery = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayQueryFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayQueryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayQuery);address+=4;
}
MarshalVkPhysicalDeviceRayQueryFeaturesKHR::~MarshalVkPhysicalDeviceRayQueryFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructurePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxGeometryCount = (uint64_t)memory->readq(address);address+=8;
    s->maxInstanceCount = (uint64_t)memory->readq(address);address+=8;
    s->maxPrimitiveCount = (uint64_t)memory->readq(address);address+=8;
    s->maxPerStageDescriptorAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
    s->minAccelerationStructureScratchOffsetAlignment = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAccelerationStructurePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->maxGeometryCount);address+=8;
    memory->writeq(address, s->maxInstanceCount);address+=8;
    memory->writeq(address, s->maxPrimitiveCount);address+=8;
    memory->writed(address, s->maxPerStageDescriptorAccelerationStructures);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindAccelerationStructures);address+=4;
    memory->writed(address, s->maxDescriptorSetAccelerationStructures);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindAccelerationStructures);address+=4;
    memory->writed(address, s->minAccelerationStructureScratchOffsetAlignment);address+=4;
}
MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR::~MarshalVkPhysicalDeviceAccelerationStructurePropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelinePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderGroupHandleSize = (uint32_t)memory->readd(address);address+=4;
    s->maxRayRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->maxShaderGroupStride = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupBaseAlignment = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupHandleCaptureReplaySize = (uint32_t)memory->readd(address);address+=4;
    s->maxRayDispatchInvocationCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupHandleAlignment = (uint32_t)memory->readd(address);address+=4;
    s->maxRayHitAttributeSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPipelinePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderGroupHandleSize);address+=4;
    memory->writed(address, s->maxRayRecursionDepth);address+=4;
    memory->writed(address, s->maxShaderGroupStride);address+=4;
    memory->writed(address, s->shaderGroupBaseAlignment);address+=4;
    memory->writed(address, s->shaderGroupHandleCaptureReplaySize);address+=4;
    memory->writed(address, s->maxRayDispatchInvocationCount);address+=4;
    memory->writed(address, s->shaderGroupHandleAlignment);address+=4;
    memory->writed(address, s->maxRayHitAttributeSize);address+=4;
}
MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR::~MarshalVkPhysicalDeviceRayTracingPipelinePropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderGroupHandleSize = (uint32_t)memory->readd(address);address+=4;
    s->maxRecursionDepth = (uint32_t)memory->readd(address);address+=4;
    s->maxShaderGroupStride = (uint32_t)memory->readd(address);address+=4;
    s->shaderGroupBaseAlignment = (uint32_t)memory->readd(address);address+=4;
    s->maxGeometryCount = (uint64_t)memory->readq(address);address+=8;
    s->maxInstanceCount = (uint64_t)memory->readq(address);address+=8;
    s->maxTriangleCount = (uint64_t)memory->readq(address);address+=8;
    s->maxDescriptorSetAccelerationStructures = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderGroupHandleSize);address+=4;
    memory->writed(address, s->maxRecursionDepth);address+=4;
    memory->writed(address, s->maxShaderGroupStride);address+=4;
    memory->writed(address, s->shaderGroupBaseAlignment);address+=4;
    memory->writeq(address, s->maxGeometryCount);address+=8;
    memory->writeq(address, s->maxInstanceCount);address+=8;
    memory->writeq(address, s->maxTriangleCount);address+=8;
    memory->writed(address, s->maxDescriptorSetAccelerationStructures);address+=4;
}
MarshalVkPhysicalDeviceRayTracingPropertiesNV::~MarshalVkPhysicalDeviceRayTracingPropertiesNV() {
    delete s.pNext;
}
void MarshalVkStridedDeviceAddressRegionKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkStridedDeviceAddressRegionKHR* s) {
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->stride = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingMaintenance1 = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingPipelineTraceRaysIndirect2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingMaintenance1);address+=4;
    memory->writed(address, s->rayTracingPipelineTraceRaysIndirect2);address+=4;
}
MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::~MarshalVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR() {
    delete s.pNext;
}
void MarshalVkImageStencilUsageCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageStencilUsageCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stencilUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkImageStencilUsageCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageStencilUsageCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stencilUsage);address+=4;
}
MarshalVkImageStencilUsageCreateInfo::~MarshalVkImageStencilUsageCreateInfo() {
    delete s.pNext;
}
void MarshalVkDeviceMemoryOverallocationCreateInfoAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceMemoryOverallocationCreateInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->overallocationBehavior = (VkMemoryOverallocationBehaviorAMD)memory->readd(address);address+=4;
}
void MarshalVkDeviceMemoryOverallocationCreateInfoAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceMemoryOverallocationCreateInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->overallocationBehavior);address+=4;
}
MarshalVkDeviceMemoryOverallocationCreateInfoAMD::~MarshalVkDeviceMemoryOverallocationCreateInfoAMD() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentDensityMap = (VkBool32)memory->readd(address);address+=4;
    s->fragmentDensityMapDynamic = (VkBool32)memory->readd(address);address+=4;
    s->fragmentDensityMapNonSubsampledImages = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentDensityMap);address+=4;
    memory->writed(address, s->fragmentDensityMapDynamic);address+=4;
    memory->writed(address, s->fragmentDensityMapNonSubsampledImages);address+=4;
}
MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT::~MarshalVkPhysicalDeviceFragmentDensityMapFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentDensityMapDeferred = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentDensityMapDeferred);address+=4;
}
MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT::~MarshalVkPhysicalDeviceFragmentDensityMap2FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentDensityMapOffset = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentDensityMapOffset);address+=4;
}
MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::~MarshalVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->minFragmentDensityTexelSize, address, 8);address+=8;
    memory->memcpy(&s->maxFragmentDensityTexelSize, address, 8);address+=8;
    s->fragmentDensityInvocations = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->minFragmentDensityTexelSize, 8); address+=8;
    memory->memcpy(address, &s->maxFragmentDensityTexelSize, 8); address+=8;
    memory->writed(address, s->fragmentDensityInvocations);address+=4;
}
MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT::~MarshalVkPhysicalDeviceFragmentDensityMapPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subsampledLoads = (VkBool32)memory->readd(address);address+=4;
    s->subsampledCoarseReconstructionEarlyAccess = (VkBool32)memory->readd(address);address+=4;
    s->maxSubsampledArrayLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetSubsampledSamplers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subsampledLoads);address+=4;
    memory->writed(address, s->subsampledCoarseReconstructionEarlyAccess);address+=4;
    memory->writed(address, s->maxSubsampledArrayLayers);address+=4;
    memory->writed(address, s->maxDescriptorSetSubsampledSamplers);address+=4;
}
MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT::~MarshalVkPhysicalDeviceFragmentDensityMap2PropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->fragmentDensityOffsetGranularity, address, 8);address+=8;
}
void MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->fragmentDensityOffsetGranularity, 8); address+=8;
}
MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::~MarshalVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM() {
    delete s.pNext;
}
void MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassFragmentDensityMapCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalVkAttachmentReference::read(pBoxedInfo, memory, address, &s->fragmentDensityMapAttachment); address+=8;
}
void MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassFragmentDensityMapCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->fragmentDensityMapAttachment, 8); address+=8;
}
MarshalVkRenderPassFragmentDensityMapCreateInfoEXT::~MarshalVkRenderPassFragmentDensityMapCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassFragmentDensityMapOffsetEndInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentDensityOffsetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFragmentDensityOffsets = NULL;
    } else {
        s->pFragmentDensityOffsets = new VkOffset2D[(U32)s->fragmentDensityOffsetCount];
        memory->memcpy((VkOffset2D*)s->pFragmentDensityOffsets, paramAddress, (U32)s->fragmentDensityOffsetCount * sizeof(VkOffset2D));
    }
}
void MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassFragmentDensityMapOffsetEndInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentDensityOffsetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkOffset2D* pFragmentDensityOffsets = new VkOffset2D();
        MarshalVkOffset2D::read(pBoxedInfo, memory, paramAddress, pFragmentDensityOffsets);
        s->pFragmentDensityOffsets = pFragmentDensityOffsets;
    }
}
MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM::~MarshalVkSubpassFragmentDensityMapOffsetEndInfoQCOM() {
    delete s.pNext;
    delete[] s.pFragmentDensityOffsets;
}
void MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceScalarBlockLayoutFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->scalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceScalarBlockLayoutFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->scalarBlockLayout);address+=4;
}
MarshalVkPhysicalDeviceScalarBlockLayoutFeatures::~MarshalVkPhysicalDeviceScalarBlockLayoutFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->uniformBufferStandardLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->uniformBufferStandardLayout);address+=4;
}
MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures::~MarshalVkPhysicalDeviceUniformBufferStandardLayoutFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClipEnableFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthClipEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClipEnableFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthClipEnable);address+=4;
}
MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT::~MarshalVkPhysicalDeviceDepthClipEnableFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationDepthClipStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineRasterizationDepthClipStateCreateFlagsEXT)memory->readd(address);address+=4;
    s->depthClipEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationDepthClipStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->depthClipEnable);address+=4;
}
MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT::~MarshalVkPipelineRasterizationDepthClipStateCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryBudgetPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->heapBudget, address, 128);address+=128;
    memory->memcpy(&s->heapUsage, address, 128);address+=128;
}
void MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryBudgetPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->heapBudget, 128); address+=128;
    memory->memcpy(address, s->heapUsage, 128); address+=128;
}
MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT::~MarshalVkPhysicalDeviceMemoryBudgetPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryPriorityFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryPriority = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMemoryPriorityFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryPriority);address+=4;
}
MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT::~MarshalVkPhysicalDeviceMemoryPriorityFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkMemoryPriorityAllocateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryPriorityAllocateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalFloat priorityFloat;
    priorityFloat.i = memory->readd(address);address+=4;
    s->priority = priorityFloat.f;
}
void MarshalVkMemoryPriorityAllocateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryPriorityAllocateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    MarshalFloat priorityFloat;
    priorityFloat.f = s->priority;
    memory->writed(address, priorityFloat.i);address+=4;
}
MarshalVkMemoryPriorityAllocateInfoEXT::~MarshalVkMemoryPriorityAllocateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pageableDeviceLocalMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pageableDeviceLocalMemory);address+=4;
}
MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::~MarshalVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
}
MarshalVkPhysicalDeviceBufferDeviceAddressFeatures::~MarshalVkPhysicalDeviceBufferDeviceAddressFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
}
MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT::~MarshalVkPhysicalDeviceBufferDeviceAddressFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkBufferDeviceAddressInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferDeviceAddressInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkBufferDeviceAddressInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferDeviceAddressInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkBufferDeviceAddressInfo::~MarshalVkBufferDeviceAddressInfo() {
    delete s.pNext;
}
void MarshalVkBufferOpaqueCaptureAddressCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferOpaqueCaptureAddressCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->opaqueCaptureAddress = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkBufferOpaqueCaptureAddressCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferOpaqueCaptureAddressCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->opaqueCaptureAddress);address+=8;
}
MarshalVkBufferOpaqueCaptureAddressCreateInfo::~MarshalVkBufferOpaqueCaptureAddressCreateInfo() {
    delete s.pNext;
}
void MarshalVkBufferDeviceAddressCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferDeviceAddressCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkBufferDeviceAddressCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferDeviceAddressCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->deviceAddress);address+=8;
}
MarshalVkBufferDeviceAddressCreateInfoEXT::~MarshalVkBufferDeviceAddressCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageViewImageFormatInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageViewType = (VkImageViewType)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageViewImageFormatInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageViewType);address+=4;
}
MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT::~MarshalVkPhysicalDeviceImageViewImageFormatInfoEXT() {
    delete s.pNext;
}
void MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFilterCubicImageViewImageFormatPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->filterCubic = (VkBool32)memory->readd(address);address+=4;
    s->filterCubicMinmax = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFilterCubicImageViewImageFormatPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->filterCubic);address+=4;
    memory->writed(address, s->filterCubicMinmax);address+=4;
}
MarshalVkFilterCubicImageViewImageFormatPropertiesEXT::~MarshalVkFilterCubicImageViewImageFormatPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImagelessFramebufferFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImagelessFramebufferFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imagelessFramebuffer = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImagelessFramebufferFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImagelessFramebufferFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imagelessFramebuffer);address+=4;
}
MarshalVkPhysicalDeviceImagelessFramebufferFeatures::~MarshalVkPhysicalDeviceImagelessFramebufferFeatures() {
    delete s.pNext;
}
void MarshalVkFramebufferAttachmentsCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferAttachmentsCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentImageInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachmentImageInfos = NULL;
    } else {
        VkFramebufferAttachmentImageInfo* pAttachmentImageInfos = new VkFramebufferAttachmentImageInfo[s->attachmentImageInfoCount];
        for (U32 i = 0; i < s->attachmentImageInfoCount; i++) {
            MarshalVkFramebufferAttachmentImageInfo::read(pBoxedInfo, memory, paramAddress + i*36, &pAttachmentImageInfos[i]);
        }
        s->pAttachmentImageInfos = pAttachmentImageInfos;
    }
}
void MarshalVkFramebufferAttachmentsCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferAttachmentsCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentImageInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkFramebufferAttachmentImageInfo* pAttachmentImageInfos = new VkFramebufferAttachmentImageInfo();
        MarshalVkFramebufferAttachmentImageInfo::read(pBoxedInfo, memory, paramAddress, pAttachmentImageInfos);
        s->pAttachmentImageInfos = pAttachmentImageInfos;
    }
}
MarshalVkFramebufferAttachmentsCreateInfo::~MarshalVkFramebufferAttachmentsCreateInfo() {
    delete s.pNext;
    delete[] s.pAttachmentImageInfos;
}
void MarshalVkFramebufferAttachmentImageInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferAttachmentImageInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkImageCreateFlags)memory->readd(address);address+=4;
    s->usage = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
    s->viewFormatCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewFormats = NULL;
    } else {
        s->pViewFormats = new VkFormat[(U32)s->viewFormatCount];
        memory->memcpy((VkFormat*)s->pViewFormats, paramAddress, (U32)s->viewFormatCount);
    }
}
void MarshalVkFramebufferAttachmentImageInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferAttachmentImageInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->usage);address+=4;
    memory->writed(address, s->width);address+=4;
    memory->writed(address, s->height);address+=4;
    memory->writed(address, s->layerCount);address+=4;
    memory->writed(address, s->viewFormatCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkFramebufferAttachmentImageInfo::~MarshalVkFramebufferAttachmentImageInfo() {
    delete s.pNext;
    delete[] s.pViewFormats;
}
void MarshalVkRenderPassAttachmentBeginInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassAttachmentBeginInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pAttachments = NULL;
    } else {
        s->pAttachments = new VkImageView[(U32)s->attachmentCount];
        memory->memcpy((VkImageView*)s->pAttachments, paramAddress, (U32)s->attachmentCount);
    }
}
void MarshalVkRenderPassAttachmentBeginInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassAttachmentBeginInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRenderPassAttachmentBeginInfo::~MarshalVkRenderPassAttachmentBeginInfo() {
    delete s.pNext;
    delete[] s.pAttachments;
}
void MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTextureCompressionASTCHDRFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->textureCompressionASTC_HDR = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTextureCompressionASTCHDRFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->textureCompressionASTC_HDR);address+=4;
}
MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures::~MarshalVkPhysicalDeviceTextureCompressionASTCHDRFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrix = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixRobustBufferAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrix);address+=4;
    memory->writed(address, s->cooperativeMatrixRobustBufferAccess);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV::~MarshalVkPhysicalDeviceCooperativeMatrixFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrixSupportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrixSupportedStages);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV::~MarshalVkPhysicalDeviceCooperativeMatrixPropertiesNV() {
    delete s.pNext;
}
void MarshalVkCooperativeMatrixPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->MSize = (uint32_t)memory->readd(address);address+=4;
    s->NSize = (uint32_t)memory->readd(address);address+=4;
    s->KSize = (uint32_t)memory->readd(address);address+=4;
    s->AType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->BType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->CType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->DType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->scope = (VkScopeKHR)memory->readd(address);address+=4;
}
void MarshalVkCooperativeMatrixPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->MSize);address+=4;
    memory->writed(address, s->NSize);address+=4;
    memory->writed(address, s->KSize);address+=4;
    memory->writed(address, s->AType);address+=4;
    memory->writed(address, s->BType);address+=4;
    memory->writed(address, s->CType);address+=4;
    memory->writed(address, s->DType);address+=4;
    memory->writed(address, s->scope);address+=4;
}
MarshalVkCooperativeMatrixPropertiesNV::~MarshalVkCooperativeMatrixPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->ycbcrImageArrays = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->ycbcrImageArrays);address+=4;
}
MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT::~MarshalVkPhysicalDeviceYcbcrImageArraysFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkImageViewHandleInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewHandleInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->descriptorType = (VkDescriptorType)memory->readd(address);address+=4;
    s->sampler = (VkSampler)memory->readq(address);address+=8;
}
void MarshalVkImageViewHandleInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewHandleInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->imageView);address+=8;
    memory->writed(address, s->descriptorType);address+=4;
    memory->writeq(address, (U64)s->sampler);address+=8;
}
MarshalVkImageViewHandleInfoNVX::~MarshalVkImageViewHandleInfoNVX() {
    delete s.pNext;
}
void MarshalVkImageViewAddressPropertiesNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewAddressPropertiesNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkImageViewAddressPropertiesNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewAddressPropertiesNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->deviceAddress);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkImageViewAddressPropertiesNVX::~MarshalVkImageViewAddressPropertiesNVX() {
    delete s.pNext;
}
void MarshalVkPipelineCreationFeedback::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreationFeedback* s) {
    s->flags = (VkPipelineCreationFeedbackFlags)memory->readd(address);address+=4;
    s->duration = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPipelineCreationFeedbackCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreationFeedbackCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineCreationFeedback = NULL;
    } else {
        VkPipelineCreationFeedback* pPipelineCreationFeedback = new VkPipelineCreationFeedback();
        MarshalVkPipelineCreationFeedback::read(pBoxedInfo, memory, paramAddress, pPipelineCreationFeedback);
        s->pPipelineCreationFeedback = pPipelineCreationFeedback;
    }
    s->pipelineStageCreationFeedbackCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPipelineStageCreationFeedbacks = NULL;
    } else {
        s->pPipelineStageCreationFeedbacks = new VkPipelineCreationFeedback[(U32)s->pipelineStageCreationFeedbackCount];
        memory->memcpy((VkPipelineCreationFeedback*)s->pPipelineStageCreationFeedbacks, paramAddress, (U32)s->pipelineStageCreationFeedbackCount * sizeof(VkPipelineCreationFeedback));
    }
}
void MarshalVkPipelineCreationFeedbackCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCreationFeedbackCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineCreationFeedback* pPipelineCreationFeedback = new VkPipelineCreationFeedback();
        MarshalVkPipelineCreationFeedback::read(pBoxedInfo, memory, paramAddress, pPipelineCreationFeedback);
        s->pPipelineCreationFeedback = pPipelineCreationFeedback;
    }
    memory->writed(address, s->pipelineStageCreationFeedbackCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPipelineCreationFeedback* pPipelineStageCreationFeedbacks = new VkPipelineCreationFeedback();
        MarshalVkPipelineCreationFeedback::read(pBoxedInfo, memory, paramAddress, pPipelineStageCreationFeedbacks);
        s->pPipelineStageCreationFeedbacks = pPipelineStageCreationFeedbacks;
    }
}
MarshalVkPipelineCreationFeedbackCreateInfo::~MarshalVkPipelineCreationFeedbackCreateInfo() {
    delete s.pNext;
    delete s.pPipelineCreationFeedback;
    delete[] s.pPipelineStageCreationFeedbacks;
}
void MarshalVkPhysicalDevicePresentBarrierFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentBarrierFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentBarrier = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePresentBarrierFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentBarrierFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentBarrier);address+=4;
}
MarshalVkPhysicalDevicePresentBarrierFeaturesNV::~MarshalVkPhysicalDevicePresentBarrierFeaturesNV() {
    delete s.pNext;
}
void MarshalVkSurfaceCapabilitiesPresentBarrierNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilitiesPresentBarrierNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentBarrierSupported = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSurfaceCapabilitiesPresentBarrierNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfaceCapabilitiesPresentBarrierNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentBarrierSupported);address+=4;
}
MarshalVkSurfaceCapabilitiesPresentBarrierNV::~MarshalVkSurfaceCapabilitiesPresentBarrierNV() {
    delete s.pNext;
}
void MarshalVkSwapchainPresentBarrierCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentBarrierCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentBarrierEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSwapchainPresentBarrierCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentBarrierCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentBarrierEnable);address+=4;
}
MarshalVkSwapchainPresentBarrierCreateInfoNV::~MarshalVkSwapchainPresentBarrierCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->performanceCounterQueryPools = (VkBool32)memory->readd(address);address+=4;
    s->performanceCounterMultipleQueryPools = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->performanceCounterQueryPools);address+=4;
    memory->writed(address, s->performanceCounterMultipleQueryPools);address+=4;
}
MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR::~MarshalVkPhysicalDevicePerformanceQueryFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->allowCommandBufferQueryCopies = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerformanceQueryPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->allowCommandBufferQueryCopies);address+=4;
}
MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR::~MarshalVkPhysicalDevicePerformanceQueryPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPerformanceCounterKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceCounterKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->unit = (VkPerformanceCounterUnitKHR)memory->readd(address);address+=4;
    s->scope = (VkPerformanceCounterScopeKHR)memory->readd(address);address+=4;
    s->storage = (VkPerformanceCounterStorageKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->uuid, address, 16);address+=16;
}
void MarshalVkPerformanceCounterKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceCounterKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->unit);address+=4;
    memory->writed(address, s->scope);address+=4;
    memory->writed(address, s->storage);address+=4;
    memory->memcpy(address, s->uuid, 16); address+=16;
}
MarshalVkPerformanceCounterKHR::~MarshalVkPerformanceCounterKHR() {
    delete s.pNext;
}
void MarshalVkPerformanceCounterDescriptionKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceCounterDescriptionKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPerformanceCounterDescriptionFlagsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->category, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
}
void MarshalVkPerformanceCounterDescriptionKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceCounterDescriptionKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->category, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
}
MarshalVkPerformanceCounterDescriptionKHR::~MarshalVkPerformanceCounterDescriptionKHR() {
    delete s.pNext;
}
void MarshalVkQueryPoolPerformanceCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolPerformanceCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->counterIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCounterIndices = NULL;
    } else {
        s->pCounterIndices = new uint32_t[(U32)s->counterIndexCount];
        memory->memcpy((uint32_t*)s->pCounterIndices, paramAddress, (U32)s->counterIndexCount);
    }
}
void MarshalVkQueryPoolPerformanceCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolPerformanceCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->counterIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkQueryPoolPerformanceCreateInfoKHR::~MarshalVkQueryPoolPerformanceCreateInfoKHR() {
    delete s.pNext;
    delete[] s.pCounterIndices;
}
void MarshalVkAcquireProfilingLockInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAcquireProfilingLockInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkAcquireProfilingLockFlagsKHR)memory->readd(address);address+=4;
    s->timeout = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkAcquireProfilingLockInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAcquireProfilingLockInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->timeout);address+=8;
}
MarshalVkAcquireProfilingLockInfoKHR::~MarshalVkAcquireProfilingLockInfoKHR() {
    delete s.pNext;
}
void MarshalVkPerformanceQuerySubmitInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceQuerySubmitInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->counterPassIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPerformanceQuerySubmitInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceQuerySubmitInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->counterPassIndex);address+=4;
}
MarshalVkPerformanceQuerySubmitInfoKHR::~MarshalVkPerformanceQuerySubmitInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCoverageReductionModeFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->coverageReductionMode = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCoverageReductionModeFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->coverageReductionMode);address+=4;
}
MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV::~MarshalVkPhysicalDeviceCoverageReductionModeFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPipelineCoverageReductionStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageReductionStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkPipelineCoverageReductionStateCreateFlagsNV)memory->readd(address);address+=4;
    s->coverageReductionMode = (VkCoverageReductionModeNV)memory->readd(address);address+=4;
}
void MarshalVkPipelineCoverageReductionStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCoverageReductionStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->coverageReductionMode);address+=4;
}
MarshalVkPipelineCoverageReductionStateCreateInfoNV::~MarshalVkPipelineCoverageReductionStateCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkFramebufferMixedSamplesCombinationNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferMixedSamplesCombinationNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->coverageReductionMode = (VkCoverageReductionModeNV)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->depthStencilSamples = (VkSampleCountFlags)memory->readd(address);address+=4;
    s->colorSamples = (VkSampleCountFlags)memory->readd(address);address+=4;
}
void MarshalVkFramebufferMixedSamplesCombinationNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFramebufferMixedSamplesCombinationNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->coverageReductionMode);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
    memory->writed(address, s->depthStencilSamples);address+=4;
    memory->writed(address, s->colorSamples);address+=4;
}
MarshalVkFramebufferMixedSamplesCombinationNV::~MarshalVkFramebufferMixedSamplesCombinationNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderIntegerFunctions2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderIntegerFunctions2);address+=4;
}
MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::~MarshalVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL() {
    delete s.pNext;
}
void MarshalVkPerformanceValueINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceValueINTEL* s) {
    s->type = (VkPerformanceValueTypeINTEL)memory->readd(address);address+=4;
    s->data = (VkPerformanceValueDataINTEL)memory->readq(address);address+=8;
}
void MarshalVkPerformanceValueINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceValueINTEL* s) {
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, s->data.value64);address+=8;
}
void MarshalVkInitializePerformanceApiInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkInitializePerformanceApiInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pUserData = (void*)memory->readd(address);address+=4;
}
void MarshalVkInitializePerformanceApiInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkInitializePerformanceApiInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->pUserData);address+=4;
}
MarshalVkInitializePerformanceApiInfoINTEL::~MarshalVkInitializePerformanceApiInfoINTEL() {
    delete s.pNext;
}
void MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolPerformanceQueryCreateInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->performanceCountersSampling = (VkQueryPoolSamplingModeINTEL)memory->readd(address);address+=4;
}
void MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolPerformanceQueryCreateInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->performanceCountersSampling);address+=4;
}
MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL::~MarshalVkQueryPoolPerformanceQueryCreateInfoINTEL() {
    delete s.pNext;
}
void MarshalVkPerformanceMarkerInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceMarkerInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->marker = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPerformanceMarkerInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceMarkerInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->marker);address+=8;
}
MarshalVkPerformanceMarkerInfoINTEL::~MarshalVkPerformanceMarkerInfoINTEL() {
    delete s.pNext;
}
void MarshalVkPerformanceStreamMarkerInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceStreamMarkerInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->marker = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPerformanceStreamMarkerInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceStreamMarkerInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->marker);address+=4;
}
MarshalVkPerformanceStreamMarkerInfoINTEL::~MarshalVkPerformanceStreamMarkerInfoINTEL() {
    delete s.pNext;
}
void MarshalVkPerformanceOverrideInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceOverrideInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkPerformanceOverrideTypeINTEL)memory->readd(address);address+=4;
    s->enable = (VkBool32)memory->readd(address);address+=4;
    s->parameter = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkPerformanceOverrideInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceOverrideInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->writed(address, s->enable);address+=4;
    memory->writeq(address, s->parameter);address+=8;
}
MarshalVkPerformanceOverrideInfoINTEL::~MarshalVkPerformanceOverrideInfoINTEL() {
    delete s.pNext;
}
void MarshalVkPerformanceConfigurationAcquireInfoINTEL::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceConfigurationAcquireInfoINTEL* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkPerformanceConfigurationTypeINTEL)memory->readd(address);address+=4;
}
void MarshalVkPerformanceConfigurationAcquireInfoINTEL::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPerformanceConfigurationAcquireInfoINTEL* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
}
MarshalVkPerformanceConfigurationAcquireInfoINTEL::~MarshalVkPerformanceConfigurationAcquireInfoINTEL() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderClockFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderClockFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSubgroupClock = (VkBool32)memory->readd(address);address+=4;
    s->shaderDeviceClock = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderClockFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderClockFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSubgroupClock);address+=4;
    memory->writed(address, s->shaderDeviceClock);address+=4;
}
MarshalVkPhysicalDeviceShaderClockFeaturesKHR::~MarshalVkPhysicalDeviceShaderClockFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceIndexTypeUint8Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceIndexTypeUint8Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->indexTypeUint8 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceIndexTypeUint8Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceIndexTypeUint8Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->indexTypeUint8);address+=4;
}
MarshalVkPhysicalDeviceIndexTypeUint8Features::~MarshalVkPhysicalDeviceIndexTypeUint8Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSMCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderWarpsPerSM = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSMCount);address+=4;
    memory->writed(address, s->shaderWarpsPerSM);address+=4;
}
MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV::~MarshalVkPhysicalDeviceShaderSMBuiltinsPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSMBuiltins = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSMBuiltins);address+=4;
}
MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV::~MarshalVkPhysicalDeviceShaderSMBuiltinsFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentShaderSampleInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShaderPixelInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShaderShadingRateInterlock = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentShaderSampleInterlock);address+=4;
    memory->writed(address, s->fragmentShaderPixelInterlock);address+=4;
    memory->writed(address, s->fragmentShaderShadingRateInterlock);address+=4;
}
MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::~MarshalVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->separateDepthStencilLayouts = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->separateDepthStencilLayouts);address+=4;
}
MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::~MarshalVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures() {
    delete s.pNext;
}
void MarshalVkAttachmentReferenceStencilLayout::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentReferenceStencilLayout* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stencilLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentReferenceStencilLayout::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentReferenceStencilLayout* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stencilLayout);address+=4;
}
MarshalVkAttachmentReferenceStencilLayout::~MarshalVkAttachmentReferenceStencilLayout() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->primitiveTopologyListRestart = (VkBool32)memory->readd(address);address+=4;
    s->primitiveTopologyPatchListRestart = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->primitiveTopologyListRestart);address+=4;
    memory->writed(address, s->primitiveTopologyPatchListRestart);address+=4;
}
MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::~MarshalVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkAttachmentDescriptionStencilLayout::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentDescriptionStencilLayout* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stencilInitialLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->stencilFinalLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkAttachmentDescriptionStencilLayout::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentDescriptionStencilLayout* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stencilInitialLayout);address+=4;
    memory->writed(address, s->stencilFinalLayout);address+=4;
}
MarshalVkAttachmentDescriptionStencilLayout::~MarshalVkAttachmentDescriptionStencilLayout() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineExecutableInfo = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineExecutableInfo);address+=4;
}
MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::~MarshalVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPipelineInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkPipelineInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
MarshalVkPipelineInfoKHR::~MarshalVkPipelineInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineExecutablePropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutablePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stages = (VkShaderStageFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineExecutablePropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutablePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stages);address+=4;
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->subgroupSize);address+=4;
}
MarshalVkPipelineExecutablePropertiesKHR::~MarshalVkPipelineExecutablePropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPipelineExecutableInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
    s->executableIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineExecutableInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
    memory->writed(address, s->executableIndex);address+=4;
}
MarshalVkPipelineExecutableInfoKHR::~MarshalVkPipelineExecutableInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineExecutableStatisticKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableStatisticKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->format = (VkPipelineExecutableStatisticFormatKHR)memory->readd(address);address+=4;
    s->value = (VkPipelineExecutableStatisticValueKHR)memory->readq(address);address+=8;
}
void MarshalVkPipelineExecutableStatisticKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableStatisticKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->format);address+=4;
    memory->writeq(address, s->value.i64);address+=8;
}
MarshalVkPipelineExecutableStatisticKHR::~MarshalVkPipelineExecutableStatisticKHR() {
    delete s.pNext;
}
void MarshalVkPipelineExecutableInternalRepresentationKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableInternalRepresentationKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->isText = (VkBool32)memory->readd(address);address+=4;
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkPipelineExecutableInternalRepresentationKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineExecutableInternalRepresentationKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->writed(address, s->isText);address+=4;
    memory->writed(address, (U32)s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineExecutableInternalRepresentationKHR::~MarshalVkPipelineExecutableInternalRepresentationKHR() {
    delete s.pNext;
    delete[] s.pData;
}
void MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderDemoteToHelperInvocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderDemoteToHelperInvocation);address+=4;
}
MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::~MarshalVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->texelBufferAlignment = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->texelBufferAlignment);address+=4;
}
MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::~MarshalVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->storageTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->storageTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
    s->uniformTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->uniformTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTexelBufferAlignmentProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTexelBufferAlignmentProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->storageTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->storageTexelBufferOffsetSingleTexelAlignment);address+=4;
    memory->writeq(address, s->uniformTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->uniformTexelBufferOffsetSingleTexelAlignment);address+=4;
}
MarshalVkPhysicalDeviceTexelBufferAlignmentProperties::~MarshalVkPhysicalDeviceTexelBufferAlignmentProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subgroupSizeControl = (VkBool32)memory->readd(address);address+=4;
    s->computeFullSubgroups = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subgroupSizeControl);address+=4;
    memory->writed(address, s->computeFullSubgroups);address+=4;
}
MarshalVkPhysicalDeviceSubgroupSizeControlFeatures::~MarshalVkPhysicalDeviceSubgroupSizeControlFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxComputeWorkgroupSubgroups = (uint32_t)memory->readd(address);address+=4;
    s->requiredSubgroupSizeStages = (VkShaderStageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubgroupSizeControlProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubgroupSizeControlProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minSubgroupSize);address+=4;
    memory->writed(address, s->maxSubgroupSize);address+=4;
    memory->writed(address, s->maxComputeWorkgroupSubgroups);address+=4;
    memory->writed(address, s->requiredSubgroupSizeStages);address+=4;
}
MarshalVkPhysicalDeviceSubgroupSizeControlProperties::~MarshalVkPhysicalDeviceSubgroupSizeControlProperties() {
    delete s.pNext;
}
void MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->requiredSubgroupSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->requiredSubgroupSize);address+=4;
}
MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo::~MarshalVkPipelineShaderStageRequiredSubgroupSizeCreateInfo() {
    delete s.pNext;
}
void MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassShadingPipelineCreateInfoHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->renderPass = (VkRenderPass)memory->readq(address);address+=8;
    s->subpass = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassShadingPipelineCreateInfoHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->renderPass);address+=8;
    memory->writed(address, s->subpass);address+=4;
}
MarshalVkSubpassShadingPipelineCreateInfoHUAWEI::~MarshalVkSubpassShadingPipelineCreateInfoHUAWEI() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxSubpassShadingWorkgroupSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxSubpassShadingWorkgroupSizeAspectRatio);address+=4;
}
MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI::~MarshalVkPhysicalDeviceSubpassShadingPropertiesHUAWEI() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->maxWorkGroupCount, address, 12);address+=12;
    memory->memcpy(&s->maxWorkGroupSize, address, 12);address+=12;
    s->maxOutputClusterCount = (uint32_t)memory->readd(address);address+=4;
    s->indirectBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->maxWorkGroupCount, 12); address+=12;
    memory->memcpy(address, s->maxWorkGroupSize, 12); address+=12;
    memory->writed(address, s->maxOutputClusterCount);address+=4;
    memory->writeq(address, s->indirectBufferOffsetAlignment);address+=8;
}
MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::~MarshalVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI() {
    delete s.pNext;
}
void MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryOpaqueCaptureAddressAllocateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->opaqueCaptureAddress = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryOpaqueCaptureAddressAllocateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->opaqueCaptureAddress);address+=8;
}
MarshalVkMemoryOpaqueCaptureAddressAllocateInfo::~MarshalVkMemoryOpaqueCaptureAddressAllocateInfo() {
    delete s.pNext;
}
void MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceMemoryOpaqueCaptureAddressInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
}
void MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceMemoryOpaqueCaptureAddressInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->memory);address+=8;
}
MarshalVkDeviceMemoryOpaqueCaptureAddressInfo::~MarshalVkDeviceMemoryOpaqueCaptureAddressInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLineRasterizationFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->bresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->smoothLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledRectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledBresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledSmoothLines = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLineRasterizationFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rectangularLines);address+=4;
    memory->writed(address, s->bresenhamLines);address+=4;
    memory->writed(address, s->smoothLines);address+=4;
    memory->writed(address, s->stippledRectangularLines);address+=4;
    memory->writed(address, s->stippledBresenhamLines);address+=4;
    memory->writed(address, s->stippledSmoothLines);address+=4;
}
MarshalVkPhysicalDeviceLineRasterizationFeatures::~MarshalVkPhysicalDeviceLineRasterizationFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLineRasterizationProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->lineSubPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLineRasterizationProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLineRasterizationProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->lineSubPixelPrecisionBits);address+=4;
}
MarshalVkPhysicalDeviceLineRasterizationProperties::~MarshalVkPhysicalDeviceLineRasterizationProperties() {
    delete s.pNext;
}
void MarshalVkPipelineRasterizationLineStateCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationLineStateCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->lineRasterizationMode = (VkLineRasterizationMode)memory->readd(address);address+=4;
    s->stippledLineEnable = (VkBool32)memory->readd(address);address+=4;
    s->lineStippleFactor = (uint32_t)memory->readd(address);address+=4;
    s->lineStipplePattern = (uint16_t)memory->readw(address);address+=2;
}
void MarshalVkPipelineRasterizationLineStateCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationLineStateCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->lineRasterizationMode);address+=4;
    memory->writed(address, s->stippledLineEnable);address+=4;
    memory->writed(address, s->lineStippleFactor);address+=4;
    memory->writew(address, s->lineStipplePattern);address+=2;
}
MarshalVkPipelineRasterizationLineStateCreateInfo::~MarshalVkPipelineRasterizationLineStateCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineCreationCacheControlFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineCreationCacheControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineCreationCacheControlFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineCreationCacheControl);address+=4;
}
MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures::~MarshalVkPhysicalDevicePipelineCreationCacheControlFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan11Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->storageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer16BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant16 = (VkBool32)memory->readd(address);address+=4;
    s->storageInputOutput16 = (VkBool32)memory->readd(address);address+=4;
    s->multiview = (VkBool32)memory->readd(address);address+=4;
    s->multiviewGeometryShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewTessellationShader = (VkBool32)memory->readd(address);address+=4;
    s->variablePointersStorageBuffer = (VkBool32)memory->readd(address);address+=4;
    s->variablePointers = (VkBool32)memory->readd(address);address+=4;
    s->protectedMemory = (VkBool32)memory->readd(address);address+=4;
    s->samplerYcbcrConversion = (VkBool32)memory->readd(address);address+=4;
    s->shaderDrawParameters = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan11Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->storageBuffer16BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer16BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant16);address+=4;
    memory->writed(address, s->storageInputOutput16);address+=4;
    memory->writed(address, s->multiview);address+=4;
    memory->writed(address, s->multiviewGeometryShader);address+=4;
    memory->writed(address, s->multiviewTessellationShader);address+=4;
    memory->writed(address, s->variablePointersStorageBuffer);address+=4;
    memory->writed(address, s->variablePointers);address+=4;
    memory->writed(address, s->protectedMemory);address+=4;
    memory->writed(address, s->samplerYcbcrConversion);address+=4;
    memory->writed(address, s->shaderDrawParameters);address+=4;
}
MarshalVkPhysicalDeviceVulkan11Features::~MarshalVkPhysicalDeviceVulkan11Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan11Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->deviceUUID, address, 16);address+=16;
    memory->memcpy(&s->driverUUID, address, 16);address+=16;
    memory->memcpy(&s->deviceLUID, address, 8);address+=8;
    s->deviceNodeMask = (uint32_t)memory->readd(address);address+=4;
    s->deviceLUIDValid = (VkBool32)memory->readd(address);address+=4;
    s->subgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->subgroupSupportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->subgroupSupportedOperations = (VkSubgroupFeatureFlags)memory->readd(address);address+=4;
    s->subgroupQuadOperationsInAllStages = (VkBool32)memory->readd(address);address+=4;
    s->pointClippingBehavior = (VkPointClippingBehavior)memory->readd(address);address+=4;
    s->maxMultiviewViewCount = (uint32_t)memory->readd(address);address+=4;
    s->maxMultiviewInstanceIndex = (uint32_t)memory->readd(address);address+=4;
    s->protectedNoFault = (VkBool32)memory->readd(address);address+=4;
    s->maxPerSetDescriptors = (uint32_t)memory->readd(address);address+=4;
    s->maxMemoryAllocationSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceVulkan11Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan11Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->deviceUUID, 16); address+=16;
    memory->memcpy(address, s->driverUUID, 16); address+=16;
    memory->memcpy(address, s->deviceLUID, 8); address+=8;
    memory->writed(address, s->deviceNodeMask);address+=4;
    memory->writed(address, s->deviceLUIDValid);address+=4;
    memory->writed(address, s->subgroupSize);address+=4;
    memory->writed(address, s->subgroupSupportedStages);address+=4;
    memory->writed(address, s->subgroupSupportedOperations);address+=4;
    memory->writed(address, s->subgroupQuadOperationsInAllStages);address+=4;
    memory->writed(address, s->pointClippingBehavior);address+=4;
    memory->writed(address, s->maxMultiviewViewCount);address+=4;
    memory->writed(address, s->maxMultiviewInstanceIndex);address+=4;
    memory->writed(address, s->protectedNoFault);address+=4;
    memory->writed(address, s->maxPerSetDescriptors);address+=4;
    memory->writeq(address, s->maxMemoryAllocationSize);address+=8;
}
MarshalVkPhysicalDeviceVulkan11Properties::~MarshalVkPhysicalDeviceVulkan11Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan12Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->samplerMirrorClampToEdge = (VkBool32)memory->readd(address);address+=4;
    s->drawIndirectCount = (VkBool32)memory->readd(address);address+=4;
    s->storageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->uniformAndStorageBuffer8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->storagePushConstant8 = (VkBool32)memory->readd(address);address+=4;
    s->shaderBufferInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderSharedInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->shaderFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderInt8 = (VkBool32)memory->readd(address);address+=4;
    s->descriptorIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayDynamicIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderUniformTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageTexelBufferArrayNonUniformIndexing = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingSampledImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageImageUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUniformTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingStorageTexelBufferUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingUpdateUnusedWhilePending = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingPartiallyBound = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingVariableDescriptorCount = (VkBool32)memory->readd(address);address+=4;
    s->runtimeDescriptorArray = (VkBool32)memory->readd(address);address+=4;
    s->samplerFilterMinmax = (VkBool32)memory->readd(address);address+=4;
    s->scalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
    s->imagelessFramebuffer = (VkBool32)memory->readd(address);address+=4;
    s->uniformBufferStandardLayout = (VkBool32)memory->readd(address);address+=4;
    s->shaderSubgroupExtendedTypes = (VkBool32)memory->readd(address);address+=4;
    s->separateDepthStencilLayouts = (VkBool32)memory->readd(address);address+=4;
    s->hostQueryReset = (VkBool32)memory->readd(address);address+=4;
    s->timelineSemaphore = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddress = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->bufferDeviceAddressMultiDevice = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModel = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelDeviceScope = (VkBool32)memory->readd(address);address+=4;
    s->vulkanMemoryModelAvailabilityVisibilityChains = (VkBool32)memory->readd(address);address+=4;
    s->shaderOutputViewportIndex = (VkBool32)memory->readd(address);address+=4;
    s->shaderOutputLayer = (VkBool32)memory->readd(address);address+=4;
    s->subgroupBroadcastDynamicId = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan12Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->samplerMirrorClampToEdge);address+=4;
    memory->writed(address, s->drawIndirectCount);address+=4;
    memory->writed(address, s->storageBuffer8BitAccess);address+=4;
    memory->writed(address, s->uniformAndStorageBuffer8BitAccess);address+=4;
    memory->writed(address, s->storagePushConstant8);address+=4;
    memory->writed(address, s->shaderBufferInt64Atomics);address+=4;
    memory->writed(address, s->shaderSharedInt64Atomics);address+=4;
    memory->writed(address, s->shaderFloat16);address+=4;
    memory->writed(address, s->shaderInt8);address+=4;
    memory->writed(address, s->descriptorIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayDynamicIndexing);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderUniformTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->shaderStorageTexelBufferArrayNonUniformIndexing);address+=4;
    memory->writed(address, s->descriptorBindingUniformBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingSampledImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageImageUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUniformTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingStorageTexelBufferUpdateAfterBind);address+=4;
    memory->writed(address, s->descriptorBindingUpdateUnusedWhilePending);address+=4;
    memory->writed(address, s->descriptorBindingPartiallyBound);address+=4;
    memory->writed(address, s->descriptorBindingVariableDescriptorCount);address+=4;
    memory->writed(address, s->runtimeDescriptorArray);address+=4;
    memory->writed(address, s->samplerFilterMinmax);address+=4;
    memory->writed(address, s->scalarBlockLayout);address+=4;
    memory->writed(address, s->imagelessFramebuffer);address+=4;
    memory->writed(address, s->uniformBufferStandardLayout);address+=4;
    memory->writed(address, s->shaderSubgroupExtendedTypes);address+=4;
    memory->writed(address, s->separateDepthStencilLayouts);address+=4;
    memory->writed(address, s->hostQueryReset);address+=4;
    memory->writed(address, s->timelineSemaphore);address+=4;
    memory->writed(address, s->bufferDeviceAddress);address+=4;
    memory->writed(address, s->bufferDeviceAddressCaptureReplay);address+=4;
    memory->writed(address, s->bufferDeviceAddressMultiDevice);address+=4;
    memory->writed(address, s->vulkanMemoryModel);address+=4;
    memory->writed(address, s->vulkanMemoryModelDeviceScope);address+=4;
    memory->writed(address, s->vulkanMemoryModelAvailabilityVisibilityChains);address+=4;
    memory->writed(address, s->shaderOutputViewportIndex);address+=4;
    memory->writed(address, s->shaderOutputLayer);address+=4;
    memory->writed(address, s->subgroupBroadcastDynamicId);address+=4;
}
MarshalVkPhysicalDeviceVulkan12Features::~MarshalVkPhysicalDeviceVulkan12Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan12Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->driverID = (VkDriverId)memory->readd(address);address+=4;
    memory->memcpy(&s->driverName, address, 256);address+=256;
    memory->memcpy(&s->driverInfo, address, 256);address+=256;
    memory->memcpy(&s->conformanceVersion, address, 4);address+=4;
    s->denormBehaviorIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->roundingModeIndependence = (VkShaderFloatControlsIndependence)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderSignedZeroInfNanPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormPreserveFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderDenormFlushToZeroFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTEFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat16 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat32 = (VkBool32)memory->readd(address);address+=4;
    s->shaderRoundingModeRTZFloat64 = (VkBool32)memory->readd(address);address+=4;
    s->maxUpdateAfterBindDescriptorsInAllPools = (uint32_t)memory->readd(address);address+=4;
    s->shaderUniformBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderSampledImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageBufferArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderStorageImageArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->shaderInputAttachmentArrayNonUniformIndexingNative = (VkBool32)memory->readd(address);address+=4;
    s->robustBufferAccessUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->quadDivergentImplicitLod = (VkBool32)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageUpdateAfterBindResources = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSamplers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffers = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindSampledImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindStorageImages = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInputAttachments = (uint32_t)memory->readd(address);address+=4;
    s->supportedDepthResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->supportedStencilResolveModes = (VkResolveModeFlags)memory->readd(address);address+=4;
    s->independentResolveNone = (VkBool32)memory->readd(address);address+=4;
    s->independentResolve = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxSingleComponentFormats = (VkBool32)memory->readd(address);address+=4;
    s->filterMinmaxImageComponentMapping = (VkBool32)memory->readd(address);address+=4;
    s->maxTimelineSemaphoreValueDifference = (uint64_t)memory->readq(address);address+=8;
    s->framebufferIntegerColorSampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan12Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan12Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->driverID);address+=4;
    memory->memcpy(address, s->driverName, 256); address+=256;
    memory->memcpy(address, s->driverInfo, 256); address+=256;
    memory->memcpy(address, &s->conformanceVersion, 4); address+=4;
    memory->writed(address, s->denormBehaviorIndependence);address+=4;
    memory->writed(address, s->roundingModeIndependence);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat16);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat32);address+=4;
    memory->writed(address, s->shaderSignedZeroInfNanPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat16);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat32);address+=4;
    memory->writed(address, s->shaderDenormPreserveFloat64);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat16);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat32);address+=4;
    memory->writed(address, s->shaderDenormFlushToZeroFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTEFloat64);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat16);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat32);address+=4;
    memory->writed(address, s->shaderRoundingModeRTZFloat64);address+=4;
    memory->writed(address, s->maxUpdateAfterBindDescriptorsInAllPools);address+=4;
    memory->writed(address, s->shaderUniformBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderSampledImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageBufferArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderStorageImageArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->shaderInputAttachmentArrayNonUniformIndexingNative);address+=4;
    memory->writed(address, s->robustBufferAccessUpdateAfterBind);address+=4;
    memory->writed(address, s->quadDivergentImplicitLod);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->maxPerStageUpdateAfterBindResources);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSamplers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffers);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindSampledImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindStorageImages);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInputAttachments);address+=4;
    memory->writed(address, s->supportedDepthResolveModes);address+=4;
    memory->writed(address, s->supportedStencilResolveModes);address+=4;
    memory->writed(address, s->independentResolveNone);address+=4;
    memory->writed(address, s->independentResolve);address+=4;
    memory->writed(address, s->filterMinmaxSingleComponentFormats);address+=4;
    memory->writed(address, s->filterMinmaxImageComponentMapping);address+=4;
    memory->writeq(address, s->maxTimelineSemaphoreValueDifference);address+=8;
    memory->writed(address, s->framebufferIntegerColorSampleCounts);address+=4;
}
MarshalVkPhysicalDeviceVulkan12Properties::~MarshalVkPhysicalDeviceVulkan12Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan13Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan13Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->robustImageAccess = (VkBool32)memory->readd(address);address+=4;
    s->inlineUniformBlock = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBindingInlineUniformBlockUpdateAfterBind = (VkBool32)memory->readd(address);address+=4;
    s->pipelineCreationCacheControl = (VkBool32)memory->readd(address);address+=4;
    s->privateData = (VkBool32)memory->readd(address);address+=4;
    s->shaderDemoteToHelperInvocation = (VkBool32)memory->readd(address);address+=4;
    s->shaderTerminateInvocation = (VkBool32)memory->readd(address);address+=4;
    s->subgroupSizeControl = (VkBool32)memory->readd(address);address+=4;
    s->computeFullSubgroups = (VkBool32)memory->readd(address);address+=4;
    s->synchronization2 = (VkBool32)memory->readd(address);address+=4;
    s->textureCompressionASTC_HDR = (VkBool32)memory->readd(address);address+=4;
    s->shaderZeroInitializeWorkgroupMemory = (VkBool32)memory->readd(address);address+=4;
    s->dynamicRendering = (VkBool32)memory->readd(address);address+=4;
    s->shaderIntegerDotProduct = (VkBool32)memory->readd(address);address+=4;
    s->maintenance4 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan13Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan13Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->robustImageAccess);address+=4;
    memory->writed(address, s->inlineUniformBlock);address+=4;
    memory->writed(address, s->descriptorBindingInlineUniformBlockUpdateAfterBind);address+=4;
    memory->writed(address, s->pipelineCreationCacheControl);address+=4;
    memory->writed(address, s->privateData);address+=4;
    memory->writed(address, s->shaderDemoteToHelperInvocation);address+=4;
    memory->writed(address, s->shaderTerminateInvocation);address+=4;
    memory->writed(address, s->subgroupSizeControl);address+=4;
    memory->writed(address, s->computeFullSubgroups);address+=4;
    memory->writed(address, s->synchronization2);address+=4;
    memory->writed(address, s->textureCompressionASTC_HDR);address+=4;
    memory->writed(address, s->shaderZeroInitializeWorkgroupMemory);address+=4;
    memory->writed(address, s->dynamicRendering);address+=4;
    memory->writed(address, s->shaderIntegerDotProduct);address+=4;
    memory->writed(address, s->maintenance4);address+=4;
}
MarshalVkPhysicalDeviceVulkan13Features::~MarshalVkPhysicalDeviceVulkan13Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan13Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan13Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxSubgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->maxComputeWorkgroupSubgroups = (uint32_t)memory->readd(address);address+=4;
    s->requiredSubgroupSizeStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->maxInlineUniformBlockSize = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = (uint32_t)memory->readd(address);address+=4;
    s->maxInlineUniformTotalSize = (uint32_t)memory->readd(address);address+=4;
    s->integerDotProduct8BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct8BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct8BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->storageTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->storageTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
    s->uniformTexelBufferOffsetAlignmentBytes = (VkDeviceSize)memory->readq(address);address+=8;
    s->uniformTexelBufferOffsetSingleTexelAlignment = (VkBool32)memory->readd(address);address+=4;
    s->maxBufferSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceVulkan13Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan13Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minSubgroupSize);address+=4;
    memory->writed(address, s->maxSubgroupSize);address+=4;
    memory->writed(address, s->maxComputeWorkgroupSubgroups);address+=4;
    memory->writed(address, s->requiredSubgroupSizeStages);address+=4;
    memory->writed(address, s->maxInlineUniformBlockSize);address+=4;
    memory->writed(address, s->maxPerStageDescriptorInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxDescriptorSetUpdateAfterBindInlineUniformBlocks);address+=4;
    memory->writed(address, s->maxInlineUniformTotalSize);address+=4;
    memory->writed(address, s->integerDotProduct8BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct8BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct8BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);address+=4;
    memory->writeq(address, s->storageTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->storageTexelBufferOffsetSingleTexelAlignment);address+=4;
    memory->writeq(address, s->uniformTexelBufferOffsetAlignmentBytes);address+=8;
    memory->writed(address, s->uniformTexelBufferOffsetSingleTexelAlignment);address+=4;
    memory->writeq(address, s->maxBufferSize);address+=8;
}
MarshalVkPhysicalDeviceVulkan13Properties::~MarshalVkPhysicalDeviceVulkan13Properties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan14Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan14Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->globalPriorityQuery = (VkBool32)memory->readd(address);address+=4;
    s->shaderSubgroupRotate = (VkBool32)memory->readd(address);address+=4;
    s->shaderSubgroupRotateClustered = (VkBool32)memory->readd(address);address+=4;
    s->shaderFloatControls2 = (VkBool32)memory->readd(address);address+=4;
    s->shaderExpectAssume = (VkBool32)memory->readd(address);address+=4;
    s->rectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->bresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->smoothLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledRectangularLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledBresenhamLines = (VkBool32)memory->readd(address);address+=4;
    s->stippledSmoothLines = (VkBool32)memory->readd(address);address+=4;
    s->vertexAttributeInstanceRateDivisor = (VkBool32)memory->readd(address);address+=4;
    s->vertexAttributeInstanceRateZeroDivisor = (VkBool32)memory->readd(address);address+=4;
    s->indexTypeUint8 = (VkBool32)memory->readd(address);address+=4;
    s->dynamicRenderingLocalRead = (VkBool32)memory->readd(address);address+=4;
    s->maintenance5 = (VkBool32)memory->readd(address);address+=4;
    s->maintenance6 = (VkBool32)memory->readd(address);address+=4;
    s->pipelineProtectedAccess = (VkBool32)memory->readd(address);address+=4;
    s->pipelineRobustness = (VkBool32)memory->readd(address);address+=4;
    s->hostImageCopy = (VkBool32)memory->readd(address);address+=4;
    s->pushDescriptor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan14Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan14Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->globalPriorityQuery);address+=4;
    memory->writed(address, s->shaderSubgroupRotate);address+=4;
    memory->writed(address, s->shaderSubgroupRotateClustered);address+=4;
    memory->writed(address, s->shaderFloatControls2);address+=4;
    memory->writed(address, s->shaderExpectAssume);address+=4;
    memory->writed(address, s->rectangularLines);address+=4;
    memory->writed(address, s->bresenhamLines);address+=4;
    memory->writed(address, s->smoothLines);address+=4;
    memory->writed(address, s->stippledRectangularLines);address+=4;
    memory->writed(address, s->stippledBresenhamLines);address+=4;
    memory->writed(address, s->stippledSmoothLines);address+=4;
    memory->writed(address, s->vertexAttributeInstanceRateDivisor);address+=4;
    memory->writed(address, s->vertexAttributeInstanceRateZeroDivisor);address+=4;
    memory->writed(address, s->indexTypeUint8);address+=4;
    memory->writed(address, s->dynamicRenderingLocalRead);address+=4;
    memory->writed(address, s->maintenance5);address+=4;
    memory->writed(address, s->maintenance6);address+=4;
    memory->writed(address, s->pipelineProtectedAccess);address+=4;
    memory->writed(address, s->pipelineRobustness);address+=4;
    memory->writed(address, s->hostImageCopy);address+=4;
    memory->writed(address, s->pushDescriptor);address+=4;
}
MarshalVkPhysicalDeviceVulkan14Features::~MarshalVkPhysicalDeviceVulkan14Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVulkan14Properties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan14Properties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->lineSubPixelPrecisionBits = (uint32_t)memory->readd(address);address+=4;
    s->maxVertexAttribDivisor = (uint32_t)memory->readd(address);address+=4;
    s->supportsNonZeroFirstInstance = (VkBool32)memory->readd(address);address+=4;
    s->maxPushDescriptors = (uint32_t)memory->readd(address);address+=4;
    s->dynamicRenderingLocalReadDepthStencilAttachments = (VkBool32)memory->readd(address);address+=4;
    s->dynamicRenderingLocalReadMultisampledAttachments = (VkBool32)memory->readd(address);address+=4;
    s->earlyFragmentMultisampleCoverageAfterSampleCounting = (VkBool32)memory->readd(address);address+=4;
    s->earlyFragmentSampleMaskTestBeforeSampleCounting = (VkBool32)memory->readd(address);address+=4;
    s->depthStencilSwizzleOneSupport = (VkBool32)memory->readd(address);address+=4;
    s->polygonModePointSize = (VkBool32)memory->readd(address);address+=4;
    s->nonStrictSinglePixelWideLinesUseParallelogram = (VkBool32)memory->readd(address);address+=4;
    s->nonStrictWideLinesUseParallelogram = (VkBool32)memory->readd(address);address+=4;
    s->blockTexelViewCompatibleMultipleLayers = (VkBool32)memory->readd(address);address+=4;
    s->maxCombinedImageSamplerDescriptorCount = (uint32_t)memory->readd(address);address+=4;
    s->fragmentShadingRateClampCombinerInputs = (VkBool32)memory->readd(address);address+=4;
    s->defaultRobustnessStorageBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessUniformBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessVertexInputs = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessImages = (VkPipelineRobustnessImageBehavior)memory->readd(address);address+=4;
    s->copySrcLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCopySrcLayouts = NULL;
    } else {
        s->pCopySrcLayouts = new VkImageLayout[(U32)s->copySrcLayoutCount];
        memory->memcpy((VkImageLayout*)s->pCopySrcLayouts, paramAddress, (U32)s->copySrcLayoutCount);
    }
    s->copyDstLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCopyDstLayouts = NULL;
    } else {
        s->pCopyDstLayouts = new VkImageLayout[(U32)s->copyDstLayoutCount];
        memory->memcpy((VkImageLayout*)s->pCopyDstLayouts, paramAddress, (U32)s->copyDstLayoutCount);
    }
    memory->memcpy(&s->optimalTilingLayoutUUID, address, 16);address+=16;
    s->identicalMemoryTypeRequirements = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVulkan14Properties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVulkan14Properties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->lineSubPixelPrecisionBits);address+=4;
    memory->writed(address, s->maxVertexAttribDivisor);address+=4;
    memory->writed(address, s->supportsNonZeroFirstInstance);address+=4;
    memory->writed(address, s->maxPushDescriptors);address+=4;
    memory->writed(address, s->dynamicRenderingLocalReadDepthStencilAttachments);address+=4;
    memory->writed(address, s->dynamicRenderingLocalReadMultisampledAttachments);address+=4;
    memory->writed(address, s->earlyFragmentMultisampleCoverageAfterSampleCounting);address+=4;
    memory->writed(address, s->earlyFragmentSampleMaskTestBeforeSampleCounting);address+=4;
    memory->writed(address, s->depthStencilSwizzleOneSupport);address+=4;
    memory->writed(address, s->polygonModePointSize);address+=4;
    memory->writed(address, s->nonStrictSinglePixelWideLinesUseParallelogram);address+=4;
    memory->writed(address, s->nonStrictWideLinesUseParallelogram);address+=4;
    memory->writed(address, s->blockTexelViewCompatibleMultipleLayers);address+=4;
    memory->writed(address, s->maxCombinedImageSamplerDescriptorCount);address+=4;
    memory->writed(address, s->fragmentShadingRateClampCombinerInputs);address+=4;
    memory->writed(address, s->defaultRobustnessStorageBuffers);address+=4;
    memory->writed(address, s->defaultRobustnessUniformBuffers);address+=4;
    memory->writed(address, s->defaultRobustnessVertexInputs);address+=4;
    memory->writed(address, s->defaultRobustnessImages);address+=4;
    memory->writed(address, s->copySrcLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->copyDstLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->optimalTilingLayoutUUID, 16); address+=16;
    memory->writed(address, s->identicalMemoryTypeRequirements);address+=4;
}
MarshalVkPhysicalDeviceVulkan14Properties::~MarshalVkPhysicalDeviceVulkan14Properties() {
    delete s.pNext;
    delete[] s.pCopySrcLayouts;
    delete[] s.pCopyDstLayouts;
}
void MarshalVkPipelineCompilerControlCreateInfoAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCompilerControlCreateInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->compilerControlFlags = (VkPipelineCompilerControlFlagsAMD)memory->readd(address);address+=4;
}
void MarshalVkPipelineCompilerControlCreateInfoAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineCompilerControlCreateInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->compilerControlFlags);address+=4;
}
MarshalVkPipelineCompilerControlCreateInfoAMD::~MarshalVkPipelineCompilerControlCreateInfoAMD() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCoherentMemoryFeaturesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceCoherentMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCoherentMemoryFeaturesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceCoherentMemory);address+=4;
}
MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD::~MarshalVkPhysicalDeviceCoherentMemoryFeaturesAMD() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceToolProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceToolProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->name, address, 256);address+=256;
    memory->memcpy(&s->version, address, 256);address+=256;
    s->purposes = (VkToolPurposeFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->description, address, 256);address+=256;
    memory->memcpy(&s->layer, address, 256);address+=256;
}
void MarshalVkPhysicalDeviceToolProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceToolProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->name, 256); address+=256;
    memory->memcpy(address, s->version, 256); address+=256;
    memory->writed(address, s->purposes);address+=4;
    memory->memcpy(address, s->description, 256); address+=256;
    memory->memcpy(address, s->layer, 256); address+=256;
}
MarshalVkPhysicalDeviceToolProperties::~MarshalVkPhysicalDeviceToolProperties() {
    delete s.pNext;
}
void MarshalVkSamplerCustomBorderColorCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCustomBorderColorCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->customBorderColor, address, 16);address+=16;
    s->format = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkSamplerCustomBorderColorCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCustomBorderColorCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->customBorderColor, 16); address+=16;
    memory->writed(address, s->format);address+=4;
}
MarshalVkSamplerCustomBorderColorCreateInfoEXT::~MarshalVkSamplerCustomBorderColorCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxCustomBorderColorSamplers = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxCustomBorderColorSamplers);address+=4;
}
MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT::~MarshalVkPhysicalDeviceCustomBorderColorPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->customBorderColors = (VkBool32)memory->readd(address);address+=4;
    s->customBorderColorWithoutFormat = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCustomBorderColorFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->customBorderColors);address+=4;
    memory->writed(address, s->customBorderColorWithoutFormat);address+=4;
}
MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT::~MarshalVkPhysicalDeviceCustomBorderColorFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerBorderColorComponentMappingCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalVkComponentMapping::read(pBoxedInfo, memory, address, &s->components); address+=16;
    s->srgb = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerBorderColorComponentMappingCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->components, 16); address+=16;
    memory->writed(address, s->srgb);address+=4;
}
MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT::~MarshalVkSamplerBorderColorComponentMappingCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->borderColorSwizzle = (VkBool32)memory->readd(address);address+=4;
    s->borderColorSwizzleFromImage = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->borderColorSwizzle);address+=4;
    memory->writed(address, s->borderColorSwizzleFromImage);address+=4;
}
MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT::~MarshalVkPhysicalDeviceBorderColorSwizzleFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureGeometryTrianglesDataKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryTrianglesDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexFormat = (VkFormat)memory->readd(address);address+=4;
    s->vertexData = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
    s->vertexStride = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxVertex = (uint32_t)memory->readd(address);address+=4;
    s->indexType = (VkIndexType)memory->readd(address);address+=4;
    s->indexData = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
    s->transformData = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryTrianglesDataKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryTrianglesDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vertexFormat);address+=4;
    memory->writeq(address, s->vertexData.deviceAddress);address+=8;
    memory->writeq(address, s->vertexStride);address+=8;
    memory->writed(address, s->maxVertex);address+=4;
    memory->writed(address, s->indexType);address+=4;
    memory->writeq(address, s->indexData.deviceAddress);address+=8;
    memory->writeq(address, s->transformData.deviceAddress);address+=8;
}
MarshalVkAccelerationStructureGeometryTrianglesDataKHR::~MarshalVkAccelerationStructureGeometryTrianglesDataKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureGeometryAabbsDataKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryAabbsDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->data = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
    s->stride = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryAabbsDataKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryAabbsDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->data.deviceAddress);address+=8;
    memory->writeq(address, s->stride);address+=8;
}
MarshalVkAccelerationStructureGeometryAabbsDataKHR::~MarshalVkAccelerationStructureGeometryAabbsDataKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureGeometryInstancesDataKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryInstancesDataKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->arrayOfPointers = (VkBool32)memory->readd(address);address+=4;
    s->data = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryInstancesDataKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryInstancesDataKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->arrayOfPointers);address+=4;
    memory->writeq(address, s->data.deviceAddress);address+=8;
}
MarshalVkAccelerationStructureGeometryInstancesDataKHR::~MarshalVkAccelerationStructureGeometryInstancesDataKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureGeometryKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->geometryType = (VkGeometryTypeKHR)memory->readd(address);address+=4;
    if (s->geometryType == VK_GEOMETRY_TYPE_TRIANGLES_KHR) {
        MarshalVkAccelerationStructureGeometryTrianglesDataKHR::read(pBoxedInfo, memory, address, &s->geometry.triangles);
    } else if (s->geometryType == VK_GEOMETRY_TYPE_AABBS_KHR) {
        MarshalVkAccelerationStructureGeometryAabbsDataKHR::read(pBoxedInfo, memory, address, &s->geometry.aabbs);
    } else if (s->geometryType == VK_GEOMETRY_TYPE_INSTANCES_KHR) {
        MarshalVkAccelerationStructureGeometryInstancesDataKHR::read(pBoxedInfo, memory, address, &s->geometry.instances);
    }
    address+=52;
    s->flags = (VkGeometryFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkAccelerationStructureGeometryKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->geometryType);address+=4;
    memory->memcpy(address, &s->geometry, 52); address+=52;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkAccelerationStructureGeometryKHR::~MarshalVkAccelerationStructureGeometryKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureBuildGeometryInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureBuildGeometryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
    s->flags = (VkBuildAccelerationStructureFlagsKHR)memory->readd(address);address+=4;
    s->mode = (VkBuildAccelerationStructureModeKHR)memory->readd(address);address+=4;
    s->srcAccelerationStructure = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->dstAccelerationStructure = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->geometryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGeometries = NULL;
    } else {
        VkAccelerationStructureGeometryKHR* pGeometries = new VkAccelerationStructureGeometryKHR[s->geometryCount];
        for (U32 i = 0; i < s->geometryCount; i++) {
            MarshalVkAccelerationStructureGeometryKHR::read(pBoxedInfo, memory, paramAddress + i*68, &pGeometries[i]);
        }
        s->pGeometries = pGeometries;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->ppGeometries = NULL;
    } else {
        VkAccelerationStructureGeometryKHR** ppGeometries = new VkAccelerationStructureGeometryKHR*[s->geometryCount];
        for (int i=0;i<(int)s->geometryCount;i++) {
            ppGeometries[i] = new VkAccelerationStructureGeometryKHR();
            U32 readAddress = memory->readd(paramAddress + i * 4);
            MarshalVkAccelerationStructureGeometryKHR::read(pBoxedInfo, memory, readAddress, ppGeometries[i]);
        }
        s->ppGeometries = ppGeometries;
    }
    s->scratchData = (VkDeviceOrHostAddressKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureBuildGeometryInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureBuildGeometryInfoKHR* s) {
    kpanic("MarshalVkAccelerationStructureBuildGeometryInfoKHR::write");
}
MarshalVkAccelerationStructureBuildGeometryInfoKHR::~MarshalVkAccelerationStructureBuildGeometryInfoKHR() {
    delete s.pNext;
    delete[] s.pGeometries;
    if (s.ppGeometries) {
        for (U32 i = 0; i < s.geometryCount; i++) {
            delete s.ppGeometries[i];
        }
    }
    delete[] s.ppGeometries;
}
void MarshalVkAccelerationStructureBuildRangeInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureBuildRangeInfoKHR* s) {
    s->primitiveCount = (uint32_t)memory->readd(address);address+=4;
    s->primitiveOffset = (uint32_t)memory->readd(address);address+=4;
    s->firstVertex = (uint32_t)memory->readd(address);address+=4;
    s->transformOffset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkAccelerationStructureCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->createFlags = (VkAccelerationStructureCreateFlagsKHR)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->type = (VkAccelerationStructureTypeKHR)memory->readd(address);address+=4;
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->createFlags);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, s->deviceAddress);address+=8;
}
MarshalVkAccelerationStructureCreateInfoKHR::~MarshalVkAccelerationStructureCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureDeviceAddressInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureDeviceAddressInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructure = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureDeviceAddressInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureDeviceAddressInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
}
MarshalVkAccelerationStructureDeviceAddressInfoKHR::~MarshalVkAccelerationStructureDeviceAddressInfoKHR() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureVersionInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureVersionInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVersionData = NULL;
    } else {
        s->pVersionData = new uint8_t[2*VK_UUID_SIZE];
        memory->memcpy((uint8_t*)s->pVersionData, paramAddress, 2*VK_UUID_SIZE);
    }
}
void MarshalVkAccelerationStructureVersionInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureVersionInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkAccelerationStructureVersionInfoKHR::~MarshalVkAccelerationStructureVersionInfoKHR() {
    delete s.pNext;
    delete[] s.pVersionData;
}
void MarshalVkCopyAccelerationStructureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyAccelerationStructureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->dst = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyAccelerationStructureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyAccelerationStructureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyAccelerationStructureInfoKHR::~MarshalVkCopyAccelerationStructureInfoKHR() {
    delete s.pNext;
}
void MarshalVkCopyAccelerationStructureToMemoryInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyAccelerationStructureToMemoryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->dst = (VkDeviceOrHostAddressKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyAccelerationStructureToMemoryInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyAccelerationStructureToMemoryInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, s->dst.deviceAddress);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyAccelerationStructureToMemoryInfoKHR::~MarshalVkCopyAccelerationStructureToMemoryInfoKHR() {
    delete s.pNext;
}
void MarshalVkCopyMemoryToAccelerationStructureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToAccelerationStructureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
    s->dst = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyAccelerationStructureModeKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyMemoryToAccelerationStructureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToAccelerationStructureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->src.deviceAddress);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyMemoryToAccelerationStructureInfoKHR::~MarshalVkCopyMemoryToAccelerationStructureInfoKHR() {
    delete s.pNext;
}
void MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineInterfaceCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxPipelineRayPayloadSize = (uint32_t)memory->readd(address);address+=4;
    s->maxPipelineRayHitAttributeSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRayTracingPipelineInterfaceCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxPipelineRayPayloadSize);address+=4;
    memory->writed(address, s->maxPipelineRayHitAttributeSize);address+=4;
}
MarshalVkRayTracingPipelineInterfaceCreateInfoKHR::~MarshalVkRayTracingPipelineInterfaceCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkPipelineLibraryCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineLibraryCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->libraryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLibraries = NULL;
    } else {
        s->pLibraries = new VkPipeline[(U32)s->libraryCount];
        memory->memcpy((VkPipeline*)s->pLibraries, paramAddress, (U32)s->libraryCount);
    }
}
void MarshalVkPipelineLibraryCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineLibraryCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->libraryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineLibraryCreateInfoKHR::~MarshalVkPipelineLibraryCreateInfoKHR() {
    delete s.pNext;
    delete[] s.pLibraries;
}
void MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->extendedDynamicState = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->extendedDynamicState);address+=4;
}
MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT::~MarshalVkPhysicalDeviceExtendedDynamicStateFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->extendedDynamicState2 = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState2LogicOp = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState2PatchControlPoints = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->extendedDynamicState2);address+=4;
    memory->writed(address, s->extendedDynamicState2LogicOp);address+=4;
    memory->writed(address, s->extendedDynamicState2PatchControlPoints);address+=4;
}
MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT::~MarshalVkPhysicalDeviceExtendedDynamicState2FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->extendedDynamicState3TessellationDomainOrigin = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3DepthClampEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3PolygonMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3RasterizationSamples = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3SampleMask = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3AlphaToCoverageEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3AlphaToOneEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3LogicOpEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ColorBlendEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ColorBlendEquation = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ColorWriteMask = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3RasterizationStream = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ConservativeRasterizationMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ExtraPrimitiveOverestimationSize = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3DepthClipEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3SampleLocationsEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ColorBlendAdvanced = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ProvokingVertexMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3LineRasterizationMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3LineStippleEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3DepthClipNegativeOneToOne = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ViewportWScalingEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ViewportSwizzle = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageToColorEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageToColorLocation = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageModulationMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageModulationTableEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageModulationTable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3CoverageReductionMode = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3RepresentativeFragmentTestEnable = (VkBool32)memory->readd(address);address+=4;
    s->extendedDynamicState3ShadingRateImageEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->extendedDynamicState3TessellationDomainOrigin);address+=4;
    memory->writed(address, s->extendedDynamicState3DepthClampEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3PolygonMode);address+=4;
    memory->writed(address, s->extendedDynamicState3RasterizationSamples);address+=4;
    memory->writed(address, s->extendedDynamicState3SampleMask);address+=4;
    memory->writed(address, s->extendedDynamicState3AlphaToCoverageEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3AlphaToOneEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3LogicOpEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3ColorBlendEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3ColorBlendEquation);address+=4;
    memory->writed(address, s->extendedDynamicState3ColorWriteMask);address+=4;
    memory->writed(address, s->extendedDynamicState3RasterizationStream);address+=4;
    memory->writed(address, s->extendedDynamicState3ConservativeRasterizationMode);address+=4;
    memory->writed(address, s->extendedDynamicState3ExtraPrimitiveOverestimationSize);address+=4;
    memory->writed(address, s->extendedDynamicState3DepthClipEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3SampleLocationsEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3ColorBlendAdvanced);address+=4;
    memory->writed(address, s->extendedDynamicState3ProvokingVertexMode);address+=4;
    memory->writed(address, s->extendedDynamicState3LineRasterizationMode);address+=4;
    memory->writed(address, s->extendedDynamicState3LineStippleEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3DepthClipNegativeOneToOne);address+=4;
    memory->writed(address, s->extendedDynamicState3ViewportWScalingEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3ViewportSwizzle);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageToColorEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageToColorLocation);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageModulationMode);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageModulationTableEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageModulationTable);address+=4;
    memory->writed(address, s->extendedDynamicState3CoverageReductionMode);address+=4;
    memory->writed(address, s->extendedDynamicState3RepresentativeFragmentTestEnable);address+=4;
    memory->writed(address, s->extendedDynamicState3ShadingRateImageEnable);address+=4;
}
MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT::~MarshalVkPhysicalDeviceExtendedDynamicState3FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dynamicPrimitiveTopologyUnrestricted = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dynamicPrimitiveTopologyUnrestricted);address+=4;
}
MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT::~MarshalVkPhysicalDeviceExtendedDynamicState3PropertiesEXT() {
    delete s.pNext;
}
void MarshalVkColorBlendEquationEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkColorBlendEquationEXT* s) {
    s->srcColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstColorBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->colorBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->srcAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->dstAlphaBlendFactor = (VkBlendFactor)memory->readd(address);address+=4;
    s->alphaBlendOp = (VkBlendOp)memory->readd(address);address+=4;
}
void MarshalVkColorBlendAdvancedEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkColorBlendAdvancedEXT* s) {
    s->advancedBlendOp = (VkBlendOp)memory->readd(address);address+=4;
    s->srcPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->dstPremultiplied = (VkBool32)memory->readd(address);address+=4;
    s->blendOverlap = (VkBlendOverlapEXT)memory->readd(address);address+=4;
    s->clampResults = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkRenderPassTransformBeginInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassTransformBeginInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkRenderPassTransformBeginInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassTransformBeginInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->transform);address+=4;
}
MarshalVkRenderPassTransformBeginInfoQCOM::~MarshalVkRenderPassTransformBeginInfoQCOM() {
    delete s.pNext;
}
void MarshalVkCopyCommandTransformInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyCommandTransformInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkCopyCommandTransformInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyCommandTransformInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->transform);address+=4;
}
MarshalVkCopyCommandTransformInfoQCOM::~MarshalVkCopyCommandTransformInfoQCOM() {
    delete s.pNext;
}
void MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceRenderPassTransformInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->transform = (VkSurfaceTransformFlagBitsKHR)memory->readd(address);address+=4;
    memory->memcpy(&s->renderArea, address, 16);address+=16;
}
void MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceRenderPassTransformInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->transform);address+=4;
    memory->memcpy(address, &s->renderArea, 16); address+=16;
}
MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM::~MarshalVkCommandBufferInheritanceRenderPassTransformInfoQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDiagnosticsConfigFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->diagnosticsConfig = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDiagnosticsConfigFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->diagnosticsConfig);address+=4;
}
MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV::~MarshalVkPhysicalDeviceDiagnosticsConfigFeaturesNV() {
    delete s.pNext;
}
void MarshalVkDeviceDiagnosticsConfigCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceDiagnosticsConfigCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDeviceDiagnosticsConfigFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkDeviceDiagnosticsConfigCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceDiagnosticsConfigCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkDeviceDiagnosticsConfigCreateInfoNV::~MarshalVkDeviceDiagnosticsConfigCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderZeroInitializeWorkgroupMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderZeroInitializeWorkgroupMemory);address+=4;
}
MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::~MarshalVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSubgroupUniformControlFlow = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSubgroupUniformControlFlow);address+=4;
}
MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::~MarshalVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRobustness2FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRobustness2FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->robustBufferAccess2 = (VkBool32)memory->readd(address);address+=4;
    s->robustImageAccess2 = (VkBool32)memory->readd(address);address+=4;
    s->nullDescriptor = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRobustness2FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRobustness2FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->robustBufferAccess2);address+=4;
    memory->writed(address, s->robustImageAccess2);address+=4;
    memory->writed(address, s->nullDescriptor);address+=4;
}
MarshalVkPhysicalDeviceRobustness2FeaturesEXT::~MarshalVkPhysicalDeviceRobustness2FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRobustness2PropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRobustness2PropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->robustStorageBufferAccessSizeAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->robustUniformBufferAccessSizeAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceRobustness2PropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRobustness2PropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->robustStorageBufferAccessSizeAlignment);address+=8;
    memory->writeq(address, s->robustUniformBufferAccessSizeAlignment);address+=8;
}
MarshalVkPhysicalDeviceRobustness2PropertiesEXT::~MarshalVkPhysicalDeviceRobustness2PropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageRobustnessFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageRobustnessFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->robustImageAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageRobustnessFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageRobustnessFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->robustImageAccess);address+=4;
}
MarshalVkPhysicalDeviceImageRobustnessFeatures::~MarshalVkPhysicalDeviceImageRobustnessFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->workgroupMemoryExplicitLayout = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayoutScalarBlockLayout = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayout8BitAccess = (VkBool32)memory->readd(address);address+=4;
    s->workgroupMemoryExplicitLayout16BitAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->workgroupMemoryExplicitLayout);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayoutScalarBlockLayout);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayout8BitAccess);address+=4;
    memory->writed(address, s->workgroupMemoryExplicitLayout16BitAccess);address+=4;
}
MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::~MarshalVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDevice4444FormatsFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice4444FormatsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->formatA4R4G4B4 = (VkBool32)memory->readd(address);address+=4;
    s->formatA4B4G4R4 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevice4444FormatsFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevice4444FormatsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->formatA4R4G4B4);address+=4;
    memory->writed(address, s->formatA4B4G4R4);address+=4;
}
MarshalVkPhysicalDevice4444FormatsFeaturesEXT::~MarshalVkPhysicalDevice4444FormatsFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subpassShading = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subpassShading);address+=4;
}
MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI::~MarshalVkPhysicalDeviceSubpassShadingFeaturesHUAWEI() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->clustercullingShader = (VkBool32)memory->readd(address);address+=4;
    s->multiviewClusterCullingShader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->clustercullingShader);address+=4;
    memory->writed(address, s->multiviewClusterCullingShader);address+=4;
}
MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::~MarshalVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->clusterShadingRate = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->clusterShadingRate);address+=4;
}
MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI::~MarshalVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI() {
    delete s.pNext;
}
void MarshalVkBufferCopy2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCopy2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->dstOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferCopy2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCopy2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->srcOffset);address+=8;
    memory->writeq(address, s->dstOffset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkBufferCopy2::~MarshalVkBufferCopy2() {
    delete s.pNext;
}
void MarshalVkImageCopy2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCopy2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkImageCopy2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCopy2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, &s->srcOffset, 12); address+=12;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, &s->dstOffset, 12); address+=12;
    memory->memcpy(address, &s->extent, 12); address+=12;
}
MarshalVkImageCopy2::~MarshalVkImageCopy2() {
    delete s.pNext;
}
void MarshalVkImageBlit2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageBlit2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffsets, address, 24);address+=24;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffsets, address, 24);address+=24;
}
void MarshalVkImageBlit2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageBlit2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, s->srcOffsets, 24); address+=24;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, s->dstOffsets, 24); address+=24;
}
MarshalVkImageBlit2::~MarshalVkImageBlit2() {
    delete s.pNext;
}
void MarshalVkBufferImageCopy2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferImageCopy2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->bufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->bufferRowLength = (uint32_t)memory->readd(address);address+=4;
    s->bufferImageHeight = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->imageSubresource, address, 16);address+=16;
    memory->memcpy(&s->imageOffset, address, 12);address+=12;
    memory->memcpy(&s->imageExtent, address, 12);address+=12;
}
void MarshalVkBufferImageCopy2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferImageCopy2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->bufferOffset);address+=8;
    memory->writed(address, s->bufferRowLength);address+=4;
    memory->writed(address, s->bufferImageHeight);address+=4;
    memory->memcpy(address, &s->imageSubresource, 16); address+=16;
    memory->memcpy(address, &s->imageOffset, 12); address+=12;
    memory->memcpy(address, &s->imageExtent, 12); address+=12;
}
MarshalVkBufferImageCopy2::~MarshalVkBufferImageCopy2() {
    delete s.pNext;
}
void MarshalVkImageResolve2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageResolve2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->srcSubresource, address, 16);address+=16;
    memory->memcpy(&s->srcOffset, address, 12);address+=12;
    memory->memcpy(&s->dstSubresource, address, 16);address+=16;
    memory->memcpy(&s->dstOffset, address, 12);address+=12;
    memory->memcpy(&s->extent, address, 12);address+=12;
}
void MarshalVkImageResolve2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageResolve2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->srcSubresource, 16); address+=16;
    memory->memcpy(address, &s->srcOffset, 12); address+=12;
    memory->memcpy(address, &s->dstSubresource, 16); address+=16;
    memory->memcpy(address, &s->dstOffset, 12); address+=12;
    memory->memcpy(address, &s->extent, 12); address+=12;
}
MarshalVkImageResolve2::~MarshalVkImageResolve2() {
    delete s.pNext;
}
void MarshalVkCopyBufferInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyBufferInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferCopy2* pRegions = new VkBufferCopy2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferCopy2::read(pBoxedInfo, memory, paramAddress + i*32, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyBufferInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyBufferInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcBuffer);address+=8;
    memory->writeq(address, (U64)s->dstBuffer);address+=8;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferCopy2* pRegions = new VkBufferCopy2();
        MarshalVkBufferCopy2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyBufferInfo2::~MarshalVkCopyBufferInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkCopyImageInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageCopy2* pRegions = new VkImageCopy2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageCopy2::read(pBoxedInfo, memory, paramAddress + i*76, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageCopy2* pRegions = new VkImageCopy2();
        MarshalVkImageCopy2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyImageInfo2::~MarshalVkCopyImageInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkBlitImageInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBlitImageInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageBlit2* pRegions = new VkImageBlit2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageBlit2::read(pBoxedInfo, memory, paramAddress + i*64, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
    s->filter = (VkFilter)memory->readd(address);address+=4;
}
void MarshalVkBlitImageInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBlitImageInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageBlit2* pRegions = new VkImageBlit2();
        MarshalVkImageBlit2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
    memory->writed(address, s->filter);address+=4;
}
MarshalVkBlitImageInfo2::~MarshalVkBlitImageInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkCopyBufferToImageInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyBufferToImageInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferImageCopy2* pRegions = new VkBufferImageCopy2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferImageCopy2::read(pBoxedInfo, memory, paramAddress + i*64, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyBufferToImageInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyBufferToImageInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcBuffer);address+=8;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferImageCopy2* pRegions = new VkBufferImageCopy2();
        MarshalVkBufferImageCopy2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyBufferToImageInfo2::~MarshalVkCopyBufferToImageInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkCopyImageToBufferInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToBufferInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkBufferImageCopy2* pRegions = new VkBufferImageCopy2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkBufferImageCopy2::read(pBoxedInfo, memory, paramAddress + i*64, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageToBufferInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToBufferInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstBuffer);address+=8;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferImageCopy2* pRegions = new VkBufferImageCopy2();
        MarshalVkBufferImageCopy2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyImageToBufferInfo2::~MarshalVkCopyImageToBufferInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkResolveImageInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkResolveImageInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageResolve2* pRegions = new VkImageResolve2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageResolve2::read(pBoxedInfo, memory, paramAddress + i*76, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkResolveImageInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkResolveImageInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageResolve2* pRegions = new VkImageResolve2();
        MarshalVkImageResolve2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkResolveImageInfo2::~MarshalVkResolveImageInfo2() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderImageInt64Atomics = (VkBool32)memory->readd(address);address+=4;
    s->sparseImageInt64Atomics = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderImageInt64Atomics);address+=4;
    memory->writed(address, s->sparseImageInt64Atomics);address+=4;
}
MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::~MarshalVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkFragmentShadingRateAttachmentInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFragmentShadingRateAttachmentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFragmentShadingRateAttachment = NULL;
    } else {
        VkAttachmentReference2* pFragmentShadingRateAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pFragmentShadingRateAttachment);
        s->pFragmentShadingRateAttachment = pFragmentShadingRateAttachment;
    }
    memory->memcpy(&s->shadingRateAttachmentTexelSize, address, 8);address+=8;
}
void MarshalVkFragmentShadingRateAttachmentInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFragmentShadingRateAttachmentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAttachmentReference2* pFragmentShadingRateAttachment = new VkAttachmentReference2();
        MarshalVkAttachmentReference2::read(pBoxedInfo, memory, paramAddress, pFragmentShadingRateAttachment);
        s->pFragmentShadingRateAttachment = pFragmentShadingRateAttachment;
    }
    memory->memcpy(address, &s->shadingRateAttachmentTexelSize, 8); address+=8;
}
MarshalVkFragmentShadingRateAttachmentInfoKHR::~MarshalVkFragmentShadingRateAttachmentInfoKHR() {
    delete s.pNext;
    delete s.pFragmentShadingRateAttachment;
}
void MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineFragmentShadingRateStateCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->fragmentSize, address, 8);address+=8;
    memory->memcpy(&s->combinerOps, address, 8);address+=8;
}
void MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineFragmentShadingRateStateCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->fragmentSize, 8); address+=8;
    memory->memcpy(address, s->combinerOps, 8); address+=8;
}
MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR::~MarshalVkPipelineFragmentShadingRateStateCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
    s->primitiveFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
    s->attachmentFragmentShadingRate = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineFragmentShadingRate);address+=4;
    memory->writed(address, s->primitiveFragmentShadingRate);address+=4;
    memory->writed(address, s->attachmentFragmentShadingRate);address+=4;
}
MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR::~MarshalVkPhysicalDeviceFragmentShadingRateFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRatePropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->minFragmentShadingRateAttachmentTexelSize, address, 8);address+=8;
    memory->memcpy(&s->maxFragmentShadingRateAttachmentTexelSize, address, 8);address+=8;
    s->maxFragmentShadingRateAttachmentTexelSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
    s->primitiveFragmentShadingRateWithMultipleViewports = (VkBool32)memory->readd(address);address+=4;
    s->layeredShadingRateAttachments = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateNonTrivialCombinerOps = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxFragmentSize, address, 8);address+=8;
    s->maxFragmentSizeAspectRatio = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentShadingRateCoverageSamples = (uint32_t)memory->readd(address);address+=4;
    s->maxFragmentShadingRateRasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
    s->fragmentShadingRateWithShaderDepthStencilWrites = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithSampleMask = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithShaderSampleMask = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithConservativeRasterization = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithFragmentShaderInterlock = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateWithCustomSampleLocations = (VkBool32)memory->readd(address);address+=4;
    s->fragmentShadingRateStrictMultiplyCombiner = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRatePropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->minFragmentShadingRateAttachmentTexelSize, 8); address+=8;
    memory->memcpy(address, &s->maxFragmentShadingRateAttachmentTexelSize, 8); address+=8;
    memory->writed(address, s->maxFragmentShadingRateAttachmentTexelSizeAspectRatio);address+=4;
    memory->writed(address, s->primitiveFragmentShadingRateWithMultipleViewports);address+=4;
    memory->writed(address, s->layeredShadingRateAttachments);address+=4;
    memory->writed(address, s->fragmentShadingRateNonTrivialCombinerOps);address+=4;
    memory->memcpy(address, &s->maxFragmentSize, 8); address+=8;
    memory->writed(address, s->maxFragmentSizeAspectRatio);address+=4;
    memory->writed(address, s->maxFragmentShadingRateCoverageSamples);address+=4;
    memory->writed(address, s->maxFragmentShadingRateRasterizationSamples);address+=4;
    memory->writed(address, s->fragmentShadingRateWithShaderDepthStencilWrites);address+=4;
    memory->writed(address, s->fragmentShadingRateWithSampleMask);address+=4;
    memory->writed(address, s->fragmentShadingRateWithShaderSampleMask);address+=4;
    memory->writed(address, s->fragmentShadingRateWithConservativeRasterization);address+=4;
    memory->writed(address, s->fragmentShadingRateWithFragmentShaderInterlock);address+=4;
    memory->writed(address, s->fragmentShadingRateWithCustomSampleLocations);address+=4;
    memory->writed(address, s->fragmentShadingRateStrictMultiplyCombiner);address+=4;
}
MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR::~MarshalVkPhysicalDeviceFragmentShadingRatePropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShadingRateKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampleCounts = (VkSampleCountFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->fragmentSize, address, 8);address+=8;
}
void MarshalVkPhysicalDeviceFragmentShadingRateKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->sampleCounts);address+=4;
    memory->memcpy(address, &s->fragmentSize, 8); address+=8;
}
MarshalVkPhysicalDeviceFragmentShadingRateKHR::~MarshalVkPhysicalDeviceFragmentShadingRateKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTerminateInvocationFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderTerminateInvocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTerminateInvocationFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderTerminateInvocation);address+=4;
}
MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures::~MarshalVkPhysicalDeviceShaderTerminateInvocationFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentShadingRateEnums = (VkBool32)memory->readd(address);address+=4;
    s->supersampleFragmentShadingRates = (VkBool32)memory->readd(address);address+=4;
    s->noInvocationFragmentShadingRates = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentShadingRateEnums);address+=4;
    memory->writed(address, s->supersampleFragmentShadingRates);address+=4;
    memory->writed(address, s->noInvocationFragmentShadingRates);address+=4;
}
MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::~MarshalVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxFragmentShadingRateInvocationCount = (VkSampleCountFlagBits)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxFragmentShadingRateInvocationCount);address+=4;
}
MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::~MarshalVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineFragmentShadingRateEnumStateCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shadingRateType = (VkFragmentShadingRateTypeNV)memory->readd(address);address+=4;
    s->shadingRate = (VkFragmentShadingRateNV)memory->readd(address);address+=4;
    memory->memcpy(&s->combinerOps, address, 8);address+=8;
}
void MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineFragmentShadingRateEnumStateCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shadingRateType);address+=4;
    memory->writed(address, s->shadingRate);address+=4;
    memory->memcpy(address, s->combinerOps, 8); address+=8;
}
MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV::~MarshalVkPipelineFragmentShadingRateEnumStateCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureBuildSizesInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureBuildSizesInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructureSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->updateScratchSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->buildScratchSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureBuildSizesInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureBuildSizesInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->accelerationStructureSize);address+=8;
    memory->writeq(address, s->updateScratchSize);address+=8;
    memory->writeq(address, s->buildScratchSize);address+=8;
}
MarshalVkAccelerationStructureBuildSizesInfoKHR::~MarshalVkAccelerationStructureBuildSizesInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image2DViewOf3D = (VkBool32)memory->readd(address);address+=4;
    s->sampler2DViewOf3D = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->image2DViewOf3D);address+=4;
    memory->writed(address, s->sampler2DViewOf3D);address+=4;
}
MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT::~MarshalVkPhysicalDeviceImage2DViewOf3DFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageSlicedViewOf3D = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageSlicedViewOf3D);address+=4;
}
MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::~MarshalVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentFeedbackLoopDynamicState = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentFeedbackLoopDynamicState);address+=4;
}
MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::~MarshalVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->legacyVertexAttributes = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->legacyVertexAttributes);address+=4;
}
MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT::~MarshalVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->nativeUnalignedPerformance = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->nativeUnalignedPerformance);address+=4;
}
MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT::~MarshalVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->mutableDescriptorType = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->mutableDescriptorType);address+=4;
}
MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::~MarshalVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkMutableDescriptorTypeListEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMutableDescriptorTypeListEXT* s) {
    s->descriptorTypeCount = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorTypes = NULL;
    } else {
        s->pDescriptorTypes = new VkDescriptorType[(U32)s->descriptorTypeCount];
        memory->memcpy((VkDescriptorType*)s->pDescriptorTypes, paramAddress, (U32)s->descriptorTypeCount);
    }
}
MarshalVkMutableDescriptorTypeListEXT::~MarshalVkMutableDescriptorTypeListEXT() {
    delete[] s.pDescriptorTypes;
}
void MarshalVkMutableDescriptorTypeCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMutableDescriptorTypeCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->mutableDescriptorTypeListCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMutableDescriptorTypeLists = NULL;
    } else {
        VkMutableDescriptorTypeListEXT* pMutableDescriptorTypeLists = new VkMutableDescriptorTypeListEXT[s->mutableDescriptorTypeListCount];
        for (U32 i = 0; i < s->mutableDescriptorTypeListCount; i++) {
            MarshalVkMutableDescriptorTypeListEXT::read(pBoxedInfo, memory, paramAddress + i*8, &pMutableDescriptorTypeLists[i]);
        }
        s->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists;
    }
}
void MarshalVkMutableDescriptorTypeCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMutableDescriptorTypeCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->mutableDescriptorTypeListCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkMutableDescriptorTypeListEXT* pMutableDescriptorTypeLists = new VkMutableDescriptorTypeListEXT();
        MarshalVkMutableDescriptorTypeListEXT::read(pBoxedInfo, memory, paramAddress, pMutableDescriptorTypeLists);
        s->pMutableDescriptorTypeLists = pMutableDescriptorTypeLists;
    }
}
MarshalVkMutableDescriptorTypeCreateInfoEXT::~MarshalVkMutableDescriptorTypeCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pMutableDescriptorTypeLists;
}
void MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClipControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthClipControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClipControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthClipControl);address+=4;
}
MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT::~MarshalVkPhysicalDeviceDepthClipControlFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceGeneratedCommands = (VkBool32)memory->readd(address);address+=4;
    s->dynamicGeneratedPipelineLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceGeneratedCommands);address+=4;
    memory->writed(address, s->dynamicGeneratedPipelineLayout);address+=4;
}
MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::~MarshalVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxIndirectPipelineCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectShaderObjectCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectSequenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenCount = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsTokenOffset = (uint32_t)memory->readd(address);address+=4;
    s->maxIndirectCommandsIndirectStride = (uint32_t)memory->readd(address);address+=4;
    s->supportedIndirectCommandsInputModes = (VkIndirectCommandsInputModeFlagsEXT)memory->readd(address);address+=4;
    s->supportedIndirectCommandsShaderStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->supportedIndirectCommandsShaderStagesPipelineBinding = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->supportedIndirectCommandsShaderStagesShaderBinding = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->deviceGeneratedCommandsTransformFeedback = (VkBool32)memory->readd(address);address+=4;
    s->deviceGeneratedCommandsMultiDrawIndirectCount = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxIndirectPipelineCount);address+=4;
    memory->writed(address, s->maxIndirectShaderObjectCount);address+=4;
    memory->writed(address, s->maxIndirectSequenceCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenCount);address+=4;
    memory->writed(address, s->maxIndirectCommandsTokenOffset);address+=4;
    memory->writed(address, s->maxIndirectCommandsIndirectStride);address+=4;
    memory->writed(address, s->supportedIndirectCommandsInputModes);address+=4;
    memory->writed(address, s->supportedIndirectCommandsShaderStages);address+=4;
    memory->writed(address, s->supportedIndirectCommandsShaderStagesPipelineBinding);address+=4;
    memory->writed(address, s->supportedIndirectCommandsShaderStagesShaderBinding);address+=4;
    memory->writed(address, s->deviceGeneratedCommandsTransformFeedback);address+=4;
    memory->writed(address, s->deviceGeneratedCommandsMultiDrawIndirectCount);address+=4;
}
MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::~MarshalVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkGeneratedCommandsPipelineInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsPipelineInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkGeneratedCommandsPipelineInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsPipelineInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
MarshalVkGeneratedCommandsPipelineInfoEXT::~MarshalVkGeneratedCommandsPipelineInfoEXT() {
    delete s.pNext;
}
void MarshalVkGeneratedCommandsShaderInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsShaderInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShaders = NULL;
    } else {
        s->pShaders = new VkShaderEXT[(U32)s->shaderCount];
        memory->memcpy((VkShaderEXT*)s->pShaders, paramAddress, (U32)s->shaderCount);
    }
}
void MarshalVkGeneratedCommandsShaderInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsShaderInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkGeneratedCommandsShaderInfoEXT::~MarshalVkGeneratedCommandsShaderInfoEXT() {
    delete s.pNext;
    delete[] s.pShaders;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->indirectExecutionSet = (VkIndirectExecutionSetEXT)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutEXT)memory->readq(address);address+=8;
    s->maxSequenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxDrawCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsMemoryRequirementsInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->indirectExecutionSet);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writed(address, s->maxSequenceCount);address+=4;
    memory->writed(address, s->maxDrawCount);address+=4;
}
MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT::~MarshalVkGeneratedCommandsMemoryRequirementsInfoEXT() {
    delete s.pNext;
}
void MarshalVkIndirectExecutionSetPipelineInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetPipelineInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->initialPipeline = (VkPipeline)memory->readq(address);address+=8;
    s->maxPipelineCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkIndirectExecutionSetPipelineInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetPipelineInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->initialPipeline);address+=8;
    memory->writed(address, s->maxPipelineCount);address+=4;
}
MarshalVkIndirectExecutionSetPipelineInfoEXT::~MarshalVkIndirectExecutionSetPipelineInfoEXT() {
    delete s.pNext;
}
void MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetShaderLayoutInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->setLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->setLayoutCount];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->setLayoutCount);
    }
}
void MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetShaderLayoutInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->setLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::~MarshalVkIndirectExecutionSetShaderLayoutInfoEXT() {
    delete s.pNext;
    delete[] s.pSetLayouts;
}
void MarshalVkIndirectExecutionSetShaderInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetShaderInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pInitialShaders = NULL;
    } else {
        s->pInitialShaders = new VkShaderEXT[(U32)s->shaderCount];
        memory->memcpy((VkShaderEXT*)s->pInitialShaders, paramAddress, (U32)s->shaderCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayoutInfos = NULL;
    } else {
        VkIndirectExecutionSetShaderLayoutInfoEXT* pSetLayoutInfos = new VkIndirectExecutionSetShaderLayoutInfoEXT[s->shaderCount];
        for (U32 i = 0; i < s->shaderCount; i++) {
            MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::read(pBoxedInfo, memory, paramAddress + i*16, &pSetLayoutInfos[i]);
        }
        s->pSetLayoutInfos = pSetLayoutInfos;
    }
    s->maxShaderCount = (uint32_t)memory->readd(address);address+=4;
    s->pushConstantRangeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPushConstantRanges = NULL;
    } else {
        s->pPushConstantRanges = new VkPushConstantRange[(U32)s->pushConstantRangeCount];
        memory->memcpy((VkPushConstantRange*)s->pPushConstantRanges, paramAddress, (U32)s->pushConstantRangeCount * sizeof(VkPushConstantRange));
    }
}
void MarshalVkIndirectExecutionSetShaderInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetShaderInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectExecutionSetShaderLayoutInfoEXT* pSetLayoutInfos = new VkIndirectExecutionSetShaderLayoutInfoEXT();
        MarshalVkIndirectExecutionSetShaderLayoutInfoEXT::read(pBoxedInfo, memory, paramAddress, pSetLayoutInfos);
        s->pSetLayoutInfos = pSetLayoutInfos;
    }
    memory->writed(address, s->maxShaderCount);address+=4;
    memory->writed(address, s->pushConstantRangeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPushConstantRange* pPushConstantRanges = new VkPushConstantRange();
        MarshalVkPushConstantRange::read(pBoxedInfo, memory, paramAddress, pPushConstantRanges);
        s->pPushConstantRanges = pPushConstantRanges;
    }
}
MarshalVkIndirectExecutionSetShaderInfoEXT::~MarshalVkIndirectExecutionSetShaderInfoEXT() {
    delete s.pNext;
    delete[] s.pInitialShaders;
    delete[] s.pSetLayoutInfos;
    delete[] s.pPushConstantRanges;
}
void MarshalVkIndirectExecutionSetCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkIndirectExecutionSetInfoTypeEXT)memory->readd(address);address+=4;
    memory->memcpy(&s->info, address, 32);address+=32;
}
void MarshalVkIndirectExecutionSetCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectExecutionSetCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->memcpy(address, &s->info, 32); address+=32;
}
MarshalVkIndirectExecutionSetCreateInfoEXT::~MarshalVkIndirectExecutionSetCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkGeneratedCommandsInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->indirectExecutionSet = (VkIndirectExecutionSetEXT)memory->readq(address);address+=8;
    s->indirectCommandsLayout = (VkIndirectCommandsLayoutEXT)memory->readq(address);address+=8;
    s->indirectAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->indirectAddressSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->preprocessAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->preprocessSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxSequenceCount = (uint32_t)memory->readd(address);address+=4;
    s->sequenceCountAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->maxDrawCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkGeneratedCommandsInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGeneratedCommandsInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderStages);address+=4;
    memory->writeq(address, (U64)s->indirectExecutionSet);address+=8;
    memory->writeq(address, (U64)s->indirectCommandsLayout);address+=8;
    memory->writeq(address, s->indirectAddress);address+=8;
    memory->writeq(address, s->indirectAddressSize);address+=8;
    memory->writeq(address, s->preprocessAddress);address+=8;
    memory->writeq(address, s->preprocessSize);address+=8;
    memory->writed(address, s->maxSequenceCount);address+=4;
    memory->writeq(address, s->sequenceCountAddress);address+=8;
    memory->writed(address, s->maxDrawCount);address+=4;
}
MarshalVkGeneratedCommandsInfoEXT::~MarshalVkGeneratedCommandsInfoEXT() {
    delete s.pNext;
}
void MarshalVkWriteIndirectExecutionSetPipelineEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteIndirectExecutionSetPipelineEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->index = (uint32_t)memory->readd(address);address+=4;
    s->pipeline = (VkPipeline)memory->readq(address);address+=8;
}
void MarshalVkWriteIndirectExecutionSetPipelineEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteIndirectExecutionSetPipelineEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->index);address+=4;
    memory->writeq(address, (U64)s->pipeline);address+=8;
}
MarshalVkWriteIndirectExecutionSetPipelineEXT::~MarshalVkWriteIndirectExecutionSetPipelineEXT() {
    delete s.pNext;
}
void MarshalVkWriteIndirectExecutionSetShaderEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteIndirectExecutionSetShaderEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->index = (uint32_t)memory->readd(address);address+=4;
    s->shader = (VkShaderEXT)memory->readq(address);address+=8;
}
void MarshalVkWriteIndirectExecutionSetShaderEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkWriteIndirectExecutionSetShaderEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->index);address+=4;
    memory->writeq(address, (U64)s->shader);address+=8;
}
MarshalVkWriteIndirectExecutionSetShaderEXT::~MarshalVkWriteIndirectExecutionSetShaderEXT() {
    delete s.pNext;
}
void MarshalVkIndirectCommandsLayoutCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkIndirectCommandsLayoutUsageFlagsEXT)memory->readd(address);address+=4;
    s->shaderStages = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->indirectStride = (uint32_t)memory->readd(address);address+=4;
    s->pipelineLayout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->tokenCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTokens = NULL;
    } else {
        VkIndirectCommandsLayoutTokenEXT* pTokens = new VkIndirectCommandsLayoutTokenEXT[s->tokenCount];
        for (U32 i = 0; i < s->tokenCount; i++) {
            MarshalVkIndirectCommandsLayoutTokenEXT::read(pBoxedInfo, memory, paramAddress + i*28, &pTokens[i]);
        }
        s->pTokens = pTokens;
    }
}
void MarshalVkIndirectCommandsLayoutCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->shaderStages);address+=4;
    memory->writed(address, s->indirectStride);address+=4;
    memory->writeq(address, (U64)s->pipelineLayout);address+=8;
    memory->writed(address, s->tokenCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkIndirectCommandsLayoutTokenEXT* pTokens = new VkIndirectCommandsLayoutTokenEXT();
        MarshalVkIndirectCommandsLayoutTokenEXT::read(pBoxedInfo, memory, paramAddress, pTokens);
        s->pTokens = pTokens;
    }
}
MarshalVkIndirectCommandsLayoutCreateInfoEXT::~MarshalVkIndirectCommandsLayoutCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pTokens;
}
void MarshalVkIndirectCommandsLayoutTokenEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkIndirectCommandsTokenTypeEXT)memory->readd(address);address+=4;
    memory->memcpy(&s->data, address, 12);address+=12;
    s->offset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkIndirectCommandsLayoutTokenEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkIndirectCommandsLayoutTokenEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->memcpy(address, &s->data, 12); address+=12;
    memory->writed(address, s->offset);address+=4;
}
MarshalVkIndirectCommandsLayoutTokenEXT::~MarshalVkIndirectCommandsLayoutTokenEXT() {
    delete s.pNext;
}
void MarshalVkPipelineViewportDepthClipControlCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportDepthClipControlCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->negativeOneToOne = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPipelineViewportDepthClipControlCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportDepthClipControlCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->negativeOneToOne);address+=4;
}
MarshalVkPipelineViewportDepthClipControlCreateInfoEXT::~MarshalVkPipelineViewportDepthClipControlCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClampControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthClampControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClampControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthClampControl);address+=4;
}
MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT::~MarshalVkPhysicalDeviceDepthClampControlFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineViewportDepthClampControlCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportDepthClampControlCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthClampMode = (VkDepthClampModeEXT)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthClampRange = NULL;
    } else {
        VkDepthClampRangeEXT* pDepthClampRange = new VkDepthClampRangeEXT();
        MarshalVkDepthClampRangeEXT::read(pBoxedInfo, memory, paramAddress, pDepthClampRange);
        s->pDepthClampRange = pDepthClampRange;
    }
}
void MarshalVkPipelineViewportDepthClampControlCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineViewportDepthClampControlCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthClampMode);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkDepthClampRangeEXT* pDepthClampRange = new VkDepthClampRangeEXT();
        MarshalVkDepthClampRangeEXT::read(pBoxedInfo, memory, paramAddress, pDepthClampRange);
        s->pDepthClampRange = pDepthClampRange;
    }
}
MarshalVkPipelineViewportDepthClampControlCreateInfoEXT::~MarshalVkPipelineViewportDepthClampControlCreateInfoEXT() {
    delete s.pNext;
    delete s.pDepthClampRange;
}
void MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexInputDynamicState = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vertexInputDynamicState);address+=4;
}
MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::~MarshalVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderRelaxedExtendedInstruction = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderRelaxedExtendedInstruction);address+=4;
}
MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR::~MarshalVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkVertexInputBindingDescription2EXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputBindingDescription2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->stride = (uint32_t)memory->readd(address);address+=4;
    s->inputRate = (VkVertexInputRate)memory->readd(address);address+=4;
    s->divisor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVertexInputBindingDescription2EXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputBindingDescription2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->binding);address+=4;
    memory->writed(address, s->stride);address+=4;
    memory->writed(address, s->inputRate);address+=4;
    memory->writed(address, s->divisor);address+=4;
}
MarshalVkVertexInputBindingDescription2EXT::~MarshalVkVertexInputBindingDescription2EXT() {
    delete s.pNext;
}
void MarshalVkVertexInputAttributeDescription2EXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputAttributeDescription2EXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->location = (uint32_t)memory->readd(address);address+=4;
    s->binding = (uint32_t)memory->readd(address);address+=4;
    s->format = (VkFormat)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVertexInputAttributeDescription2EXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVertexInputAttributeDescription2EXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->location);address+=4;
    memory->writed(address, s->binding);address+=4;
    memory->writed(address, s->format);address+=4;
    memory->writed(address, s->offset);address+=4;
}
MarshalVkVertexInputAttributeDescription2EXT::~MarshalVkVertexInputAttributeDescription2EXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceColorWriteEnableFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->colorWriteEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceColorWriteEnableFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->colorWriteEnable);address+=4;
}
MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT::~MarshalVkPhysicalDeviceColorWriteEnableFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineColorWriteCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorWriteCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorWriteEnables = NULL;
    } else {
        s->pColorWriteEnables = new VkBool32[(U32)s->attachmentCount];
        memory->memcpy((VkBool32*)s->pColorWriteEnables, paramAddress, (U32)s->attachmentCount);
    }
}
void MarshalVkPipelineColorWriteCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineColorWriteCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineColorWriteCreateInfoEXT::~MarshalVkPipelineColorWriteCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pColorWriteEnables;
}
void MarshalVkMemoryBarrier2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryBarrier2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
}
void MarshalVkMemoryBarrier2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryBarrier2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
}
MarshalVkMemoryBarrier2::~MarshalVkMemoryBarrier2() {
    delete s.pNext;
}
void MarshalVkImageMemoryBarrier2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryBarrier2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
    s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->image = (VkImage)memory->readq(address);address+=8;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkImageMemoryBarrier2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageMemoryBarrier2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
    memory->writed(address, s->oldLayout);address+=4;
    memory->writed(address, s->newLayout);address+=4;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->image);address+=8;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
MarshalVkImageMemoryBarrier2::~MarshalVkImageMemoryBarrier2() {
    delete s.pNext;
}
void MarshalVkBufferMemoryBarrier2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryBarrier2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->srcStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->srcAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
    s->dstStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->dstAccessMask = (VkAccessFlags2)memory->readq(address);address+=8;
    s->srcQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->dstQueueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBufferMemoryBarrier2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferMemoryBarrier2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->srcStageMask);address+=8;
    memory->writeq(address, s->srcAccessMask);address+=8;
    memory->writeq(address, s->dstStageMask);address+=8;
    memory->writeq(address, s->dstAccessMask);address+=8;
    memory->writed(address, s->srcQueueFamilyIndex);address+=4;
    memory->writed(address, s->dstQueueFamilyIndex);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkBufferMemoryBarrier2::~MarshalVkBufferMemoryBarrier2() {
    delete s.pNext;
}
void MarshalVkDependencyInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDependencyInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dependencyFlags = (VkDependencyFlags)memory->readd(address);address+=4;
    s->memoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pMemoryBarriers = NULL;
    } else {
        VkMemoryBarrier2* pMemoryBarriers = new VkMemoryBarrier2[s->memoryBarrierCount];
        for (U32 i = 0; i < s->memoryBarrierCount; i++) {
            MarshalVkMemoryBarrier2::read(pBoxedInfo, memory, paramAddress + i*40, &pMemoryBarriers[i]);
        }
        s->pMemoryBarriers = pMemoryBarriers;
    }
    s->bufferMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferMemoryBarriers = NULL;
    } else {
        VkBufferMemoryBarrier2* pBufferMemoryBarriers = new VkBufferMemoryBarrier2[s->bufferMemoryBarrierCount];
        for (U32 i = 0; i < s->bufferMemoryBarrierCount; i++) {
            MarshalVkBufferMemoryBarrier2::read(pBoxedInfo, memory, paramAddress + i*72, &pBufferMemoryBarriers[i]);
        }
        s->pBufferMemoryBarriers = pBufferMemoryBarriers;
    }
    s->imageMemoryBarrierCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageMemoryBarriers = NULL;
    } else {
        VkImageMemoryBarrier2* pImageMemoryBarriers = new VkImageMemoryBarrier2[s->imageMemoryBarrierCount];
        for (U32 i = 0; i < s->imageMemoryBarrierCount; i++) {
            MarshalVkImageMemoryBarrier2::read(pBoxedInfo, memory, paramAddress + i*84, &pImageMemoryBarriers[i]);
        }
        s->pImageMemoryBarriers = pImageMemoryBarriers;
    }
}
void MarshalVkDependencyInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDependencyInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dependencyFlags);address+=4;
    memory->writed(address, s->memoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkMemoryBarrier2* pMemoryBarriers = new VkMemoryBarrier2();
        MarshalVkMemoryBarrier2::read(pBoxedInfo, memory, paramAddress, pMemoryBarriers);
        s->pMemoryBarriers = pMemoryBarriers;
    }
    memory->writed(address, s->bufferMemoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkBufferMemoryBarrier2* pBufferMemoryBarriers = new VkBufferMemoryBarrier2();
        MarshalVkBufferMemoryBarrier2::read(pBoxedInfo, memory, paramAddress, pBufferMemoryBarriers);
        s->pBufferMemoryBarriers = pBufferMemoryBarriers;
    }
    memory->writed(address, s->imageMemoryBarrierCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageMemoryBarrier2* pImageMemoryBarriers = new VkImageMemoryBarrier2();
        MarshalVkImageMemoryBarrier2::read(pBoxedInfo, memory, paramAddress, pImageMemoryBarriers);
        s->pImageMemoryBarriers = pImageMemoryBarriers;
    }
}
MarshalVkDependencyInfo::~MarshalVkDependencyInfo() {
    delete s.pNext;
    delete[] s.pMemoryBarriers;
    delete[] s.pBufferMemoryBarriers;
    delete[] s.pImageMemoryBarriers;
}
void MarshalVkSemaphoreSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->semaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->value = (uint64_t)memory->readq(address);address+=8;
    s->stageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->deviceIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkSemaphoreSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSemaphoreSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->semaphore);address+=8;
    memory->writeq(address, s->value);address+=8;
    memory->writeq(address, s->stageMask);address+=8;
    memory->writed(address, s->deviceIndex);address+=4;
}
MarshalVkSemaphoreSubmitInfo::~MarshalVkSemaphoreSubmitInfo() {
    delete s.pNext;
}
void MarshalVkCommandBufferSubmitInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferSubmitInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->commandBuffer = (VkCommandBuffer)getVulkanPtr(memory, memory->readd(address));address+=4;
    s->deviceMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferSubmitInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferSubmitInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    kpanic("VkCommandBufferSubmitInfo.commandBuffer did not marshal write correctly");
    memory->writed(address, s->deviceMask);address+=4;
}
MarshalVkCommandBufferSubmitInfo::~MarshalVkCommandBufferSubmitInfo() {
    delete s.pNext;
}
void MarshalVkSubmitInfo2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubmitInfo2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkSubmitFlags)memory->readd(address);address+=4;
    s->waitSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWaitSemaphoreInfos = NULL;
    } else {
        VkSemaphoreSubmitInfo* pWaitSemaphoreInfos = new VkSemaphoreSubmitInfo[s->waitSemaphoreInfoCount];
        for (U32 i = 0; i < s->waitSemaphoreInfoCount; i++) {
            MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress + i*36, &pWaitSemaphoreInfos[i]);
        }
        s->pWaitSemaphoreInfos = pWaitSemaphoreInfos;
    }
    s->commandBufferInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCommandBufferInfos = NULL;
    } else {
        VkCommandBufferSubmitInfo* pCommandBufferInfos = new VkCommandBufferSubmitInfo[s->commandBufferInfoCount];
        for (U32 i = 0; i < s->commandBufferInfoCount; i++) {
            MarshalVkCommandBufferSubmitInfo::read(pBoxedInfo, memory, paramAddress + i*16, &pCommandBufferInfos[i]);
        }
        s->pCommandBufferInfos = pCommandBufferInfos;
    }
    s->signalSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSignalSemaphoreInfos = NULL;
    } else {
        VkSemaphoreSubmitInfo* pSignalSemaphoreInfos = new VkSemaphoreSubmitInfo[s->signalSemaphoreInfoCount];
        for (U32 i = 0; i < s->signalSemaphoreInfoCount; i++) {
            MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress + i*36, &pSignalSemaphoreInfos[i]);
        }
        s->pSignalSemaphoreInfos = pSignalSemaphoreInfos;
    }
}
void MarshalVkSubmitInfo2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubmitInfo2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->waitSemaphoreInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSemaphoreSubmitInfo* pWaitSemaphoreInfos = new VkSemaphoreSubmitInfo();
        MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress, pWaitSemaphoreInfos);
        s->pWaitSemaphoreInfos = pWaitSemaphoreInfos;
    }
    memory->writed(address, s->commandBufferInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkCommandBufferSubmitInfo* pCommandBufferInfos = new VkCommandBufferSubmitInfo();
        MarshalVkCommandBufferSubmitInfo::read(pBoxedInfo, memory, paramAddress, pCommandBufferInfos);
        s->pCommandBufferInfos = pCommandBufferInfos;
    }
    memory->writed(address, s->signalSemaphoreInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSemaphoreSubmitInfo* pSignalSemaphoreInfos = new VkSemaphoreSubmitInfo();
        MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress, pSignalSemaphoreInfos);
        s->pSignalSemaphoreInfos = pSignalSemaphoreInfos;
    }
}
MarshalVkSubmitInfo2::~MarshalVkSubmitInfo2() {
    delete s.pNext;
    delete[] s.pWaitSemaphoreInfos;
    delete[] s.pCommandBufferInfos;
    delete[] s.pSignalSemaphoreInfos;
}
void MarshalVkQueueFamilyCheckpointProperties2NV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyCheckpointProperties2NV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->checkpointExecutionStageMask = (VkPipelineStageFlags2)memory->readq(address);address+=8;
}
void MarshalVkQueueFamilyCheckpointProperties2NV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyCheckpointProperties2NV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->checkpointExecutionStageMask);address+=8;
}
MarshalVkQueueFamilyCheckpointProperties2NV::~MarshalVkQueueFamilyCheckpointProperties2NV() {
    delete s.pNext;
}
void MarshalVkCheckpointData2NV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCheckpointData2NV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stage = (VkPipelineStageFlags2)memory->readq(address);address+=8;
    s->pCheckpointMarker = (void*)memory->readd(address);address+=4;
}
void MarshalVkCheckpointData2NV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCheckpointData2NV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->stage);address+=8;
    memory->writed(address, (U32)s->pCheckpointMarker);address+=4;
}
MarshalVkCheckpointData2NV::~MarshalVkCheckpointData2NV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSynchronization2Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSynchronization2Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->synchronization2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSynchronization2Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSynchronization2Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->synchronization2);address+=4;
}
MarshalVkPhysicalDeviceSynchronization2Features::~MarshalVkPhysicalDeviceSynchronization2Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceHostImageCopyFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostImageCopyFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hostImageCopy = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceHostImageCopyFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostImageCopyFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hostImageCopy);address+=4;
}
MarshalVkPhysicalDeviceHostImageCopyFeatures::~MarshalVkPhysicalDeviceHostImageCopyFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceHostImageCopyProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostImageCopyProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->copySrcLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCopySrcLayouts = NULL;
    } else {
        s->pCopySrcLayouts = new VkImageLayout[(U32)s->copySrcLayoutCount];
        memory->memcpy((VkImageLayout*)s->pCopySrcLayouts, paramAddress, (U32)s->copySrcLayoutCount);
    }
    s->copyDstLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCopyDstLayouts = NULL;
    } else {
        s->pCopyDstLayouts = new VkImageLayout[(U32)s->copyDstLayoutCount];
        memory->memcpy((VkImageLayout*)s->pCopyDstLayouts, paramAddress, (U32)s->copyDstLayoutCount);
    }
    memory->memcpy(&s->optimalTilingLayoutUUID, address, 16);address+=16;
    s->identicalMemoryTypeRequirements = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceHostImageCopyProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHostImageCopyProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->copySrcLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->copyDstLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->memcpy(address, s->optimalTilingLayoutUUID, 16); address+=16;
    memory->writed(address, s->identicalMemoryTypeRequirements);address+=4;
}
MarshalVkPhysicalDeviceHostImageCopyProperties::~MarshalVkPhysicalDeviceHostImageCopyProperties() {
    delete s.pNext;
    delete[] s.pCopySrcLayouts;
    delete[] s.pCopyDstLayouts;
}
void MarshalVkMemoryToImageCopy::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryToImageCopy* s) {
    kpanic("MarshalVkMemoryToImageCopy::read");
}
void MarshalVkMemoryToImageCopy::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryToImageCopy* s) {
    kpanic("MarshalVkMemoryToImageCopy::write");
}
void MarshalVkImageToMemoryCopy::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageToMemoryCopy* s) {
    kpanic("MarshalVkImageToMemoryCopy::read");
}
void MarshalVkImageToMemoryCopy::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageToMemoryCopy* s) {
    kpanic("MarshalVkImageToMemoryCopy::write");
}
void MarshalVkCopyMemoryToImageInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToImageInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkHostImageCopyFlags)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkMemoryToImageCopy* pRegions = new VkMemoryToImageCopy[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkMemoryToImageCopy::read(pBoxedInfo, memory, paramAddress + i*60, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyMemoryToImageInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToImageInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkMemoryToImageCopy* pRegions = new VkMemoryToImageCopy();
        MarshalVkMemoryToImageCopy::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyMemoryToImageInfo::~MarshalVkCopyMemoryToImageInfo() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkCopyImageToMemoryInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToMemoryInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkHostImageCopyFlags)memory->readd(address);address+=4;
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageToMemoryCopy* pRegions = new VkImageToMemoryCopy[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageToMemoryCopy::read(pBoxedInfo, memory, paramAddress + i*60, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageToMemoryInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToMemoryInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageToMemoryCopy* pRegions = new VkImageToMemoryCopy();
        MarshalVkImageToMemoryCopy::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyImageToMemoryInfo::~MarshalVkCopyImageToMemoryInfo() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkCopyImageToImageInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToImageInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkHostImageCopyFlags)memory->readd(address);address+=4;
    s->srcImage = (VkImage)memory->readq(address);address+=8;
    s->srcImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->dstImage = (VkImage)memory->readq(address);address+=8;
    s->dstImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        VkImageCopy2* pRegions = new VkImageCopy2[s->regionCount];
        for (U32 i = 0; i < s->regionCount; i++) {
            MarshalVkImageCopy2::read(pBoxedInfo, memory, paramAddress + i*76, &pRegions[i]);
        }
        s->pRegions = pRegions;
    }
}
void MarshalVkCopyImageToImageInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyImageToImageInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->srcImage);address+=8;
    memory->writed(address, s->srcImageLayout);address+=4;
    memory->writeq(address, (U64)s->dstImage);address+=8;
    memory->writed(address, s->dstImageLayout);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageCopy2* pRegions = new VkImageCopy2();
        MarshalVkImageCopy2::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkCopyImageToImageInfo::~MarshalVkCopyImageToImageInfo() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkHostImageLayoutTransitionInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHostImageLayoutTransitionInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
    s->oldLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->newLayout = (VkImageLayout)memory->readd(address);address+=4;
    memory->memcpy(&s->subresourceRange, address, 20);address+=20;
}
void MarshalVkHostImageLayoutTransitionInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHostImageLayoutTransitionInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
    memory->writed(address, s->oldLayout);address+=4;
    memory->writed(address, s->newLayout);address+=4;
    memory->memcpy(address, &s->subresourceRange, 20); address+=20;
}
MarshalVkHostImageLayoutTransitionInfo::~MarshalVkHostImageLayoutTransitionInfo() {
    delete s.pNext;
}
void MarshalVkSubresourceHostMemcpySize::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceHostMemcpySize* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkSubresourceHostMemcpySize::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceHostMemcpySize* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->size);address+=8;
}
MarshalVkSubresourceHostMemcpySize::~MarshalVkSubresourceHostMemcpySize() {
    delete s.pNext;
}
void MarshalVkHostImageCopyDevicePerformanceQuery::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHostImageCopyDevicePerformanceQuery* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->optimalDeviceAccess = (VkBool32)memory->readd(address);address+=4;
    s->identicalMemoryLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkHostImageCopyDevicePerformanceQuery::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkHostImageCopyDevicePerformanceQuery* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->optimalDeviceAccess);address+=4;
    memory->writed(address, s->identicalMemoryLayout);address+=4;
}
MarshalVkHostImageCopyDevicePerformanceQuery::~MarshalVkHostImageCopyDevicePerformanceQuery() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->primitivesGeneratedQuery = (VkBool32)memory->readd(address);address+=4;
    s->primitivesGeneratedQueryWithRasterizerDiscard = (VkBool32)memory->readd(address);address+=4;
    s->primitivesGeneratedQueryWithNonZeroStreams = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->primitivesGeneratedQuery);address+=4;
    memory->writed(address, s->primitivesGeneratedQueryWithRasterizerDiscard);address+=4;
    memory->writed(address, s->primitivesGeneratedQueryWithNonZeroStreams);address+=4;
}
MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::~MarshalVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyDitheringFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->legacyDithering = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLegacyDitheringFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->legacyDithering);address+=4;
}
MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT::~MarshalVkPhysicalDeviceLegacyDitheringFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multisampledRenderToSingleSampled = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multisampledRenderToSingleSampled);address+=4;
}
MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::~MarshalVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkSubpassResolvePerformanceQueryEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassResolvePerformanceQueryEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->optimal = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSubpassResolvePerformanceQueryEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubpassResolvePerformanceQueryEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->optimal);address+=4;
}
MarshalVkSubpassResolvePerformanceQueryEXT::~MarshalVkSubpassResolvePerformanceQueryEXT() {
    delete s.pNext;
}
void MarshalVkMultisampledRenderToSingleSampledInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultisampledRenderToSingleSampledInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multisampledRenderToSingleSampledEnable = (VkBool32)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
}
void MarshalVkMultisampledRenderToSingleSampledInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultisampledRenderToSingleSampledInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multisampledRenderToSingleSampledEnable);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
}
MarshalVkMultisampledRenderToSingleSampledInfoEXT::~MarshalVkMultisampledRenderToSingleSampledInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineProtectedAccessFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineProtectedAccessFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineProtectedAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineProtectedAccessFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineProtectedAccessFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineProtectedAccess);address+=4;
}
MarshalVkPhysicalDevicePipelineProtectedAccessFeatures::~MarshalVkPhysicalDevicePipelineProtectedAccessFeatures() {
    delete s.pNext;
}
void MarshalVkQueueFamilyVideoPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyVideoPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoCodecOperations = (VkVideoCodecOperationFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkQueueFamilyVideoPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyVideoPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoCodecOperations);address+=4;
}
MarshalVkQueueFamilyVideoPropertiesKHR::~MarshalVkQueueFamilyVideoPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkQueueFamilyQueryResultStatusPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyQueryResultStatusPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->queryResultStatusSupport = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkQueueFamilyQueryResultStatusPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueueFamilyQueryResultStatusPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->queryResultStatusSupport);address+=4;
}
MarshalVkQueueFamilyQueryResultStatusPropertiesKHR::~MarshalVkQueueFamilyQueryResultStatusPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoProfileListInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoProfileListInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->profileCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pProfiles = NULL;
    } else {
        VkVideoProfileInfoKHR* pProfiles = new VkVideoProfileInfoKHR[s->profileCount];
        for (U32 i = 0; i < s->profileCount; i++) {
            MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress + i*24, &pProfiles[i]);
        }
        s->pProfiles = pProfiles;
    }
}
void MarshalVkVideoProfileListInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoProfileListInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->profileCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoProfileInfoKHR* pProfiles = new VkVideoProfileInfoKHR();
        MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress, pProfiles);
        s->pProfiles = pProfiles;
    }
}
MarshalVkVideoProfileListInfoKHR::~MarshalVkVideoProfileListInfoKHR() {
    delete s.pNext;
    delete[] s.pProfiles;
}
void MarshalVkPhysicalDeviceVideoFormatInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoFormatInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageUsage = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVideoFormatInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoFormatInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageUsage);address+=4;
}
MarshalVkPhysicalDeviceVideoFormatInfoKHR::~MarshalVkPhysicalDeviceVideoFormatInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoFormatPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
    MarshalVkComponentMapping::read(pBoxedInfo, memory, address, &s->componentMapping); address+=16;
    s->imageCreateFlags = (VkImageCreateFlags)memory->readd(address);address+=4;
    s->imageType = (VkImageType)memory->readd(address);address+=4;
    s->imageTiling = (VkImageTiling)memory->readd(address);address+=4;
    s->imageUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkVideoFormatPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->format);address+=4;
    memory->memcpy(address, &s->componentMapping, 16); address+=16;
    memory->writed(address, s->imageCreateFlags);address+=4;
    memory->writed(address, s->imageType);address+=4;
    memory->writed(address, s->imageTiling);address+=4;
    memory->writed(address, s->imageUsageFlags);address+=4;
}
MarshalVkVideoFormatPropertiesKHR::~MarshalVkVideoFormatPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->maxQuantizationMapExtent, address, 8);address+=8;
}
void MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->maxQuantizationMapExtent, 8); address+=8;
}
MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR::~MarshalVkVideoEncodeQuantizationMapCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264QuantizationMapCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minQpDelta = (int32_t)memory->readd(address);address+=4;
    s->maxQpDelta = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264QuantizationMapCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minQpDelta);address+=4;
    memory->writed(address, s->maxQpDelta);address+=4;
}
MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR::~MarshalVkVideoEncodeH264QuantizationMapCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265QuantizationMapCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minQpDelta = (int32_t)memory->readd(address);address+=4;
    s->maxQpDelta = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265QuantizationMapCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minQpDelta);address+=4;
    memory->writed(address, s->maxQpDelta);address+=4;
}
MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR::~MarshalVkVideoEncodeH265QuantizationMapCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minQIndexDelta = (int32_t)memory->readd(address);address+=4;
    s->maxQIndexDelta = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minQIndexDelta);address+=4;
    memory->writed(address, s->maxQIndexDelta);address+=4;
}
MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR::~MarshalVkVideoEncodeAV1QuantizationMapCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoFormatQuantizationMapPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatQuantizationMapPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->quantizationMapTexelSize, address, 8);address+=8;
}
void MarshalVkVideoFormatQuantizationMapPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatQuantizationMapPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->quantizationMapTexelSize, 8); address+=8;
}
MarshalVkVideoFormatQuantizationMapPropertiesKHR::~MarshalVkVideoFormatQuantizationMapPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoFormatH265QuantizationMapPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatH265QuantizationMapPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->compatibleCtbSizes = (VkVideoEncodeH265CtbSizeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoFormatH265QuantizationMapPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatH265QuantizationMapPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->compatibleCtbSizes);address+=4;
}
MarshalVkVideoFormatH265QuantizationMapPropertiesKHR::~MarshalVkVideoFormatH265QuantizationMapPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatAV1QuantizationMapPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->compatibleSuperblockSizes = (VkVideoEncodeAV1SuperblockSizeFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoFormatAV1QuantizationMapPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->compatibleSuperblockSizes);address+=4;
}
MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR::~MarshalVkVideoFormatAV1QuantizationMapPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoCodecOperation = (VkVideoCodecOperationFlagBitsKHR)memory->readd(address);address+=4;
    s->chromaSubsampling = (VkVideoChromaSubsamplingFlagsKHR)memory->readd(address);address+=4;
    s->lumaBitDepth = (VkVideoComponentBitDepthFlagsKHR)memory->readd(address);address+=4;
    s->chromaBitDepth = (VkVideoComponentBitDepthFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoCodecOperation);address+=4;
    memory->writed(address, s->chromaSubsampling);address+=4;
    memory->writed(address, s->lumaBitDepth);address+=4;
    memory->writed(address, s->chromaBitDepth);address+=4;
}
MarshalVkVideoProfileInfoKHR::~MarshalVkVideoProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoCapabilityFlagsKHR)memory->readd(address);address+=4;
    s->minBitstreamBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->minBitstreamBufferSizeAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    memory->memcpy(&s->pictureAccessGranularity, address, 8);address+=8;
    memory->memcpy(&s->minCodedExtent, address, 8);address+=8;
    memory->memcpy(&s->maxCodedExtent, address, 8);address+=8;
    s->maxDpbSlots = (uint32_t)memory->readd(address);address+=4;
    s->maxActiveReferencePictures = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->stdHeaderVersion, address, 8);address+=8;
}
void MarshalVkVideoCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->minBitstreamBufferOffsetAlignment);address+=8;
    memory->writeq(address, s->minBitstreamBufferSizeAlignment);address+=8;
    memory->memcpy(address, &s->pictureAccessGranularity, 8); address+=8;
    memory->memcpy(address, &s->minCodedExtent, 8); address+=8;
    memory->memcpy(address, &s->maxCodedExtent, 8); address+=8;
    memory->writed(address, s->maxDpbSlots);address+=4;
    memory->writed(address, s->maxActiveReferencePictures);address+=4;
    memory->memcpy(address, &s->stdHeaderVersion, 8); address+=8;
}
MarshalVkVideoCapabilitiesKHR::~MarshalVkVideoCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoSessionMemoryRequirementsKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionMemoryRequirementsKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryBindIndex = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->memoryRequirements, address, 20);address+=20;
}
void MarshalVkVideoSessionMemoryRequirementsKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionMemoryRequirementsKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryBindIndex);address+=4;
    memory->memcpy(address, &s->memoryRequirements, 20); address+=20;
}
MarshalVkVideoSessionMemoryRequirementsKHR::~MarshalVkVideoSessionMemoryRequirementsKHR() {
    delete s.pNext;
}
void MarshalVkBindVideoSessionMemoryInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindVideoSessionMemoryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryBindIndex = (uint32_t)memory->readd(address);address+=4;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->memoryOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->memorySize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkBindVideoSessionMemoryInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindVideoSessionMemoryInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryBindIndex);address+=4;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->memoryOffset);address+=8;
    memory->writeq(address, s->memorySize);address+=8;
}
MarshalVkBindVideoSessionMemoryInfoKHR::~MarshalVkBindVideoSessionMemoryInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoPictureResourceInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoPictureResourceInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->codedOffset, address, 8);address+=8;
    memory->memcpy(&s->codedExtent, address, 8);address+=8;
    s->baseArrayLayer = (uint32_t)memory->readd(address);address+=4;
    s->imageViewBinding = (VkImageView)memory->readq(address);address+=8;
}
void MarshalVkVideoPictureResourceInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoPictureResourceInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->codedOffset, 8); address+=8;
    memory->memcpy(address, &s->codedExtent, 8); address+=8;
    memory->writed(address, s->baseArrayLayer);address+=4;
    memory->writeq(address, (U64)s->imageViewBinding);address+=8;
}
MarshalVkVideoPictureResourceInfoKHR::~MarshalVkVideoPictureResourceInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoReferenceSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoReferenceSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->slotIndex = (int32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPictureResource = NULL;
    } else {
        VkVideoPictureResourceInfoKHR* pPictureResource = new VkVideoPictureResourceInfoKHR();
        MarshalVkVideoPictureResourceInfoKHR::read(pBoxedInfo, memory, paramAddress, pPictureResource);
        s->pPictureResource = pPictureResource;
    }
}
void MarshalVkVideoReferenceSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoReferenceSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->slotIndex);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoPictureResourceInfoKHR* pPictureResource = new VkVideoPictureResourceInfoKHR();
        MarshalVkVideoPictureResourceInfoKHR::read(pBoxedInfo, memory, paramAddress, pPictureResource);
        s->pPictureResource = pPictureResource;
    }
}
MarshalVkVideoReferenceSlotInfoKHR::~MarshalVkVideoReferenceSlotInfoKHR() {
    delete s.pNext;
    delete s.pPictureResource;
}
void MarshalVkVideoDecodeCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoDecodeCapabilityFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkVideoDecodeCapabilitiesKHR::~MarshalVkVideoDecodeCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeUsageInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeUsageInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoUsageHints = (VkVideoDecodeUsageFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeUsageInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeUsageInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoUsageHints);address+=4;
}
MarshalVkVideoDecodeUsageInfoKHR::~MarshalVkVideoDecodeUsageInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoDecodeFlagsKHR)memory->readd(address);address+=4;
    s->srcBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->srcBufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->srcBufferRange = (VkDeviceSize)memory->readq(address);address+=8;
    MarshalVkVideoPictureResourceInfoKHR::read(pBoxedInfo, memory, address, &s->dstPictureResource); address+=36;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetupReferenceSlot = NULL;
    } else {
        VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pSetupReferenceSlot);
        s->pSetupReferenceSlot = pSetupReferenceSlot;
    }
    s->referenceSlotCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pReferenceSlots = NULL;
    } else {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR[s->referenceSlotCount];
        for (U32 i = 0; i < s->referenceSlotCount; i++) {
            MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pReferenceSlots[i]);
        }
        s->pReferenceSlots = pReferenceSlots;
    }
}
void MarshalVkVideoDecodeInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->srcBuffer);address+=8;
    memory->writeq(address, s->srcBufferOffset);address+=8;
    memory->writeq(address, s->srcBufferRange);address+=8;
    memory->memcpy(address, &s->dstPictureResource, 36); address+=36;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pSetupReferenceSlot);
        s->pSetupReferenceSlot = pSetupReferenceSlot;
    }
    memory->writed(address, s->referenceSlotCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pReferenceSlots);
        s->pReferenceSlots = pReferenceSlots;
    }
}
MarshalVkVideoDecodeInfoKHR::~MarshalVkVideoDecodeInfoKHR() {
    delete s.pNext;
    delete s.pSetupReferenceSlot;
    delete[] s.pReferenceSlots;
}
void MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoMaintenance1FeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoMaintenance1 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoMaintenance1FeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoMaintenance1);address+=4;
}
MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR::~MarshalVkPhysicalDeviceVideoMaintenance1FeaturesKHR() {
    delete s.pNext;
}
void MarshalVkVideoInlineQueryInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoInlineQueryInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->queryPool = (VkQueryPool)memory->readq(address);address+=8;
    s->firstQuery = (uint32_t)memory->readd(address);address+=4;
    s->queryCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoInlineQueryInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoInlineQueryInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->queryPool);address+=8;
    memory->writed(address, s->firstQuery);address+=4;
    memory->writed(address, s->queryCount);address+=4;
}
MarshalVkVideoInlineQueryInfoKHR::~MarshalVkVideoInlineQueryInfoKHR() {
    delete s.pNext;
}
void MarshalStdVideoDecodeH264PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeH264PictureInfo* s) {
    s->flags = (StdVideoDecodeH264PictureInfoFlags)memory->readd(address);address+=4;
    s->seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved2 = (uint8_t)memory->readb(address);address+=1;
    s->frame_num = (uint16_t)memory->readw(address);address+=2;
    s->idr_pic_id = (uint16_t)memory->readw(address);address+=2;
    memory->memcpy(&s->PicOrderCnt, address, 8);address+=8;
}
void MarshalStdVideoDecodeH264ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeH264ReferenceInfo* s) {
    s->flags = (StdVideoDecodeH264ReferenceInfoFlags)memory->readd(address);address+=4;
    s->FrameNum = (uint16_t)memory->readw(address);address+=2;
    s->reserved = (uint16_t)memory->readw(address);address+=2;
    memory->memcpy(&s->PicOrderCnt, address, 8);address+=8;
}
void MarshalVkVideoDecodeH264ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfileIdc = (StdVideoH264ProfileIdc)memory->readd(address);address+=4;
    s->pictureLayout = (VkVideoDecodeH264PictureLayoutFlagBitsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeH264ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfileIdc);address+=4;
    memory->writed(address, s->pictureLayout);address+=4;
}
MarshalVkVideoDecodeH264ProfileInfoKHR::~MarshalVkVideoDecodeH264ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeH264CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxLevelIdc = (StdVideoH264LevelIdc)memory->readd(address);address+=4;
    memory->memcpy(&s->fieldOffsetGranularity, address, 8);address+=8;
}
void MarshalVkVideoDecodeH264CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxLevelIdc);address+=4;
    memory->memcpy(address, &s->fieldOffsetGranularity, 8); address+=8;
}
MarshalVkVideoDecodeH264CapabilitiesKHR::~MarshalVkVideoDecodeH264CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalStdVideoH264SequenceParameterSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH264SequenceParameterSet* s) {
    kpanic("MarshalStdVideoH264SequenceParameterSet::read");
}
void MarshalStdVideoH264PictureParameterSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH264PictureParameterSet* s) {
    s->flags = (StdVideoH264PpsFlags)memory->readd(address);address+=4;
    s->seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l0_default_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l1_default_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->weighted_bipred_idc = (StdVideoH264WeightedBipredIdc)memory->readd(address);address+=4;
    s->pic_init_qp_minus26 = (int8_t)memory->readb(address);address+=1;
    s->pic_init_qs_minus26 = (int8_t)memory->readb(address);address+=1;
    s->chroma_qp_index_offset = (int8_t)memory->readb(address);address+=1;
    s->second_chroma_qp_index_offset = (int8_t)memory->readb(address);address+=1;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pScalingLists = NULL;
    } else {
        StdVideoH264ScalingLists* pScalingLists = new StdVideoH264ScalingLists();
        MarshalStdVideoH264ScalingLists::read(pBoxedInfo, memory, paramAddress, pScalingLists);
        s->pScalingLists = pScalingLists;
    }
}
MarshalStdVideoH264PictureParameterSet::~MarshalStdVideoH264PictureParameterSet() {
    delete s.pScalingLists;
}
void MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264SessionParametersAddInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdSPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSPSs = NULL;
    } else {
        s->pStdSPSs = new StdVideoH264SequenceParameterSet[(U32)s->stdSPSCount];
        memory->memcpy((StdVideoH264SequenceParameterSet*)s->pStdSPSs, paramAddress, (U32)s->stdSPSCount * sizeof(StdVideoH264SequenceParameterSet));
    }
    s->stdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPPSs = NULL;
    } else {
        s->pStdPPSs = new StdVideoH264PictureParameterSet[(U32)s->stdPPSCount];
        memory->memcpy((StdVideoH264PictureParameterSet*)s->pStdPPSs, paramAddress, (U32)s->stdPPSCount * sizeof(StdVideoH264PictureParameterSet));
    }
}
void MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264SessionParametersAddInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdSPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH264SequenceParameterSet* pStdSPSs = new StdVideoH264SequenceParameterSet();
        MarshalStdVideoH264SequenceParameterSet::read(pBoxedInfo, memory, paramAddress, pStdSPSs);
        s->pStdSPSs = pStdSPSs;
    }
    memory->writed(address, s->stdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH264PictureParameterSet* pStdPPSs = new StdVideoH264PictureParameterSet();
        MarshalStdVideoH264PictureParameterSet::read(pBoxedInfo, memory, paramAddress, pStdPPSs);
        s->pStdPPSs = pStdPPSs;
    }
}
MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::~MarshalVkVideoDecodeH264SessionParametersAddInfoKHR() {
    delete s.pNext;
    delete[] s.pStdSPSs;
    delete[] s.pStdPPSs;
}
void MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxStdSPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pParametersAddInfo = NULL;
    } else {
        VkVideoDecodeH264SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoDecodeH264SessionParametersAddInfoKHR();
        MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
void MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxStdSPSCount);address+=4;
    memory->writed(address, s->maxStdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoDecodeH264SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoDecodeH264SessionParametersAddInfoKHR();
        MarshalVkVideoDecodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR::~MarshalVkVideoDecodeH264SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pParametersAddInfo;
}
void MarshalVkVideoDecodeH264PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoDecodeH264PictureInfo* pStdPictureInfo = new StdVideoDecodeH264PictureInfo();
        MarshalStdVideoDecodeH264PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    s->sliceCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSliceOffsets = NULL;
    } else {
        s->pSliceOffsets = new uint32_t[(U32)s->sliceCount];
        memory->memcpy((uint32_t*)s->pSliceOffsets, paramAddress, (U32)s->sliceCount);
    }
}
void MarshalVkVideoDecodeH264PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeH264PictureInfo* pStdPictureInfo = new StdVideoDecodeH264PictureInfo();
        MarshalStdVideoDecodeH264PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->writed(address, s->sliceCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkVideoDecodeH264PictureInfoKHR::~MarshalVkVideoDecodeH264PictureInfoKHR() {
    delete s.pNext;
    delete s.pStdPictureInfo;
    delete[] s.pSliceOffsets;
}
void MarshalVkVideoDecodeH264DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeH264ReferenceInfo();
        MarshalStdVideoDecodeH264ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoDecodeH264DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH264DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeH264ReferenceInfo();
        MarshalStdVideoDecodeH264ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoDecodeH264DpbSlotInfoKHR::~MarshalVkVideoDecodeH264DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalStdVideoH265VideoParameterSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265VideoParameterSet* s) {
    s->flags = (StdVideoH265VpsFlags)memory->readd(address);address+=4;
    s->vps_video_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->vps_max_sub_layers_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved2 = (uint8_t)memory->readb(address);address+=1;
    s->vps_num_units_in_tick = (uint32_t)memory->readd(address);address+=4;
    s->vps_time_scale = (uint32_t)memory->readd(address);address+=4;
    s->vps_num_ticks_poc_diff_one_minus1 = (uint32_t)memory->readd(address);address+=4;
    s->reserved3 = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDecPicBufMgr = NULL;
    } else {
        StdVideoH265DecPicBufMgr* pDecPicBufMgr = new StdVideoH265DecPicBufMgr();
        MarshalStdVideoH265DecPicBufMgr::read(pBoxedInfo, memory, paramAddress, pDecPicBufMgr);
        s->pDecPicBufMgr = pDecPicBufMgr;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pHrdParameters = NULL;
    } else {
        StdVideoH265HrdParameters* pHrdParameters = new StdVideoH265HrdParameters();
        MarshalStdVideoH265HrdParameters::read(pBoxedInfo, memory, paramAddress, pHrdParameters);
        s->pHrdParameters = pHrdParameters;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pProfileTierLevel = NULL;
    } else {
        StdVideoH265ProfileTierLevel* pProfileTierLevel = new StdVideoH265ProfileTierLevel();
        MarshalStdVideoH265ProfileTierLevel::read(pBoxedInfo, memory, paramAddress, pProfileTierLevel);
        s->pProfileTierLevel = pProfileTierLevel;
    }
}
MarshalStdVideoH265VideoParameterSet::~MarshalStdVideoH265VideoParameterSet() {
    delete s.pDecPicBufMgr;
    delete s.pHrdParameters;
    delete s.pProfileTierLevel;
}
void MarshalStdVideoH265SequenceParameterSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265SequenceParameterSet* s) {
    s->flags = (StdVideoH265SpsFlags)memory->readd(address);address+=4;
    s->chroma_format_idc = (StdVideoH265ChromaFormatIdc)memory->readd(address);address+=4;
    s->pic_width_in_luma_samples = (uint32_t)memory->readd(address);address+=4;
    s->pic_height_in_luma_samples = (uint32_t)memory->readd(address);address+=4;
    s->sps_video_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->sps_max_sub_layers_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->sps_seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->bit_depth_luma_minus8 = (uint8_t)memory->readb(address);address+=1;
    s->bit_depth_chroma_minus8 = (uint8_t)memory->readb(address);address+=1;
    s->log2_max_pic_order_cnt_lsb_minus4 = (uint8_t)memory->readb(address);address+=1;
    s->log2_min_luma_coding_block_size_minus3 = (uint8_t)memory->readb(address);address+=1;
    s->log2_diff_max_min_luma_coding_block_size = (uint8_t)memory->readb(address);address+=1;
    s->log2_min_luma_transform_block_size_minus2 = (uint8_t)memory->readb(address);address+=1;
    s->log2_diff_max_min_luma_transform_block_size = (uint8_t)memory->readb(address);address+=1;
    s->max_transform_hierarchy_depth_inter = (uint8_t)memory->readb(address);address+=1;
    s->max_transform_hierarchy_depth_intra = (uint8_t)memory->readb(address);address+=1;
    s->num_short_term_ref_pic_sets = (uint8_t)memory->readb(address);address+=1;
    s->num_long_term_ref_pics_sps = (uint8_t)memory->readb(address);address+=1;
    s->pcm_sample_bit_depth_luma_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->pcm_sample_bit_depth_chroma_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->log2_min_pcm_luma_coding_block_size_minus3 = (uint8_t)memory->readb(address);address+=1;
    s->log2_diff_max_min_pcm_luma_coding_block_size = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved2 = (uint8_t)memory->readb(address);address+=1;
    s->palette_max_size = (uint8_t)memory->readb(address);address+=1;
    s->delta_palette_max_predictor_size = (uint8_t)memory->readb(address);address+=1;
    s->motion_vector_resolution_control_idc = (uint8_t)memory->readb(address);address+=1;
    s->sps_num_palette_predictor_initializers_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->conf_win_left_offset = (uint32_t)memory->readd(address);address+=4;
    s->conf_win_right_offset = (uint32_t)memory->readd(address);address+=4;
    s->conf_win_top_offset = (uint32_t)memory->readd(address);address+=4;
    s->conf_win_bottom_offset = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pProfileTierLevel = NULL;
    } else {
        StdVideoH265ProfileTierLevel* pProfileTierLevel = new StdVideoH265ProfileTierLevel();
        MarshalStdVideoH265ProfileTierLevel::read(pBoxedInfo, memory, paramAddress, pProfileTierLevel);
        s->pProfileTierLevel = pProfileTierLevel;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDecPicBufMgr = NULL;
    } else {
        StdVideoH265DecPicBufMgr* pDecPicBufMgr = new StdVideoH265DecPicBufMgr();
        MarshalStdVideoH265DecPicBufMgr::read(pBoxedInfo, memory, paramAddress, pDecPicBufMgr);
        s->pDecPicBufMgr = pDecPicBufMgr;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pScalingLists = NULL;
    } else {
        StdVideoH265ScalingLists* pScalingLists = new StdVideoH265ScalingLists();
        MarshalStdVideoH265ScalingLists::read(pBoxedInfo, memory, paramAddress, pScalingLists);
        s->pScalingLists = pScalingLists;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShortTermRefPicSet = NULL;
    } else {
        StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet = new StdVideoH265ShortTermRefPicSet();
        MarshalStdVideoH265ShortTermRefPicSet::read(pBoxedInfo, memory, paramAddress, pShortTermRefPicSet);
        s->pShortTermRefPicSet = pShortTermRefPicSet;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLongTermRefPicsSps = NULL;
    } else {
        StdVideoH265LongTermRefPicsSps* pLongTermRefPicsSps = new StdVideoH265LongTermRefPicsSps();
        MarshalStdVideoH265LongTermRefPicsSps::read(pBoxedInfo, memory, paramAddress, pLongTermRefPicsSps);
        s->pLongTermRefPicsSps = pLongTermRefPicsSps;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSequenceParameterSetVui = NULL;
    } else {
        StdVideoH265SequenceParameterSetVui* pSequenceParameterSetVui = new StdVideoH265SequenceParameterSetVui();
        MarshalStdVideoH265SequenceParameterSetVui::read(pBoxedInfo, memory, paramAddress, pSequenceParameterSetVui);
        s->pSequenceParameterSetVui = pSequenceParameterSetVui;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPredictorPaletteEntries = NULL;
    } else {
        StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries = new StdVideoH265PredictorPaletteEntries();
        MarshalStdVideoH265PredictorPaletteEntries::read(pBoxedInfo, memory, paramAddress, pPredictorPaletteEntries);
        s->pPredictorPaletteEntries = pPredictorPaletteEntries;
    }
}
MarshalStdVideoH265SequenceParameterSet::~MarshalStdVideoH265SequenceParameterSet() {
    delete s.pProfileTierLevel;
    delete s.pDecPicBufMgr;
    delete s.pScalingLists;
    delete s.pShortTermRefPicSet;
    delete s.pLongTermRefPicsSps;
    delete s.pSequenceParameterSetVui;
    delete s.pPredictorPaletteEntries;
}
void MarshalStdVideoH265PictureParameterSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265PictureParameterSet* s) {
    s->flags = (StdVideoH265PpsFlags)memory->readd(address);address+=4;
    s->pps_pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pps_seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->sps_video_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->num_extra_slice_header_bits = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l0_default_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l1_default_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->init_qp_minus26 = (int8_t)memory->readb(address);address+=1;
    s->diff_cu_qp_delta_depth = (uint8_t)memory->readb(address);address+=1;
    s->pps_cb_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->pps_cr_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->pps_beta_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->pps_tc_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->log2_parallel_merge_level_minus2 = (uint8_t)memory->readb(address);address+=1;
    s->log2_max_transform_skip_block_size_minus2 = (uint8_t)memory->readb(address);address+=1;
    s->diff_cu_chroma_qp_offset_depth = (uint8_t)memory->readb(address);address+=1;
    s->chroma_qp_offset_list_len_minus1 = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->cb_qp_offset_list, address, 6);address+=6;
    memory->memcpy(&s->cr_qp_offset_list, address, 6);address+=6;
    s->log2_sao_offset_scale_luma = (uint8_t)memory->readb(address);address+=1;
    s->log2_sao_offset_scale_chroma = (uint8_t)memory->readb(address);address+=1;
    s->pps_act_y_qp_offset_plus5 = (int8_t)memory->readb(address);address+=1;
    s->pps_act_cb_qp_offset_plus5 = (int8_t)memory->readb(address);address+=1;
    s->pps_act_cr_qp_offset_plus3 = (int8_t)memory->readb(address);address+=1;
    s->pps_num_palette_predictor_initializers = (uint8_t)memory->readb(address);address+=1;
    s->luma_bit_depth_entry_minus8 = (uint8_t)memory->readb(address);address+=1;
    s->chroma_bit_depth_entry_minus8 = (uint8_t)memory->readb(address);address+=1;
    s->num_tile_columns_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->num_tile_rows_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved2 = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->column_width_minus1, address, 38);address+=38;
    memory->memcpy(&s->row_height_minus1, address, 42);address+=42;
    s->reserved3 = (uint32_t)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pScalingLists = NULL;
    } else {
        StdVideoH265ScalingLists* pScalingLists = new StdVideoH265ScalingLists();
        MarshalStdVideoH265ScalingLists::read(pBoxedInfo, memory, paramAddress, pScalingLists);
        s->pScalingLists = pScalingLists;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPredictorPaletteEntries = NULL;
    } else {
        StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries = new StdVideoH265PredictorPaletteEntries();
        MarshalStdVideoH265PredictorPaletteEntries::read(pBoxedInfo, memory, paramAddress, pPredictorPaletteEntries);
        s->pPredictorPaletteEntries = pPredictorPaletteEntries;
    }
}
MarshalStdVideoH265PictureParameterSet::~MarshalStdVideoH265PictureParameterSet() {
    delete s.pScalingLists;
    delete s.pPredictorPaletteEntries;
}
void MarshalStdVideoDecodeH265PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeH265PictureInfo* s) {
    s->flags = (StdVideoDecodeH265PictureInfoFlags)memory->readd(address);address+=4;
    s->sps_video_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pps_seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pps_pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->NumDeltaPocsOfRefRpsIdx = (uint8_t)memory->readb(address);address+=1;
    s->PicOrderCntVal = (int32_t)memory->readd(address);address+=4;
    s->NumBitsForSTRefPicSetInSlice = (uint16_t)memory->readw(address);address+=2;
    s->reserved = (uint16_t)memory->readw(address);address+=2;
    memory->memcpy(&s->RefPicSetStCurrBefore, address, 8);address+=8;
    memory->memcpy(&s->RefPicSetStCurrAfter, address, 8);address+=8;
    memory->memcpy(&s->RefPicSetLtCurr, address, 8);address+=8;
}
void MarshalStdVideoDecodeH265ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeH265ReferenceInfo* s) {
    s->flags = (StdVideoDecodeH265ReferenceInfoFlags)memory->readd(address);address+=4;
    s->PicOrderCntVal = (int32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeH265ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfileIdc = (StdVideoH265ProfileIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeH265ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfileIdc);address+=4;
}
MarshalVkVideoDecodeH265ProfileInfoKHR::~MarshalVkVideoDecodeH265ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeH265CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxLevelIdc = (StdVideoH265LevelIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeH265CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxLevelIdc);address+=4;
}
MarshalVkVideoDecodeH265CapabilitiesKHR::~MarshalVkVideoDecodeH265CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265SessionParametersAddInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdVPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdVPSs = NULL;
    } else {
        s->pStdVPSs = new StdVideoH265VideoParameterSet[(U32)s->stdVPSCount];
        memory->memcpy((StdVideoH265VideoParameterSet*)s->pStdVPSs, paramAddress, (U32)s->stdVPSCount * sizeof(StdVideoH265VideoParameterSet));
    }
    s->stdSPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSPSs = NULL;
    } else {
        s->pStdSPSs = new StdVideoH265SequenceParameterSet[(U32)s->stdSPSCount];
        memory->memcpy((StdVideoH265SequenceParameterSet*)s->pStdSPSs, paramAddress, (U32)s->stdSPSCount * sizeof(StdVideoH265SequenceParameterSet));
    }
    s->stdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPPSs = NULL;
    } else {
        s->pStdPPSs = new StdVideoH265PictureParameterSet[(U32)s->stdPPSCount];
        memory->memcpy((StdVideoH265PictureParameterSet*)s->pStdPPSs, paramAddress, (U32)s->stdPPSCount * sizeof(StdVideoH265PictureParameterSet));
    }
}
void MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265SessionParametersAddInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdVPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265VideoParameterSet* pStdVPSs = new StdVideoH265VideoParameterSet();
        MarshalStdVideoH265VideoParameterSet::read(pBoxedInfo, memory, paramAddress, pStdVPSs);
        s->pStdVPSs = pStdVPSs;
    }
    memory->writed(address, s->stdSPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265SequenceParameterSet* pStdSPSs = new StdVideoH265SequenceParameterSet();
        MarshalStdVideoH265SequenceParameterSet::read(pBoxedInfo, memory, paramAddress, pStdSPSs);
        s->pStdSPSs = pStdSPSs;
    }
    memory->writed(address, s->stdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265PictureParameterSet* pStdPPSs = new StdVideoH265PictureParameterSet();
        MarshalStdVideoH265PictureParameterSet::read(pBoxedInfo, memory, paramAddress, pStdPPSs);
        s->pStdPPSs = pStdPPSs;
    }
}
MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::~MarshalVkVideoDecodeH265SessionParametersAddInfoKHR() {
    delete s.pNext;
    delete[] s.pStdVPSs;
    delete[] s.pStdSPSs;
    delete[] s.pStdPPSs;
}
void MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxStdVPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdSPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pParametersAddInfo = NULL;
    } else {
        VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoDecodeH265SessionParametersAddInfoKHR();
        MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
void MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxStdVPSCount);address+=4;
    memory->writed(address, s->maxStdSPSCount);address+=4;
    memory->writed(address, s->maxStdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoDecodeH265SessionParametersAddInfoKHR();
        MarshalVkVideoDecodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR::~MarshalVkVideoDecodeH265SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pParametersAddInfo;
}
void MarshalVkVideoDecodeH265PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoDecodeH265PictureInfo* pStdPictureInfo = new StdVideoDecodeH265PictureInfo();
        MarshalStdVideoDecodeH265PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    s->sliceSegmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSliceSegmentOffsets = NULL;
    } else {
        s->pSliceSegmentOffsets = new uint32_t[(U32)s->sliceSegmentCount];
        memory->memcpy((uint32_t*)s->pSliceSegmentOffsets, paramAddress, (U32)s->sliceSegmentCount);
    }
}
void MarshalVkVideoDecodeH265PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeH265PictureInfo* pStdPictureInfo = new StdVideoDecodeH265PictureInfo();
        MarshalStdVideoDecodeH265PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->writed(address, s->sliceSegmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkVideoDecodeH265PictureInfoKHR::~MarshalVkVideoDecodeH265PictureInfoKHR() {
    delete s.pNext;
    delete s.pStdPictureInfo;
    delete[] s.pSliceSegmentOffsets;
}
void MarshalVkVideoDecodeH265DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeH265ReferenceInfo();
        MarshalStdVideoDecodeH265ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoDecodeH265DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeH265DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeH265ReferenceInfo();
        MarshalStdVideoDecodeH265ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoDecodeH265DpbSlotInfoKHR::~MarshalVkVideoDecodeH265DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalStdVideoAV1SequenceHeader::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1SequenceHeader* s) {
    s->flags = (StdVideoAV1SequenceHeaderFlags)memory->readd(address);address+=4;
    s->seq_profile = (StdVideoAV1Profile)memory->readd(address);address+=4;
    s->frame_width_bits_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->frame_height_bits_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->max_frame_width_minus_1 = (uint16_t)memory->readw(address);address+=2;
    s->max_frame_height_minus_1 = (uint16_t)memory->readw(address);address+=2;
    s->delta_frame_id_length_minus_2 = (uint8_t)memory->readb(address);address+=1;
    s->additional_frame_id_length_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->order_hint_bits_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->seq_force_integer_mv = (uint8_t)memory->readb(address);address+=1;
    s->seq_force_screen_content_tools = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved1, address, 5);address+=5;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorConfig = NULL;
    } else {
        StdVideoAV1ColorConfig* pColorConfig = new StdVideoAV1ColorConfig();
        MarshalStdVideoAV1ColorConfig::read(pBoxedInfo, memory, paramAddress, pColorConfig);
        s->pColorConfig = pColorConfig;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTimingInfo = NULL;
    } else {
        StdVideoAV1TimingInfo* pTimingInfo = new StdVideoAV1TimingInfo();
        MarshalStdVideoAV1TimingInfo::read(pBoxedInfo, memory, paramAddress, pTimingInfo);
        s->pTimingInfo = pTimingInfo;
    }
}
MarshalStdVideoAV1SequenceHeader::~MarshalStdVideoAV1SequenceHeader() {
    delete s.pColorConfig;
    delete s.pTimingInfo;
}
void MarshalStdVideoDecodeAV1PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeAV1PictureInfo* s) {
    s->flags = (StdVideoDecodeAV1PictureInfoFlags)memory->readd(address);address+=4;
    s->frame_type = (StdVideoAV1FrameType)memory->readd(address);address+=4;
    s->current_frame_id = (uint32_t)memory->readd(address);address+=4;
    s->OrderHint = (uint8_t)memory->readb(address);address+=1;
    s->primary_ref_frame = (uint8_t)memory->readb(address);address+=1;
    s->refresh_frame_flags = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->interpolation_filter = (StdVideoAV1InterpolationFilter)memory->readd(address);address+=4;
    s->TxMode = (StdVideoAV1TxMode)memory->readd(address);address+=4;
    s->delta_q_res = (uint8_t)memory->readb(address);address+=1;
    s->delta_lf_res = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->SkipModeFrame, address, 2);address+=2;
    s->coded_denom = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved2, address, 3);address+=3;
    memory->memcpy(&s->OrderHints, address, 8);address+=8;
    memory->memcpy(&s->expectedFrameId, address, 32);address+=32;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTileInfo = NULL;
    } else {
        StdVideoAV1TileInfo* pTileInfo = new StdVideoAV1TileInfo();
        MarshalStdVideoAV1TileInfo::read(pBoxedInfo, memory, paramAddress, pTileInfo);
        s->pTileInfo = pTileInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQuantization = NULL;
    } else {
        StdVideoAV1Quantization* pQuantization = new StdVideoAV1Quantization();
        MarshalStdVideoAV1Quantization::read(pBoxedInfo, memory, paramAddress, pQuantization);
        s->pQuantization = pQuantization;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSegmentation = NULL;
    } else {
        StdVideoAV1Segmentation* pSegmentation = new StdVideoAV1Segmentation();
        MarshalStdVideoAV1Segmentation::read(pBoxedInfo, memory, paramAddress, pSegmentation);
        s->pSegmentation = pSegmentation;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLoopFilter = NULL;
    } else {
        StdVideoAV1LoopFilter* pLoopFilter = new StdVideoAV1LoopFilter();
        MarshalStdVideoAV1LoopFilter::read(pBoxedInfo, memory, paramAddress, pLoopFilter);
        s->pLoopFilter = pLoopFilter;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCDEF = NULL;
    } else {
        StdVideoAV1CDEF* pCDEF = new StdVideoAV1CDEF();
        MarshalStdVideoAV1CDEF::read(pBoxedInfo, memory, paramAddress, pCDEF);
        s->pCDEF = pCDEF;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLoopRestoration = NULL;
    } else {
        StdVideoAV1LoopRestoration* pLoopRestoration = new StdVideoAV1LoopRestoration();
        MarshalStdVideoAV1LoopRestoration::read(pBoxedInfo, memory, paramAddress, pLoopRestoration);
        s->pLoopRestoration = pLoopRestoration;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGlobalMotion = NULL;
    } else {
        StdVideoAV1GlobalMotion* pGlobalMotion = new StdVideoAV1GlobalMotion();
        MarshalStdVideoAV1GlobalMotion::read(pBoxedInfo, memory, paramAddress, pGlobalMotion);
        s->pGlobalMotion = pGlobalMotion;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFilmGrain = NULL;
    } else {
        StdVideoAV1FilmGrain* pFilmGrain = new StdVideoAV1FilmGrain();
        MarshalStdVideoAV1FilmGrain::read(pBoxedInfo, memory, paramAddress, pFilmGrain);
        s->pFilmGrain = pFilmGrain;
    }
}
MarshalStdVideoDecodeAV1PictureInfo::~MarshalStdVideoDecodeAV1PictureInfo() {
    delete s.pTileInfo;
    delete s.pQuantization;
    delete s.pSegmentation;
    delete s.pLoopFilter;
    delete s.pCDEF;
    delete s.pLoopRestoration;
    delete s.pGlobalMotion;
    delete s.pFilmGrain;
}
void MarshalStdVideoDecodeAV1ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoDecodeAV1ReferenceInfo* s) {
    s->flags = (StdVideoDecodeAV1ReferenceInfoFlags)memory->readd(address);address+=4;
    s->frame_type = (uint8_t)memory->readb(address);address+=1;
    s->RefFrameSignBias = (uint8_t)memory->readb(address);address+=1;
    s->OrderHint = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->SavedOrderHints, address, 8);address+=8;
}
void MarshalVkVideoDecodeAV1ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfile = (StdVideoAV1Profile)memory->readd(address);address+=4;
    s->filmGrainSupport = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeAV1ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfile);address+=4;
    memory->writed(address, s->filmGrainSupport);address+=4;
}
MarshalVkVideoDecodeAV1ProfileInfoKHR::~MarshalVkVideoDecodeAV1ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeAV1CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxLevel = (StdVideoAV1Level)memory->readd(address);address+=4;
}
void MarshalVkVideoDecodeAV1CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxLevel);address+=4;
}
MarshalVkVideoDecodeAV1CapabilitiesKHR::~MarshalVkVideoDecodeAV1CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSequenceHeader = NULL;
    } else {
        StdVideoAV1SequenceHeader* pStdSequenceHeader = new StdVideoAV1SequenceHeader();
        MarshalStdVideoAV1SequenceHeader::read(pBoxedInfo, memory, paramAddress, pStdSequenceHeader);
        s->pStdSequenceHeader = pStdSequenceHeader;
    }
}
void MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoAV1SequenceHeader* pStdSequenceHeader = new StdVideoAV1SequenceHeader();
        MarshalStdVideoAV1SequenceHeader::read(pBoxedInfo, memory, paramAddress, pStdSequenceHeader);
        s->pStdSequenceHeader = pStdSequenceHeader;
    }
}
MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR::~MarshalVkVideoDecodeAV1SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pStdSequenceHeader;
}
void MarshalVkVideoDecodeAV1PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoDecodeAV1PictureInfo* pStdPictureInfo = new StdVideoDecodeAV1PictureInfo();
        MarshalStdVideoDecodeAV1PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->memcpy(&s->referenceNameSlotIndices, address, 28);address+=28;
    s->frameHeaderOffset = (uint32_t)memory->readd(address);address+=4;
    s->tileCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTileOffsets = NULL;
    } else {
        s->pTileOffsets = new uint32_t[(U32)s->tileCount];
        memory->memcpy((uint32_t*)s->pTileOffsets, paramAddress, (U32)s->tileCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTileSizes = NULL;
    } else {
        s->pTileSizes = new uint32_t[(U32)s->tileCount];
        memory->memcpy((uint32_t*)s->pTileSizes, paramAddress, (U32)s->tileCount);
    }
}
void MarshalVkVideoDecodeAV1PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeAV1PictureInfo* pStdPictureInfo = new StdVideoDecodeAV1PictureInfo();
        MarshalStdVideoDecodeAV1PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->memcpy(address, s->referenceNameSlotIndices, 28); address+=28;
    memory->writed(address, s->frameHeaderOffset);address+=4;
    memory->writed(address, s->tileCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkVideoDecodeAV1PictureInfoKHR::~MarshalVkVideoDecodeAV1PictureInfoKHR() {
    delete s.pNext;
    delete s.pStdPictureInfo;
    delete[] s.pTileOffsets;
    delete[] s.pTileSizes;
}
void MarshalVkVideoDecodeAV1DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoDecodeAV1ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeAV1ReferenceInfo();
        MarshalStdVideoDecodeAV1ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoDecodeAV1DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoDecodeAV1DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoDecodeAV1ReferenceInfo* pStdReferenceInfo = new StdVideoDecodeAV1ReferenceInfo();
        MarshalStdVideoDecodeAV1ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoDecodeAV1DpbSlotInfoKHR::~MarshalVkVideoDecodeAV1DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalVkVideoSessionCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->queueFamilyIndex = (uint32_t)memory->readd(address);address+=4;
    s->flags = (VkVideoSessionCreateFlagsKHR)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVideoProfile = NULL;
    } else {
        VkVideoProfileInfoKHR* pVideoProfile = new VkVideoProfileInfoKHR();
        MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress, pVideoProfile);
        s->pVideoProfile = pVideoProfile;
    }
    s->pictureFormat = (VkFormat)memory->readd(address);address+=4;
    memory->memcpy(&s->maxCodedExtent, address, 8);address+=8;
    s->referencePictureFormat = (VkFormat)memory->readd(address);address+=4;
    s->maxDpbSlots = (uint32_t)memory->readd(address);address+=4;
    s->maxActiveReferencePictures = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdHeaderVersion = NULL;
    } else {
        VkExtensionProperties* pStdHeaderVersion = new VkExtensionProperties();
        MarshalVkExtensionProperties::read(pBoxedInfo, memory, paramAddress, pStdHeaderVersion);
        s->pStdHeaderVersion = pStdHeaderVersion;
    }
}
void MarshalVkVideoSessionCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->queueFamilyIndex);address+=4;
    memory->writed(address, s->flags);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoProfileInfoKHR* pVideoProfile = new VkVideoProfileInfoKHR();
        MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress, pVideoProfile);
        s->pVideoProfile = pVideoProfile;
    }
    memory->writed(address, s->pictureFormat);address+=4;
    memory->memcpy(address, &s->maxCodedExtent, 8); address+=8;
    memory->writed(address, s->referencePictureFormat);address+=4;
    memory->writed(address, s->maxDpbSlots);address+=4;
    memory->writed(address, s->maxActiveReferencePictures);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkExtensionProperties* pStdHeaderVersion = new VkExtensionProperties();
        MarshalVkExtensionProperties::read(pBoxedInfo, memory, paramAddress, pStdHeaderVersion);
        s->pStdHeaderVersion = pStdHeaderVersion;
    }
}
MarshalVkVideoSessionCreateInfoKHR::~MarshalVkVideoSessionCreateInfoKHR() {
    delete s.pNext;
    delete s.pVideoProfile;
    delete s.pStdHeaderVersion;
}
void MarshalVkVideoSessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoSessionParametersCreateFlagsKHR)memory->readd(address);address+=4;
    s->videoSessionParametersTemplate = (VkVideoSessionParametersKHR)memory->readq(address);address+=8;
    s->videoSession = (VkVideoSessionKHR)memory->readq(address);address+=8;
}
void MarshalVkVideoSessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->videoSessionParametersTemplate);address+=8;
    memory->writeq(address, (U64)s->videoSession);address+=8;
}
MarshalVkVideoSessionParametersCreateInfoKHR::~MarshalVkVideoSessionParametersCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoSessionParametersUpdateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionParametersUpdateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->updateSequenceCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoSessionParametersUpdateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoSessionParametersUpdateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->updateSequenceCount);address+=4;
}
MarshalVkVideoSessionParametersUpdateInfoKHR::~MarshalVkVideoSessionParametersUpdateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeSessionParametersGetInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeSessionParametersGetInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoSessionParameters = (VkVideoSessionParametersKHR)memory->readq(address);address+=8;
}
void MarshalVkVideoEncodeSessionParametersGetInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeSessionParametersGetInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->videoSessionParameters);address+=8;
}
MarshalVkVideoEncodeSessionParametersGetInfoKHR::~MarshalVkVideoEncodeSessionParametersGetInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeSessionParametersFeedbackInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hasOverrides = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeSessionParametersFeedbackInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hasOverrides);address+=4;
}
MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR::~MarshalVkVideoEncodeSessionParametersFeedbackInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoBeginCodingInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoBeginCodingInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoBeginCodingFlagsKHR)memory->readd(address);address+=4;
    s->videoSession = (VkVideoSessionKHR)memory->readq(address);address+=8;
    s->videoSessionParameters = (VkVideoSessionParametersKHR)memory->readq(address);address+=8;
    s->referenceSlotCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pReferenceSlots = NULL;
    } else {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR[s->referenceSlotCount];
        for (U32 i = 0; i < s->referenceSlotCount; i++) {
            MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pReferenceSlots[i]);
        }
        s->pReferenceSlots = pReferenceSlots;
    }
}
void MarshalVkVideoBeginCodingInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoBeginCodingInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->videoSession);address+=8;
    memory->writeq(address, (U64)s->videoSessionParameters);address+=8;
    memory->writed(address, s->referenceSlotCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pReferenceSlots);
        s->pReferenceSlots = pReferenceSlots;
    }
}
MarshalVkVideoBeginCodingInfoKHR::~MarshalVkVideoBeginCodingInfoKHR() {
    delete s.pNext;
    delete[] s.pReferenceSlots;
}
void MarshalVkVideoEndCodingInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEndCodingInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEndCodingFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEndCodingInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEndCodingInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkVideoEndCodingInfoKHR::~MarshalVkVideoEndCodingInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoCodingControlInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoCodingControlInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoCodingControlFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoCodingControlInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoCodingControlInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkVideoCodingControlInfoKHR::~MarshalVkVideoCodingControlInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeUsageInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeUsageInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoUsageHints = (VkVideoEncodeUsageFlagsKHR)memory->readd(address);address+=4;
    s->videoContentHints = (VkVideoEncodeContentFlagsKHR)memory->readd(address);address+=4;
    s->tuningMode = (VkVideoEncodeTuningModeKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeUsageInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeUsageInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoUsageHints);address+=4;
    memory->writed(address, s->videoContentHints);address+=4;
    memory->writed(address, s->tuningMode);address+=4;
}
MarshalVkVideoEncodeUsageInfoKHR::~MarshalVkVideoEncodeUsageInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeFlagsKHR)memory->readd(address);address+=4;
    s->dstBuffer = (VkBuffer)memory->readq(address);address+=8;
    s->dstBufferOffset = (VkDeviceSize)memory->readq(address);address+=8;
    s->dstBufferRange = (VkDeviceSize)memory->readq(address);address+=8;
    MarshalVkVideoPictureResourceInfoKHR::read(pBoxedInfo, memory, address, &s->srcPictureResource); address+=36;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetupReferenceSlot = NULL;
    } else {
        VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pSetupReferenceSlot);
        s->pSetupReferenceSlot = pSetupReferenceSlot;
    }
    s->referenceSlotCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pReferenceSlots = NULL;
    } else {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR[s->referenceSlotCount];
        for (U32 i = 0; i < s->referenceSlotCount; i++) {
            MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pReferenceSlots[i]);
        }
        s->pReferenceSlots = pReferenceSlots;
    }
    s->precedingExternallyEncodedBytes = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->dstBuffer);address+=8;
    memory->writeq(address, s->dstBufferOffset);address+=8;
    memory->writeq(address, s->dstBufferRange);address+=8;
    memory->memcpy(address, &s->srcPictureResource, 36); address+=36;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pSetupReferenceSlot);
        s->pSetupReferenceSlot = pSetupReferenceSlot;
    }
    memory->writed(address, s->referenceSlotCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoReferenceSlotInfoKHR* pReferenceSlots = new VkVideoReferenceSlotInfoKHR();
        MarshalVkVideoReferenceSlotInfoKHR::read(pBoxedInfo, memory, paramAddress, pReferenceSlots);
        s->pReferenceSlots = pReferenceSlots;
    }
    memory->writed(address, s->precedingExternallyEncodedBytes);address+=4;
}
MarshalVkVideoEncodeInfoKHR::~MarshalVkVideoEncodeInfoKHR() {
    delete s.pNext;
    delete s.pSetupReferenceSlot;
    delete[] s.pReferenceSlots;
}
void MarshalVkVideoEncodeQuantizationMapInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->quantizationMap = (VkImageView)memory->readq(address);address+=8;
    memory->memcpy(&s->quantizationMapExtent, address, 8);address+=8;
}
void MarshalVkVideoEncodeQuantizationMapInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->quantizationMap);address+=8;
    memory->memcpy(address, &s->quantizationMapExtent, 8); address+=8;
}
MarshalVkVideoEncodeQuantizationMapInfoKHR::~MarshalVkVideoEncodeQuantizationMapInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->quantizationMapTexelSize, address, 8);address+=8;
}
void MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->quantizationMapTexelSize, 8); address+=8;
}
MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR::~MarshalVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoEncodeQuantizationMap = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoEncodeQuantizationMap);address+=4;
}
MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR::~MarshalVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->encodeFeedbackFlags = (VkVideoEncodeFeedbackFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->encodeFeedbackFlags);address+=4;
}
MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR::~MarshalVkQueryPoolVideoEncodeFeedbackCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeQualityLevelInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQualityLevelInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->qualityLevel = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeQualityLevelInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQualityLevelInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->qualityLevel);address+=4;
}
MarshalVkVideoEncodeQualityLevelInfoKHR::~MarshalVkVideoEncodeQualityLevelInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVideoProfile = NULL;
    } else {
        VkVideoProfileInfoKHR* pVideoProfile = new VkVideoProfileInfoKHR();
        MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress, pVideoProfile);
        s->pVideoProfile = pVideoProfile;
    }
    s->qualityLevel = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoProfileInfoKHR* pVideoProfile = new VkVideoProfileInfoKHR();
        MarshalVkVideoProfileInfoKHR::read(pBoxedInfo, memory, paramAddress, pVideoProfile);
        s->pVideoProfile = pVideoProfile;
    }
    memory->writed(address, s->qualityLevel);address+=4;
}
MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR::~MarshalVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR() {
    delete s.pNext;
    delete s.pVideoProfile;
}
void MarshalVkVideoEncodeQualityLevelPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQualityLevelPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->preferredRateControlMode = (VkVideoEncodeRateControlModeFlagBitsKHR)memory->readd(address);address+=4;
    s->preferredRateControlLayerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeQualityLevelPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeQualityLevelPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->preferredRateControlMode);address+=4;
    memory->writed(address, s->preferredRateControlLayerCount);address+=4;
}
MarshalVkVideoEncodeQualityLevelPropertiesKHR::~MarshalVkVideoEncodeQualityLevelPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeRateControlInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeRateControlInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeRateControlFlagsKHR)memory->readd(address);address+=4;
    s->rateControlMode = (VkVideoEncodeRateControlModeFlagBitsKHR)memory->readd(address);address+=4;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLayers = NULL;
    } else {
        VkVideoEncodeRateControlLayerInfoKHR* pLayers = new VkVideoEncodeRateControlLayerInfoKHR[s->layerCount];
        for (U32 i = 0; i < s->layerCount; i++) {
            MarshalVkVideoEncodeRateControlLayerInfoKHR::read(pBoxedInfo, memory, paramAddress + i*32, &pLayers[i]);
        }
        s->pLayers = pLayers;
    }
    s->virtualBufferSizeInMs = (uint32_t)memory->readd(address);address+=4;
    s->initialVirtualBufferSizeInMs = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeRateControlInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeRateControlInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rateControlMode);address+=4;
    memory->writed(address, s->layerCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoEncodeRateControlLayerInfoKHR* pLayers = new VkVideoEncodeRateControlLayerInfoKHR();
        MarshalVkVideoEncodeRateControlLayerInfoKHR::read(pBoxedInfo, memory, paramAddress, pLayers);
        s->pLayers = pLayers;
    }
    memory->writed(address, s->virtualBufferSizeInMs);address+=4;
    memory->writed(address, s->initialVirtualBufferSizeInMs);address+=4;
}
MarshalVkVideoEncodeRateControlInfoKHR::~MarshalVkVideoEncodeRateControlInfoKHR() {
    delete s.pNext;
    delete[] s.pLayers;
}
void MarshalVkVideoEncodeRateControlLayerInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeRateControlLayerInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->averageBitrate = (uint64_t)memory->readq(address);address+=8;
    s->maxBitrate = (uint64_t)memory->readq(address);address+=8;
    s->frameRateNumerator = (uint32_t)memory->readd(address);address+=4;
    s->frameRateDenominator = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeRateControlLayerInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeRateControlLayerInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->averageBitrate);address+=8;
    memory->writeq(address, s->maxBitrate);address+=8;
    memory->writed(address, s->frameRateNumerator);address+=4;
    memory->writed(address, s->frameRateDenominator);address+=4;
}
MarshalVkVideoEncodeRateControlLayerInfoKHR::~MarshalVkVideoEncodeRateControlLayerInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeCapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeCapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeCapabilityFlagsKHR)memory->readd(address);address+=4;
    s->rateControlModes = (VkVideoEncodeRateControlModeFlagsKHR)memory->readd(address);address+=4;
    s->maxRateControlLayers = (uint32_t)memory->readd(address);address+=4;
    s->maxBitrate = (uint64_t)memory->readq(address);address+=8;
    s->maxQualityLevels = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->encodeInputPictureGranularity, address, 8);address+=8;
    s->supportedEncodeFeedbackFlags = (VkVideoEncodeFeedbackFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeCapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeCapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->rateControlModes);address+=4;
    memory->writed(address, s->maxRateControlLayers);address+=4;
    memory->writeq(address, s->maxBitrate);address+=8;
    memory->writed(address, s->maxQualityLevels);address+=4;
    memory->memcpy(address, &s->encodeInputPictureGranularity, 8); address+=8;
    memory->writed(address, s->supportedEncodeFeedbackFlags);address+=4;
}
MarshalVkVideoEncodeCapabilitiesKHR::~MarshalVkVideoEncodeCapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeH264CapabilityFlagsKHR)memory->readd(address);address+=4;
    s->maxLevelIdc = (StdVideoH264LevelIdc)memory->readd(address);address+=4;
    s->maxSliceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxPPictureL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxBPictureL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxL1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxTemporalLayerCount = (uint32_t)memory->readd(address);address+=4;
    s->expectDyadicTemporalLayerPattern = (VkBool32)memory->readd(address);address+=4;
    s->minQp = (int32_t)memory->readd(address);address+=4;
    s->maxQp = (int32_t)memory->readd(address);address+=4;
    s->prefersGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->requiresGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->stdSyntaxFlags = (VkVideoEncodeH264StdFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->maxLevelIdc);address+=4;
    memory->writed(address, s->maxSliceCount);address+=4;
    memory->writed(address, s->maxPPictureL0ReferenceCount);address+=4;
    memory->writed(address, s->maxBPictureL0ReferenceCount);address+=4;
    memory->writed(address, s->maxL1ReferenceCount);address+=4;
    memory->writed(address, s->maxTemporalLayerCount);address+=4;
    memory->writed(address, s->expectDyadicTemporalLayerPattern);address+=4;
    memory->writed(address, s->minQp);address+=4;
    memory->writed(address, s->maxQp);address+=4;
    memory->writed(address, s->prefersGopRemainingFrames);address+=4;
    memory->writed(address, s->requiresGopRemainingFrames);address+=4;
    memory->writed(address, s->stdSyntaxFlags);address+=4;
}
MarshalVkVideoEncodeH264CapabilitiesKHR::~MarshalVkVideoEncodeH264CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264QualityLevelPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264QualityLevelPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->preferredRateControlFlags = (VkVideoEncodeH264RateControlFlagsKHR)memory->readd(address);address+=4;
    s->preferredGopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredIdrPeriod = (uint32_t)memory->readd(address);address+=4;
    s->preferredConsecutiveBFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredTemporalLayerCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->preferredConstantQp, address, 12);address+=12;
    s->preferredMaxL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxL1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredStdEntropyCodingModeFlag = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264QualityLevelPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264QualityLevelPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->preferredRateControlFlags);address+=4;
    memory->writed(address, s->preferredGopFrameCount);address+=4;
    memory->writed(address, s->preferredIdrPeriod);address+=4;
    memory->writed(address, s->preferredConsecutiveBFrameCount);address+=4;
    memory->writed(address, s->preferredTemporalLayerCount);address+=4;
    memory->memcpy(address, &s->preferredConstantQp, 12); address+=12;
    memory->writed(address, s->preferredMaxL0ReferenceCount);address+=4;
    memory->writed(address, s->preferredMaxL1ReferenceCount);address+=4;
    memory->writed(address, s->preferredStdEntropyCodingModeFlag);address+=4;
}
MarshalVkVideoEncodeH264QualityLevelPropertiesKHR::~MarshalVkVideoEncodeH264QualityLevelPropertiesKHR() {
    delete s.pNext;
}
void MarshalStdVideoEncodeH264SliceHeader::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264SliceHeader* s) {
    s->first_mb_in_slice = (uint32_t)memory->readd(address);address+=4;
    s->slice_type = (StdVideoH264SliceType)memory->readd(address);address+=4;
    s->slice_alpha_c0_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->slice_beta_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->slice_qp_delta = (int8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->cabac_init_idc = (StdVideoH264CabacInitIdc)memory->readd(address);address+=4;
    s->disable_deblocking_filter_idc = (StdVideoH264DisableDeblockingFilterIdc)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWeightTable = NULL;
    } else {
        s->pWeightTable = new StdVideoEncodeH264WeightTable[1];
        memory->memcpy((StdVideoEncodeH264WeightTable*)s->pWeightTable, paramAddress, 1 * sizeof(StdVideoEncodeH264WeightTable));
    }
}
MarshalStdVideoEncodeH264SliceHeader::~MarshalStdVideoEncodeH264SliceHeader() {
    delete[] s.pWeightTable;
}
void MarshalStdVideoEncodeH264PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264PictureInfo* s) {
    s->flags = (StdVideoEncodeH264PictureInfoFlags)memory->readd(address);address+=4;
    s->seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->idr_pic_id = (uint16_t)memory->readw(address);address+=2;
    s->primary_pic_type = (StdVideoH264PictureType)memory->readd(address);address+=4;
    s->frame_num = (uint32_t)memory->readd(address);address+=4;
    s->PicOrderCnt = (int32_t)memory->readd(address);address+=4;
    s->temporal_id = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved1, address, 3);address+=3;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRefLists = NULL;
    } else {
        StdVideoEncodeH264ReferenceListsInfo* pRefLists = new StdVideoEncodeH264ReferenceListsInfo();
        MarshalStdVideoEncodeH264ReferenceListsInfo::read(pBoxedInfo, memory, paramAddress, pRefLists);
        s->pRefLists = pRefLists;
    }
}
MarshalStdVideoEncodeH264PictureInfo::~MarshalStdVideoEncodeH264PictureInfo() {
    delete s.pRefLists;
}
void MarshalStdVideoEncodeH264ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264ReferenceInfo* s) {
    s->flags = (StdVideoEncodeH264ReferenceInfoFlags)memory->readd(address);address+=4;
    s->primary_pic_type = (StdVideoH264PictureType)memory->readd(address);address+=4;
    s->FrameNum = (uint32_t)memory->readd(address);address+=4;
    s->PicOrderCnt = (int32_t)memory->readd(address);address+=4;
    s->long_term_pic_num = (uint16_t)memory->readw(address);address+=2;
    s->long_term_frame_idx = (uint16_t)memory->readw(address);address+=2;
    s->temporal_id = (uint8_t)memory->readb(address);address+=1;
}
void MarshalVkVideoEncodeH264SessionCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMaxLevelIdc = (VkBool32)memory->readd(address);address+=4;
    s->maxLevelIdc = (StdVideoH264LevelIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264SessionCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMaxLevelIdc);address+=4;
    memory->writed(address, s->maxLevelIdc);address+=4;
}
MarshalVkVideoEncodeH264SessionCreateInfoKHR::~MarshalVkVideoEncodeH264SessionCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersAddInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdSPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSPSs = NULL;
    } else {
        s->pStdSPSs = new StdVideoH264SequenceParameterSet[(U32)s->stdSPSCount];
        memory->memcpy((StdVideoH264SequenceParameterSet*)s->pStdSPSs, paramAddress, (U32)s->stdSPSCount * sizeof(StdVideoH264SequenceParameterSet));
    }
    s->stdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPPSs = NULL;
    } else {
        s->pStdPPSs = new StdVideoH264PictureParameterSet[(U32)s->stdPPSCount];
        memory->memcpy((StdVideoH264PictureParameterSet*)s->pStdPPSs, paramAddress, (U32)s->stdPPSCount * sizeof(StdVideoH264PictureParameterSet));
    }
}
void MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersAddInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdSPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH264SequenceParameterSet* pStdSPSs = new StdVideoH264SequenceParameterSet();
        MarshalStdVideoH264SequenceParameterSet::read(pBoxedInfo, memory, paramAddress, pStdSPSs);
        s->pStdSPSs = pStdSPSs;
    }
    memory->writed(address, s->stdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH264PictureParameterSet* pStdPPSs = new StdVideoH264PictureParameterSet();
        MarshalStdVideoH264PictureParameterSet::read(pBoxedInfo, memory, paramAddress, pStdPPSs);
        s->pStdPPSs = pStdPPSs;
    }
}
MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::~MarshalVkVideoEncodeH264SessionParametersAddInfoKHR() {
    delete s.pNext;
    delete[] s.pStdSPSs;
    delete[] s.pStdPPSs;
}
void MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxStdSPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pParametersAddInfo = NULL;
    } else {
        VkVideoEncodeH264SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoEncodeH264SessionParametersAddInfoKHR();
        MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
void MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxStdSPSCount);address+=4;
    memory->writed(address, s->maxStdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoEncodeH264SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoEncodeH264SessionParametersAddInfoKHR();
        MarshalVkVideoEncodeH264SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR::~MarshalVkVideoEncodeH264SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pParametersAddInfo;
}
void MarshalVkVideoEncodeH264SessionParametersGetInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersGetInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->writeStdSPS = (VkBool32)memory->readd(address);address+=4;
    s->writeStdPPS = (VkBool32)memory->readd(address);address+=4;
    s->stdSPSId = (uint32_t)memory->readd(address);address+=4;
    s->stdPPSId = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264SessionParametersGetInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersGetInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->writeStdSPS);address+=4;
    memory->writed(address, s->writeStdPPS);address+=4;
    memory->writed(address, s->stdSPSId);address+=4;
    memory->writed(address, s->stdPPSId);address+=4;
}
MarshalVkVideoEncodeH264SessionParametersGetInfoKHR::~MarshalVkVideoEncodeH264SessionParametersGetInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersFeedbackInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hasStdSPSOverrides = (VkBool32)memory->readd(address);address+=4;
    s->hasStdPPSOverrides = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264SessionParametersFeedbackInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hasStdSPSOverrides);address+=4;
    memory->writed(address, s->hasStdPPSOverrides);address+=4;
}
MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR::~MarshalVkVideoEncodeH264SessionParametersFeedbackInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeH264ReferenceInfo();
        MarshalStdVideoEncodeH264ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoEncodeH264DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeH264ReferenceInfo();
        MarshalStdVideoEncodeH264ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoEncodeH264DpbSlotInfoKHR::~MarshalVkVideoEncodeH264DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalVkVideoEncodeH264PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->naluSliceEntryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNaluSliceEntries = NULL;
    } else {
        VkVideoEncodeH264NaluSliceInfoKHR* pNaluSliceEntries = new VkVideoEncodeH264NaluSliceInfoKHR[s->naluSliceEntryCount];
        for (U32 i = 0; i < s->naluSliceEntryCount; i++) {
            MarshalVkVideoEncodeH264NaluSliceInfoKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pNaluSliceEntries[i]);
        }
        s->pNaluSliceEntries = pNaluSliceEntries;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoEncodeH264PictureInfo* pStdPictureInfo = new StdVideoEncodeH264PictureInfo();
        MarshalStdVideoEncodeH264PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    s->generatePrefixNalu = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->naluSliceEntryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoEncodeH264NaluSliceInfoKHR* pNaluSliceEntries = new VkVideoEncodeH264NaluSliceInfoKHR();
        MarshalVkVideoEncodeH264NaluSliceInfoKHR::read(pBoxedInfo, memory, paramAddress, pNaluSliceEntries);
        s->pNaluSliceEntries = pNaluSliceEntries;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH264PictureInfo* pStdPictureInfo = new StdVideoEncodeH264PictureInfo();
        MarshalStdVideoEncodeH264PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->writed(address, s->generatePrefixNalu);address+=4;
}
MarshalVkVideoEncodeH264PictureInfoKHR::~MarshalVkVideoEncodeH264PictureInfoKHR() {
    delete s.pNext;
    delete[] s.pNaluSliceEntries;
    delete s.pStdPictureInfo;
}
void MarshalVkVideoEncodeH264ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfileIdc = (StdVideoH264ProfileIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfileIdc);address+=4;
}
MarshalVkVideoEncodeH264ProfileInfoKHR::~MarshalVkVideoEncodeH264ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264NaluSliceInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264NaluSliceInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->constantQp = (int32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSliceHeader = NULL;
    } else {
        s->pStdSliceHeader = new StdVideoEncodeH264SliceHeader[1];
        memory->memcpy((StdVideoEncodeH264SliceHeader*)s->pStdSliceHeader, paramAddress, 1 * sizeof(StdVideoEncodeH264SliceHeader));
    }
}
void MarshalVkVideoEncodeH264NaluSliceInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264NaluSliceInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->constantQp);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH264SliceHeader* pStdSliceHeader = new StdVideoEncodeH264SliceHeader();
        MarshalStdVideoEncodeH264SliceHeader::read(pBoxedInfo, memory, paramAddress, pStdSliceHeader);
        s->pStdSliceHeader = pStdSliceHeader;
    }
}
MarshalVkVideoEncodeH264NaluSliceInfoKHR::~MarshalVkVideoEncodeH264NaluSliceInfoKHR() {
    delete s.pNext;
    delete[] s.pStdSliceHeader;
}
void MarshalVkVideoEncodeH264RateControlInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264RateControlInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeH264RateControlFlagsKHR)memory->readd(address);address+=4;
    s->gopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->idrPeriod = (uint32_t)memory->readd(address);address+=4;
    s->consecutiveBFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->temporalLayerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264RateControlInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264RateControlInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->gopFrameCount);address+=4;
    memory->writed(address, s->idrPeriod);address+=4;
    memory->writed(address, s->consecutiveBFrameCount);address+=4;
    memory->writed(address, s->temporalLayerCount);address+=4;
}
MarshalVkVideoEncodeH264RateControlInfoKHR::~MarshalVkVideoEncodeH264RateControlInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264GopRemainingFrameInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->gopRemainingI = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingP = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingB = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264GopRemainingFrameInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useGopRemainingFrames);address+=4;
    memory->writed(address, s->gopRemainingI);address+=4;
    memory->writed(address, s->gopRemainingP);address+=4;
    memory->writed(address, s->gopRemainingB);address+=4;
}
MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR::~MarshalVkVideoEncodeH264GopRemainingFrameInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH264RateControlLayerInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264RateControlLayerInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMinQp = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->minQp, address, 12);address+=12;
    s->useMaxQp = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxQp, address, 12);address+=12;
    s->useMaxFrameSize = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxFrameSize, address, 12);address+=12;
}
void MarshalVkVideoEncodeH264RateControlLayerInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH264RateControlLayerInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMinQp);address+=4;
    memory->memcpy(address, &s->minQp, 12); address+=12;
    memory->writed(address, s->useMaxQp);address+=4;
    memory->memcpy(address, &s->maxQp, 12); address+=12;
    memory->writed(address, s->useMaxFrameSize);address+=4;
    memory->memcpy(address, &s->maxFrameSize, 12); address+=12;
}
MarshalVkVideoEncodeH264RateControlLayerInfoKHR::~MarshalVkVideoEncodeH264RateControlLayerInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeH265CapabilityFlagsKHR)memory->readd(address);address+=4;
    s->maxLevelIdc = (StdVideoH265LevelIdc)memory->readd(address);address+=4;
    s->maxSliceSegmentCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxTiles, address, 8);address+=8;
    s->ctbSizes = (VkVideoEncodeH265CtbSizeFlagsKHR)memory->readd(address);address+=4;
    s->transformBlockSizes = (VkVideoEncodeH265TransformBlockSizeFlagsKHR)memory->readd(address);address+=4;
    s->maxPPictureL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxBPictureL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxL1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxSubLayerCount = (uint32_t)memory->readd(address);address+=4;
    s->expectDyadicTemporalSubLayerPattern = (VkBool32)memory->readd(address);address+=4;
    s->minQp = (int32_t)memory->readd(address);address+=4;
    s->maxQp = (int32_t)memory->readd(address);address+=4;
    s->prefersGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->requiresGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->stdSyntaxFlags = (VkVideoEncodeH265StdFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->maxLevelIdc);address+=4;
    memory->writed(address, s->maxSliceSegmentCount);address+=4;
    memory->memcpy(address, &s->maxTiles, 8); address+=8;
    memory->writed(address, s->ctbSizes);address+=4;
    memory->writed(address, s->transformBlockSizes);address+=4;
    memory->writed(address, s->maxPPictureL0ReferenceCount);address+=4;
    memory->writed(address, s->maxBPictureL0ReferenceCount);address+=4;
    memory->writed(address, s->maxL1ReferenceCount);address+=4;
    memory->writed(address, s->maxSubLayerCount);address+=4;
    memory->writed(address, s->expectDyadicTemporalSubLayerPattern);address+=4;
    memory->writed(address, s->minQp);address+=4;
    memory->writed(address, s->maxQp);address+=4;
    memory->writed(address, s->prefersGopRemainingFrames);address+=4;
    memory->writed(address, s->requiresGopRemainingFrames);address+=4;
    memory->writed(address, s->stdSyntaxFlags);address+=4;
}
MarshalVkVideoEncodeH265CapabilitiesKHR::~MarshalVkVideoEncodeH265CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265QualityLevelPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265QualityLevelPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->preferredRateControlFlags = (VkVideoEncodeH265RateControlFlagsKHR)memory->readd(address);address+=4;
    s->preferredGopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredIdrPeriod = (uint32_t)memory->readd(address);address+=4;
    s->preferredConsecutiveBFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredSubLayerCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->preferredConstantQp, address, 12);address+=12;
    s->preferredMaxL0ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxL1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265QualityLevelPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265QualityLevelPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->preferredRateControlFlags);address+=4;
    memory->writed(address, s->preferredGopFrameCount);address+=4;
    memory->writed(address, s->preferredIdrPeriod);address+=4;
    memory->writed(address, s->preferredConsecutiveBFrameCount);address+=4;
    memory->writed(address, s->preferredSubLayerCount);address+=4;
    memory->memcpy(address, &s->preferredConstantQp, 12); address+=12;
    memory->writed(address, s->preferredMaxL0ReferenceCount);address+=4;
    memory->writed(address, s->preferredMaxL1ReferenceCount);address+=4;
}
MarshalVkVideoEncodeH265QualityLevelPropertiesKHR::~MarshalVkVideoEncodeH265QualityLevelPropertiesKHR() {
    delete s.pNext;
}
void MarshalStdVideoEncodeH265PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265PictureInfo* s) {
    s->flags = (StdVideoEncodeH265PictureInfoFlags)memory->readd(address);address+=4;
    s->pic_type = (StdVideoH265PictureType)memory->readd(address);address+=4;
    s->sps_video_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pps_seq_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->pps_pic_parameter_set_id = (uint8_t)memory->readb(address);address+=1;
    s->short_term_ref_pic_set_idx = (uint8_t)memory->readb(address);address+=1;
    s->PicOrderCntVal = (int32_t)memory->readd(address);address+=4;
    s->TemporalId = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved1, address, 7);address+=7;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRefLists = NULL;
    } else {
        StdVideoEncodeH265ReferenceListsInfo* pRefLists = new StdVideoEncodeH265ReferenceListsInfo();
        MarshalStdVideoEncodeH265ReferenceListsInfo::read(pBoxedInfo, memory, paramAddress, pRefLists);
        s->pRefLists = pRefLists;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pShortTermRefPicSet = NULL;
    } else {
        StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet = new StdVideoH265ShortTermRefPicSet();
        MarshalStdVideoH265ShortTermRefPicSet::read(pBoxedInfo, memory, paramAddress, pShortTermRefPicSet);
        s->pShortTermRefPicSet = pShortTermRefPicSet;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLongTermRefPics = NULL;
    } else {
        StdVideoEncodeH265LongTermRefPics* pLongTermRefPics = new StdVideoEncodeH265LongTermRefPics();
        MarshalStdVideoEncodeH265LongTermRefPics::read(pBoxedInfo, memory, paramAddress, pLongTermRefPics);
        s->pLongTermRefPics = pLongTermRefPics;
    }
}
MarshalStdVideoEncodeH265PictureInfo::~MarshalStdVideoEncodeH265PictureInfo() {
    delete s.pRefLists;
    delete s.pShortTermRefPicSet;
    delete s.pLongTermRefPics;
}
void MarshalStdVideoEncodeH265SliceSegmentHeader::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265SliceSegmentHeader* s) {
    s->flags = (StdVideoEncodeH265SliceSegmentHeaderFlags)memory->readd(address);address+=4;
    s->slice_type = (StdVideoH265SliceType)memory->readd(address);address+=4;
    s->slice_segment_address = (uint32_t)memory->readd(address);address+=4;
    s->collocated_ref_idx = (uint8_t)memory->readb(address);address+=1;
    s->MaxNumMergeCand = (uint8_t)memory->readb(address);address+=1;
    s->slice_cb_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->slice_cr_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->slice_beta_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->slice_tc_offset_div2 = (int8_t)memory->readb(address);address+=1;
    s->slice_act_y_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->slice_act_cb_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->slice_act_cr_qp_offset = (int8_t)memory->readb(address);address+=1;
    s->slice_qp_delta = (int8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint16_t)memory->readw(address);address+=2;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pWeightTable = NULL;
    } else {
        StdVideoEncodeH265WeightTable* pWeightTable = new StdVideoEncodeH265WeightTable();
        MarshalStdVideoEncodeH265WeightTable::read(pBoxedInfo, memory, paramAddress, pWeightTable);
        s->pWeightTable = pWeightTable;
    }
}
MarshalStdVideoEncodeH265SliceSegmentHeader::~MarshalStdVideoEncodeH265SliceSegmentHeader() {
    delete s.pWeightTable;
}
void MarshalStdVideoEncodeH265ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265ReferenceInfo* s) {
    s->flags = (StdVideoEncodeH265ReferenceInfoFlags)memory->readd(address);address+=4;
    s->pic_type = (StdVideoH265PictureType)memory->readd(address);address+=4;
    s->PicOrderCntVal = (int32_t)memory->readd(address);address+=4;
    s->TemporalId = (uint8_t)memory->readb(address);address+=1;
}
void MarshalVkVideoEncodeH265SessionCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMaxLevelIdc = (VkBool32)memory->readd(address);address+=4;
    s->maxLevelIdc = (StdVideoH265LevelIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265SessionCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMaxLevelIdc);address+=4;
    memory->writed(address, s->maxLevelIdc);address+=4;
}
MarshalVkVideoEncodeH265SessionCreateInfoKHR::~MarshalVkVideoEncodeH265SessionCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersAddInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdVPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdVPSs = NULL;
    } else {
        s->pStdVPSs = new StdVideoH265VideoParameterSet[(U32)s->stdVPSCount];
        memory->memcpy((StdVideoH265VideoParameterSet*)s->pStdVPSs, paramAddress, (U32)s->stdVPSCount * sizeof(StdVideoH265VideoParameterSet));
    }
    s->stdSPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSPSs = NULL;
    } else {
        s->pStdSPSs = new StdVideoH265SequenceParameterSet[(U32)s->stdSPSCount];
        memory->memcpy((StdVideoH265SequenceParameterSet*)s->pStdSPSs, paramAddress, (U32)s->stdSPSCount * sizeof(StdVideoH265SequenceParameterSet));
    }
    s->stdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPPSs = NULL;
    } else {
        s->pStdPPSs = new StdVideoH265PictureParameterSet[(U32)s->stdPPSCount];
        memory->memcpy((StdVideoH265PictureParameterSet*)s->pStdPPSs, paramAddress, (U32)s->stdPPSCount * sizeof(StdVideoH265PictureParameterSet));
    }
}
void MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersAddInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdVPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265VideoParameterSet* pStdVPSs = new StdVideoH265VideoParameterSet();
        MarshalStdVideoH265VideoParameterSet::read(pBoxedInfo, memory, paramAddress, pStdVPSs);
        s->pStdVPSs = pStdVPSs;
    }
    memory->writed(address, s->stdSPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265SequenceParameterSet* pStdSPSs = new StdVideoH265SequenceParameterSet();
        MarshalStdVideoH265SequenceParameterSet::read(pBoxedInfo, memory, paramAddress, pStdSPSs);
        s->pStdSPSs = pStdSPSs;
    }
    memory->writed(address, s->stdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoH265PictureParameterSet* pStdPPSs = new StdVideoH265PictureParameterSet();
        MarshalStdVideoH265PictureParameterSet::read(pBoxedInfo, memory, paramAddress, pStdPPSs);
        s->pStdPPSs = pStdPPSs;
    }
}
MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::~MarshalVkVideoEncodeH265SessionParametersAddInfoKHR() {
    delete s.pNext;
    delete[] s.pStdVPSs;
    delete[] s.pStdSPSs;
    delete[] s.pStdPPSs;
}
void MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxStdVPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdSPSCount = (uint32_t)memory->readd(address);address+=4;
    s->maxStdPPSCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pParametersAddInfo = NULL;
    } else {
        VkVideoEncodeH265SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoEncodeH265SessionParametersAddInfoKHR();
        MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
void MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxStdVPSCount);address+=4;
    memory->writed(address, s->maxStdSPSCount);address+=4;
    memory->writed(address, s->maxStdPPSCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoEncodeH265SessionParametersAddInfoKHR* pParametersAddInfo = new VkVideoEncodeH265SessionParametersAddInfoKHR();
        MarshalVkVideoEncodeH265SessionParametersAddInfoKHR::read(pBoxedInfo, memory, paramAddress, pParametersAddInfo);
        s->pParametersAddInfo = pParametersAddInfo;
    }
}
MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR::~MarshalVkVideoEncodeH265SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pParametersAddInfo;
}
void MarshalVkVideoEncodeH265SessionParametersGetInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersGetInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->writeStdVPS = (VkBool32)memory->readd(address);address+=4;
    s->writeStdSPS = (VkBool32)memory->readd(address);address+=4;
    s->writeStdPPS = (VkBool32)memory->readd(address);address+=4;
    s->stdVPSId = (uint32_t)memory->readd(address);address+=4;
    s->stdSPSId = (uint32_t)memory->readd(address);address+=4;
    s->stdPPSId = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265SessionParametersGetInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersGetInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->writeStdVPS);address+=4;
    memory->writed(address, s->writeStdSPS);address+=4;
    memory->writed(address, s->writeStdPPS);address+=4;
    memory->writed(address, s->stdVPSId);address+=4;
    memory->writed(address, s->stdSPSId);address+=4;
    memory->writed(address, s->stdPPSId);address+=4;
}
MarshalVkVideoEncodeH265SessionParametersGetInfoKHR::~MarshalVkVideoEncodeH265SessionParametersGetInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersFeedbackInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hasStdVPSOverrides = (VkBool32)memory->readd(address);address+=4;
    s->hasStdSPSOverrides = (VkBool32)memory->readd(address);address+=4;
    s->hasStdPPSOverrides = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265SessionParametersFeedbackInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hasStdVPSOverrides);address+=4;
    memory->writed(address, s->hasStdSPSOverrides);address+=4;
    memory->writed(address, s->hasStdPPSOverrides);address+=4;
}
MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR::~MarshalVkVideoEncodeH265SessionParametersFeedbackInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->naluSliceSegmentEntryCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNaluSliceSegmentEntries = NULL;
    } else {
        VkVideoEncodeH265NaluSliceSegmentInfoKHR* pNaluSliceSegmentEntries = new VkVideoEncodeH265NaluSliceSegmentInfoKHR[s->naluSliceSegmentEntryCount];
        for (U32 i = 0; i < s->naluSliceSegmentEntryCount; i++) {
            MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::read(pBoxedInfo, memory, paramAddress + i*16, &pNaluSliceSegmentEntries[i]);
        }
        s->pNaluSliceSegmentEntries = pNaluSliceSegmentEntries;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoEncodeH265PictureInfo* pStdPictureInfo = new StdVideoEncodeH265PictureInfo();
        MarshalStdVideoEncodeH265PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
}
void MarshalVkVideoEncodeH265PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->naluSliceSegmentEntryCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkVideoEncodeH265NaluSliceSegmentInfoKHR* pNaluSliceSegmentEntries = new VkVideoEncodeH265NaluSliceSegmentInfoKHR();
        MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::read(pBoxedInfo, memory, paramAddress, pNaluSliceSegmentEntries);
        s->pNaluSliceSegmentEntries = pNaluSliceSegmentEntries;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH265PictureInfo* pStdPictureInfo = new StdVideoEncodeH265PictureInfo();
        MarshalStdVideoEncodeH265PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
}
MarshalVkVideoEncodeH265PictureInfoKHR::~MarshalVkVideoEncodeH265PictureInfoKHR() {
    delete s.pNext;
    delete[] s.pNaluSliceSegmentEntries;
    delete s.pStdPictureInfo;
}
void MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265NaluSliceSegmentInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->constantQp = (int32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSliceSegmentHeader = NULL;
    } else {
        StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader = new StdVideoEncodeH265SliceSegmentHeader();
        MarshalStdVideoEncodeH265SliceSegmentHeader::read(pBoxedInfo, memory, paramAddress, pStdSliceSegmentHeader);
        s->pStdSliceSegmentHeader = pStdSliceSegmentHeader;
    }
}
void MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265NaluSliceSegmentInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->constantQp);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader = new StdVideoEncodeH265SliceSegmentHeader();
        MarshalStdVideoEncodeH265SliceSegmentHeader::read(pBoxedInfo, memory, paramAddress, pStdSliceSegmentHeader);
        s->pStdSliceSegmentHeader = pStdSliceSegmentHeader;
    }
}
MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR::~MarshalVkVideoEncodeH265NaluSliceSegmentInfoKHR() {
    delete s.pNext;
    delete s.pStdSliceSegmentHeader;
}
void MarshalVkVideoEncodeH265RateControlInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265RateControlInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeH265RateControlFlagsKHR)memory->readd(address);address+=4;
    s->gopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->idrPeriod = (uint32_t)memory->readd(address);address+=4;
    s->consecutiveBFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->subLayerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265RateControlInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265RateControlInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->gopFrameCount);address+=4;
    memory->writed(address, s->idrPeriod);address+=4;
    memory->writed(address, s->consecutiveBFrameCount);address+=4;
    memory->writed(address, s->subLayerCount);address+=4;
}
MarshalVkVideoEncodeH265RateControlInfoKHR::~MarshalVkVideoEncodeH265RateControlInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265GopRemainingFrameInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->gopRemainingI = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingP = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingB = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265GopRemainingFrameInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useGopRemainingFrames);address+=4;
    memory->writed(address, s->gopRemainingI);address+=4;
    memory->writed(address, s->gopRemainingP);address+=4;
    memory->writed(address, s->gopRemainingB);address+=4;
}
MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR::~MarshalVkVideoEncodeH265GopRemainingFrameInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265RateControlLayerInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265RateControlLayerInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMinQp = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->minQp, address, 12);address+=12;
    s->useMaxQp = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxQp, address, 12);address+=12;
    s->useMaxFrameSize = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxFrameSize, address, 12);address+=12;
}
void MarshalVkVideoEncodeH265RateControlLayerInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265RateControlLayerInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMinQp);address+=4;
    memory->memcpy(address, &s->minQp, 12); address+=12;
    memory->writed(address, s->useMaxQp);address+=4;
    memory->memcpy(address, &s->maxQp, 12); address+=12;
    memory->writed(address, s->useMaxFrameSize);address+=4;
    memory->memcpy(address, &s->maxFrameSize, 12); address+=12;
}
MarshalVkVideoEncodeH265RateControlLayerInfoKHR::~MarshalVkVideoEncodeH265RateControlLayerInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfileIdc = (StdVideoH265ProfileIdc)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeH265ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfileIdc);address+=4;
}
MarshalVkVideoEncodeH265ProfileInfoKHR::~MarshalVkVideoEncodeH265ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeH265DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeH265ReferenceInfo();
        MarshalStdVideoEncodeH265ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoEncodeH265DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeH265DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeH265ReferenceInfo();
        MarshalStdVideoEncodeH265ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoEncodeH265DpbSlotInfoKHR::~MarshalVkVideoEncodeH265DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalVkVideoEncodeAV1CapabilitiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1CapabilitiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeAV1CapabilityFlagsKHR)memory->readd(address);address+=4;
    s->maxLevel = (StdVideoAV1Level)memory->readd(address);address+=4;
    memory->memcpy(&s->codedPictureAlignment, address, 8);address+=8;
    memory->memcpy(&s->maxTiles, address, 8);address+=8;
    memory->memcpy(&s->minTileSize, address, 8);address+=8;
    memory->memcpy(&s->maxTileSize, address, 8);address+=8;
    s->superblockSizes = (VkVideoEncodeAV1SuperblockSizeFlagsKHR)memory->readd(address);address+=4;
    s->maxSingleReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->singleReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
    s->maxUnidirectionalCompoundReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxUnidirectionalCompoundGroup1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->unidirectionalCompoundReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
    s->maxBidirectionalCompoundReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxBidirectionalCompoundGroup1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->maxBidirectionalCompoundGroup2ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->bidirectionalCompoundReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
    s->maxTemporalLayerCount = (uint32_t)memory->readd(address);address+=4;
    s->maxSpatialLayerCount = (uint32_t)memory->readd(address);address+=4;
    s->maxOperatingPoints = (uint32_t)memory->readd(address);address+=4;
    s->minQIndex = (uint32_t)memory->readd(address);address+=4;
    s->maxQIndex = (uint32_t)memory->readd(address);address+=4;
    s->prefersGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->requiresGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->stdSyntaxFlags = (VkVideoEncodeAV1StdFlagsKHR)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1CapabilitiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1CapabilitiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->maxLevel);address+=4;
    memory->memcpy(address, &s->codedPictureAlignment, 8); address+=8;
    memory->memcpy(address, &s->maxTiles, 8); address+=8;
    memory->memcpy(address, &s->minTileSize, 8); address+=8;
    memory->memcpy(address, &s->maxTileSize, 8); address+=8;
    memory->writed(address, s->superblockSizes);address+=4;
    memory->writed(address, s->maxSingleReferenceCount);address+=4;
    memory->writed(address, s->singleReferenceNameMask);address+=4;
    memory->writed(address, s->maxUnidirectionalCompoundReferenceCount);address+=4;
    memory->writed(address, s->maxUnidirectionalCompoundGroup1ReferenceCount);address+=4;
    memory->writed(address, s->unidirectionalCompoundReferenceNameMask);address+=4;
    memory->writed(address, s->maxBidirectionalCompoundReferenceCount);address+=4;
    memory->writed(address, s->maxBidirectionalCompoundGroup1ReferenceCount);address+=4;
    memory->writed(address, s->maxBidirectionalCompoundGroup2ReferenceCount);address+=4;
    memory->writed(address, s->bidirectionalCompoundReferenceNameMask);address+=4;
    memory->writed(address, s->maxTemporalLayerCount);address+=4;
    memory->writed(address, s->maxSpatialLayerCount);address+=4;
    memory->writed(address, s->maxOperatingPoints);address+=4;
    memory->writed(address, s->minQIndex);address+=4;
    memory->writed(address, s->maxQIndex);address+=4;
    memory->writed(address, s->prefersGopRemainingFrames);address+=4;
    memory->writed(address, s->requiresGopRemainingFrames);address+=4;
    memory->writed(address, s->stdSyntaxFlags);address+=4;
}
MarshalVkVideoEncodeAV1CapabilitiesKHR::~MarshalVkVideoEncodeAV1CapabilitiesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1QualityLevelPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->preferredRateControlFlags = (VkVideoEncodeAV1RateControlFlagsKHR)memory->readd(address);address+=4;
    s->preferredGopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredKeyFramePeriod = (uint32_t)memory->readd(address);address+=4;
    s->preferredConsecutiveBipredictiveFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredTemporalLayerCount = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->preferredConstantQIndex, address, 12);address+=12;
    s->preferredMaxSingleReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredSingleReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxUnidirectionalCompoundReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxUnidirectionalCompoundGroup1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredUnidirectionalCompoundReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxBidirectionalCompoundReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxBidirectionalCompoundGroup1ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredMaxBidirectionalCompoundGroup2ReferenceCount = (uint32_t)memory->readd(address);address+=4;
    s->preferredBidirectionalCompoundReferenceNameMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1QualityLevelPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->preferredRateControlFlags);address+=4;
    memory->writed(address, s->preferredGopFrameCount);address+=4;
    memory->writed(address, s->preferredKeyFramePeriod);address+=4;
    memory->writed(address, s->preferredConsecutiveBipredictiveFrameCount);address+=4;
    memory->writed(address, s->preferredTemporalLayerCount);address+=4;
    memory->memcpy(address, &s->preferredConstantQIndex, 12); address+=12;
    memory->writed(address, s->preferredMaxSingleReferenceCount);address+=4;
    memory->writed(address, s->preferredSingleReferenceNameMask);address+=4;
    memory->writed(address, s->preferredMaxUnidirectionalCompoundReferenceCount);address+=4;
    memory->writed(address, s->preferredMaxUnidirectionalCompoundGroup1ReferenceCount);address+=4;
    memory->writed(address, s->preferredUnidirectionalCompoundReferenceNameMask);address+=4;
    memory->writed(address, s->preferredMaxBidirectionalCompoundReferenceCount);address+=4;
    memory->writed(address, s->preferredMaxBidirectionalCompoundGroup1ReferenceCount);address+=4;
    memory->writed(address, s->preferredMaxBidirectionalCompoundGroup2ReferenceCount);address+=4;
    memory->writed(address, s->preferredBidirectionalCompoundReferenceNameMask);address+=4;
}
MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR::~MarshalVkVideoEncodeAV1QualityLevelPropertiesKHR() {
    delete s.pNext;
}
void MarshalStdVideoEncodeAV1ExtensionHeader::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeAV1ExtensionHeader* s) {
    s->temporal_id = (uint8_t)memory->readb(address);address+=1;
    s->spatial_id = (uint8_t)memory->readb(address);address+=1;
}
void MarshalStdVideoEncodeAV1DecoderModelInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeAV1DecoderModelInfo* s) {
    s->buffer_delay_length_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->buffer_removal_time_length_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->frame_presentation_time_length_minus_1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->num_units_in_decoding_tick = (uint32_t)memory->readd(address);address+=4;
}
void MarshalStdVideoEncodeAV1OperatingPointInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeAV1OperatingPointInfo* s) {
    s->flags = (StdVideoEncodeAV1OperatingPointInfoFlags)memory->readd(address);address+=4;
    s->operating_point_idc = (uint16_t)memory->readw(address);address+=2;
    s->seq_level_idx = (uint8_t)memory->readb(address);address+=1;
    s->seq_tier = (uint8_t)memory->readb(address);address+=1;
    s->decoder_buffer_delay = (uint32_t)memory->readd(address);address+=4;
    s->encoder_buffer_delay = (uint32_t)memory->readd(address);address+=4;
    s->initial_display_delay_minus_1 = (uint8_t)memory->readb(address);address+=1;
}
void MarshalStdVideoEncodeAV1PictureInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeAV1PictureInfo* s) {
    s->flags = (StdVideoEncodeAV1PictureInfoFlags)memory->readd(address);address+=4;
    s->frame_type = (StdVideoAV1FrameType)memory->readd(address);address+=4;
    s->frame_presentation_time = (uint32_t)memory->readd(address);address+=4;
    s->current_frame_id = (uint32_t)memory->readd(address);address+=4;
    s->order_hint = (uint8_t)memory->readb(address);address+=1;
    s->primary_ref_frame = (uint8_t)memory->readb(address);address+=1;
    s->refresh_frame_flags = (uint8_t)memory->readb(address);address+=1;
    s->coded_denom = (uint8_t)memory->readb(address);address+=1;
    s->render_width_minus_1 = (uint16_t)memory->readw(address);address+=2;
    s->render_height_minus_1 = (uint16_t)memory->readw(address);address+=2;
    s->interpolation_filter = (StdVideoAV1InterpolationFilter)memory->readd(address);address+=4;
    s->TxMode = (StdVideoAV1TxMode)memory->readd(address);address+=4;
    s->delta_q_res = (uint8_t)memory->readb(address);address+=1;
    s->delta_lf_res = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->ref_order_hint, address, 8);address+=8;
    memory->memcpy(&s->ref_frame_idx, address, 7);address+=7;
    memory->memcpy(&s->reserved1, address, 3);address+=3;
    memory->memcpy(&s->delta_frame_id_minus_1, address, 28);address+=28;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTileInfo = NULL;
    } else {
        StdVideoAV1TileInfo* pTileInfo = new StdVideoAV1TileInfo();
        MarshalStdVideoAV1TileInfo::read(pBoxedInfo, memory, paramAddress, pTileInfo);
        s->pTileInfo = pTileInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pQuantization = NULL;
    } else {
        StdVideoAV1Quantization* pQuantization = new StdVideoAV1Quantization();
        MarshalStdVideoAV1Quantization::read(pBoxedInfo, memory, paramAddress, pQuantization);
        s->pQuantization = pQuantization;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSegmentation = NULL;
    } else {
        StdVideoAV1Segmentation* pSegmentation = new StdVideoAV1Segmentation();
        MarshalStdVideoAV1Segmentation::read(pBoxedInfo, memory, paramAddress, pSegmentation);
        s->pSegmentation = pSegmentation;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLoopFilter = NULL;
    } else {
        StdVideoAV1LoopFilter* pLoopFilter = new StdVideoAV1LoopFilter();
        MarshalStdVideoAV1LoopFilter::read(pBoxedInfo, memory, paramAddress, pLoopFilter);
        s->pLoopFilter = pLoopFilter;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCDEF = NULL;
    } else {
        StdVideoAV1CDEF* pCDEF = new StdVideoAV1CDEF();
        MarshalStdVideoAV1CDEF::read(pBoxedInfo, memory, paramAddress, pCDEF);
        s->pCDEF = pCDEF;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pLoopRestoration = NULL;
    } else {
        StdVideoAV1LoopRestoration* pLoopRestoration = new StdVideoAV1LoopRestoration();
        MarshalStdVideoAV1LoopRestoration::read(pBoxedInfo, memory, paramAddress, pLoopRestoration);
        s->pLoopRestoration = pLoopRestoration;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pGlobalMotion = NULL;
    } else {
        StdVideoAV1GlobalMotion* pGlobalMotion = new StdVideoAV1GlobalMotion();
        MarshalStdVideoAV1GlobalMotion::read(pBoxedInfo, memory, paramAddress, pGlobalMotion);
        s->pGlobalMotion = pGlobalMotion;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pExtensionHeader = NULL;
    } else {
        StdVideoEncodeAV1ExtensionHeader* pExtensionHeader = new StdVideoEncodeAV1ExtensionHeader();
        MarshalStdVideoEncodeAV1ExtensionHeader::read(pBoxedInfo, memory, paramAddress, pExtensionHeader);
        s->pExtensionHeader = pExtensionHeader;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferRemovalTimes = NULL;
    } else {
        s->pBufferRemovalTimes = new uint32_t[1];
        memory->memcpy((uint32_t*)s->pBufferRemovalTimes, paramAddress, 1);
    }
}
MarshalStdVideoEncodeAV1PictureInfo::~MarshalStdVideoEncodeAV1PictureInfo() {
    delete s.pTileInfo;
    delete s.pQuantization;
    delete s.pSegmentation;
    delete s.pLoopFilter;
    delete s.pCDEF;
    delete s.pLoopRestoration;
    delete s.pGlobalMotion;
    delete s.pExtensionHeader;
    delete[] s.pBufferRemovalTimes;
}
void MarshalStdVideoEncodeAV1ReferenceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeAV1ReferenceInfo* s) {
    s->flags = (StdVideoEncodeAV1ReferenceInfoFlags)memory->readd(address);address+=4;
    s->RefFrameId = (uint32_t)memory->readd(address);address+=4;
    s->frame_type = (StdVideoAV1FrameType)memory->readd(address);address+=4;
    s->OrderHint = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved1, address, 3);address+=3;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pExtensionHeader = NULL;
    } else {
        StdVideoEncodeAV1ExtensionHeader* pExtensionHeader = new StdVideoEncodeAV1ExtensionHeader();
        MarshalStdVideoEncodeAV1ExtensionHeader::read(pBoxedInfo, memory, paramAddress, pExtensionHeader);
        s->pExtensionHeader = pExtensionHeader;
    }
}
MarshalStdVideoEncodeAV1ReferenceInfo::~MarshalStdVideoEncodeAV1ReferenceInfo() {
    delete s.pExtensionHeader;
}
void MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->videoEncodeAV1 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->videoEncodeAV1);address+=4;
}
MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR::~MarshalVkPhysicalDeviceVideoEncodeAV1FeaturesKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1SessionCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1SessionCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMaxLevel = (VkBool32)memory->readd(address);address+=4;
    s->maxLevel = (StdVideoAV1Level)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1SessionCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1SessionCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMaxLevel);address+=4;
    memory->writed(address, s->maxLevel);address+=4;
}
MarshalVkVideoEncodeAV1SessionCreateInfoKHR::~MarshalVkVideoEncodeAV1SessionCreateInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1SessionParametersCreateInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdSequenceHeader = NULL;
    } else {
        StdVideoAV1SequenceHeader* pStdSequenceHeader = new StdVideoAV1SequenceHeader();
        MarshalStdVideoAV1SequenceHeader::read(pBoxedInfo, memory, paramAddress, pStdSequenceHeader);
        s->pStdSequenceHeader = pStdSequenceHeader;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdDecoderModelInfo = NULL;
    } else {
        StdVideoEncodeAV1DecoderModelInfo* pStdDecoderModelInfo = new StdVideoEncodeAV1DecoderModelInfo();
        MarshalStdVideoEncodeAV1DecoderModelInfo::read(pBoxedInfo, memory, paramAddress, pStdDecoderModelInfo);
        s->pStdDecoderModelInfo = pStdDecoderModelInfo;
    }
    s->stdOperatingPointCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdOperatingPoints = NULL;
    } else {
        s->pStdOperatingPoints = new StdVideoEncodeAV1OperatingPointInfo[(U32)s->stdOperatingPointCount];
        memory->memcpy((StdVideoEncodeAV1OperatingPointInfo*)s->pStdOperatingPoints, paramAddress, (U32)s->stdOperatingPointCount * sizeof(StdVideoEncodeAV1OperatingPointInfo));
    }
}
void MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1SessionParametersCreateInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoAV1SequenceHeader* pStdSequenceHeader = new StdVideoAV1SequenceHeader();
        MarshalStdVideoAV1SequenceHeader::read(pBoxedInfo, memory, paramAddress, pStdSequenceHeader);
        s->pStdSequenceHeader = pStdSequenceHeader;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeAV1DecoderModelInfo* pStdDecoderModelInfo = new StdVideoEncodeAV1DecoderModelInfo();
        MarshalStdVideoEncodeAV1DecoderModelInfo::read(pBoxedInfo, memory, paramAddress, pStdDecoderModelInfo);
        s->pStdDecoderModelInfo = pStdDecoderModelInfo;
    }
    memory->writed(address, s->stdOperatingPointCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeAV1OperatingPointInfo* pStdOperatingPoints = new StdVideoEncodeAV1OperatingPointInfo();
        MarshalStdVideoEncodeAV1OperatingPointInfo::read(pBoxedInfo, memory, paramAddress, pStdOperatingPoints);
        s->pStdOperatingPoints = pStdOperatingPoints;
    }
}
MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR::~MarshalVkVideoEncodeAV1SessionParametersCreateInfoKHR() {
    delete s.pNext;
    delete s.pStdSequenceHeader;
    delete s.pStdDecoderModelInfo;
    delete[] s.pStdOperatingPoints;
}
void MarshalVkVideoEncodeAV1DpbSlotInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1DpbSlotInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdReferenceInfo = NULL;
    } else {
        StdVideoEncodeAV1ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeAV1ReferenceInfo();
        MarshalStdVideoEncodeAV1ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
void MarshalVkVideoEncodeAV1DpbSlotInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1DpbSlotInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeAV1ReferenceInfo* pStdReferenceInfo = new StdVideoEncodeAV1ReferenceInfo();
        MarshalStdVideoEncodeAV1ReferenceInfo::read(pBoxedInfo, memory, paramAddress, pStdReferenceInfo);
        s->pStdReferenceInfo = pStdReferenceInfo;
    }
}
MarshalVkVideoEncodeAV1DpbSlotInfoKHR::~MarshalVkVideoEncodeAV1DpbSlotInfoKHR() {
    delete s.pNext;
    delete s.pStdReferenceInfo;
}
void MarshalVkVideoEncodeAV1PictureInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1PictureInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->predictionMode = (VkVideoEncodeAV1PredictionModeKHR)memory->readd(address);address+=4;
    s->rateControlGroup = (VkVideoEncodeAV1RateControlGroupKHR)memory->readd(address);address+=4;
    s->constantQIndex = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStdPictureInfo = NULL;
    } else {
        StdVideoEncodeAV1PictureInfo* pStdPictureInfo = new StdVideoEncodeAV1PictureInfo();
        MarshalStdVideoEncodeAV1PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->memcpy(&s->referenceNameSlotIndices, address, 28);address+=28;
    s->primaryReferenceCdfOnly = (VkBool32)memory->readd(address);address+=4;
    s->generateObuExtensionHeader = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1PictureInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1PictureInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->predictionMode);address+=4;
    memory->writed(address, s->rateControlGroup);address+=4;
    memory->writed(address, s->constantQIndex);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        StdVideoEncodeAV1PictureInfo* pStdPictureInfo = new StdVideoEncodeAV1PictureInfo();
        MarshalStdVideoEncodeAV1PictureInfo::read(pBoxedInfo, memory, paramAddress, pStdPictureInfo);
        s->pStdPictureInfo = pStdPictureInfo;
    }
    memory->memcpy(address, s->referenceNameSlotIndices, 28); address+=28;
    memory->writed(address, s->primaryReferenceCdfOnly);address+=4;
    memory->writed(address, s->generateObuExtensionHeader);address+=4;
}
MarshalVkVideoEncodeAV1PictureInfoKHR::~MarshalVkVideoEncodeAV1PictureInfoKHR() {
    delete s.pNext;
    delete s.pStdPictureInfo;
}
void MarshalVkVideoEncodeAV1ProfileInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1ProfileInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stdProfile = (StdVideoAV1Profile)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1ProfileInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1ProfileInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stdProfile);address+=4;
}
MarshalVkVideoEncodeAV1ProfileInfoKHR::~MarshalVkVideoEncodeAV1ProfileInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1RateControlInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1RateControlInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkVideoEncodeAV1RateControlFlagsKHR)memory->readd(address);address+=4;
    s->gopFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->keyFramePeriod = (uint32_t)memory->readd(address);address+=4;
    s->consecutiveBipredictiveFrameCount = (uint32_t)memory->readd(address);address+=4;
    s->temporalLayerCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1RateControlInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1RateControlInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->gopFrameCount);address+=4;
    memory->writed(address, s->keyFramePeriod);address+=4;
    memory->writed(address, s->consecutiveBipredictiveFrameCount);address+=4;
    memory->writed(address, s->temporalLayerCount);address+=4;
}
MarshalVkVideoEncodeAV1RateControlInfoKHR::~MarshalVkVideoEncodeAV1RateControlInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1GopRemainingFrameInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useGopRemainingFrames = (VkBool32)memory->readd(address);address+=4;
    s->gopRemainingIntra = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingPredictive = (uint32_t)memory->readd(address);address+=4;
    s->gopRemainingBipredictive = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1GopRemainingFrameInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useGopRemainingFrames);address+=4;
    memory->writed(address, s->gopRemainingIntra);address+=4;
    memory->writed(address, s->gopRemainingPredictive);address+=4;
    memory->writed(address, s->gopRemainingBipredictive);address+=4;
}
MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR::~MarshalVkVideoEncodeAV1GopRemainingFrameInfoKHR() {
    delete s.pNext;
}
void MarshalVkVideoEncodeAV1RateControlLayerInfoKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1RateControlLayerInfoKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->useMinQIndex = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->minQIndex, address, 12);address+=12;
    s->useMaxQIndex = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxQIndex, address, 12);address+=12;
    s->useMaxFrameSize = (VkBool32)memory->readd(address);address+=4;
    memory->memcpy(&s->maxFrameSize, address, 12);address+=12;
}
void MarshalVkVideoEncodeAV1RateControlLayerInfoKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkVideoEncodeAV1RateControlLayerInfoKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->useMinQIndex);address+=4;
    memory->memcpy(address, &s->minQIndex, 12); address+=12;
    memory->writed(address, s->useMaxQIndex);address+=4;
    memory->memcpy(address, &s->maxQIndex, 12); address+=12;
    memory->writed(address, s->useMaxFrameSize);address+=4;
    memory->memcpy(address, &s->maxFrameSize, 12); address+=12;
}
MarshalVkVideoEncodeAV1RateControlLayerInfoKHR::~MarshalVkVideoEncodeAV1RateControlLayerInfoKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInheritedViewportScissorFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->inheritedViewportScissor2D = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceInheritedViewportScissorFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->inheritedViewportScissor2D);address+=4;
}
MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV::~MarshalVkPhysicalDeviceInheritedViewportScissorFeaturesNV() {
    delete s.pNext;
}
void MarshalVkCommandBufferInheritanceViewportScissorInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceViewportScissorInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->viewportScissor2D = (VkBool32)memory->readd(address);address+=4;
    s->viewportDepthCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pViewportDepths = NULL;
    } else {
        VkViewport* pViewportDepths = new VkViewport();
        MarshalVkViewport::read(pBoxedInfo, memory, paramAddress, pViewportDepths);
        s->pViewportDepths = pViewportDepths;
    }
}
void MarshalVkCommandBufferInheritanceViewportScissorInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceViewportScissorInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->viewportScissor2D);address+=4;
    memory->writed(address, s->viewportDepthCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkViewport* pViewportDepths = new VkViewport();
        MarshalVkViewport::read(pBoxedInfo, memory, paramAddress, pViewportDepths);
        s->pViewportDepths = pViewportDepths;
    }
}
MarshalVkCommandBufferInheritanceViewportScissorInfoNV::~MarshalVkCommandBufferInheritanceViewportScissorInfoNV() {
    delete s.pNext;
    delete s.pViewportDepths;
}
void MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->ycbcr2plane444Formats = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->ycbcr2plane444Formats);address+=4;
}
MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::~MarshalVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->provokingVertexLast = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackPreservesProvokingVertex = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->provokingVertexLast);address+=4;
    memory->writed(address, s->transformFeedbackPreservesProvokingVertex);address+=4;
}
MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT::~MarshalVkPhysicalDeviceProvokingVertexFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->provokingVertexModePerPipeline = (VkBool32)memory->readd(address);address+=4;
    s->transformFeedbackPreservesTriangleFanProvokingVertex = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceProvokingVertexPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->provokingVertexModePerPipeline);address+=4;
    memory->writed(address, s->transformFeedbackPreservesTriangleFanProvokingVertex);address+=4;
}
MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT::~MarshalVkPhysicalDeviceProvokingVertexPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->provokingVertexMode = (VkProvokingVertexModeEXT)memory->readd(address);address+=4;
}
void MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->provokingVertexMode);address+=4;
}
MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT::~MarshalVkPipelineRasterizationProvokingVertexStateCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkCuModuleCreateInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuModuleCreateInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkCuModuleCreateInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuModuleCreateInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkCuModuleCreateInfoNVX::~MarshalVkCuModuleCreateInfoNVX() {
    delete s.pNext;
    delete[] s.pData;
}
void MarshalVkCuModuleTexturingModeCreateInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuModuleTexturingModeCreateInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->use64bitTexturing = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkCuModuleTexturingModeCreateInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuModuleTexturingModeCreateInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->use64bitTexturing);address+=4;
}
MarshalVkCuModuleTexturingModeCreateInfoNVX::~MarshalVkCuModuleTexturingModeCreateInfoNVX() {
    delete s.pNext;
}
void MarshalVkCuFunctionCreateInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuFunctionCreateInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->module = (VkCuModuleNVX)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen);
    }
}
void MarshalVkCuFunctionCreateInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuFunctionCreateInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->module);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkCuFunctionCreateInfoNVX::~MarshalVkCuFunctionCreateInfoNVX() {
    delete s.pNext;
    delete[] s.pName;
}
void MarshalVkCuLaunchInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuLaunchInfoNVX* s) {
    kpanic("MarshalVkCuLaunchInfoNVX::read");
}
void MarshalVkCuLaunchInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCuLaunchInfoNVX* s) {
    kpanic("MarshalVkCuLaunchInfoNVX::write");
}
void MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorBuffer = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBufferCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBufferImageLayoutIgnored = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBufferPushDescriptors = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->descriptorBuffer);address+=4;
    memory->writed(address, s->descriptorBufferCaptureReplay);address+=4;
    memory->writed(address, s->descriptorBufferImageLayoutIgnored);address+=4;
    memory->writed(address, s->descriptorBufferPushDescriptors);address+=4;
}
MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT::~MarshalVkPhysicalDeviceDescriptorBufferFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->combinedImageSamplerDescriptorSingleArray = (VkBool32)memory->readd(address);address+=4;
    s->bufferlessPushDescriptors = (VkBool32)memory->readd(address);address+=4;
    s->allowSamplerImageViewPostSubmitCreation = (VkBool32)memory->readd(address);address+=4;
    s->descriptorBufferOffsetAlignment = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxDescriptorBufferBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxResourceDescriptorBufferBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxSamplerDescriptorBufferBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxEmbeddedImmutableSamplerBindings = (uint32_t)memory->readd(address);address+=4;
    s->maxEmbeddedImmutableSamplers = (uint32_t)memory->readd(address);address+=4;
    s->bufferCaptureReplayDescriptorDataSize = (size_t)memory->readd(address);address+=4;
    s->imageCaptureReplayDescriptorDataSize = (size_t)memory->readd(address);address+=4;
    s->imageViewCaptureReplayDescriptorDataSize = (size_t)memory->readd(address);address+=4;
    s->samplerCaptureReplayDescriptorDataSize = (size_t)memory->readd(address);address+=4;
    s->accelerationStructureCaptureReplayDescriptorDataSize = (size_t)memory->readd(address);address+=4;
    s->samplerDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->combinedImageSamplerDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->sampledImageDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->storageImageDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->uniformTexelBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->robustUniformTexelBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->storageTexelBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->robustStorageTexelBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->uniformBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->robustUniformBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->storageBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->robustStorageBufferDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->inputAttachmentDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->accelerationStructureDescriptorSize = (size_t)memory->readd(address);address+=4;
    s->maxSamplerDescriptorBufferRange = (VkDeviceSize)memory->readq(address);address+=8;
    s->maxResourceDescriptorBufferRange = (VkDeviceSize)memory->readq(address);address+=8;
    s->samplerDescriptorBufferAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->resourceDescriptorBufferAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->descriptorBufferAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->combinedImageSamplerDescriptorSingleArray);address+=4;
    memory->writed(address, s->bufferlessPushDescriptors);address+=4;
    memory->writed(address, s->allowSamplerImageViewPostSubmitCreation);address+=4;
    memory->writeq(address, s->descriptorBufferOffsetAlignment);address+=8;
    memory->writed(address, s->maxDescriptorBufferBindings);address+=4;
    memory->writed(address, s->maxResourceDescriptorBufferBindings);address+=4;
    memory->writed(address, s->maxSamplerDescriptorBufferBindings);address+=4;
    memory->writed(address, s->maxEmbeddedImmutableSamplerBindings);address+=4;
    memory->writed(address, s->maxEmbeddedImmutableSamplers);address+=4;
    memory->writed(address, (U32)s->bufferCaptureReplayDescriptorDataSize);address+=4;
    memory->writed(address, (U32)s->imageCaptureReplayDescriptorDataSize);address+=4;
    memory->writed(address, (U32)s->imageViewCaptureReplayDescriptorDataSize);address+=4;
    memory->writed(address, (U32)s->samplerCaptureReplayDescriptorDataSize);address+=4;
    memory->writed(address, (U32)s->accelerationStructureCaptureReplayDescriptorDataSize);address+=4;
    memory->writed(address, (U32)s->samplerDescriptorSize);address+=4;
    memory->writed(address, (U32)s->combinedImageSamplerDescriptorSize);address+=4;
    memory->writed(address, (U32)s->sampledImageDescriptorSize);address+=4;
    memory->writed(address, (U32)s->storageImageDescriptorSize);address+=4;
    memory->writed(address, (U32)s->uniformTexelBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->robustUniformTexelBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->storageTexelBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->robustStorageTexelBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->uniformBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->robustUniformBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->storageBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->robustStorageBufferDescriptorSize);address+=4;
    memory->writed(address, (U32)s->inputAttachmentDescriptorSize);address+=4;
    memory->writed(address, (U32)s->accelerationStructureDescriptorSize);address+=4;
    memory->writeq(address, s->maxSamplerDescriptorBufferRange);address+=8;
    memory->writeq(address, s->maxResourceDescriptorBufferRange);address+=8;
    memory->writeq(address, s->samplerDescriptorBufferAddressSpaceSize);address+=8;
    memory->writeq(address, s->resourceDescriptorBufferAddressSpaceSize);address+=8;
    memory->writeq(address, s->descriptorBufferAddressSpaceSize);address+=8;
}
MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT::~MarshalVkPhysicalDeviceDescriptorBufferPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->combinedImageSamplerDensityMapDescriptorSize = (size_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->combinedImageSamplerDensityMapDescriptorSize);address+=4;
}
MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::~MarshalVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkDescriptorAddressInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorAddressInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->address = (VkDeviceAddress)memory->readq(address);address+=8;
    s->range = (VkDeviceSize)memory->readq(address);address+=8;
    s->format = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkDescriptorAddressInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorAddressInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->address);address+=8;
    memory->writeq(address, s->range);address+=8;
    memory->writed(address, s->format);address+=4;
}
MarshalVkDescriptorAddressInfoEXT::~MarshalVkDescriptorAddressInfoEXT() {
    delete s.pNext;
}
void MarshalVkDescriptorBufferBindingInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorBufferBindingInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->address = (VkDeviceAddress)memory->readq(address);address+=8;
    s->usage = (VkBufferUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkDescriptorBufferBindingInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorBufferBindingInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->address);address+=8;
    memory->writed(address, s->usage);address+=4;
}
MarshalVkDescriptorBufferBindingInfoEXT::~MarshalVkDescriptorBufferBindingInfoEXT() {
    delete s.pNext;
}
void MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT::~MarshalVkDescriptorBufferBindingPushDescriptorBufferHandleEXT() {
    delete s.pNext;
}
void MarshalVkDescriptorGetInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorGetInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->type = (VkDescriptorType)memory->readd(address);address+=4;
    memory->memcpy(&s->data, address, 28);address+=28;
}
void MarshalVkDescriptorGetInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorGetInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->type);address+=4;
    memory->memcpy(address, &s->data, 28); address+=28;
}
MarshalVkDescriptorGetInfoEXT::~MarshalVkDescriptorGetInfoEXT() {
    delete s.pNext;
}
void MarshalVkBufferCaptureDescriptorDataInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCaptureDescriptorDataInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
}
void MarshalVkBufferCaptureDescriptorDataInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBufferCaptureDescriptorDataInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->buffer);address+=8;
}
MarshalVkBufferCaptureDescriptorDataInfoEXT::~MarshalVkBufferCaptureDescriptorDataInfoEXT() {
    delete s.pNext;
}
void MarshalVkImageCaptureDescriptorDataInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCaptureDescriptorDataInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->image = (VkImage)memory->readq(address);address+=8;
}
void MarshalVkImageCaptureDescriptorDataInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCaptureDescriptorDataInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->image);address+=8;
}
MarshalVkImageCaptureDescriptorDataInfoEXT::~MarshalVkImageCaptureDescriptorDataInfoEXT() {
    delete s.pNext;
}
void MarshalVkImageViewCaptureDescriptorDataInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewCaptureDescriptorDataInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageView = (VkImageView)memory->readq(address);address+=8;
}
void MarshalVkImageViewCaptureDescriptorDataInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewCaptureDescriptorDataInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->imageView);address+=8;
}
MarshalVkImageViewCaptureDescriptorDataInfoEXT::~MarshalVkImageViewCaptureDescriptorDataInfoEXT() {
    delete s.pNext;
}
void MarshalVkSamplerCaptureDescriptorDataInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCaptureDescriptorDataInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->sampler = (VkSampler)memory->readq(address);address+=8;
}
void MarshalVkSamplerCaptureDescriptorDataInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCaptureDescriptorDataInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->sampler);address+=8;
}
MarshalVkSamplerCaptureDescriptorDataInfoEXT::~MarshalVkSamplerCaptureDescriptorDataInfoEXT() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCaptureDescriptorDataInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->accelerationStructure = (VkAccelerationStructureKHR)memory->readq(address);address+=8;
    s->accelerationStructureNV = (VkAccelerationStructureNV)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureCaptureDescriptorDataInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->accelerationStructure);address+=8;
    memory->writeq(address, (U64)s->accelerationStructureNV);address+=8;
}
MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT::~MarshalVkAccelerationStructureCaptureDescriptorDataInfoEXT() {
    delete s.pNext;
}
void MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpaqueCaptureDescriptorDataCreateInfoEXT* s) {
    kpanic("MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::read");
}
void MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpaqueCaptureDescriptorDataCreateInfoEXT* s) {
    kpanic("MarshalVkOpaqueCaptureDescriptorDataCreateInfoEXT::write");
}
void MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerDotProductFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderIntegerDotProduct = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerDotProductFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderIntegerDotProduct);address+=4;
}
MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures::~MarshalVkPhysicalDeviceShaderIntegerDotProductFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderIntegerDotProductProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerDotProductProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->integerDotProduct8BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct8BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct8BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct4x8BitPackedMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct16BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct32BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProduct64BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitSignedAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderIntegerDotProductProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderIntegerDotProductProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->integerDotProduct8BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct8BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct8BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct4x8BitPackedMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct16BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct32BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProduct64BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitSignedAccelerated);address+=4;
    memory->writed(address, s->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);address+=4;
}
MarshalVkPhysicalDeviceShaderIntegerDotProductProperties::~MarshalVkPhysicalDeviceShaderIntegerDotProductProperties() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->fragmentShaderBarycentric = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->fragmentShaderBarycentric);address+=4;
}
MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::~MarshalVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->triStripVertexOrderIndependentOfProvokingVertex = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->triStripVertexOrderIndependentOfProvokingVertex);address+=4;
}
MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::~MarshalVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingMotionBlur = (VkBool32)memory->readd(address);address+=4;
    s->rayTracingMotionBlurPipelineTraceRaysIndirect = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingMotionBlur);address+=4;
    memory->writed(address, s->rayTracingMotionBlurPipelineTraceRaysIndirect);address+=4;
}
MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV::~MarshalVkPhysicalDeviceRayTracingMotionBlurFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingValidationFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingValidation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingValidationFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingValidation);address+=4;
}
MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV::~MarshalVkPhysicalDeviceRayTracingValidationFeaturesNV() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryMotionTrianglesDataNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexData = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
}
void MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureGeometryMotionTrianglesDataNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->vertexData.deviceAddress);address+=8;
}
MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV::~MarshalVkAccelerationStructureGeometryMotionTrianglesDataNV() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureMotionInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureMotionInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxInstances = (uint32_t)memory->readd(address);address+=4;
    s->flags = (VkAccelerationStructureMotionInfoFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkAccelerationStructureMotionInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureMotionInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxInstances);address+=4;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkAccelerationStructureMotionInfoNV::~MarshalVkAccelerationStructureMotionInfoNV() {
    delete s.pNext;
}
void MarshalVkCudaModuleCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaModuleCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dataSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pData = NULL;
    } else {
        s->pData = new char[(U32)s->dataSize];
        memory->memcpy((void*)s->pData, paramAddress, (U32)s->dataSize);
    }
}
void MarshalVkCudaModuleCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaModuleCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->dataSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkCudaModuleCreateInfoNV::~MarshalVkCudaModuleCreateInfoNV() {
    delete s.pNext;
    delete[] s.pData;
}
void MarshalVkCudaFunctionCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaFunctionCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->module = (VkCudaModuleNV)memory->readq(address);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen);
    }
}
void MarshalVkCudaFunctionCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaFunctionCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->module);address+=8;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkCudaFunctionCreateInfoNV::~MarshalVkCudaFunctionCreateInfoNV() {
    delete s.pNext;
    delete[] s.pName;
}
void MarshalVkCudaLaunchInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaLaunchInfoNV* s) {
    kpanic("MarshalVkCudaLaunchInfoNV::read");
}
void MarshalVkCudaLaunchInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCudaLaunchInfoNV* s) {
    kpanic("MarshalVkCudaLaunchInfoNV::write");
}
void MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->formatRgba10x6WithoutYCbCrSampler = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->formatRgba10x6WithoutYCbCrSampler);address+=4;
}
MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::~MarshalVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkFormatProperties3::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties3* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->linearTilingFeatures = (VkFormatFeatureFlags2)memory->readq(address);address+=8;
    s->optimalTilingFeatures = (VkFormatFeatureFlags2)memory->readq(address);address+=8;
    s->bufferFeatures = (VkFormatFeatureFlags2)memory->readq(address);address+=8;
}
void MarshalVkFormatProperties3::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFormatProperties3* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->linearTilingFeatures);address+=8;
    memory->writeq(address, s->optimalTilingFeatures);address+=8;
    memory->writeq(address, s->bufferFeatures);address+=8;
}
MarshalVkFormatProperties3::~MarshalVkFormatProperties3() {
    delete s.pNext;
}
void MarshalVkPipelineRenderingCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRenderingCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachmentFormats = NULL;
    } else {
        s->pColorAttachmentFormats = new VkFormat[(U32)s->colorAttachmentCount];
        memory->memcpy((VkFormat*)s->pColorAttachmentFormats, paramAddress, (U32)s->colorAttachmentCount);
    }
    s->depthAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
    s->stencilAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkPipelineRenderingCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRenderingCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->depthAttachmentFormat);address+=4;
    memory->writed(address, s->stencilAttachmentFormat);address+=4;
}
MarshalVkPipelineRenderingCreateInfo::~MarshalVkPipelineRenderingCreateInfo() {
    delete s.pNext;
    delete[] s.pColorAttachmentFormats;
}
void MarshalVkRenderingInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkRenderingFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->renderArea, address, 16);address+=16;
    s->layerCount = (uint32_t)memory->readd(address);address+=4;
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachments = NULL;
    } else {
        VkRenderingAttachmentInfo* pColorAttachments = new VkRenderingAttachmentInfo[s->colorAttachmentCount];
        for (U32 i = 0; i < s->colorAttachmentCount; i++) {
            MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress + i*60, &pColorAttachments[i]);
        }
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDepthAttachment = NULL;
    } else {
        VkRenderingAttachmentInfo* pDepthAttachment = new VkRenderingAttachmentInfo();
        MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress, pDepthAttachment);
        s->pDepthAttachment = pDepthAttachment;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStencilAttachment = NULL;
    } else {
        VkRenderingAttachmentInfo* pStencilAttachment = new VkRenderingAttachmentInfo();
        MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress, pStencilAttachment);
        s->pStencilAttachment = pStencilAttachment;
    }
}
void MarshalVkRenderingInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->memcpy(address, &s->renderArea, 16); address+=16;
    memory->writed(address, s->layerCount);address+=4;
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderingAttachmentInfo* pColorAttachments = new VkRenderingAttachmentInfo();
        MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress, pColorAttachments);
        s->pColorAttachments = pColorAttachments;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderingAttachmentInfo* pDepthAttachment = new VkRenderingAttachmentInfo();
        MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress, pDepthAttachment);
        s->pDepthAttachment = pDepthAttachment;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderingAttachmentInfo* pStencilAttachment = new VkRenderingAttachmentInfo();
        MarshalVkRenderingAttachmentInfo::read(pBoxedInfo, memory, paramAddress, pStencilAttachment);
        s->pStencilAttachment = pStencilAttachment;
    }
}
MarshalVkRenderingInfo::~MarshalVkRenderingInfo() {
    delete s.pNext;
    delete[] s.pColorAttachments;
    delete s.pDepthAttachment;
    delete s.pStencilAttachment;
}
void MarshalVkRenderingAttachmentInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAttachmentInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->imageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->resolveMode = (VkResolveModeFlagBits)memory->readd(address);address+=4;
    s->resolveImageView = (VkImageView)memory->readq(address);address+=8;
    s->resolveImageLayout = (VkImageLayout)memory->readd(address);address+=4;
    s->loadOp = (VkAttachmentLoadOp)memory->readd(address);address+=4;
    s->storeOp = (VkAttachmentStoreOp)memory->readd(address);address+=4;
    memory->memcpy(&s->clearValue, address, 16);address+=16;
}
void MarshalVkRenderingAttachmentInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAttachmentInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->imageView);address+=8;
    memory->writed(address, s->imageLayout);address+=4;
    memory->writed(address, s->resolveMode);address+=4;
    memory->writeq(address, (U64)s->resolveImageView);address+=8;
    memory->writed(address, s->resolveImageLayout);address+=4;
    memory->writed(address, s->loadOp);address+=4;
    memory->writed(address, s->storeOp);address+=4;
    memory->memcpy(address, &s->clearValue, 16); address+=16;
}
MarshalVkRenderingAttachmentInfo::~MarshalVkRenderingAttachmentInfo() {
    delete s.pNext;
}
void MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingFragmentDensityMapAttachmentInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageView = (VkImageView)memory->readq(address);address+=8;
    s->imageLayout = (VkImageLayout)memory->readd(address);address+=4;
}
void MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingFragmentDensityMapAttachmentInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->imageView);address+=8;
    memory->writed(address, s->imageLayout);address+=4;
}
MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT::~MarshalVkRenderingFragmentDensityMapAttachmentInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDynamicRenderingFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dynamicRendering = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDynamicRenderingFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dynamicRendering);address+=4;
}
MarshalVkPhysicalDeviceDynamicRenderingFeatures::~MarshalVkPhysicalDeviceDynamicRenderingFeatures() {
    delete s.pNext;
}
void MarshalVkCommandBufferInheritanceRenderingInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceRenderingInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkRenderingFlags)memory->readd(address);address+=4;
    s->viewMask = (uint32_t)memory->readd(address);address+=4;
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachmentFormats = NULL;
    } else {
        s->pColorAttachmentFormats = new VkFormat[(U32)s->colorAttachmentCount];
        memory->memcpy((VkFormat*)s->pColorAttachmentFormats, paramAddress, (U32)s->colorAttachmentCount);
    }
    s->depthAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
    s->stencilAttachmentFormat = (VkFormat)memory->readd(address);address+=4;
    s->rasterizationSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
}
void MarshalVkCommandBufferInheritanceRenderingInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCommandBufferInheritanceRenderingInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->viewMask);address+=4;
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->depthAttachmentFormat);address+=4;
    memory->writed(address, s->stencilAttachmentFormat);address+=4;
    memory->writed(address, s->rasterizationSamples);address+=4;
}
MarshalVkCommandBufferInheritanceRenderingInfo::~MarshalVkCommandBufferInheritanceRenderingInfo() {
    delete s.pNext;
    delete[] s.pColorAttachmentFormats;
}
void MarshalVkAttachmentSampleCountInfoAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentSampleCountInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachmentSamples = NULL;
    } else {
        s->pColorAttachmentSamples = new VkSampleCountFlagBits[(U32)s->colorAttachmentCount];
        memory->memcpy((VkSampleCountFlagBits*)s->pColorAttachmentSamples, paramAddress, (U32)s->colorAttachmentCount);
    }
    s->depthStencilAttachmentSamples = (VkSampleCountFlagBits)memory->readd(address);address+=4;
}
void MarshalVkAttachmentSampleCountInfoAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAttachmentSampleCountInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->depthStencilAttachmentSamples);address+=4;
}
MarshalVkAttachmentSampleCountInfoAMD::~MarshalVkAttachmentSampleCountInfoAMD() {
    delete s.pNext;
    delete[] s.pColorAttachmentSamples;
}
void MarshalVkMultiviewPerViewAttributesInfoNVX::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiviewPerViewAttributesInfoNVX* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->perViewAttributes = (VkBool32)memory->readd(address);address+=4;
    s->perViewAttributesPositionXOnly = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkMultiviewPerViewAttributesInfoNVX::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiviewPerViewAttributesInfoNVX* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->perViewAttributes);address+=4;
    memory->writed(address, s->perViewAttributesPositionXOnly);address+=4;
}
MarshalVkMultiviewPerViewAttributesInfoNVX::~MarshalVkMultiviewPerViewAttributesInfoNVX() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageViewMinLodFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minLod = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageViewMinLodFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->minLod);address+=4;
}
MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT::~MarshalVkPhysicalDeviceImageViewMinLodFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkImageViewMinLodCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewMinLodCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalFloat minLodFloat;
    minLodFloat.i = memory->readd(address);address+=4;
    s->minLod = minLodFloat.f;
}
void MarshalVkImageViewMinLodCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewMinLodCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    MarshalFloat minLodFloat;
    minLodFloat.f = s->minLod;
    memory->writed(address, minLodFloat.i);address+=4;
}
MarshalVkImageViewMinLodCreateInfoEXT::~MarshalVkImageViewMinLodCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rasterizationOrderColorAttachmentAccess = (VkBool32)memory->readd(address);address+=4;
    s->rasterizationOrderDepthAttachmentAccess = (VkBool32)memory->readd(address);address+=4;
    s->rasterizationOrderStencilAttachmentAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rasterizationOrderColorAttachmentAccess);address+=4;
    memory->writed(address, s->rasterizationOrderDepthAttachmentAccess);address+=4;
    memory->writed(address, s->rasterizationOrderStencilAttachmentAccess);address+=4;
}
MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::~MarshalVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLinearColorAttachmentFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->linearColorAttachment = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLinearColorAttachmentFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->linearColorAttachment);address+=4;
}
MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV::~MarshalVkPhysicalDeviceLinearColorAttachmentFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->graphicsPipelineLibrary = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->graphicsPipelineLibrary);address+=4;
}
MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::~MarshalVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineBinaryFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBinaries = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineBinaryFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBinaries);address+=4;
}
MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR::~MarshalVkPhysicalDevicePipelineBinaryFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkDevicePipelineBinaryInternalCacheControlKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDevicePipelineBinaryInternalCacheControlKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->disableInternalCache = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDevicePipelineBinaryInternalCacheControlKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDevicePipelineBinaryInternalCacheControlKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->disableInternalCache);address+=4;
}
MarshalVkDevicePipelineBinaryInternalCacheControlKHR::~MarshalVkDevicePipelineBinaryInternalCacheControlKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineBinaryPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineBinaryInternalCache = (VkBool32)memory->readd(address);address+=4;
    s->pipelineBinaryInternalCacheControl = (VkBool32)memory->readd(address);address+=4;
    s->pipelineBinaryPrefersInternalCache = (VkBool32)memory->readd(address);address+=4;
    s->pipelineBinaryPrecompiledInternalCache = (VkBool32)memory->readd(address);address+=4;
    s->pipelineBinaryCompressedData = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineBinaryPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineBinaryInternalCache);address+=4;
    memory->writed(address, s->pipelineBinaryInternalCacheControl);address+=4;
    memory->writed(address, s->pipelineBinaryPrefersInternalCache);address+=4;
    memory->writed(address, s->pipelineBinaryPrecompiledInternalCache);address+=4;
    memory->writed(address, s->pipelineBinaryCompressedData);address+=4;
}
MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR::~MarshalVkPhysicalDevicePipelineBinaryPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->graphicsPipelineLibraryFastLinking = (VkBool32)memory->readd(address);address+=4;
    s->graphicsPipelineLibraryIndependentInterpolationDecoration = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->graphicsPipelineLibraryFastLinking);address+=4;
    memory->writed(address, s->graphicsPipelineLibraryIndependentInterpolationDecoration);address+=4;
}
MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::~MarshalVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkGraphicsPipelineLibraryCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineLibraryCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkGraphicsPipelineLibraryFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkGraphicsPipelineLibraryCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGraphicsPipelineLibraryCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
}
MarshalVkGraphicsPipelineLibraryCreateInfoEXT::~MarshalVkGraphicsPipelineLibraryCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorSetHostMapping = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->descriptorSetHostMapping);address+=4;
}
MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::~MarshalVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE() {
    delete s.pNext;
}
void MarshalVkDescriptorSetBindingReferenceVALVE::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetBindingReferenceVALVE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorSetLayout = (VkDescriptorSetLayout)memory->readq(address);address+=8;
    s->binding = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetBindingReferenceVALVE::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetBindingReferenceVALVE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->descriptorSetLayout);address+=8;
    memory->writed(address, s->binding);address+=4;
}
MarshalVkDescriptorSetBindingReferenceVALVE::~MarshalVkDescriptorSetBindingReferenceVALVE() {
    delete s.pNext;
}
void MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutHostMappingInfoVALVE* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorOffset = (size_t)memory->readd(address);address+=4;
    s->descriptorSize = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDescriptorSetLayoutHostMappingInfoVALVE* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, (U32)s->descriptorOffset);address+=4;
    memory->writed(address, s->descriptorSize);address+=4;
}
MarshalVkDescriptorSetLayoutHostMappingInfoVALVE::~MarshalVkDescriptorSetLayoutHostMappingInfoVALVE() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNestedCommandBufferFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->nestedCommandBuffer = (VkBool32)memory->readd(address);address+=4;
    s->nestedCommandBufferRendering = (VkBool32)memory->readd(address);address+=4;
    s->nestedCommandBufferSimultaneousUse = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNestedCommandBufferFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->nestedCommandBuffer);address+=4;
    memory->writed(address, s->nestedCommandBufferRendering);address+=4;
    memory->writed(address, s->nestedCommandBufferSimultaneousUse);address+=4;
}
MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT::~MarshalVkPhysicalDeviceNestedCommandBufferFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNestedCommandBufferPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxCommandBufferNestingLevel = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNestedCommandBufferPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxCommandBufferNestingLevel);address+=4;
}
MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT::~MarshalVkPhysicalDeviceNestedCommandBufferPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderModuleIdentifier = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderModuleIdentifier);address+=4;
}
MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::~MarshalVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->shaderModuleIdentifierAlgorithmUUID, address, 16);address+=16;
}
void MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->shaderModuleIdentifierAlgorithmUUID, 16); address+=16;
}
MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::~MarshalVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageModuleIdentifierCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->identifierSize = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pIdentifier = NULL;
    } else {
        s->pIdentifier = new uint8_t[(U32)s->identifierSize];
        memory->memcpy((uint8_t*)s->pIdentifier, paramAddress, (U32)s->identifierSize);
    }
}
void MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineShaderStageModuleIdentifierCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->identifierSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT::~MarshalVkPipelineShaderStageModuleIdentifierCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pIdentifier;
}
void MarshalVkShaderModuleIdentifierEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleIdentifierEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->identifierSize = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->identifier, address, 32);address+=32;
}
void MarshalVkShaderModuleIdentifierEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderModuleIdentifierEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->identifierSize);address+=4;
    memory->memcpy(address, s->identifier, 32); address+=32;
}
MarshalVkShaderModuleIdentifierEXT::~MarshalVkShaderModuleIdentifierEXT() {
    delete s.pNext;
}
void MarshalVkImageCompressionControlEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCompressionControlEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkImageCompressionFlagsEXT)memory->readd(address);address+=4;
    s->compressionControlPlaneCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFixedRateFlags = NULL;
    } else {
        s->pFixedRateFlags = new VkImageCompressionFixedRateFlagsEXT[(U32)s->compressionControlPlaneCount];
        memory->memcpy((VkImageCompressionFixedRateFlagsEXT*)s->pFixedRateFlags, paramAddress, (U32)s->compressionControlPlaneCount);
    }
}
void MarshalVkImageCompressionControlEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCompressionControlEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->compressionControlPlaneCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkImageCompressionControlEXT::~MarshalVkImageCompressionControlEXT() {
    delete s.pNext;
    delete[] s.pFixedRateFlags;
}
void MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageCompressionControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageCompressionControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageCompressionControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageCompressionControl);address+=4;
}
MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT::~MarshalVkPhysicalDeviceImageCompressionControlFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkImageCompressionPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCompressionPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageCompressionFlags = (VkImageCompressionFlagsEXT)memory->readd(address);address+=4;
    s->imageCompressionFixedRateFlags = (VkImageCompressionFixedRateFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkImageCompressionPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageCompressionPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageCompressionFlags);address+=4;
    memory->writed(address, s->imageCompressionFixedRateFlags);address+=4;
}
MarshalVkImageCompressionPropertiesEXT::~MarshalVkImageCompressionPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageCompressionControlSwapchain = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageCompressionControlSwapchain);address+=4;
}
MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::~MarshalVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkImageSubresource2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSubresource2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->imageSubresource, address, 12);address+=12;
}
void MarshalVkImageSubresource2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageSubresource2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->imageSubresource, 12); address+=12;
}
MarshalVkImageSubresource2::~MarshalVkImageSubresource2() {
    delete s.pNext;
}
void MarshalVkSubresourceLayout2::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceLayout2* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->subresourceLayout, address, 40);address+=40;
}
void MarshalVkSubresourceLayout2::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSubresourceLayout2* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->subresourceLayout, 40); address+=40;
}
MarshalVkSubresourceLayout2::~MarshalVkSubresourceLayout2() {
    delete s.pNext;
}
void MarshalVkRenderPassCreationControlEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreationControlEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->disallowMerging = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkRenderPassCreationControlEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreationControlEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->disallowMerging);address+=4;
}
MarshalVkRenderPassCreationControlEXT::~MarshalVkRenderPassCreationControlEXT() {
    delete s.pNext;
}
void MarshalVkRenderPassCreationFeedbackInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreationFeedbackInfoEXT* s) {
    s->postMergeSubpassCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkRenderPassCreationFeedbackCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreationFeedbackCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRenderPassFeedback = NULL;
    } else {
        VkRenderPassCreationFeedbackInfoEXT* pRenderPassFeedback = new VkRenderPassCreationFeedbackInfoEXT();
        MarshalVkRenderPassCreationFeedbackInfoEXT::read(pBoxedInfo, memory, paramAddress, pRenderPassFeedback);
        s->pRenderPassFeedback = pRenderPassFeedback;
    }
}
void MarshalVkRenderPassCreationFeedbackCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassCreationFeedbackCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderPassCreationFeedbackInfoEXT* pRenderPassFeedback = new VkRenderPassCreationFeedbackInfoEXT();
        MarshalVkRenderPassCreationFeedbackInfoEXT::read(pBoxedInfo, memory, paramAddress, pRenderPassFeedback);
        s->pRenderPassFeedback = pRenderPassFeedback;
    }
}
MarshalVkRenderPassCreationFeedbackCreateInfoEXT::~MarshalVkRenderPassCreationFeedbackCreateInfoEXT() {
    delete s.pNext;
    delete s.pRenderPassFeedback;
}
void MarshalVkRenderPassSubpassFeedbackInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassSubpassFeedbackInfoEXT* s) {
    s->subpassMergeStatus = (VkSubpassMergeStatusEXT)memory->readd(address);address+=4;
    memory->memcpy(&s->description, address, 256);address+=256;
    s->postMergeIndex = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkRenderPassSubpassFeedbackCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassSubpassFeedbackCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubpassFeedback = NULL;
    } else {
        VkRenderPassSubpassFeedbackInfoEXT* pSubpassFeedback = new VkRenderPassSubpassFeedbackInfoEXT();
        MarshalVkRenderPassSubpassFeedbackInfoEXT::read(pBoxedInfo, memory, paramAddress, pSubpassFeedback);
        s->pSubpassFeedback = pSubpassFeedback;
    }
}
void MarshalVkRenderPassSubpassFeedbackCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassSubpassFeedbackCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderPassSubpassFeedbackInfoEXT* pSubpassFeedback = new VkRenderPassSubpassFeedbackInfoEXT();
        MarshalVkRenderPassSubpassFeedbackInfoEXT::read(pBoxedInfo, memory, paramAddress, pSubpassFeedback);
        s->pSubpassFeedback = pSubpassFeedback;
    }
}
MarshalVkRenderPassSubpassFeedbackCreateInfoEXT::~MarshalVkRenderPassSubpassFeedbackCreateInfoEXT() {
    delete s.pNext;
    delete s.pSubpassFeedback;
}
void MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->subpassMergeFeedback = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->subpassMergeFeedback);address+=4;
}
MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::~MarshalVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkMicromapBuildInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapBuildInfoEXT* s) {
    kpanic("MarshalVkMicromapBuildInfoEXT::read");
}
void MarshalVkMicromapBuildInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapBuildInfoEXT* s) {
    kpanic("MarshalVkMicromapBuildInfoEXT::write");
}
void MarshalVkMicromapCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->createFlags = (VkMicromapCreateFlagsEXT)memory->readd(address);address+=4;
    s->buffer = (VkBuffer)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->type = (VkMicromapTypeEXT)memory->readd(address);address+=4;
    s->deviceAddress = (VkDeviceAddress)memory->readq(address);address+=8;
}
void MarshalVkMicromapCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->createFlags);address+=4;
    memory->writeq(address, (U64)s->buffer);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->type);address+=4;
    memory->writeq(address, s->deviceAddress);address+=8;
}
MarshalVkMicromapCreateInfoEXT::~MarshalVkMicromapCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkMicromapVersionInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapVersionInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pVersionData = NULL;
    } else {
        s->pVersionData = new uint8_t[2*VK_UUID_SIZE];
        memory->memcpy((uint8_t*)s->pVersionData, paramAddress, 2*VK_UUID_SIZE);
    }
}
void MarshalVkMicromapVersionInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapVersionInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkMicromapVersionInfoEXT::~MarshalVkMicromapVersionInfoEXT() {
    delete s.pNext;
    delete[] s.pVersionData;
}
void MarshalVkCopyMicromapInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMicromapInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkMicromapEXT)memory->readq(address);address+=8;
    s->dst = (VkMicromapEXT)memory->readq(address);address+=8;
    s->mode = (VkCopyMicromapModeEXT)memory->readd(address);address+=4;
}
void MarshalVkCopyMicromapInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMicromapInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyMicromapInfoEXT::~MarshalVkCopyMicromapInfoEXT() {
    delete s.pNext;
}
void MarshalVkCopyMicromapToMemoryInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMicromapToMemoryInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkMicromapEXT)memory->readq(address);address+=8;
    s->dst = (VkDeviceOrHostAddressKHR)memory->readq(address);address+=8;
    s->mode = (VkCopyMicromapModeEXT)memory->readd(address);address+=4;
}
void MarshalVkCopyMicromapToMemoryInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMicromapToMemoryInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->src);address+=8;
    memory->writeq(address, s->dst.deviceAddress);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyMicromapToMemoryInfoEXT::~MarshalVkCopyMicromapToMemoryInfoEXT() {
    delete s.pNext;
}
void MarshalVkCopyMemoryToMicromapInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToMicromapInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->src = (VkDeviceOrHostAddressConstKHR)memory->readq(address);address+=8;
    s->dst = (VkMicromapEXT)memory->readq(address);address+=8;
    s->mode = (VkCopyMicromapModeEXT)memory->readd(address);address+=4;
}
void MarshalVkCopyMemoryToMicromapInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCopyMemoryToMicromapInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->src.deviceAddress);address+=8;
    memory->writeq(address, (U64)s->dst);address+=8;
    memory->writed(address, s->mode);address+=4;
}
MarshalVkCopyMemoryToMicromapInfoEXT::~MarshalVkCopyMemoryToMicromapInfoEXT() {
    delete s.pNext;
}
void MarshalVkMicromapBuildSizesInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapBuildSizesInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->micromapSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->buildScratchSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->discardable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkMicromapBuildSizesInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMicromapBuildSizesInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->micromapSize);address+=8;
    memory->writeq(address, s->buildScratchSize);address+=8;
    memory->writed(address, s->discardable);address+=4;
}
MarshalVkMicromapBuildSizesInfoEXT::~MarshalVkMicromapBuildSizesInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpacityMicromapFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->micromap = (VkBool32)memory->readd(address);address+=4;
    s->micromapCaptureReplay = (VkBool32)memory->readd(address);address+=4;
    s->micromapHostCommands = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpacityMicromapFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->micromap);address+=4;
    memory->writed(address, s->micromapCaptureReplay);address+=4;
    memory->writed(address, s->micromapHostCommands);address+=4;
}
MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT::~MarshalVkPhysicalDeviceOpacityMicromapFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpacityMicromapPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxOpacity2StateSubdivisionLevel = (uint32_t)memory->readd(address);address+=4;
    s->maxOpacity4StateSubdivisionLevel = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpacityMicromapPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxOpacity2StateSubdivisionLevel);address+=4;
    memory->writed(address, s->maxOpacity4StateSubdivisionLevel);address+=4;
}
MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT::~MarshalVkPhysicalDeviceOpacityMicromapPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureTrianglesOpacityMicromapEXT* s) {
    kpanic("MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::read");
}
void MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAccelerationStructureTrianglesOpacityMicromapEXT* s) {
    kpanic("MarshalVkAccelerationStructureTrianglesOpacityMicromapEXT::write");
}
void MarshalVkPipelinePropertiesIdentifierEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelinePropertiesIdentifierEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->pipelineIdentifier, address, 16);address+=16;
}
void MarshalVkPipelinePropertiesIdentifierEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelinePropertiesIdentifierEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->pipelineIdentifier, 16); address+=16;
}
MarshalVkPipelinePropertiesIdentifierEXT::~MarshalVkPipelinePropertiesIdentifierEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelinePropertiesFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelinePropertiesIdentifier = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelinePropertiesFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelinePropertiesIdentifier);address+=4;
}
MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT::~MarshalVkPhysicalDevicePipelinePropertiesFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderEarlyAndLateFragmentTests = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderEarlyAndLateFragmentTests);address+=4;
}
MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::~MarshalVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD() {
    delete s.pNext;
}
void MarshalVkExternalMemoryAcquireUnmodifiedEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryAcquireUnmodifiedEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->acquireUnmodifiedMemory = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkExternalMemoryAcquireUnmodifiedEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkExternalMemoryAcquireUnmodifiedEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->acquireUnmodifiedMemory);address+=4;
}
MarshalVkExternalMemoryAcquireUnmodifiedEXT::~MarshalVkExternalMemoryAcquireUnmodifiedEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->nonSeamlessCubeMap = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->nonSeamlessCubeMap);address+=4;
}
MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::~MarshalVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineRobustnessFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineRobustnessFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineRobustness = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineRobustnessFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineRobustnessFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineRobustness);address+=4;
}
MarshalVkPhysicalDevicePipelineRobustnessFeatures::~MarshalVkPhysicalDevicePipelineRobustnessFeatures() {
    delete s.pNext;
}
void MarshalVkPipelineRobustnessCreateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRobustnessCreateInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->storageBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->uniformBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->vertexInputs = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->images = (VkPipelineRobustnessImageBehavior)memory->readd(address);address+=4;
}
void MarshalVkPipelineRobustnessCreateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPipelineRobustnessCreateInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->storageBuffers);address+=4;
    memory->writed(address, s->uniformBuffers);address+=4;
    memory->writed(address, s->vertexInputs);address+=4;
    memory->writed(address, s->images);address+=4;
}
MarshalVkPipelineRobustnessCreateInfo::~MarshalVkPipelineRobustnessCreateInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePipelineRobustnessProperties::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineRobustnessProperties* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->defaultRobustnessStorageBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessUniformBuffers = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessVertexInputs = (VkPipelineRobustnessBufferBehavior)memory->readd(address);address+=4;
    s->defaultRobustnessImages = (VkPipelineRobustnessImageBehavior)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineRobustnessProperties::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineRobustnessProperties* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->defaultRobustnessStorageBuffers);address+=4;
    memory->writed(address, s->defaultRobustnessUniformBuffers);address+=4;
    memory->writed(address, s->defaultRobustnessVertexInputs);address+=4;
    memory->writed(address, s->defaultRobustnessImages);address+=4;
}
MarshalVkPhysicalDevicePipelineRobustnessProperties::~MarshalVkPhysicalDevicePipelineRobustnessProperties() {
    delete s.pNext;
}
void MarshalVkImageViewSampleWeightCreateInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewSampleWeightCreateInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->filterCenter, address, 8);address+=8;
    memory->memcpy(&s->filterSize, address, 8);address+=8;
    s->numPhases = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkImageViewSampleWeightCreateInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageViewSampleWeightCreateInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->filterCenter, 8); address+=8;
    memory->memcpy(address, &s->filterSize, 8); address+=8;
    memory->writed(address, s->numPhases);address+=4;
}
MarshalVkImageViewSampleWeightCreateInfoQCOM::~MarshalVkImageViewSampleWeightCreateInfoQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessingFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->textureSampleWeighted = (VkBool32)memory->readd(address);address+=4;
    s->textureBoxFilter = (VkBool32)memory->readd(address);address+=4;
    s->textureBlockMatch = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessingFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->textureSampleWeighted);address+=4;
    memory->writed(address, s->textureBoxFilter);address+=4;
    memory->writed(address, s->textureBlockMatch);address+=4;
}
MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM::~MarshalVkPhysicalDeviceImageProcessingFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessingPropertiesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maxWeightFilterPhases = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->maxWeightFilterDimension, address, 8);address+=8;
    memory->memcpy(&s->maxBlockMatchRegion, address, 8);address+=8;
    memory->memcpy(&s->maxBoxFilterBlockSize, address, 8);address+=8;
}
void MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessingPropertiesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maxWeightFilterPhases);address+=4;
    memory->memcpy(address, &s->maxWeightFilterDimension, 8); address+=8;
    memory->memcpy(address, &s->maxBlockMatchRegion, 8); address+=8;
    memory->memcpy(address, &s->maxBoxFilterBlockSize, 8); address+=8;
}
MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM::~MarshalVkPhysicalDeviceImageProcessingPropertiesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTilePropertiesFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->tileProperties = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceTilePropertiesFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->tileProperties);address+=4;
}
MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM::~MarshalVkPhysicalDeviceTilePropertiesFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkTilePropertiesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTilePropertiesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->tileSize, address, 12);address+=12;
    memory->memcpy(&s->apronSize, address, 8);address+=8;
    memory->memcpy(&s->origin, address, 8);address+=8;
}
void MarshalVkTilePropertiesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkTilePropertiesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->tileSize, 12); address+=12;
    memory->memcpy(address, &s->apronSize, 8); address+=8;
    memory->memcpy(address, &s->origin, 8); address+=8;
}
MarshalVkTilePropertiesQCOM::~MarshalVkTilePropertiesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->attachmentFeedbackLoopLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->attachmentFeedbackLoopLayout);address+=4;
}
MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::~MarshalVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthClampZeroOne = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthClampZeroOne);address+=4;
}
MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT::~MarshalVkPhysicalDeviceDepthClampZeroOneFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAddressBindingReportFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->reportAddressBinding = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAddressBindingReportFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->reportAddressBinding);address+=4;
}
MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT::~MarshalVkPhysicalDeviceAddressBindingReportFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkDeviceAddressBindingCallbackDataEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceAddressBindingCallbackDataEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkDeviceAddressBindingFlagsEXT)memory->readd(address);address+=4;
    s->baseAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
    s->bindingType = (VkDeviceAddressBindingTypeEXT)memory->readd(address);address+=4;
}
void MarshalVkDeviceAddressBindingCallbackDataEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceAddressBindingCallbackDataEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->baseAddress);address+=8;
    memory->writeq(address, s->size);address+=8;
    memory->writed(address, s->bindingType);address+=4;
}
MarshalVkDeviceAddressBindingCallbackDataEXT::~MarshalVkDeviceAddressBindingCallbackDataEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceOpticalFlowFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpticalFlowFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->opticalFlow = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceOpticalFlowFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpticalFlowFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->opticalFlow);address+=4;
}
MarshalVkPhysicalDeviceOpticalFlowFeaturesNV::~MarshalVkPhysicalDeviceOpticalFlowFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceOpticalFlowPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpticalFlowPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportedOutputGridSizes = (VkOpticalFlowGridSizeFlagsNV)memory->readd(address);address+=4;
    s->supportedHintGridSizes = (VkOpticalFlowGridSizeFlagsNV)memory->readd(address);address+=4;
    s->hintSupported = (VkBool32)memory->readd(address);address+=4;
    s->costSupported = (VkBool32)memory->readd(address);address+=4;
    s->bidirectionalFlowSupported = (VkBool32)memory->readd(address);address+=4;
    s->globalFlowSupported = (VkBool32)memory->readd(address);address+=4;
    s->minWidth = (uint32_t)memory->readd(address);address+=4;
    s->minHeight = (uint32_t)memory->readd(address);address+=4;
    s->maxWidth = (uint32_t)memory->readd(address);address+=4;
    s->maxHeight = (uint32_t)memory->readd(address);address+=4;
    s->maxNumRegionsOfInterest = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceOpticalFlowPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceOpticalFlowPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportedOutputGridSizes);address+=4;
    memory->writed(address, s->supportedHintGridSizes);address+=4;
    memory->writed(address, s->hintSupported);address+=4;
    memory->writed(address, s->costSupported);address+=4;
    memory->writed(address, s->bidirectionalFlowSupported);address+=4;
    memory->writed(address, s->globalFlowSupported);address+=4;
    memory->writed(address, s->minWidth);address+=4;
    memory->writed(address, s->minHeight);address+=4;
    memory->writed(address, s->maxWidth);address+=4;
    memory->writed(address, s->maxHeight);address+=4;
    memory->writed(address, s->maxNumRegionsOfInterest);address+=4;
}
MarshalVkPhysicalDeviceOpticalFlowPropertiesNV::~MarshalVkPhysicalDeviceOpticalFlowPropertiesNV() {
    delete s.pNext;
}
void MarshalVkOpticalFlowImageFormatInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowImageFormatInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->usage = (VkOpticalFlowUsageFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkOpticalFlowImageFormatInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowImageFormatInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->usage);address+=4;
}
MarshalVkOpticalFlowImageFormatInfoNV::~MarshalVkOpticalFlowImageFormatInfoNV() {
    delete s.pNext;
}
void MarshalVkOpticalFlowImageFormatPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowImageFormatPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->format = (VkFormat)memory->readd(address);address+=4;
}
void MarshalVkOpticalFlowImageFormatPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowImageFormatPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->format);address+=4;
}
MarshalVkOpticalFlowImageFormatPropertiesNV::~MarshalVkOpticalFlowImageFormatPropertiesNV() {
    delete s.pNext;
}
void MarshalVkOpticalFlowSessionCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowSessionCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->width = (uint32_t)memory->readd(address);address+=4;
    s->height = (uint32_t)memory->readd(address);address+=4;
    s->imageFormat = (VkFormat)memory->readd(address);address+=4;
    s->flowVectorFormat = (VkFormat)memory->readd(address);address+=4;
    s->costFormat = (VkFormat)memory->readd(address);address+=4;
    s->outputGridSize = (VkOpticalFlowGridSizeFlagsNV)memory->readd(address);address+=4;
    s->hintGridSize = (VkOpticalFlowGridSizeFlagsNV)memory->readd(address);address+=4;
    s->performanceLevel = (VkOpticalFlowPerformanceLevelNV)memory->readd(address);address+=4;
    s->flags = (VkOpticalFlowSessionCreateFlagsNV)memory->readd(address);address+=4;
}
void MarshalVkOpticalFlowSessionCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowSessionCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->width);address+=4;
    memory->writed(address, s->height);address+=4;
    memory->writed(address, s->imageFormat);address+=4;
    memory->writed(address, s->flowVectorFormat);address+=4;
    memory->writed(address, s->costFormat);address+=4;
    memory->writed(address, s->outputGridSize);address+=4;
    memory->writed(address, s->hintGridSize);address+=4;
    memory->writed(address, s->performanceLevel);address+=4;
    memory->writed(address, s->flags);address+=4;
}
MarshalVkOpticalFlowSessionCreateInfoNV::~MarshalVkOpticalFlowSessionCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowSessionCreatePrivateDataInfoNV* s) {
    kpanic("MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::read");
}
void MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowSessionCreatePrivateDataInfoNV* s) {
    kpanic("MarshalVkOpticalFlowSessionCreatePrivateDataInfoNV::write");
}
void MarshalVkOpticalFlowExecuteInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowExecuteInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkOpticalFlowExecuteFlagsNV)memory->readd(address);address+=4;
    s->regionCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRegions = NULL;
    } else {
        s->pRegions = new VkRect2D[(U32)s->regionCount];
        memory->memcpy((VkRect2D*)s->pRegions, paramAddress, (U32)s->regionCount * sizeof(VkRect2D));
    }
}
void MarshalVkOpticalFlowExecuteInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOpticalFlowExecuteInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->regionCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pRegions = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pRegions);
        s->pRegions = pRegions;
    }
}
MarshalVkOpticalFlowExecuteInfoNV::~MarshalVkOpticalFlowExecuteInfoNV() {
    delete s.pNext;
    delete[] s.pRegions;
}
void MarshalVkPhysicalDeviceFaultFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFaultFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->deviceFault = (VkBool32)memory->readd(address);address+=4;
    s->deviceFaultVendorBinary = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFaultFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFaultFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->deviceFault);address+=4;
    memory->writed(address, s->deviceFaultVendorBinary);address+=4;
}
MarshalVkPhysicalDeviceFaultFeaturesEXT::~MarshalVkPhysicalDeviceFaultFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkDeviceFaultCountsEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceFaultCountsEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->addressInfoCount = (uint32_t)memory->readd(address);address+=4;
    s->vendorInfoCount = (uint32_t)memory->readd(address);address+=4;
    s->vendorBinarySize = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkDeviceFaultCountsEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceFaultCountsEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->addressInfoCount);address+=4;
    memory->writed(address, s->vendorInfoCount);address+=4;
    memory->writeq(address, s->vendorBinarySize);address+=8;
}
MarshalVkDeviceFaultCountsEXT::~MarshalVkDeviceFaultCountsEXT() {
    delete s.pNext;
}
void MarshalVkDeviceFaultInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceFaultInfoEXT* s) {
    kpanic("MarshalVkDeviceFaultInfoEXT::read");
}
void MarshalVkDeviceFaultInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceFaultInfoEXT* s) {
    kpanic("MarshalVkDeviceFaultInfoEXT::write");
}
void MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pipelineLibraryGroupHandles = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pipelineLibraryGroupHandles);address+=4;
}
MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::~MarshalVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkDepthBiasInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDepthBiasInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasConstantFactor = depthBiasConstantFactorFloat.f;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.i = memory->readd(address);address+=4;
    s->depthBiasClamp = depthBiasClampFloat.f;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.i = memory->readd(address);address+=4;
    s->depthBiasSlopeFactor = depthBiasSlopeFactorFloat.f;
}
void MarshalVkDepthBiasInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDepthBiasInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    MarshalFloat depthBiasConstantFactorFloat;
    depthBiasConstantFactorFloat.f = s->depthBiasConstantFactor;
    memory->writed(address, depthBiasConstantFactorFloat.i);address+=4;
    MarshalFloat depthBiasClampFloat;
    depthBiasClampFloat.f = s->depthBiasClamp;
    memory->writed(address, depthBiasClampFloat.i);address+=4;
    MarshalFloat depthBiasSlopeFactorFloat;
    depthBiasSlopeFactorFloat.f = s->depthBiasSlopeFactor;
    memory->writed(address, depthBiasSlopeFactorFloat.i);address+=4;
}
MarshalVkDepthBiasInfoEXT::~MarshalVkDepthBiasInfoEXT() {
    delete s.pNext;
}
void MarshalVkDepthBiasRepresentationInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDepthBiasRepresentationInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthBiasRepresentation = (VkDepthBiasRepresentationEXT)memory->readd(address);address+=4;
    s->depthBiasExact = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkDepthBiasRepresentationInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDepthBiasRepresentationInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthBiasRepresentation);address+=4;
    memory->writed(address, s->depthBiasExact);address+=4;
}
MarshalVkDepthBiasRepresentationInfoEXT::~MarshalVkDepthBiasRepresentationInfoEXT() {
    delete s.pNext;
}
void MarshalVkDecompressMemoryRegionNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDecompressMemoryRegionNV* s) {
    s->srcAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->dstAddress = (VkDeviceAddress)memory->readq(address);address+=8;
    s->compressedSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->decompressedSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->decompressionMethod = (VkMemoryDecompressionMethodFlagsNV)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCoreMask = (uint64_t)memory->readq(address);address+=8;
    s->shaderCoreCount = (uint32_t)memory->readd(address);address+=4;
    s->shaderWarpsPerCore = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->shaderCoreMask);address+=8;
    memory->writed(address, s->shaderCoreCount);address+=4;
    memory->writed(address, s->shaderWarpsPerCore);address+=4;
}
MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::~MarshalVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCoreBuiltins = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderCoreBuiltins);address+=4;
}
MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::~MarshalVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM() {
    delete s.pNext;
}
void MarshalVkFrameBoundaryEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFrameBoundaryEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkFrameBoundaryFlagsEXT)memory->readd(address);address+=4;
    s->frameID = (uint64_t)memory->readq(address);address+=8;
    s->imageCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImages = NULL;
    } else {
        s->pImages = new VkImage[(U32)s->imageCount];
        memory->memcpy((VkImage*)s->pImages, paramAddress, (U32)s->imageCount);
    }
    s->bufferCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBuffers = NULL;
    } else {
        s->pBuffers = new VkBuffer[(U32)s->bufferCount];
        memory->memcpy((VkBuffer*)s->pBuffers, paramAddress, (U32)s->bufferCount);
    }
    s->tagName = (uint64_t)memory->readq(address);address+=8;
    s->tagSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTag = NULL;
    } else {
        s->pTag = new char[(U32)s->tagSize];
        memory->memcpy((void*)s->pTag, paramAddress, (U32)s->tagSize);
    }
}
void MarshalVkFrameBoundaryEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkFrameBoundaryEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, s->frameID);address+=8;
    memory->writed(address, s->imageCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->bufferCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writeq(address, s->tagName);address+=8;
    memory->writed(address, (U32)s->tagSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkFrameBoundaryEXT::~MarshalVkFrameBoundaryEXT() {
    delete s.pNext;
    delete[] s.pImages;
    delete[] s.pBuffers;
    delete[] s.pTag;
}
void MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFrameBoundaryFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->frameBoundary = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceFrameBoundaryFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->frameBoundary);address+=4;
}
MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT::~MarshalVkPhysicalDeviceFrameBoundaryFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dynamicRenderingUnusedAttachments = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dynamicRenderingUnusedAttachments);address+=4;
}
MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::~MarshalVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkSurfacePresentModeEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentModeEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentMode = (VkPresentModeKHR)memory->readd(address);address+=4;
}
void MarshalVkSurfacePresentModeEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentModeEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentMode);address+=4;
}
MarshalVkSurfacePresentModeEXT::~MarshalVkSurfacePresentModeEXT() {
    delete s.pNext;
}
void MarshalVkSurfacePresentScalingCapabilitiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentScalingCapabilitiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportedPresentScaling = (VkPresentScalingFlagsEXT)memory->readd(address);address+=4;
    s->supportedPresentGravityX = (VkPresentGravityFlagsEXT)memory->readd(address);address+=4;
    s->supportedPresentGravityY = (VkPresentGravityFlagsEXT)memory->readd(address);address+=4;
    memory->memcpy(&s->minScaledImageExtent, address, 8);address+=8;
    memory->memcpy(&s->maxScaledImageExtent, address, 8);address+=8;
}
void MarshalVkSurfacePresentScalingCapabilitiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentScalingCapabilitiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportedPresentScaling);address+=4;
    memory->writed(address, s->supportedPresentGravityX);address+=4;
    memory->writed(address, s->supportedPresentGravityY);address+=4;
    memory->memcpy(address, &s->minScaledImageExtent, 8); address+=8;
    memory->memcpy(address, &s->maxScaledImageExtent, 8); address+=8;
}
MarshalVkSurfacePresentScalingCapabilitiesEXT::~MarshalVkSurfacePresentScalingCapabilitiesEXT() {
    delete s.pNext;
}
void MarshalVkSurfacePresentModeCompatibilityEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentModeCompatibilityEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentModeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentModes = NULL;
    } else {
        s->pPresentModes = new VkPresentModeKHR[(U32)s->presentModeCount];
        memory->memcpy((VkPresentModeKHR*)s->pPresentModes, paramAddress, (U32)s->presentModeCount);
    }
}
void MarshalVkSurfacePresentModeCompatibilityEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSurfacePresentModeCompatibilityEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentModeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSurfacePresentModeCompatibilityEXT::~MarshalVkSurfacePresentModeCompatibilityEXT() {
    delete s.pNext;
    delete[] s.pPresentModes;
}
void MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainMaintenance1 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainMaintenance1);address+=4;
}
MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::~MarshalVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT() {
    delete s.pNext;
}
void MarshalVkSwapchainPresentFenceInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentFenceInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pFences = NULL;
    } else {
        s->pFences = new VkFence[(U32)s->swapchainCount];
        memory->memcpy((VkFence*)s->pFences, paramAddress, (U32)s->swapchainCount);
    }
}
void MarshalVkSwapchainPresentFenceInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentFenceInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSwapchainPresentFenceInfoEXT::~MarshalVkSwapchainPresentFenceInfoEXT() {
    delete s.pNext;
    delete[] s.pFences;
}
void MarshalVkSwapchainPresentModesCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentModesCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentModeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentModes = NULL;
    } else {
        s->pPresentModes = new VkPresentModeKHR[(U32)s->presentModeCount];
        memory->memcpy((VkPresentModeKHR*)s->pPresentModes, paramAddress, (U32)s->presentModeCount);
    }
}
void MarshalVkSwapchainPresentModesCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentModesCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentModeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSwapchainPresentModesCreateInfoEXT::~MarshalVkSwapchainPresentModesCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pPresentModes;
}
void MarshalVkSwapchainPresentModeInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentModeInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchainCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentModes = NULL;
    } else {
        s->pPresentModes = new VkPresentModeKHR[(U32)s->swapchainCount];
        memory->memcpy((VkPresentModeKHR*)s->pPresentModes, paramAddress, (U32)s->swapchainCount);
    }
}
void MarshalVkSwapchainPresentModeInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentModeInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->swapchainCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSwapchainPresentModeInfoEXT::~MarshalVkSwapchainPresentModeInfoEXT() {
    delete s.pNext;
    delete[] s.pPresentModes;
}
void MarshalVkSwapchainPresentScalingCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentScalingCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->scalingBehavior = (VkPresentScalingFlagsEXT)memory->readd(address);address+=4;
    s->presentGravityX = (VkPresentGravityFlagsEXT)memory->readd(address);address+=4;
    s->presentGravityY = (VkPresentGravityFlagsEXT)memory->readd(address);address+=4;
}
void MarshalVkSwapchainPresentScalingCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainPresentScalingCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->scalingBehavior);address+=4;
    memory->writed(address, s->presentGravityX);address+=4;
    memory->writed(address, s->presentGravityY);address+=4;
}
MarshalVkSwapchainPresentScalingCreateInfoEXT::~MarshalVkSwapchainPresentScalingCreateInfoEXT() {
    delete s.pNext;
}
void MarshalVkReleaseSwapchainImagesInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkReleaseSwapchainImagesInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->swapchain = (VkSwapchainKHR)memory->readq(address);address+=8;
    s->imageIndexCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pImageIndices = NULL;
    } else {
        s->pImageIndices = new uint32_t[(U32)s->imageIndexCount];
        memory->memcpy((uint32_t*)s->pImageIndices, paramAddress, (U32)s->imageIndexCount);
    }
}
void MarshalVkReleaseSwapchainImagesInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkReleaseSwapchainImagesInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->swapchain);address+=8;
    memory->writed(address, s->imageIndexCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkReleaseSwapchainImagesInfoEXT::~MarshalVkReleaseSwapchainImagesInfoEXT() {
    delete s.pNext;
    delete[] s.pImageIndices;
}
void MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthBiasControlFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->depthBiasControl = (VkBool32)memory->readd(address);address+=4;
    s->leastRepresentableValueForceUnormRepresentation = (VkBool32)memory->readd(address);address+=4;
    s->floatRepresentation = (VkBool32)memory->readd(address);address+=4;
    s->depthBiasExact = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDepthBiasControlFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->depthBiasControl);address+=4;
    memory->writed(address, s->leastRepresentableValueForceUnormRepresentation);address+=4;
    memory->writed(address, s->floatRepresentation);address+=4;
    memory->writed(address, s->depthBiasExact);address+=4;
}
MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT::~MarshalVkPhysicalDeviceDepthBiasControlFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingInvocationReorder = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingInvocationReorder);address+=4;
}
MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::~MarshalVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingInvocationReorderReorderingHint = (VkRayTracingInvocationReorderModeNV)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingInvocationReorderReorderingHint);address+=4;
}
MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::~MarshalVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->extendedSparseAddressSpace = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->extendedSparseAddressSpace);address+=4;
}
MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV::~MarshalVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->extendedSparseAddressSpaceSize = (VkDeviceSize)memory->readq(address);address+=8;
    s->extendedSparseImageUsageFlags = (VkImageUsageFlags)memory->readd(address);address+=4;
    s->extendedSparseBufferUsageFlags = (VkBufferUsageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->extendedSparseAddressSpaceSize);address+=8;
    memory->writed(address, s->extendedSparseImageUsageFlags);address+=4;
    memory->writed(address, s->extendedSparseBufferUsageFlags);address+=4;
}
MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::~MarshalVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multiviewPerViewViewports = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multiviewPerViewViewports);address+=4;
}
MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::~MarshalVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->rayTracingPositionFetch = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->rayTracingPositionFetch);address+=4;
}
MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::~MarshalVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkDeviceImageSubresourceInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceImageSubresourceInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCreateInfo = NULL;
    } else {
        VkImageCreateInfo* pCreateInfo = new VkImageCreateInfo();
        MarshalVkImageCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubresource = NULL;
    } else {
        VkImageSubresource2* pSubresource = new VkImageSubresource2();
        MarshalVkImageSubresource2::read(pBoxedInfo, memory, paramAddress, pSubresource);
        s->pSubresource = pSubresource;
    }
}
void MarshalVkDeviceImageSubresourceInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceImageSubresourceInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageCreateInfo* pCreateInfo = new VkImageCreateInfo();
        MarshalVkImageCreateInfo::read(pBoxedInfo, memory, paramAddress, pCreateInfo);
        s->pCreateInfo = pCreateInfo;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkImageSubresource2* pSubresource = new VkImageSubresource2();
        MarshalVkImageSubresource2::read(pBoxedInfo, memory, paramAddress, pSubresource);
        s->pSubresource = pSubresource;
    }
}
MarshalVkDeviceImageSubresourceInfo::~MarshalVkDeviceImageSubresourceInfo() {
    delete s.pNext;
    delete s.pCreateInfo;
    delete s.pSubresource;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->pixelRate = (uint32_t)memory->readd(address);address+=4;
    s->texelRate = (uint32_t)memory->readd(address);address+=4;
    s->fmaRate = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderCorePropertiesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderCorePropertiesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->pixelRate);address+=4;
    memory->writed(address, s->texelRate);address+=4;
    memory->writed(address, s->fmaRate);address+=4;
}
MarshalVkPhysicalDeviceShaderCorePropertiesARM::~MarshalVkPhysicalDeviceShaderCorePropertiesARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->multiviewPerViewRenderAreas = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->multiviewPerViewRenderAreas);address+=4;
}
MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::~MarshalVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->perViewRenderAreaCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPerViewRenderAreas = NULL;
    } else {
        s->pPerViewRenderAreas = new VkRect2D[(U32)s->perViewRenderAreaCount];
        memory->memcpy((VkRect2D*)s->pPerViewRenderAreas, paramAddress, (U32)s->perViewRenderAreaCount * sizeof(VkRect2D));
    }
}
void MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->perViewRenderAreaCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRect2D* pPerViewRenderAreas = new VkRect2D();
        MarshalVkRect2D::read(pBoxedInfo, memory, paramAddress, pPerViewRenderAreas);
        s->pPerViewRenderAreas = pPerViewRenderAreas;
    }
}
MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::~MarshalVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM() {
    delete s.pNext;
    delete[] s.pPerViewRenderAreas;
}
void MarshalVkQueryLowLatencySupportNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryLowLatencySupportNV* s) {
    kpanic("MarshalVkQueryLowLatencySupportNV::read");
}
void MarshalVkQueryLowLatencySupportNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkQueryLowLatencySupportNV* s) {
    kpanic("MarshalVkQueryLowLatencySupportNV::write");
}
void MarshalVkMemoryMapInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryMapInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkMemoryMapFlags)memory->readd(address);address+=4;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
    s->offset = (VkDeviceSize)memory->readq(address);address+=8;
    s->size = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkMemoryMapInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryMapInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->memory);address+=8;
    memory->writeq(address, s->offset);address+=8;
    memory->writeq(address, s->size);address+=8;
}
MarshalVkMemoryMapInfo::~MarshalVkMemoryMapInfo() {
    delete s.pNext;
}
void MarshalVkMemoryUnmapInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryUnmapInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkMemoryUnmapFlags)memory->readd(address);address+=4;
    s->memory = (VkDeviceMemory)memory->readq(address);address+=8;
}
void MarshalVkMemoryUnmapInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryUnmapInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writeq(address, (U64)s->memory);address+=8;
}
MarshalVkMemoryUnmapInfo::~MarshalVkMemoryUnmapInfo() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderObjectFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderObjectFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderObject = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderObjectFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderObjectFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderObject);address+=4;
}
MarshalVkPhysicalDeviceShaderObjectFeaturesEXT::~MarshalVkPhysicalDeviceShaderObjectFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderObjectPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderObjectPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->shaderBinaryUUID, address, 16);address+=16;
    s->shaderBinaryVersion = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderObjectPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderObjectPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, s->shaderBinaryUUID, 16); address+=16;
    memory->writed(address, s->shaderBinaryVersion);address+=4;
}
MarshalVkPhysicalDeviceShaderObjectPropertiesEXT::~MarshalVkPhysicalDeviceShaderObjectPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkShaderCreateInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderCreateInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->flags = (VkShaderCreateFlagsEXT)memory->readd(address);address+=4;
    s->stage = (VkShaderStageFlagBits)memory->readd(address);address+=4;
    s->nextStage = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->codeType = (VkShaderCodeTypeEXT)memory->readd(address);address+=4;
    s->codeSize = (size_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pCode = NULL;
    } else {
        s->pCode = new char[(U32)s->codeSize];
        memory->memcpy((void*)s->pCode, paramAddress, (U32)s->codeSize);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pName = NULL;
    } else {
        U32 pNameLen = memory->strlen(paramAddress)+1;
        s->pName = new char[pNameLen];
        memory->memcpy((char*)s->pName, paramAddress, pNameLen);
    }
    s->setLayoutCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSetLayouts = NULL;
    } else {
        s->pSetLayouts = new VkDescriptorSetLayout[(U32)s->setLayoutCount];
        memory->memcpy((VkDescriptorSetLayout*)s->pSetLayouts, paramAddress, (U32)s->setLayoutCount);
    }
    s->pushConstantRangeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPushConstantRanges = NULL;
    } else {
        s->pPushConstantRanges = new VkPushConstantRange[(U32)s->pushConstantRangeCount];
        memory->memcpy((VkPushConstantRange*)s->pPushConstantRanges, paramAddress, (U32)s->pushConstantRangeCount * sizeof(VkPushConstantRange));
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSpecializationInfo = NULL;
    } else {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(pBoxedInfo, memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
void MarshalVkShaderCreateInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkShaderCreateInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->flags);address+=4;
    memory->writed(address, s->stage);address+=4;
    memory->writed(address, s->nextStage);address+=4;
    memory->writed(address, s->codeType);address+=4;
    memory->writed(address, (U32)s->codeSize);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->setLayoutCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->pushConstantRangeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkPushConstantRange* pPushConstantRanges = new VkPushConstantRange();
        MarshalVkPushConstantRange::read(pBoxedInfo, memory, paramAddress, pPushConstantRanges);
        s->pPushConstantRanges = pPushConstantRanges;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSpecializationInfo* pSpecializationInfo = new VkSpecializationInfo();
        MarshalVkSpecializationInfo::read(pBoxedInfo, memory, paramAddress, pSpecializationInfo);
        s->pSpecializationInfo = pSpecializationInfo;
    }
}
MarshalVkShaderCreateInfoEXT::~MarshalVkShaderCreateInfoEXT() {
    delete s.pNext;
    delete[] s.pCode;
    delete[] s.pName;
    delete[] s.pSetLayouts;
    delete[] s.pPushConstantRanges;
    delete s.pSpecializationInfo;
}
void MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTileImageFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderTileImageColorReadAccess = (VkBool32)memory->readd(address);address+=4;
    s->shaderTileImageDepthReadAccess = (VkBool32)memory->readd(address);address+=4;
    s->shaderTileImageStencilReadAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTileImageFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderTileImageColorReadAccess);address+=4;
    memory->writed(address, s->shaderTileImageDepthReadAccess);address+=4;
    memory->writed(address, s->shaderTileImageStencilReadAccess);address+=4;
}
MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT::~MarshalVkPhysicalDeviceShaderTileImageFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTileImagePropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderTileImageCoherentReadAccelerated = (VkBool32)memory->readd(address);address+=4;
    s->shaderTileImageReadSampleFromPixelRateInvocation = (VkBool32)memory->readd(address);address+=4;
    s->shaderTileImageReadFromHelperInvocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderTileImagePropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderTileImageCoherentReadAccelerated);address+=4;
    memory->writed(address, s->shaderTileImageReadSampleFromPixelRateInvocation);address+=4;
    memory->writed(address, s->shaderTileImageReadFromHelperInvocation);address+=4;
}
MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT::~MarshalVkPhysicalDeviceShaderTileImagePropertiesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrix = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixRobustBufferAccess = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrix);address+=4;
    memory->writed(address, s->cooperativeMatrixRobustBufferAccess);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR::~MarshalVkPhysicalDeviceCooperativeMatrixFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkCooperativeMatrixPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->MSize = (uint32_t)memory->readd(address);address+=4;
    s->NSize = (uint32_t)memory->readd(address);address+=4;
    s->KSize = (uint32_t)memory->readd(address);address+=4;
    s->AType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->BType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->CType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->ResultType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->saturatingAccumulation = (VkBool32)memory->readd(address);address+=4;
    s->scope = (VkScopeKHR)memory->readd(address);address+=4;
}
void MarshalVkCooperativeMatrixPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->MSize);address+=4;
    memory->writed(address, s->NSize);address+=4;
    memory->writed(address, s->KSize);address+=4;
    memory->writed(address, s->AType);address+=4;
    memory->writed(address, s->BType);address+=4;
    memory->writed(address, s->CType);address+=4;
    memory->writed(address, s->ResultType);address+=4;
    memory->writed(address, s->saturatingAccumulation);address+=4;
    memory->writed(address, s->scope);address+=4;
}
MarshalVkCooperativeMatrixPropertiesKHR::~MarshalVkCooperativeMatrixPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrixSupportedStages = (VkShaderStageFlags)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrixPropertiesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrixSupportedStages);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR::~MarshalVkPhysicalDeviceCooperativeMatrixPropertiesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceAntiLagFeaturesAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAntiLagFeaturesAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->antiLag = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceAntiLagFeaturesAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceAntiLagFeaturesAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->antiLag);address+=4;
}
MarshalVkPhysicalDeviceAntiLagFeaturesAMD::~MarshalVkPhysicalDeviceAntiLagFeaturesAMD() {
    delete s.pNext;
}
void MarshalVkAntiLagDataAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAntiLagDataAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->mode = (VkAntiLagModeAMD)memory->readd(address);address+=4;
    s->maxFPS = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentationInfo = NULL;
    } else {
        VkAntiLagPresentationInfoAMD* pPresentationInfo = new VkAntiLagPresentationInfoAMD();
        MarshalVkAntiLagPresentationInfoAMD::read(pBoxedInfo, memory, paramAddress, pPresentationInfo);
        s->pPresentationInfo = pPresentationInfo;
    }
}
void MarshalVkAntiLagDataAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAntiLagDataAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->mode);address+=4;
    memory->writed(address, s->maxFPS);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkAntiLagPresentationInfoAMD* pPresentationInfo = new VkAntiLagPresentationInfoAMD();
        MarshalVkAntiLagPresentationInfoAMD::read(pBoxedInfo, memory, paramAddress, pPresentationInfo);
        s->pPresentationInfo = pPresentationInfo;
    }
}
MarshalVkAntiLagDataAMD::~MarshalVkAntiLagDataAMD() {
    delete s.pNext;
    delete s.pPresentationInfo;
}
void MarshalVkAntiLagPresentationInfoAMD::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAntiLagPresentationInfoAMD* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stage = (VkAntiLagStageAMD)memory->readd(address);address+=4;
    s->frameIndex = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkAntiLagPresentationInfoAMD::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkAntiLagPresentationInfoAMD* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stage);address+=4;
    memory->writeq(address, s->frameIndex);address+=8;
}
MarshalVkAntiLagPresentationInfoAMD::~MarshalVkAntiLagPresentationInfoAMD() {
    delete s.pNext;
}
void MarshalVkBindMemoryStatus::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindMemoryStatus* s) {
    kpanic("MarshalVkBindMemoryStatus::read");
}
void MarshalVkBindMemoryStatus::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindMemoryStatus* s) {
    kpanic("MarshalVkBindMemoryStatus::write");
}
void MarshalVkBindDescriptorSetsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindDescriptorSetsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->firstSet = (uint32_t)memory->readd(address);address+=4;
    s->descriptorSetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorSets = NULL;
    } else {
        s->pDescriptorSets = new VkDescriptorSet[(U32)s->descriptorSetCount];
        memory->memcpy((VkDescriptorSet*)s->pDescriptorSets, paramAddress, (U32)s->descriptorSetCount);
    }
    s->dynamicOffsetCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDynamicOffsets = NULL;
    } else {
        s->pDynamicOffsets = new uint32_t[(U32)s->dynamicOffsetCount];
        memory->memcpy((uint32_t*)s->pDynamicOffsets, paramAddress, (U32)s->dynamicOffsetCount);
    }
}
void MarshalVkBindDescriptorSetsInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindDescriptorSetsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stageFlags);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writed(address, s->firstSet);address+=4;
    memory->writed(address, s->descriptorSetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    memory->writed(address, s->dynamicOffsetCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkBindDescriptorSetsInfo::~MarshalVkBindDescriptorSetsInfo() {
    delete s.pNext;
    delete[] s.pDescriptorSets;
    delete[] s.pDynamicOffsets;
}
void MarshalVkPushConstantsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushConstantsInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->offset = (uint32_t)memory->readd(address);address+=4;
    s->size = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pValues = NULL;
    } else {
        s->pValues = new char[(U32)s->size];
        memory->memcpy((void*)s->pValues, paramAddress, (U32)s->size);
    }
}
void MarshalVkPushConstantsInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushConstantsInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writed(address, s->stageFlags);address+=4;
    memory->writed(address, s->offset);address+=4;
    memory->writed(address, s->size);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkPushConstantsInfo::~MarshalVkPushConstantsInfo() {
    delete s.pNext;
    delete[] s.pValues;
}
void MarshalVkPushDescriptorSetInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushDescriptorSetInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->set = (uint32_t)memory->readd(address);address+=4;
    s->descriptorWriteCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pDescriptorWrites = NULL;
    } else {
        VkWriteDescriptorSet* pDescriptorWrites = new VkWriteDescriptorSet[s->descriptorWriteCount];
        for (U32 i = 0; i < s->descriptorWriteCount; i++) {
            MarshalVkWriteDescriptorSet::read(pBoxedInfo, memory, paramAddress + i*44, &pDescriptorWrites[i]);
        }
        s->pDescriptorWrites = pDescriptorWrites;
    }
}
void MarshalVkPushDescriptorSetInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushDescriptorSetInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stageFlags);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writed(address, s->set);address+=4;
    memory->writed(address, s->descriptorWriteCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkWriteDescriptorSet* pDescriptorWrites = new VkWriteDescriptorSet();
        MarshalVkWriteDescriptorSet::read(pBoxedInfo, memory, paramAddress, pDescriptorWrites);
        s->pDescriptorWrites = pDescriptorWrites;
    }
}
MarshalVkPushDescriptorSetInfo::~MarshalVkPushDescriptorSetInfo() {
    delete s.pNext;
    delete[] s.pDescriptorWrites;
}
void MarshalVkPushDescriptorSetWithTemplateInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushDescriptorSetWithTemplateInfo* s) {
    kpanic("MarshalVkPushDescriptorSetWithTemplateInfo::read");
}
void MarshalVkPushDescriptorSetWithTemplateInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPushDescriptorSetWithTemplateInfo* s) {
    kpanic("MarshalVkPushDescriptorSetWithTemplateInfo::write");
}
void MarshalVkSetDescriptorBufferOffsetsInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSetDescriptorBufferOffsetsInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->firstSet = (uint32_t)memory->readd(address);address+=4;
    s->setCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pBufferIndices = NULL;
    } else {
        s->pBufferIndices = new uint32_t[(U32)s->setCount];
        memory->memcpy((uint32_t*)s->pBufferIndices, paramAddress, (U32)s->setCount);
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pOffsets = NULL;
    } else {
        s->pOffsets = new VkDeviceSize[(U32)s->setCount];
        memory->memcpy((VkDeviceSize*)s->pOffsets, paramAddress, (U32)s->setCount);
    }
}
void MarshalVkSetDescriptorBufferOffsetsInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSetDescriptorBufferOffsetsInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stageFlags);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writed(address, s->firstSet);address+=4;
    memory->writed(address, s->setCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkSetDescriptorBufferOffsetsInfoEXT::~MarshalVkSetDescriptorBufferOffsetsInfoEXT() {
    delete s.pNext;
    delete[] s.pBufferIndices;
    delete[] s.pOffsets;
}
void MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindDescriptorBufferEmbeddedSamplersInfoEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stageFlags = (VkShaderStageFlags)memory->readd(address);address+=4;
    s->layout = (VkPipelineLayout)memory->readq(address);address+=8;
    s->set = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBindDescriptorBufferEmbeddedSamplersInfoEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stageFlags);address+=4;
    memory->writeq(address, (U64)s->layout);address+=8;
    memory->writed(address, s->set);address+=4;
}
MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT::~MarshalVkBindDescriptorBufferEmbeddedSamplersInfoEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCubicClampFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCubicClampFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cubicRangeClamp = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCubicClampFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCubicClampFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cubicRangeClamp);address+=4;
}
MarshalVkPhysicalDeviceCubicClampFeaturesQCOM::~MarshalVkPhysicalDeviceCubicClampFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->ycbcrDegamma = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->ycbcrDegamma);address+=4;
}
MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM::~MarshalVkPhysicalDeviceYcbcrDegammaFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->enableYDegamma = (VkBool32)memory->readd(address);address+=4;
    s->enableCbCrDegamma = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->enableYDegamma);address+=4;
    memory->writed(address, s->enableCbCrDegamma);address+=4;
}
MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::~MarshalVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCubicWeightsFeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->selectableCubicWeights = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCubicWeightsFeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->selectableCubicWeights);address+=4;
}
MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM::~MarshalVkPhysicalDeviceCubicWeightsFeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkSamplerCubicWeightsCreateInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCubicWeightsCreateInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cubicWeights = (VkCubicFilterWeightsQCOM)memory->readd(address);address+=4;
}
void MarshalVkSamplerCubicWeightsCreateInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerCubicWeightsCreateInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cubicWeights);address+=4;
}
MarshalVkSamplerCubicWeightsCreateInfoQCOM::~MarshalVkSamplerCubicWeightsCreateInfoQCOM() {
    delete s.pNext;
}
void MarshalVkBlitImageCubicWeightsInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBlitImageCubicWeightsInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cubicWeights = (VkCubicFilterWeightsQCOM)memory->readd(address);address+=4;
}
void MarshalVkBlitImageCubicWeightsInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkBlitImageCubicWeightsInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cubicWeights);address+=4;
}
MarshalVkBlitImageCubicWeightsInfoQCOM::~MarshalVkBlitImageCubicWeightsInfoQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessing2FeaturesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->textureBlockMatch2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessing2FeaturesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->textureBlockMatch2);address+=4;
}
MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM::~MarshalVkPhysicalDeviceImageProcessing2FeaturesQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessing2PropertiesQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->maxBlockMatchWindow, address, 8);address+=8;
}
void MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageProcessing2PropertiesQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->maxBlockMatchWindow, 8); address+=8;
}
MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM::~MarshalVkPhysicalDeviceImageProcessing2PropertiesQCOM() {
    delete s.pNext;
}
void MarshalVkSamplerBlockMatchWindowCreateInfoQCOM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerBlockMatchWindowCreateInfoQCOM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->windowExtent, address, 8);address+=8;
    s->windowCompareMode = (VkBlockMatchWindowCompareModeQCOM)memory->readd(address);address+=4;
}
void MarshalVkSamplerBlockMatchWindowCreateInfoQCOM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSamplerBlockMatchWindowCreateInfoQCOM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->windowExtent, 8); address+=8;
    memory->writed(address, s->windowCompareMode);address+=4;
}
MarshalVkSamplerBlockMatchWindowCreateInfoQCOM::~MarshalVkSamplerBlockMatchWindowCreateInfoQCOM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->descriptorPoolOverallocation = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->descriptorPoolOverallocation);address+=4;
}
MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::~MarshalVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLayeredDriverPropertiesMSFT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->underlyingAPI = (VkLayeredDriverUnderlyingApiMSFT)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceLayeredDriverPropertiesMSFT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->underlyingAPI);address+=4;
}
MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT::~MarshalVkPhysicalDeviceLayeredDriverPropertiesMSFT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerStageDescriptorSetFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->perStageDescriptorSet = (VkBool32)memory->readd(address);address+=4;
    s->dynamicPipelineLayout = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePerStageDescriptorSetFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->perStageDescriptorSet);address+=4;
    memory->writed(address, s->dynamicPipelineLayout);address+=4;
}
MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV::~MarshalVkPhysicalDevicePerStageDescriptorSetFeaturesNV() {
    delete s.pNext;
}
void MarshalVkLatencySleepModeInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySleepModeInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->lowLatencyMode = (VkBool32)memory->readd(address);address+=4;
    s->lowLatencyBoost = (VkBool32)memory->readd(address);address+=4;
    s->minimumIntervalUs = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkLatencySleepModeInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySleepModeInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->lowLatencyMode);address+=4;
    memory->writed(address, s->lowLatencyBoost);address+=4;
    memory->writed(address, s->minimumIntervalUs);address+=4;
}
MarshalVkLatencySleepModeInfoNV::~MarshalVkLatencySleepModeInfoNV() {
    delete s.pNext;
}
void MarshalVkLatencySleepInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySleepInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->signalSemaphore = (VkSemaphore)memory->readq(address);address+=8;
    s->value = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkLatencySleepInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySleepInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, (U64)s->signalSemaphore);address+=8;
    memory->writeq(address, s->value);address+=8;
}
MarshalVkLatencySleepInfoNV::~MarshalVkLatencySleepInfoNV() {
    delete s.pNext;
}
void MarshalVkSetLatencyMarkerInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSetLatencyMarkerInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentID = (uint64_t)memory->readq(address);address+=8;
    s->marker = (VkLatencyMarkerNV)memory->readd(address);address+=4;
}
void MarshalVkSetLatencyMarkerInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSetLatencyMarkerInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->presentID);address+=8;
    memory->writed(address, s->marker);address+=4;
}
MarshalVkSetLatencyMarkerInfoNV::~MarshalVkSetLatencyMarkerInfoNV() {
    delete s.pNext;
}
void MarshalVkGetLatencyMarkerInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGetLatencyMarkerInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->timingCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pTimings = NULL;
    } else {
        VkLatencyTimingsFrameReportNV* pTimings = new VkLatencyTimingsFrameReportNV[s->timingCount];
        for (U32 i = 0; i < s->timingCount; i++) {
            MarshalVkLatencyTimingsFrameReportNV::read(pBoxedInfo, memory, paramAddress + i*120, &pTimings[i]);
        }
        s->pTimings = pTimings;
    }
}
void MarshalVkGetLatencyMarkerInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkGetLatencyMarkerInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->timingCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkLatencyTimingsFrameReportNV* pTimings = new VkLatencyTimingsFrameReportNV();
        MarshalVkLatencyTimingsFrameReportNV::read(pBoxedInfo, memory, paramAddress, pTimings);
        s->pTimings = pTimings;
    }
}
MarshalVkGetLatencyMarkerInfoNV::~MarshalVkGetLatencyMarkerInfoNV() {
    delete s.pNext;
    delete[] s.pTimings;
}
void MarshalVkLatencyTimingsFrameReportNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencyTimingsFrameReportNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentID = (uint64_t)memory->readq(address);address+=8;
    s->inputSampleTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->simStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->simEndTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->renderSubmitStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->renderSubmitEndTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->presentStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->presentEndTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->driverStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->driverEndTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->osRenderQueueStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->osRenderQueueEndTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->gpuRenderStartTimeUs = (uint64_t)memory->readq(address);address+=8;
    s->gpuRenderEndTimeUs = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkLatencyTimingsFrameReportNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencyTimingsFrameReportNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->presentID);address+=8;
    memory->writeq(address, s->inputSampleTimeUs);address+=8;
    memory->writeq(address, s->simStartTimeUs);address+=8;
    memory->writeq(address, s->simEndTimeUs);address+=8;
    memory->writeq(address, s->renderSubmitStartTimeUs);address+=8;
    memory->writeq(address, s->renderSubmitEndTimeUs);address+=8;
    memory->writeq(address, s->presentStartTimeUs);address+=8;
    memory->writeq(address, s->presentEndTimeUs);address+=8;
    memory->writeq(address, s->driverStartTimeUs);address+=8;
    memory->writeq(address, s->driverEndTimeUs);address+=8;
    memory->writeq(address, s->osRenderQueueStartTimeUs);address+=8;
    memory->writeq(address, s->osRenderQueueEndTimeUs);address+=8;
    memory->writeq(address, s->gpuRenderStartTimeUs);address+=8;
    memory->writeq(address, s->gpuRenderEndTimeUs);address+=8;
}
MarshalVkLatencyTimingsFrameReportNV::~MarshalVkLatencyTimingsFrameReportNV() {
    delete s.pNext;
}
void MarshalVkOutOfBandQueueTypeInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOutOfBandQueueTypeInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->queueType = (VkOutOfBandQueueTypeNV)memory->readd(address);address+=4;
}
void MarshalVkOutOfBandQueueTypeInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkOutOfBandQueueTypeInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->queueType);address+=4;
}
MarshalVkOutOfBandQueueTypeInfoNV::~MarshalVkOutOfBandQueueTypeInfoNV() {
    delete s.pNext;
}
void MarshalVkLatencySubmissionPresentIdNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySubmissionPresentIdNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentID = (uint64_t)memory->readq(address);address+=8;
}
void MarshalVkLatencySubmissionPresentIdNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySubmissionPresentIdNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->presentID);address+=8;
}
MarshalVkLatencySubmissionPresentIdNV::~MarshalVkLatencySubmissionPresentIdNV() {
    delete s.pNext;
}
void MarshalVkSwapchainLatencyCreateInfoNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainLatencyCreateInfoNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->latencyModeEnable = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkSwapchainLatencyCreateInfoNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkSwapchainLatencyCreateInfoNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->latencyModeEnable);address+=4;
}
MarshalVkSwapchainLatencyCreateInfoNV::~MarshalVkSwapchainLatencyCreateInfoNV() {
    delete s.pNext;
}
void MarshalVkLatencySurfaceCapabilitiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySurfaceCapabilitiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentModeCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pPresentModes = NULL;
    } else {
        s->pPresentModes = new VkPresentModeKHR[(U32)s->presentModeCount];
        memory->memcpy((VkPresentModeKHR*)s->pPresentModes, paramAddress, (U32)s->presentModeCount);
    }
}
void MarshalVkLatencySurfaceCapabilitiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkLatencySurfaceCapabilitiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentModeCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkLatencySurfaceCapabilitiesNV::~MarshalVkLatencySurfaceCapabilitiesNV() {
    delete s.pNext;
    delete[] s.pPresentModes;
}
void MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCudaKernelLaunchFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cudaKernelLaunchFeatures = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCudaKernelLaunchFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cudaKernelLaunchFeatures);address+=4;
}
MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV::~MarshalVkPhysicalDeviceCudaKernelLaunchFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCudaKernelLaunchPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->computeCapabilityMinor = (uint32_t)memory->readd(address);address+=4;
    s->computeCapabilityMajor = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCudaKernelLaunchPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->computeCapabilityMinor);address+=4;
    memory->writed(address, s->computeCapabilityMajor);address+=4;
}
MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV::~MarshalVkPhysicalDeviceCudaKernelLaunchPropertiesNV() {
    delete s.pNext;
}
void MarshalVkDeviceQueueShaderCoreControlCreateInfoARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueShaderCoreControlCreateInfoARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderCoreCount = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkDeviceQueueShaderCoreControlCreateInfoARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDeviceQueueShaderCoreControlCreateInfoARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderCoreCount);address+=4;
}
MarshalVkDeviceQueueShaderCoreControlCreateInfoARM::~MarshalVkDeviceQueueShaderCoreControlCreateInfoARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSchedulingControlsFeaturesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->schedulingControls = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSchedulingControlsFeaturesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->schedulingControls);address+=4;
}
MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM::~MarshalVkPhysicalDeviceSchedulingControlsFeaturesARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSchedulingControlsPropertiesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->schedulingControlsFlags = (VkPhysicalDeviceSchedulingControlsFlagsARM)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceSchedulingControlsPropertiesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->schedulingControlsFlags);address+=8;
}
MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM::~MarshalVkPhysicalDeviceSchedulingControlsPropertiesARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->relaxedLineRasterization = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->relaxedLineRasterization);address+=4;
}
MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG::~MarshalVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRenderPassStripedFeaturesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->renderPassStriped = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRenderPassStripedFeaturesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->renderPassStriped);address+=4;
}
MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM::~MarshalVkPhysicalDeviceRenderPassStripedFeaturesARM() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRenderPassStripedPropertiesARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->renderPassStripeGranularity, address, 8);address+=8;
    s->maxRenderPassStripes = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRenderPassStripedPropertiesARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->renderPassStripeGranularity, 8); address+=8;
    memory->writed(address, s->maxRenderPassStripes);address+=4;
}
MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM::~MarshalVkPhysicalDeviceRenderPassStripedPropertiesARM() {
    delete s.pNext;
}
void MarshalVkRenderPassStripeInfoARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeInfoARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    memory->memcpy(&s->stripeArea, address, 16);address+=16;
}
void MarshalVkRenderPassStripeInfoARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeInfoARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->memcpy(address, &s->stripeArea, 16); address+=16;
}
MarshalVkRenderPassStripeInfoARM::~MarshalVkRenderPassStripeInfoARM() {
    delete s.pNext;
}
void MarshalVkRenderPassStripeBeginInfoARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeBeginInfoARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stripeInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStripeInfos = NULL;
    } else {
        VkRenderPassStripeInfoARM* pStripeInfos = new VkRenderPassStripeInfoARM[s->stripeInfoCount];
        for (U32 i = 0; i < s->stripeInfoCount; i++) {
            MarshalVkRenderPassStripeInfoARM::read(pBoxedInfo, memory, paramAddress + i*24, &pStripeInfos[i]);
        }
        s->pStripeInfos = pStripeInfos;
    }
}
void MarshalVkRenderPassStripeBeginInfoARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeBeginInfoARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stripeInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkRenderPassStripeInfoARM* pStripeInfos = new VkRenderPassStripeInfoARM();
        MarshalVkRenderPassStripeInfoARM::read(pBoxedInfo, memory, paramAddress, pStripeInfos);
        s->pStripeInfos = pStripeInfos;
    }
}
MarshalVkRenderPassStripeBeginInfoARM::~MarshalVkRenderPassStripeBeginInfoARM() {
    delete s.pNext;
    delete[] s.pStripeInfos;
}
void MarshalVkRenderPassStripeSubmitInfoARM::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeSubmitInfoARM* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->stripeSemaphoreInfoCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pStripeSemaphoreInfos = NULL;
    } else {
        VkSemaphoreSubmitInfo* pStripeSemaphoreInfos = new VkSemaphoreSubmitInfo[s->stripeSemaphoreInfoCount];
        for (U32 i = 0; i < s->stripeSemaphoreInfoCount; i++) {
            MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress + i*36, &pStripeSemaphoreInfos[i]);
        }
        s->pStripeSemaphoreInfos = pStripeSemaphoreInfos;
    }
}
void MarshalVkRenderPassStripeSubmitInfoARM::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderPassStripeSubmitInfoARM* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->stripeSemaphoreInfoCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        VkSemaphoreSubmitInfo* pStripeSemaphoreInfos = new VkSemaphoreSubmitInfo();
        MarshalVkSemaphoreSubmitInfo::read(pBoxedInfo, memory, paramAddress, pStripeSemaphoreInfos);
        s->pStripeSemaphoreInfos = pStripeSemaphoreInfos;
    }
}
MarshalVkRenderPassStripeSubmitInfoARM::~MarshalVkRenderPassStripeSubmitInfoARM() {
    delete s.pNext;
    delete[] s.pStripeSemaphoreInfos;
}
void MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderMaximalReconvergence = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderMaximalReconvergence);address+=4;
}
MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR::~MarshalVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupRotateFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderSubgroupRotate = (VkBool32)memory->readd(address);address+=4;
    s->shaderSubgroupRotateClustered = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderSubgroupRotateFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderSubgroupRotate);address+=4;
    memory->writed(address, s->shaderSubgroupRotateClustered);address+=4;
}
MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures::~MarshalVkPhysicalDeviceShaderSubgroupRotateFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderExpectAssumeFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderExpectAssumeFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderExpectAssume = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderExpectAssumeFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderExpectAssumeFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderExpectAssume);address+=4;
}
MarshalVkPhysicalDeviceShaderExpectAssumeFeatures::~MarshalVkPhysicalDeviceShaderExpectAssumeFeatures() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderFloatControls2Features::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderFloatControls2Features* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderFloatControls2 = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderFloatControls2Features::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderFloatControls2Features* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderFloatControls2);address+=4;
}
MarshalVkPhysicalDeviceShaderFloatControls2Features::~MarshalVkPhysicalDeviceShaderFloatControls2Features() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingLocalReadFeatures* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->dynamicRenderingLocalRead = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceDynamicRenderingLocalReadFeatures* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->dynamicRenderingLocalRead);address+=4;
}
MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures::~MarshalVkPhysicalDeviceDynamicRenderingLocalReadFeatures() {
    delete s.pNext;
}
void MarshalVkRenderingAttachmentLocationInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAttachmentLocationInfo* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->colorAttachmentCount = (uint32_t)memory->readd(address);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pColorAttachmentLocations = NULL;
    } else {
        s->pColorAttachmentLocations = new uint32_t[(U32)s->colorAttachmentCount];
        memory->memcpy((uint32_t*)s->pColorAttachmentLocations, paramAddress, (U32)s->colorAttachmentCount);
    }
}
void MarshalVkRenderingAttachmentLocationInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingAttachmentLocationInfo* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->colorAttachmentCount);address+=4;
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        kpanic("Can't marshal void*");
    }
}
MarshalVkRenderingAttachmentLocationInfo::~MarshalVkRenderingAttachmentLocationInfo() {
    delete s.pNext;
    delete[] s.pColorAttachmentLocations;
}
void MarshalVkRenderingInputAttachmentIndexInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingInputAttachmentIndexInfo* s) {
    kpanic("MarshalVkRenderingInputAttachmentIndexInfo::read");
}
void MarshalVkRenderingInputAttachmentIndexInfo::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkRenderingInputAttachmentIndexInfo* s) {
    kpanic("MarshalVkRenderingInputAttachmentIndexInfo::write");
}
void MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderQuadControlFeaturesKHR* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderQuadControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderQuadControlFeaturesKHR* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderQuadControl);address+=4;
}
MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR::~MarshalVkPhysicalDeviceShaderQuadControlFeaturesKHR() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderFloat16VectorAtomics = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderFloat16VectorAtomics);address+=4;
}
MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV::~MarshalVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->memoryMapPlaced = (VkBool32)memory->readd(address);address+=4;
    s->memoryMapRangePlaced = (VkBool32)memory->readd(address);address+=4;
    s->memoryUnmapReserve = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->memoryMapPlaced);address+=4;
    memory->writed(address, s->memoryMapRangePlaced);address+=4;
    memory->writed(address, s->memoryUnmapReserve);address+=4;
}
MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT::~MarshalVkPhysicalDeviceMapMemoryPlacedFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->minPlacedMemoryMapAlignment = (VkDeviceSize)memory->readq(address);address+=8;
}
void MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writeq(address, s->minPlacedMemoryMapAlignment);address+=8;
}
MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT::~MarshalVkPhysicalDeviceMapMemoryPlacedPropertiesEXT() {
    delete s.pNext;
}
void MarshalVkMemoryMapPlacedInfoEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryMapPlacedInfoEXT* s) {
    kpanic("MarshalVkMemoryMapPlacedInfoEXT::read");
}
void MarshalVkMemoryMapPlacedInfoEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkMemoryMapPlacedInfoEXT* s) {
    kpanic("MarshalVkMemoryMapPlacedInfoEXT::write");
}
void MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRawAccessChainsFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderRawAccessChains = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceRawAccessChainsFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderRawAccessChains);address+=4;
}
MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV::~MarshalVkPhysicalDeviceRawAccessChainsFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->commandBufferInheritance = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->commandBufferInheritance);address+=4;
}
MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV::~MarshalVkPhysicalDeviceCommandBufferInheritanceFeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageAlignmentControlFeaturesMESA* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->imageAlignmentControl = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageAlignmentControlFeaturesMESA* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->imageAlignmentControl);address+=4;
}
MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA::~MarshalVkPhysicalDeviceImageAlignmentControlFeaturesMESA() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageAlignmentControlPropertiesMESA* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->supportedImageAlignmentMask = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceImageAlignmentControlPropertiesMESA* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->supportedImageAlignmentMask);address+=4;
}
MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA::~MarshalVkPhysicalDeviceImageAlignmentControlPropertiesMESA() {
    delete s.pNext;
}
void MarshalVkImageAlignmentControlCreateInfoMESA::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageAlignmentControlCreateInfoMESA* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->maximumRequestedAlignment = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkImageAlignmentControlCreateInfoMESA::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkImageAlignmentControlCreateInfoMESA* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->maximumRequestedAlignment);address+=4;
}
MarshalVkImageAlignmentControlCreateInfoMESA::~MarshalVkImageAlignmentControlCreateInfoMESA() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->shaderReplicatedComposites = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->shaderReplicatedComposites);address+=4;
}
MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT::~MarshalVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->presentModeFifoLatestReady = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->presentModeFifoLatestReady);address+=4;
}
MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT::~MarshalVkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT() {
    delete s.pNext;
}
void MarshalVkDepthClampRangeEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkDepthClampRangeEXT* s) {
    MarshalFloat minDepthClampFloat;
    minDepthClampFloat.i = memory->readd(address);address+=4;
    s->minDepthClamp = minDepthClampFloat.f;
    MarshalFloat maxDepthClampFloat;
    maxDepthClampFloat.i = memory->readd(address);address+=4;
    s->maxDepthClamp = maxDepthClampFloat.f;
}
void MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrix2FeaturesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrixWorkgroupScope = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixFlexibleDimensions = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixReductions = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixConversions = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixPerElementOperations = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixTensorAddressing = (VkBool32)memory->readd(address);address+=4;
    s->cooperativeMatrixBlockLoads = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrix2FeaturesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrixWorkgroupScope);address+=4;
    memory->writed(address, s->cooperativeMatrixFlexibleDimensions);address+=4;
    memory->writed(address, s->cooperativeMatrixReductions);address+=4;
    memory->writed(address, s->cooperativeMatrixConversions);address+=4;
    memory->writed(address, s->cooperativeMatrixPerElementOperations);address+=4;
    memory->writed(address, s->cooperativeMatrixTensorAddressing);address+=4;
    memory->writed(address, s->cooperativeMatrixBlockLoads);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV::~MarshalVkPhysicalDeviceCooperativeMatrix2FeaturesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrix2PropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize = (uint32_t)memory->readd(address);address+=4;
    s->cooperativeMatrixFlexibleDimensionsMaxDimension = (uint32_t)memory->readd(address);address+=4;
    s->cooperativeMatrixWorkgroupScopeReservedSharedMemory = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceCooperativeMatrix2PropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize);address+=4;
    memory->writed(address, s->cooperativeMatrixFlexibleDimensionsMaxDimension);address+=4;
    memory->writed(address, s->cooperativeMatrixWorkgroupScopeReservedSharedMemory);address+=4;
}
MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV::~MarshalVkPhysicalDeviceCooperativeMatrix2PropertiesNV() {
    delete s.pNext;
}
void MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->MGranularity = (uint32_t)memory->readd(address);address+=4;
    s->NGranularity = (uint32_t)memory->readd(address);address+=4;
    s->KGranularity = (uint32_t)memory->readd(address);address+=4;
    s->AType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->BType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->CType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->ResultType = (VkComponentTypeKHR)memory->readd(address);address+=4;
    s->saturatingAccumulation = (VkBool32)memory->readd(address);address+=4;
    s->scope = (VkScopeKHR)memory->readd(address);address+=4;
    s->workgroupInvocations = (uint32_t)memory->readd(address);address+=4;
}
void MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->MGranularity);address+=4;
    memory->writed(address, s->NGranularity);address+=4;
    memory->writed(address, s->KGranularity);address+=4;
    memory->writed(address, s->AType);address+=4;
    memory->writed(address, s->BType);address+=4;
    memory->writed(address, s->CType);address+=4;
    memory->writed(address, s->ResultType);address+=4;
    memory->writed(address, s->saturatingAccumulation);address+=4;
    memory->writed(address, s->scope);address+=4;
    memory->writed(address, s->workgroupInvocations);address+=4;
}
MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV::~MarshalVkCooperativeMatrixFlexibleDimensionsPropertiesNV() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHdrVividFeaturesHUAWEI* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->hdrVivid = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceHdrVividFeaturesHUAWEI* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->hdrVivid);address+=4;
}
MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI::~MarshalVkPhysicalDeviceHdrVividFeaturesHUAWEI() {
    delete s.pNext;
}
void MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* s) {
    s->sType = (VkStructureType)memory->readd(address);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pNext = NULL;
    } else {
        s->pNext = vulkanGetNextPtr(pBoxedInfo, memory, paramAddress);
    }
    s->vertexAttributeRobustness = (VkBool32)memory->readd(address);address+=4;
}
void MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT::write(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* s) {
    memory->writed(address, s->sType);address+=4;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress != 0) {
        vulkanWriteNextPtr(pBoxedInfo, memory, paramAddress, s->pNext);
    }
    memory->writed(address, s->vertexAttributeRobustness);address+=4;
}
MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT::~MarshalVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT() {
    delete s.pNext;
}
void MarshalStdVideoH265SubLayerHrdParameters::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265SubLayerHrdParameters* s) {
    memory->memcpy(&s->bit_rate_value_minus1, address, 128);address+=128;
    memory->memcpy(&s->cpb_size_value_minus1, address, 128);address+=128;
    memory->memcpy(&s->cpb_size_du_value_minus1, address, 128);address+=128;
    memory->memcpy(&s->bit_rate_du_value_minus1, address, 128);address+=128;
    s->cbr_flag = (uint32_t)memory->readd(address);address+=4;
}
void MarshalStdVideoH265DecPicBufMgr::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265DecPicBufMgr* s) {
    memory->memcpy(&s->max_latency_increase_plus1, address, 28);address+=28;
    memory->memcpy(&s->max_dec_pic_buffering_minus1, address, 7);address+=7;
    memory->memcpy(&s->max_num_reorder_pics, address, 7);address+=7;
}
void MarshalStdVideoH265HrdParameters::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265HrdParameters* s) {
    s->flags = (StdVideoH265HrdFlags)memory->readd(address);address+=4;
    s->tick_divisor_minus2 = (uint8_t)memory->readb(address);address+=1;
    s->du_cpb_removal_delay_increment_length_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->dpb_output_delay_du_length_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->bit_rate_scale = (uint8_t)memory->readb(address);address+=1;
    s->cpb_size_scale = (uint8_t)memory->readb(address);address+=1;
    s->cpb_size_du_scale = (uint8_t)memory->readb(address);address+=1;
    s->initial_cpb_removal_delay_length_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->au_cpb_removal_delay_length_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->dpb_output_delay_length_minus1 = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->cpb_cnt_minus1, address, 7);address+=7;
    memory->memcpy(&s->elemental_duration_in_tc_minus1, address, 7);address+=7;
    memory->memcpy(&s->reserved, address, 3);address+=3;
    address+=2; // structure padding
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubLayerHrdParametersNal = NULL;
    } else {
        StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersNal = new StdVideoH265SubLayerHrdParameters();
        MarshalStdVideoH265SubLayerHrdParameters::read(pBoxedInfo, memory, paramAddress, pSubLayerHrdParametersNal);
        s->pSubLayerHrdParametersNal = pSubLayerHrdParametersNal;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pSubLayerHrdParametersVcl = NULL;
    } else {
        StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersVcl = new StdVideoH265SubLayerHrdParameters();
        MarshalStdVideoH265SubLayerHrdParameters::read(pBoxedInfo, memory, paramAddress, pSubLayerHrdParametersVcl);
        s->pSubLayerHrdParametersVcl = pSubLayerHrdParametersVcl;
    }
}
MarshalStdVideoH265HrdParameters::~MarshalStdVideoH265HrdParameters() {
    delete s.pSubLayerHrdParametersNal;
    delete s.pSubLayerHrdParametersVcl;
}
void MarshalStdVideoH265ProfileTierLevel::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265ProfileTierLevel* s) {
    s->flags = (StdVideoH265ProfileTierLevelFlags)memory->readd(address);address+=4;
    s->general_profile_idc = (StdVideoH265ProfileIdc)memory->readd(address);address+=4;
    s->general_level_idc = (StdVideoH265LevelIdc)memory->readd(address);address+=4;
}
void MarshalStdVideoH265ScalingLists::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265ScalingLists* s) {
    memory->memcpy(&s->ScalingList4x4, address, 96);address+=96;
    memory->memcpy(&s->ScalingList8x8, address, 384);address+=384;
    memory->memcpy(&s->ScalingList16x16, address, 384);address+=384;
    memory->memcpy(&s->ScalingList32x32, address, 128);address+=128;
    memory->memcpy(&s->ScalingListDCCoef16x16, address, 6);address+=6;
    memory->memcpy(&s->ScalingListDCCoef32x32, address, 2);address+=2;
}
void MarshalStdVideoH265ShortTermRefPicSet::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265ShortTermRefPicSet* s) {
    kpanic("MarshalStdVideoH265ShortTermRefPicSet::read");
}
void MarshalStdVideoH265LongTermRefPicsSps::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265LongTermRefPicsSps* s) {
    s->used_by_curr_pic_lt_sps_flag = (uint32_t)memory->readd(address);address+=4;
    memory->memcpy(&s->lt_ref_pic_poc_lsb_sps, address, 128);address+=128;
}
void MarshalStdVideoH265PredictorPaletteEntries::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265PredictorPaletteEntries* s) {
    memory->memcpy(&s->PredictorPaletteEntries, address, 768);address+=768;
}
void MarshalStdVideoH265SequenceParameterSetVui::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH265SequenceParameterSetVui* s) {
    s->flags = (StdVideoH265SpsVuiFlags)memory->readd(address);address+=4;
    s->aspect_ratio_idc = (StdVideoH265AspectRatioIdc)memory->readd(address);address+=4;
    s->sar_width = (uint16_t)memory->readw(address);address+=2;
    s->sar_height = (uint16_t)memory->readw(address);address+=2;
    s->video_format = (uint8_t)memory->readb(address);address+=1;
    s->colour_primaries = (uint8_t)memory->readb(address);address+=1;
    s->transfer_characteristics = (uint8_t)memory->readb(address);address+=1;
    s->matrix_coeffs = (uint8_t)memory->readb(address);address+=1;
    s->chroma_sample_loc_type_top_field = (uint8_t)memory->readb(address);address+=1;
    s->chroma_sample_loc_type_bottom_field = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->reserved2 = (uint8_t)memory->readb(address);address+=1;
    s->def_disp_win_left_offset = (uint16_t)memory->readw(address);address+=2;
    s->def_disp_win_right_offset = (uint16_t)memory->readw(address);address+=2;
    s->def_disp_win_top_offset = (uint16_t)memory->readw(address);address+=2;
    s->def_disp_win_bottom_offset = (uint16_t)memory->readw(address);address+=2;
    s->vui_num_units_in_tick = (uint32_t)memory->readd(address);address+=4;
    s->vui_time_scale = (uint32_t)memory->readd(address);address+=4;
    s->vui_num_ticks_poc_diff_one_minus1 = (uint32_t)memory->readd(address);address+=4;
    s->min_spatial_segmentation_idc = (uint16_t)memory->readw(address);address+=2;
    s->reserved3 = (uint16_t)memory->readw(address);address+=2;
    s->max_bytes_per_pic_denom = (uint8_t)memory->readb(address);address+=1;
    s->max_bits_per_min_cu_denom = (uint8_t)memory->readb(address);address+=1;
    s->log2_max_mv_length_horizontal = (uint8_t)memory->readb(address);address+=1;
    s->log2_max_mv_length_vertical = (uint8_t)memory->readb(address);address+=1;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pHrdParameters = NULL;
    } else {
        StdVideoH265HrdParameters* pHrdParameters = new StdVideoH265HrdParameters();
        MarshalStdVideoH265HrdParameters::read(pBoxedInfo, memory, paramAddress, pHrdParameters);
        s->pHrdParameters = pHrdParameters;
    }
}
MarshalStdVideoH265SequenceParameterSetVui::~MarshalStdVideoH265SequenceParameterSetVui() {
    delete s.pHrdParameters;
}
void MarshalStdVideoEncodeH265WeightTable::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265WeightTable* s) {
    memory->memcpy(&s->flags, address, 8);address+=8;
    s->luma_log2_weight_denom = (uint8_t)memory->readb(address);address+=1;
    s->delta_chroma_log2_weight_denom = (int8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->delta_luma_weight_l0, address, 15);address+=15;
    memory->memcpy(&s->luma_offset_l0, address, 15);address+=15;
    memory->memcpy(&s->delta_chroma_weight_l0, address, 30);address+=30;
    memory->memcpy(&s->delta_chroma_offset_l0, address, 30);address+=30;
    memory->memcpy(&s->delta_luma_weight_l1, address, 15);address+=15;
    memory->memcpy(&s->luma_offset_l1, address, 15);address+=15;
    memory->memcpy(&s->delta_chroma_weight_l1, address, 30);address+=30;
    memory->memcpy(&s->delta_chroma_offset_l1, address, 30);address+=30;
}
void MarshalStdVideoEncodeH265ReferenceListsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265ReferenceListsInfo* s) {
    s->flags = (StdVideoEncodeH265ReferenceListsInfoFlags)memory->readd(address);address+=4;
    s->num_ref_idx_l0_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l1_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->RefPicList0, address, 15);address+=15;
    memory->memcpy(&s->RefPicList1, address, 15);address+=15;
    memory->memcpy(&s->list_entry_l0, address, 15);address+=15;
    memory->memcpy(&s->list_entry_l1, address, 15);address+=15;
}
void MarshalStdVideoEncodeH265LongTermRefPics::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH265LongTermRefPics* s) {
    s->num_long_term_sps = (uint8_t)memory->readb(address);address+=1;
    s->num_long_term_pics = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->lt_idx_sps, address, 32);address+=32;
    memory->memcpy(&s->poc_lsb_lt, address, 16);address+=16;
    s->used_by_curr_pic_lt_flag = (uint16_t)memory->readw(address);address+=2;
    memory->memcpy(&s->delta_poc_msb_present_flag, address, 48);address+=48;
    memory->memcpy(&s->delta_poc_msb_cycle_lt, address, 48);address+=48;
}
void MarshalStdVideoH264ScalingLists::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoH264ScalingLists* s) {
    s->scaling_list_present_mask = (uint16_t)memory->readw(address);address+=2;
    s->use_default_scaling_matrix_mask = (uint16_t)memory->readw(address);address+=2;
    memory->memcpy(&s->ScalingList4x4, address, 96);address+=96;
    memory->memcpy(&s->ScalingList8x8, address, 384);address+=384;
}
void MarshalStdVideoEncodeH264RefListModEntry::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264RefListModEntry* s) {
    s->modification_of_pic_nums_idc = (StdVideoH264ModificationOfPicNumsIdc)memory->readd(address);address+=4;
    s->abs_diff_pic_num_minus1 = (uint16_t)memory->readw(address);address+=2;
    s->long_term_pic_num = (uint16_t)memory->readw(address);address+=2;
}
void MarshalStdVideoEncodeH264RefPicMarkingEntry::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264RefPicMarkingEntry* s) {
    s->memory_management_control_operation = (StdVideoH264MemMgmtControlOp)memory->readd(address);address+=4;
    s->difference_of_pic_nums_minus1 = (uint16_t)memory->readw(address);address+=2;
    s->long_term_pic_num = (uint16_t)memory->readw(address);address+=2;
    s->long_term_frame_idx = (uint16_t)memory->readw(address);address+=2;
    s->max_long_term_frame_idx_plus1 = (uint16_t)memory->readw(address);address+=2;
}
void MarshalStdVideoEncodeH264ReferenceListsInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoEncodeH264ReferenceListsInfo* s) {
    s->flags = (StdVideoEncodeH264ReferenceListsInfoFlags)memory->readd(address);address+=4;
    s->num_ref_idx_l0_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    s->num_ref_idx_l1_active_minus1 = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->RefPicList0, address, 32);address+=32;
    memory->memcpy(&s->RefPicList1, address, 32);address+=32;
    s->refList0ModOpCount = (uint8_t)memory->readb(address);address+=1;
    s->refList1ModOpCount = (uint8_t)memory->readb(address);address+=1;
    s->refPicMarkingOpCount = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->reserved1, address, 7);address+=7;
    U32 paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRefList0ModOperations = NULL;
    } else {
        StdVideoEncodeH264RefListModEntry* pRefList0ModOperations = new StdVideoEncodeH264RefListModEntry();
        MarshalStdVideoEncodeH264RefListModEntry::read(pBoxedInfo, memory, paramAddress, pRefList0ModOperations);
        s->pRefList0ModOperations = pRefList0ModOperations;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRefList1ModOperations = NULL;
    } else {
        StdVideoEncodeH264RefListModEntry* pRefList1ModOperations = new StdVideoEncodeH264RefListModEntry();
        MarshalStdVideoEncodeH264RefListModEntry::read(pBoxedInfo, memory, paramAddress, pRefList1ModOperations);
        s->pRefList1ModOperations = pRefList1ModOperations;
    }
    paramAddress = memory->readd(address);address+=4;
    if (paramAddress == 0) {
        s->pRefPicMarkingOperations = NULL;
    } else {
        StdVideoEncodeH264RefPicMarkingEntry* pRefPicMarkingOperations = new StdVideoEncodeH264RefPicMarkingEntry();
        MarshalStdVideoEncodeH264RefPicMarkingEntry::read(pBoxedInfo, memory, paramAddress, pRefPicMarkingOperations);
        s->pRefPicMarkingOperations = pRefPicMarkingOperations;
    }
}
MarshalStdVideoEncodeH264ReferenceListsInfo::~MarshalStdVideoEncodeH264ReferenceListsInfo() {
    delete s.pRefList0ModOperations;
    delete s.pRefList1ModOperations;
    delete s.pRefPicMarkingOperations;
}
void MarshalStdVideoAV1Quantization::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1Quantization* s) {
    s->flags = (StdVideoAV1QuantizationFlags)memory->readd(address);address+=4;
    s->base_q_idx = (uint8_t)memory->readb(address);address+=1;
    s->DeltaQYDc = (int8_t)memory->readb(address);address+=1;
    s->DeltaQUDc = (int8_t)memory->readb(address);address+=1;
    s->DeltaQUAc = (int8_t)memory->readb(address);address+=1;
    s->DeltaQVDc = (int8_t)memory->readb(address);address+=1;
    s->DeltaQVAc = (int8_t)memory->readb(address);address+=1;
    s->qm_y = (uint8_t)memory->readb(address);address+=1;
    s->qm_u = (uint8_t)memory->readb(address);address+=1;
    s->qm_v = (uint8_t)memory->readb(address);address+=1;
}
void MarshalStdVideoAV1TileInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1TileInfo* s) {
    kpanic("MarshalStdVideoAV1TileInfo::read");
}
void MarshalStdVideoAV1LoopFilter::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1LoopFilter* s) {
    s->flags = (StdVideoAV1LoopFilterFlags)memory->readd(address);address+=4;
    memory->memcpy(&s->loop_filter_level, address, 4);address+=4;
    s->loop_filter_sharpness = (uint8_t)memory->readb(address);address+=1;
    s->update_ref_delta = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->loop_filter_ref_deltas, address, 8);address+=8;
    s->update_mode_delta = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->loop_filter_mode_deltas, address, 2);address+=2;
}
void MarshalStdVideoAV1Segmentation::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1Segmentation* s) {
    memory->memcpy(&s->FeatureEnabled, address, 8);address+=8;
    memory->memcpy(&s->FeatureData, address, 128);address+=128;
}
void MarshalStdVideoAV1CDEF::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1CDEF* s) {
    s->cdef_damping_minus_3 = (uint8_t)memory->readb(address);address+=1;
    s->cdef_bits = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->cdef_y_pri_strength, address, 8);address+=8;
    memory->memcpy(&s->cdef_y_sec_strength, address, 8);address+=8;
    memory->memcpy(&s->cdef_uv_pri_strength, address, 8);address+=8;
    memory->memcpy(&s->cdef_uv_sec_strength, address, 8);address+=8;
}
void MarshalStdVideoAV1LoopRestoration::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1LoopRestoration* s) {
    memory->memcpy(&s->FrameRestorationType, address, 12);address+=12;
    memory->memcpy(&s->LoopRestorationSize, address, 6);address+=6;
}
void MarshalStdVideoAV1GlobalMotion::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1GlobalMotion* s) {
    memory->memcpy(&s->GmType, address, 8);address+=8;
    memory->memcpy(&s->gm_params, address, 192);address+=192;
}
void MarshalStdVideoAV1TimingInfo::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1TimingInfo* s) {
    s->flags = (StdVideoAV1TimingInfoFlags)memory->readd(address);address+=4;
    s->num_units_in_display_tick = (uint32_t)memory->readd(address);address+=4;
    s->time_scale = (uint32_t)memory->readd(address);address+=4;
    s->num_ticks_per_picture_minus_1 = (uint32_t)memory->readd(address);address+=4;
}
void MarshalStdVideoAV1ColorConfig::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1ColorConfig* s) {
    s->flags = (StdVideoAV1ColorConfigFlags)memory->readd(address);address+=4;
    s->BitDepth = (uint8_t)memory->readb(address);address+=1;
    s->subsampling_x = (uint8_t)memory->readb(address);address+=1;
    s->subsampling_y = (uint8_t)memory->readb(address);address+=1;
    s->reserved1 = (uint8_t)memory->readb(address);address+=1;
    s->color_primaries = (StdVideoAV1ColorPrimaries)memory->readd(address);address+=4;
    s->transfer_characteristics = (StdVideoAV1TransferCharacteristics)memory->readd(address);address+=4;
    s->matrix_coefficients = (StdVideoAV1MatrixCoefficients)memory->readd(address);address+=4;
    s->chroma_sample_position = (StdVideoAV1ChromaSamplePosition)memory->readd(address);address+=4;
}
void MarshalStdVideoAV1FilmGrain::read(BoxedVulkanInfo* pBoxedInfo, KMemory* memory, U32 address, StdVideoAV1FilmGrain* s) {
    s->flags = (StdVideoAV1FilmGrainFlags)memory->readd(address);address+=4;
    s->grain_scaling_minus_8 = (uint8_t)memory->readb(address);address+=1;
    s->ar_coeff_lag = (uint8_t)memory->readb(address);address+=1;
    s->ar_coeff_shift_minus_6 = (uint8_t)memory->readb(address);address+=1;
    s->grain_scale_shift = (uint8_t)memory->readb(address);address+=1;
    s->grain_seed = (uint16_t)memory->readw(address);address+=2;
    s->film_grain_params_ref_idx = (uint8_t)memory->readb(address);address+=1;
    s->num_y_points = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->point_y_value, address, 14);address+=14;
    memory->memcpy(&s->point_y_scaling, address, 14);address+=14;
    s->num_cb_points = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->point_cb_value, address, 10);address+=10;
    memory->memcpy(&s->point_cb_scaling, address, 10);address+=10;
    s->num_cr_points = (uint8_t)memory->readb(address);address+=1;
    memory->memcpy(&s->point_cr_value, address, 10);address+=10;
    memory->memcpy(&s->point_cr_scaling, address, 10);address+=10;
    memory->memcpy(&s->ar_coeffs_y_plus_128, address, 24);address+=24;
    memory->memcpy(&s->ar_coeffs_cb_plus_128, address, 25);address+=25;
    memory->memcpy(&s->ar_coeffs_cr_plus_128, address, 25);address+=25;
    s->cb_mult = (uint8_t)memory->readb(address);address+=1;
    s->cb_luma_mult = (uint8_t)memory->readb(address);address+=1;
    s->cb_offset = (uint16_t)memory->readw(address);address+=2;
    s->cr_mult = (uint8_t)memory->readb(address);address+=1;
    s->cr_luma_mult = (uint8_t)memory->readb(address);address+=1;
    s->cr_offset = (uint16_t)memory->readw(address);address+=2;
}
#endif

